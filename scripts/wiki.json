{
  "wiki": {
    "wikis": {
      "en": {
        "metadata": {
          "repo_name": "gojue/ecapture",
          "commit_hash": "0766a93b",
          "generated_at": "2025-12-22T04:32:54.412647",
          "config": null,
          "config_source": "none"
        },
        "pages": [
          {
            "page_plan": {
              "id": "1",
              "title": "Overview"
            },
            "content": "# Overview\n\n<details>\n<summary>Relevant source files</summary>\n\nThe following files were used as context for generating this wiki page:\n\n- [CHANGELOG.md](CHANGELOG.md)\n- [README.md](README.md)\n- [README_CN.md](README_CN.md)\n- [go.mod](go.mod)\n- [go.sum](go.sum)\n- [images/ecapture-help-v0.8.9.svg](images/ecapture-help-v0.8.9.svg)\n- [main.go](main.go)\n\n</details>\n\n\n\nThis document introduces eCapture (旁观者), an eBPF-based network traffic capture and system auditing tool. eCapture intercepts SSL/TLS encrypted communications and extracts plaintext data without requiring CA certificates or application modifications. It also provides system auditing capabilities for shell commands and database queries.\n\nFor installation and usage instructions, see [Installation and Quick Start](#1.1). For detailed module documentation, see [Capture Modules](#3). For build and development information, see [Development Guide](#5).\n\n## System Purpose and Capabilities\n\neCapture captures encrypted network traffic at the user-space and kernel-space boundaries using eBPF (Extended Berkeley Packet Filter) technology. The system attaches probes to SSL/TLS library functions and network stack entry points, enabling plaintext capture of encrypted communications and runtime auditing of system activities.\n\n**Core Capabilities:**\n- **SSL/TLS Plaintext Capture**: Intercepts encrypted data from OpenSSL, BoringSSL, GnuTLS, NSS/NSPR libraries\n- **Go TLS Capture**: Supports native Go `crypto/tls` library encryption\n- **System Auditing**: Captures Bash/Zsh commands and MySQL/PostgreSQL SQL queries\n- **No CA Certificates Required**: Works transparently without certificate installation\n- **Multiple Output Formats**: Text, PCAP-NG, keylog (SSLKEYLOGFILE), Protobuf streams\n\nSources: [README.md:1-43](), [README_CN.md:40-43](), [CHANGELOG.md:188-273]()\n\n## Platform Support\n\neCapture supports Linux and Android operating systems with specific kernel version requirements:\n\n| Architecture | Minimum Kernel Version | Notes |\n|--------------|------------------------|-------|\n| x86_64 | 4.18 | Full feature support |\n| aarch64 | 5.5 | Full feature support |\n\n**Requirements:**\n- ROOT permissions for eBPF operations\n- BTF (BPF Type Format) support preferred but not required\n- Kernel headers for non-CO-RE compilation mode\n\n**Unsupported Platforms:**\n- Windows (no eBPF support)\n- macOS (no eBPF support)\n\nThe system automatically detects kernel capabilities and selects between CO-RE (Compile Once - Run Everywhere) and non-CO-RE bytecode at runtime.\n\nSources: [README.md:14-16](), [README_CN.md:15-17](), [go.mod:1-60]()\n\n## System Architecture\n\n```mermaid\ngraph TB\n    subgraph CLI[\"CLI Entry Point\"]\n        main[\"main.go<br/>cli.Start()\"]\n        cobra[\"cobra/pflag<br/>Command Framework\"]\n    end\n    \n    subgraph Modules[\"Capture Modules\"]\n        tls[\"EBPFProbeOPENSSL<br/>OpenSSL/BoringSSL\"]\n        gotls[\"EBPFProbeGOTLS<br/>Go crypto/tls\"]\n        gnutls[\"EBPFProbeGNUTLS<br/>GnuTLS\"]\n        nspr[\"EBPFProbeNSPR<br/>NSS/NSPR\"]\n        bash[\"EBPFProbeBASH<br/>Bash readline\"]\n        zsh[\"EBPFProbeZSH<br/>Zsh zle\"]\n        mysql[\"EBPFProbeMYSQLD<br/>MySQL dispatch_command\"]\n        postgres[\"EBPFProbePOSTGRES<br/>PostgreSQL exec_simple_query\"]\n    end\n    \n    subgraph eBPF[\"eBPF Runtime\"]\n        manager[\"ebpfmanager<br/>Lifecycle Management\"]\n        uprobe[\"Uprobe Programs<br/>Function Hooks\"]\n        tc[\"TC Programs<br/>Network Packets\"]\n        kprobe[\"Kprobe Programs<br/>Kernel Hooks\"]\n        maps[\"eBPF Maps<br/>Perf/RingBuffer\"]\n    end\n    \n    subgraph Events[\"Event Processing\"]\n        reader[\"perfEventReader<br/>ringbufEventReader\"]\n        worker[\"eventWorker<br/>Connection Lifecycle\"]\n        parser[\"IParser<br/>HTTP/HTTP2 Parsing\"]\n    end\n    \n    subgraph Output[\"Output Layer\"]\n        text[\"Text Logger<br/>Console/File\"]\n        pcap[\"PCAP Writer<br/>pcapng Format\"]\n        keylog[\"Keylog Writer<br/>SSLKEYLOGFILE\"]\n        proto[\"Protobuf Stream<br/>WebSocket\"]\n    end\n    \n    main --> cobra\n    cobra --> tls\n    cobra --> gotls\n    cobra --> gnutls\n    cobra --> nspr\n    cobra --> bash\n    cobra --> zsh\n    cobra --> mysql\n    cobra --> postgres\n    \n    tls --> manager\n    gotls --> manager\n    gnutls --> manager\n    nspr --> manager\n    bash --> manager\n    zsh --> manager\n    mysql --> manager\n    postgres --> manager\n    \n    manager --> uprobe\n    manager --> tc\n    manager --> kprobe\n    \n    uprobe --> maps\n    tc --> maps\n    kprobe --> maps\n    \n    maps --> reader\n    reader --> worker\n    worker --> parser\n    \n    parser --> text\n    parser --> pcap\n    parser --> keylog\n    parser --> proto\n```\n\n**System Layers:**\n\n1. **CLI Entry Point**: Command-line interface using Cobra framework for subcommand routing\n2. **Capture Modules**: Eight specialized modules implementing `IModule` interface for different protocols\n3. **eBPF Runtime**: Probe management, bytecode loading, and eBPF program lifecycle\n4. **Event Processing**: Event reading, connection tracking, and protocol parsing\n5. **Output Layer**: Multiple output formats for different consumption scenarios\n\nEach module operates independently with its own eBPF programs and event handlers, coordinated through the `IModule` interface.\n\nSources: [main.go:1-12](), [README.md:152-161](), [README_CN.md:129-140]()\n\n## Capture Modules\n\neCapture provides eight modules for capturing different protocols and applications:\n\n| Module | Target | Description | Command |\n|--------|--------|-------------|---------|\n| `tls` | OpenSSL/BoringSSL | Captures SSL/TLS plaintext from OpenSSL 1.0.x-3.5.x and BoringSSL (Android 12-16) | `ecapture tls` |\n| `gotls` | Go crypto/tls | Captures TLS traffic from Go applications using native crypto/tls library | `ecapture gotls` |\n| `gnutls` | GnuTLS | Captures TLS traffic from GnuTLS library applications | `ecapture gnutls` |\n| `nss` | NSS/NSPR | Captures traffic from Firefox and other NSS/NSPR-based applications | `ecapture nss` |\n| `bash` | Bash | Audits bash command execution via readline library hooks | `ecapture bash` |\n| `zsh` | Zsh | Audits zsh command execution via zle (Z-Shell Line Editor) hooks | `ecapture zsh` |\n| `mysqld` | MySQL/MariaDB | Captures SQL queries from MySQL 5.6/5.7/8.0 and MariaDB | `ecapture mysqld` |\n| `postgres` | PostgreSQL | Captures SQL queries from PostgreSQL 10+ | `ecapture postgres` |\n\nEach module implements the `IModule` interface and can run independently or be combined with others.\n\nSources: [README.md:152-161](), [README_CN.md:129-140](), [CHANGELOG.md:38-42]()\n\n## eBPF Technology Usage\n\n```mermaid\ngraph LR\n    subgraph UserSpace[\"User Space Applications\"]\n        app[\"Target Application<br/>OpenSSL/Go/MySQL/Bash\"]\n    end\n    \n    subgraph Kernel[\"Kernel Space\"]\n        uprobe_entry[\"uprobe<br/>SSL_read entry\"]\n        uprobe_ret[\"uretprobe<br/>SSL_read return\"]\n        tc_ingress[\"TC ingress<br/>capture_packets\"]\n        tc_egress[\"TC egress<br/>capture_packets\"]\n        kprobe_hook[\"kprobe<br/>tcp_sendmsg<br/>udp_sendmsg\"]\n    end\n    \n    subgraph Maps[\"eBPF Maps\"]\n        perf[\"Perf Array<br/>Data Events\"]\n        ring[\"Ring Buffer<br/>Events\"]\n        hash[\"Hash Maps<br/>pidConns<br/>sock2pidFd<br/>masterKeys\"]\n    end\n    \n    app -->|\"function call\"| uprobe_entry\n    app -->|\"function return\"| uprobe_ret\n    app -->|\"network packets\"| tc_ingress\n    app -->|\"network packets\"| tc_egress\n    app -->|\"socket operations\"| kprobe_hook\n    \n    uprobe_entry --> perf\n    uprobe_ret --> perf\n    tc_ingress --> ring\n    tc_egress --> ring\n    kprobe_hook --> hash\n    \n    perf --> reader[\"perfEventReader<br/>User Space\"]\n    ring --> reader\n    hash --> reader\n```\n\n**eBPF Probe Types:**\n\n1. **Uprobe/Uretprobe**: Attaches to user-space library functions\n   - Entry probes capture function arguments (e.g., `SSL_read(ssl, buf, len)`)\n   - Return probes capture return values and output buffers\n   - Used for: SSL/TLS functions, database queries, shell commands\n\n2. **TC (Traffic Control)**: Attaches to network interface ingress/egress\n   - Captures network packets at kernel level\n   - Extracts 4-tuple (src/dst IP:port) for connection tracking\n   - Used for: PCAP mode packet capture with process attribution\n\n3. **Kprobe**: Attaches to kernel functions\n   - Hooks socket operations (`tcp_sendmsg`, `udp_sendmsg`)\n   - Maps socket file descriptors to processes\n   - Used for: Connection tracking and process identification\n\n**CO-RE vs Non-CO-RE:**\n- **CO-RE (BTF-enabled)**: Single bytecode works across kernel versions\n- **Non-CO-RE**: Requires kernel-specific bytecode with header files\n- eCapture detects BTF availability and loads appropriate bytecode automatically\n\nSources: [README.md:38-43](), [CHANGELOG.md:249-251](), [CHANGELOG.md:552-556]()\n\n## Output Modes and Formats\n\neCapture supports four primary output modes, configurable per module:\n\n### Text Mode\n\n**Command**: `ecapture tls -m text` (default mode)\n\nOutputs plaintext data directly to console or file. Includes HTTP/1.x and HTTP/2 protocol parsing with automatic decoding of compressed responses.\n\n**Features:**\n- Real-time output to stdout\n- File output with `-w <filename>`\n- HTTP/HTTP2 request/response parsing\n- Color-coded output for readability\n- Hex dump mode with `--hex` flag\n\n### PCAP Mode\n\n**Command**: `ecapture tls -m pcap --pcapfile=output.pcapng -i eth0`\n\nGenerates PCAP-NG files compatible with Wireshark, combining captured plaintext with reconstructed network packets.\n\n**Features:**\n- Standard pcapng format with EPB (Enhanced Packet Block)\n- DSB (Decryption Secrets Block) for TLS master keys\n- IPv4/IPv6 support with 4-tuple tracking\n- TCP and UDP protocol support (including QUIC)\n- PID/UID filtering via eBPF\n\n### Keylog Mode\n\n**Command**: `ecapture tls -m keylog --keylogfile=keys.log`\n\nExports TLS master secrets in `SSLKEYLOGFILE` format for use with Wireshark or tshark.\n\n**Format:**\n```\nCLIENT_RANDOM <client_random_hex> <master_secret_hex>\nCLIENT_HANDSHAKE_TRAFFIC_SECRET <client_random_hex> <secret_hex>\nSERVER_HANDSHAKE_TRAFFIC_SECRET <client_random_hex> <secret_hex>\n```\n\n**Use Case:**\n```shell\n# Capture keys\necapture tls -m keylog --keylogfile=keys.log\n\n# Decrypt with tshark\ntshark -o tls.keylog_file:keys.log -Y http -T fields -e http.file_data -f \"port 443\" -i eth0\n```\n\n### Protobuf Mode\n\n**Command**: `ecapture tls` with WebSocket server enabled (default: `localhost:28256`)\n\nStreams events in Protocol Buffer format to connected clients (e.g., eCaptureQ GUI application).\n\n**Event Types:**\n- `SSLDataEvent`: Plaintext SSL/TLS data\n- `MasterSecretEvent`: TLS master secrets\n- `BashEvent`: Shell commands\n- `MysqldEvent`: SQL queries\n\nSources: [README.md:172-253](), [README_CN.md:150-220](), [CHANGELOG.md:715-747]()\n\n## Data Flow Pipeline\n\n```mermaid\nflowchart TD\n    subgraph Capture[\"eBPF Capture\"]\n        ssl[\"SSL_read/SSL_write<br/>Uprobe Hooks\"]\n        gotls_read[\"crypto/tls.Conn.Read<br/>Uprobe Hook\"]\n        tc[\"TC Packet Capture<br/>4-tuple Extraction\"]\n        mysql[\"dispatch_command<br/>Uprobe Hook\"]\n    end\n    \n    subgraph Maps[\"eBPF Maps\"]\n        perf[\"Perf Events<br/>Plaintext Data\"]\n        master[\"Master Key Map<br/>TLS Secrets\"]\n        conn[\"Connection Maps<br/>pidConns<br/>sock2pidFd\"]\n    end\n    \n    subgraph Reader[\"Event Readers\"]\n        perf_reader[\"perfEventReader<br/>4MB Ring\"]\n        ring_reader[\"ringbufEventReader<br/>Kernel 5.8+\"]\n    end\n    \n    subgraph Worker[\"Event Worker\"]\n        dispatch[\"Dispatcher<br/>Event Type Routing\"]\n        lifecycle[\"Connection Lifecycle<br/>Default vs Socket Mode\"]\n    end\n    \n    subgraph Parser[\"Protocol Parsers\"]\n        http1[\"HTTP/1.x Parser<br/>Request/Response\"]\n        http2[\"HTTP/2 Parser<br/>HPACK Decoder\"]\n        sql[\"SQL Parser<br/>Query Extraction\"]\n    end\n    \n    subgraph Collector[\"Event Collector\"]\n        aggregate[\"Aggregation<br/>Multi-buffer Assembly\"]\n        truncate[\"Truncation<br/>--truncate Size\"]\n        rotate[\"Rotation<br/>--eventrotatesize\"]\n    end\n    \n    subgraph Writers[\"Output Writers\"]\n        text_w[\"Text Writer<br/>Console/File\"]\n        pcap_w[\"PCAP Writer<br/>gopacket\"]\n        key_w[\"Keylog Writer<br/>SSLKEYLOGFILE\"]\n        proto_w[\"Protobuf Writer<br/>WebSocket\"]\n    end\n    \n    ssl --> perf\n    gotls_read --> perf\n    mysql --> perf\n    ssl --> master\n    tc --> conn\n    \n    perf --> perf_reader\n    perf --> ring_reader\n    master --> perf_reader\n    conn --> perf_reader\n    \n    perf_reader --> dispatch\n    ring_reader --> dispatch\n    \n    dispatch --> lifecycle\n    lifecycle --> http1\n    lifecycle --> http2\n    lifecycle --> sql\n    \n    http1 --> aggregate\n    http2 --> aggregate\n    sql --> aggregate\n    \n    aggregate --> truncate\n    truncate --> rotate\n    \n    rotate --> text_w\n    rotate --> pcap_w\n    rotate --> key_w\n    rotate --> proto_w\n```\n\n**Pipeline Stages:**\n\n1. **Capture**: eBPF probes intercept function calls and network packets\n2. **Maps**: Kernel-space storage for events and connection state\n3. **Readers**: User-space consumers of eBPF map data (perf array or ring buffer)\n4. **Worker**: Event type dispatch and connection lifecycle management\n5. **Parser**: Protocol-specific parsing (HTTP, HTTP/2, SQL)\n6. **Collector**: Event aggregation, truncation, and rotation\n7. **Writers**: Format-specific output generation\n\nThe pipeline supports configurable event truncation (`--truncate`), file rotation (`--eventrotatesize`, `--eventrotatetime`), and selective filtering by PID (`--pid`) or UID (`--uid`).\n\nSources: [CHANGELOG.md:137-163](), [CHANGELOG.md:647-653](), [CHANGELOG.md:491-493]()\n\n## Version Detection and Bytecode Selection\n\n```mermaid\ngraph TD\n    start[\"Module Init<br/>e.g., MOpenSSLProbe.Init()\"]\n    detect[\"Version Detection<br/>ELF Parsing\"]\n    check_ver{{\"Version<br/>Found?\"}}\n    map[\"Bytecode Mapping<br/>OpenSSL 1.0.2-3.5.x<br/>BoringSSL A12-A16\"]\n    check_btf{{\"BTF<br/>Enabled?\"}}\n    core[\"Load CO-RE Bytecode<br/>*_core.o\"}\n    noncore[\"Load Non-CO-RE<br/>*_noncore.o\"]\n    fallback[\"Use Default<br/>linux_default_3_0\"}\n    attach[\"Attach Probes<br/>ebpfmanager\"]\n    \n    start --> detect\n    detect --> check_ver\n    check_ver -->|\"Yes\"| map\n    check_ver -->|\"No\"| fallback\n    map --> check_btf\n    fallback --> check_btf\n    check_btf -->|\"Yes\"| core\n    check_btf -->|\"No\"| noncore\n    core --> attach\n    noncore --> attach\n```\n\n**Version Detection Process:**\n\n1. **ELF Parsing**: Reads shared library file (e.g., `libssl.so.3`) to extract version strings\n2. **Version Mapping**: Maps detected version to specific structure offsets\n3. **Bytecode Selection**: Chooses appropriate eBPF bytecode based on version and BTF availability\n4. **Fallback Strategy**: Uses default version offsets if detection fails\n\n**Supported OpenSSL Versions:**\n- 1.0.2 series: 1.0.2a-1.0.2zg\n- 1.1.0 series: 1.1.0-1.1.0l\n- 1.1.1 series: 1.1.1-1.1.1w\n- 3.0 series: 3.0.0-3.0.15\n- 3.1 series: 3.1.0-3.1.7\n- 3.2 series: 3.2.0-3.2.3\n- 3.3 series: 3.3.0-3.3.3\n- 3.4 series: 3.4.0-3.4.1\n- 3.5 series: 3.5.0-3.5.4\n\n**Supported BoringSSL Versions:**\n- Android 12 (API 31, A12)\n- Android 13 (API 33, A13)\n- Android 14 (API 34, A14)\n- Android 15 (API 35, A15)\n- Android 16 (API 36, A16)\n\nThe system warns when version detection fails but continues with default offsets.\n\nSources: [CHANGELOG.md:14-35](), [CHANGELOG.md:98-99](), [CHANGELOG.md:305-308](), [CHANGELOG.md:540-541](), [CHANGELOG.md:651-654](), [CHANGELOG.md:779-781]()\n\n## Use Cases\n\n### Network Debugging and Development\n\n**Scenario**: Debugging HTTPS API calls without modifying application code\n\n```shell\n# Capture plaintext for specific process\necapture tls --pid=12345\n\n# Capture with HTTP/2 parsing\necapture tls -m text\n\n# Generate PCAP for Wireshark analysis\necapture tls -m pcap -i eth0 --pcapfile=debug.pcapng\n```\n\n### Security Analysis and Monitoring\n\n**Scenario**: Real-time monitoring of encrypted communications for security audit\n\n```shell\n# Capture all HTTPS traffic on system\necapture tls\n\n# Monitor specific user's connections\necapture tls --uid=1000\n\n# Export keys for offline analysis\necapture tls -m keylog --keylogfile=audit_keys.log\n```\n\n### Database Activity Auditing\n\n**Scenario**: Monitor SQL queries for compliance and performance analysis\n\n```shell\n# Capture MySQL queries\necapture mysqld --pid=$(pidof mysqld)\n\n# Capture PostgreSQL queries\necapture postgres --pid=$(pidof postgres)\n```\n\n### Shell Command Auditing\n\n**Scenario**: Track shell commands for security auditing and incident response\n\n```shell\n# Audit all bash sessions\necapture bash\n\n# Audit zsh sessions\necapture zsh\n```\n\n### Go Application TLS Capture\n\n**Scenario**: Debug Go applications using native crypto/tls library\n\n```shell\n# Specify Go binary path\necapture gotls --elfpath=/path/to/go_binary\n\n# Capture with keylog mode\necapture gotls --elfpath=/path/to/go_binary -m keylog\n```\n\nSources: [README.md:72-280](), [README_CN.md:69-251](), [CHANGELOG.md:260-273]()\n\n## Remote Configuration and Integration\n\neCapture provides HTTP API for runtime configuration updates and event forwarding:\n\n**HTTP Configuration API**: Accessible at `localhost:28256` (configurable with `--listen` flag)\n\n**Event Forwarding**: \n- WebSocket streaming to external clients\n- Protocol Buffer serialization for structured data\n- Integration with eCaptureQ GUI application\n- Support for Burp Suite and other analysis tools\n\nFor detailed API documentation, see:\n- Remote configuration: [docs/remote-config-update-api.md]()\n- Event forwarding: [docs/event-forward-api.md]()\n- Protobuf protocol: [protobuf/PROTOCOLS.md]()\n\nSources: [CHANGELOG.md:16-17](), [CHANGELOG.md:27-28](), [CHANGELOG.md:43-45](), [CHANGELOG.md:82-89](), [README.md:288-327](), [README_CN.md:268-307]()\n\n## Build and Deployment\n\neCapture uses a sophisticated build system that produces self-contained binaries:\n\n**Build Artifacts:**\n- **Linux ELF binaries**: Static binaries with embedded eBPF bytecode\n- **Docker images**: Multi-arch images (linux/amd64, linux/arm64)\n- **Debian packages**: `.deb` format for package management\n- **Android releases**: Non-CO-RE only with BoringSSL support\n\n**Binary Embedding**: All eBPF bytecode variants are embedded using `go-bindata`, eliminating runtime dependencies on external bytecode files.\n\n**Cross-Compilation**: Supports building x86_64 binaries on aarch64 hosts and vice versa.\n\nFor build instructions and development setup, see [Build System](#5.1).\n\nSources: [CHANGELOG.md:537-538](), [README.md:316-319](), [README_CN.md:297-300]()"
          },
          {
            "page_plan": {
              "id": "1.1",
              "title": "Installation and Quick Start"
            },
            "content": "# Installation and Quick Start\n\n<details>\n<summary>Relevant source files</summary>\n\nThe following files were used as context for generating this wiki page:\n\n- [.github/workflows/codeql-analysis.yml](.github/workflows/codeql-analysis.yml)\n- [.github/workflows/go-c-cpp.yml](.github/workflows/go-c-cpp.yml)\n- [.github/workflows/release.yml](.github/workflows/release.yml)\n- [CHANGELOG.md](CHANGELOG.md)\n- [Makefile](Makefile)\n- [README.md](README.md)\n- [README_CN.md](README_CN.md)\n- [builder/Dockerfile](builder/Dockerfile)\n- [builder/Makefile.release](builder/Makefile.release)\n- [builder/init_env.sh](builder/init_env.sh)\n- [functions.mk](functions.mk)\n- [images/ecapture-help-v0.8.9.svg](images/ecapture-help-v0.8.9.svg)\n- [main.go](main.go)\n\n</details>\n\n\n\nThis page provides instructions for installing eCapture and running your first capture. It covers system requirements, installation methods (binary download, Docker, source compilation), and basic usage examples to get started capturing SSL/TLS plaintext traffic.\n\nFor detailed information about compilation options and customization, see [Compilation](#5.1). For comprehensive CLI documentation, see [Command Line Interface](#1.2). For understanding the underlying architecture, see [Architecture](#2).\n\n---\n\n## System Requirements\n\neCapture has specific kernel and architecture requirements due to its eBPF-based implementation:\n\n### Kernel Version Requirements\n\n| Architecture | Minimum Kernel Version | Notes |\n|-------------|------------------------|-------|\n| x86_64 (amd64) | 4.18 | Full feature support |\n| aarch64 (arm64) | 5.5 | Full feature support |\n\n### Additional Requirements\n\n- **Privileges**: ROOT (superuser) permissions required\n- **BTF Support**: Optional but recommended for CO-RE mode (better portability)\n- **Supported Platforms**: Linux, Android\n- **Unsupported Platforms**: Windows, macOS\n\nBTF (BPF Type Format) support can be verified with:\n\n```bash\n# Check if kernel has BTF support\ncat /boot/config-$(uname -r) | grep CONFIG_DEBUG_INFO_BTF\n# Should output: CONFIG_DEBUG_INFO_BTF=y\n```\n\n### System Architecture Detection Diagram\n\n```mermaid\ngraph TB\n    subgraph \"System Verification\"\n        CHECK_KERN[\"Check Kernel Version<br/>uname -r\"]\n        CHECK_ARCH[\"Check CPU Architecture<br/>uname -m\"]\n        CHECK_BTF[\"Check BTF Support<br/>CONFIG_DEBUG_INFO_BTF\"]\n        CHECK_ROOT[\"Verify ROOT Access<br/>sudo/CAP_BPF\"]\n    end\n    \n    subgraph \"Execution Mode Selection\"\n        BTF_YES[\"BTF Available\"]\n        BTF_NO[\"BTF Not Available\"]\n        CORE_MODE[\"CO-RE Mode<br/>*_core.o bytecode\"]\n        NONCORE_MODE[\"Non-CO-RE Mode<br/>*_noncore.o bytecode\"]\n    end\n    \n    subgraph \"Binary Selection\"\n        AMD64_BIN[\"ecapture-linux-amd64\"]\n        ARM64_BIN[\"ecapture-linux-arm64\"]\n        ANDROID_BIN[\"ecapture-android-arm64\"]\n    end\n    \n    CHECK_KERN --> CHECK_ARCH\n    CHECK_ARCH --> CHECK_BTF\n    CHECK_BTF --> BTF_YES\n    CHECK_BTF --> BTF_NO\n    CHECK_BTF --> CHECK_ROOT\n    \n    BTF_YES --> CORE_MODE\n    BTF_NO --> NONCORE_MODE\n    \n    CHECK_ARCH --> AMD64_BIN\n    CHECK_ARCH --> ARM64_BIN\n    CHECK_ARCH --> ANDROID_BIN\n    \n    CORE_MODE -.->|\"embedded in\"| AMD64_BIN\n    NONCORE_MODE -.->|\"embedded in\"| AMD64_BIN\n```\n\n**Sources**: [README.md:13-16](), [README_CN.md:14-17](), [.github/workflows/go-c-cpp.yml:10-127]()\n\n---\n\n## Installation Methods\n\neCapture provides three primary installation methods: pre-built binary downloads, Docker containers, and source compilation.\n\n### Method 1: Binary Release Download\n\nThe simplest installation method is downloading pre-compiled binaries from GitHub releases.\n\n#### Download and Extract\n\n```bash\n# Download latest release (replace VERSION with actual version, e.g., v0.8.6)\nVERSION=v1.5.1\nARCH=amd64  # or arm64\n\n# Download archive\nwget https://github.com/gojue/ecapture/releases/download/${VERSION}/ecapture-${VERSION}-linux-${ARCH}.tar.gz\n\n# Extract\ntar -xzf ecapture-${VERSION}-linux-${ARCH}.tar.gz\ncd ecapture-${VERSION}-linux-${ARCH}\n\n# Verify\nsudo ./ecapture --help\n```\n\n#### Binary Package Contents\n\nEach release archive contains:\n\n| File | Description |\n|------|-------------|\n| `ecapture` | Main executable binary |\n| `LICENSE` | Project license |\n| `CHANGELOG.md` | Release notes and version history |\n| `README.md` | English documentation |\n| `README_CN.md` | Chinese documentation |\n\n#### Architecture-Specific Binaries\n\n```mermaid\ngraph LR\n    subgraph \"Release Artifacts\"\n        RELEASE[\"GitHub Release<br/>github.com/gojue/ecapture/releases\"]\n    end\n    \n    subgraph \"Linux x86_64\"\n        LINUX_AMD64[\"ecapture-VERSION-linux-amd64.tar.gz\"]\n        CORE_AMD64[\"Includes CO-RE bytecode\"]\n        NONCORE_AMD64[\"Includes non-CO-RE bytecode\"]\n    end\n    \n    subgraph \"Linux aarch64\"\n        LINUX_ARM64[\"ecapture-VERSION-linux-arm64.tar.gz\"]\n        CORE_ARM64[\"Includes CO-RE bytecode\"]\n        NONCORE_ARM64[\"Includes non-CO-RE bytecode\"]\n    end\n    \n    subgraph \"Android aarch64\"\n        ANDROID_ARM64[\"ecapture-VERSION-android-arm64-nocore.tar.gz\"]\n        ANDROID_NONCORE[\"Non-CO-RE only\"]\n        ANDROID_BORING[\"BoringSSL focused\"]\n    end\n    \n    RELEASE --> LINUX_AMD64\n    RELEASE --> LINUX_ARM64\n    RELEASE --> ANDROID_ARM64\n    \n    LINUX_AMD64 --> CORE_AMD64\n    LINUX_AMD64 --> NONCORE_AMD64\n    LINUX_ARM64 --> CORE_ARM64\n    LINUX_ARM64 --> NONCORE_ARM64\n    ANDROID_ARM64 --> ANDROID_NONCORE\n    ANDROID_ARM64 --> ANDROID_BORING\n```\n\n**Sources**: [README.md:48-56](), [README_CN.md:48-55](), [.github/workflows/release.yml:88-100]()\n\n### Method 2: Docker Container\n\nDocker provides an isolated environment for running eCapture without installing dependencies on the host system.\n\n#### Pull and Run Docker Image\n\n```bash\n# Pull latest image\ndocker pull gojue/ecapture:latest\n\n# Run with required privileges\ndocker run --rm \\\n  --privileged=true \\\n  --net=host \\\n  -v /path/on/host:/path/in/container \\\n  gojue/ecapture:latest tls\n\n# Example: Save output to host directory\ndocker run --rm \\\n  --privileged=true \\\n  --net=host \\\n  -v $(pwd)/captures:/captures \\\n  gojue/ecapture:latest tls --pcapfile=/captures/output.pcapng\n```\n\n#### Docker Build Process\n\nThe Docker image is built using a multi-stage process:\n\n```mermaid\ngraph TB\n    subgraph \"Stage 1: Builder\"\n        BASE[\"ubuntu:22.04\"]\n        DEPS[\"Install Dependencies<br/>clang-14, llvm-14<br/>golang 1.24.6<br/>linux-headers\"]\n        SOURCE[\"Copy Source Code<br/>/build/ecapture\"]\n        COMPILE[\"make all<br/>SNAPSHOT_VERSION\"]\n        BINARY[\"bin/ecapture\"]\n    end\n    \n    subgraph \"Stage 2: Runtime\"\n        ALPINE[\"alpine:latest\"]\n        COPY_BIN[\"Copy /build/ecapture/bin/ecapture\"]\n        FINAL[\"ecapture runtime image\"]\n    end\n    \n    BASE --> DEPS\n    DEPS --> SOURCE\n    SOURCE --> COMPILE\n    COMPILE --> BINARY\n    \n    BINARY -.->|\"COPY --from=ecapture_builder\"| COPY_BIN\n    ALPINE --> COPY_BIN\n    COPY_BIN --> FINAL\n```\n\n**Docker Configuration Details**:\n\n- **Base Image**: Ubuntu 22.04 for building, Alpine for runtime\n- **Required Flags**: `--privileged=true` (eBPF requires kernel access), `--net=host` (network monitoring)\n- **Volume Mounts**: Use `-v` to save output files to host\n- **Multi-Architecture**: Supports linux/amd64 and linux/arm64\n\n**Sources**: [README.md:58-70](), [README_CN.md:57-67](), [builder/Dockerfile:1-39]()\n\n### Method 3: Build from Source\n\nBuilding from source allows customization and provides the latest development features.\n\n#### Quick Build\n\n```bash\n# Clone repository\ngit clone https://github.com/gojue/ecapture.git\ncd ecapture\ngit submodule update --init\n\n# Install dependencies (Ubuntu/Debian)\nsudo apt-get update\nsudo apt-get install -y \\\n  build-essential \\\n  pkgconf \\\n  libelf-dev \\\n  llvm-14 \\\n  clang-14 \\\n  linux-tools-common \\\n  linux-tools-generic \\\n  linux-source\n\n# Set up environment\nmake env\n\n# Build (includes both CO-RE and non-CO-RE)\nmake all\n\n# Binary output location\n./bin/ecapture --help\n```\n\n#### Build System Overview\n\n```mermaid\ngraph TB\n    subgraph \"Source Files\"\n        KERN_C[\"kern/*.c<br/>27+ eBPF programs\"]\n        GO_SRC[\"user/module/*.go<br/>cli/cmd/*.go<br/>pkg/*\"]\n        LIBPCAP[\"lib/libpcap/<br/>submodule\"]\n    end\n    \n    subgraph \"Build Process - Makefile\"\n        EBPF_CORE[\"Compile CO-RE<br/>clang -target bpfel<br/>*_core.o\"]\n        EBPF_NONCORE[\"Compile Non-CO-RE<br/>clang + llc<br/>*_noncore.o\"]\n        LESS52[\"Compile <5.2 variants<br/>*_less52.o\"]\n        \n        EMBED[\"go-bindata<br/>Embed bytecode<br/>assets/ebpf_probe.go\"]\n        \n        LIBPCAP_BUILD[\"Build libpcap<br/>Static library\"]\n        \n        GO_BUILD[\"Go Build<br/>CGO_ENABLED=1<br/>Static linking\"]\n    end\n    \n    subgraph \"Output\"\n        BINARY[\"bin/ecapture<br/>Single binary<br/>All bytecode embedded\"]\n    end\n    \n    KERN_C --> EBPF_CORE\n    KERN_C --> EBPF_NONCORE\n    KERN_C --> LESS52\n    \n    EBPF_CORE --> EMBED\n    EBPF_NONCORE --> EMBED\n    LESS52 --> EMBED\n    \n    LIBPCAP --> LIBPCAP_BUILD\n    \n    EMBED --> GO_BUILD\n    GO_SRC --> GO_BUILD\n    LIBPCAP_BUILD --> GO_BUILD\n    \n    GO_BUILD --> BINARY\n```\n\n**Build Targets**:\n\n| Target | Description | Command |\n|--------|-------------|---------|\n| `all` | Full build with CO-RE and non-CO-RE | `make all` |\n| `nocore` | Non-CO-RE only (older kernels) | `make nocore` |\n| `env` | Display build environment | `make env` |\n| `clean` | Clean build artifacts | `make clean` |\n\n**Cross-Compilation**:\n\n```bash\n# Build for ARM64 on x86_64 host\nCROSS_ARCH=arm64 make env\nCROSS_ARCH=arm64 make all\n\n# Build for Android\nANDROID=1 CROSS_ARCH=arm64 make nocore\n```\n\n**Sources**: [Makefile:1-269](), [README.md:316-319](), [CHANGELOG.md:553-562](), [builder/init_env.sh:1-106]()\n\n---\n\n## First Capture: TLS Module\n\nAfter installation, verify eCapture is working by capturing SSL/TLS traffic.\n\n### Basic TLS Capture\n\nThe simplest capture command monitors all OpenSSL/BoringSSL encrypted traffic:\n\n```bash\nsudo ecapture tls\n```\n\n**Expected Output Structure**:\n\n```mermaid\ngraph TB\n    subgraph \"Initialization Phase\"\n        BANNER[\"AppName, Version, Homepage\"]\n        SYSINFO[\"Kernel Info, BTF Mode\"]\n        LIBDETECT[\"Library Detection<br/>OpenSSL/BoringSSL version\"]\n        HOOKSETUP[\"Hook Setup<br/>SSL_read, SSL_write, etc.\"]\n    end\n    \n    subgraph \"Runtime Phase\"\n        EVENTS[\"Event Stream<br/>UUID, Type, Length\"]\n        HTTP_REQ[\"HTTP Request<br/>GET /path HTTP/1.1\"]\n        HTTP_RESP[\"HTTP Response<br/>HTTP/1.1 200 OK\"]\n        HTTP2_FRAME[\"HTTP/2 Frames<br/>HEADERS, DATA, etc.\"]\n    end\n    \n    BANNER --> SYSINFO\n    SYSINFO --> LIBDETECT\n    LIBDETECT --> HOOKSETUP\n    \n    HOOKSETUP --> EVENTS\n    EVENTS --> HTTP_REQ\n    EVENTS --> HTTP_RESP\n    EVENTS --> HTTP2_FRAME\n```\n\n### Example Output Walkthrough\n\n```\n2024-09-15T11:51:31Z INF AppName=\"eCapture(旁观者)\"\n2024-09-15T11:51:31Z INF Version=linux_arm64:0.8.6-20240915-d87ae48:5.15.0-113-generic\n2024-09-15T11:51:31Z INF Listen=localhost:28256\n2024-09-15T11:51:31Z WRN ========== module starting. ==========\n2024-09-15T11:51:31Z INF Kernel Info=5.15.152 Pid=233698\n2024-09-15T11:51:31Z INF BTF bytecode mode: CORE. btfMode=0\n2024-09-15T11:51:31Z INF Hook masterKey function Functions=[\"SSL_get_wbio\",\"SSL_in_before\",\"SSL_do_handshake\"]\n2024-09-15T11:51:31Z INF target all process.\n```\n\n**Output Field Explanations**:\n\n| Field | Description | Example Value |\n|-------|-------------|---------------|\n| `Version` | Build info: OS_ARCH:VERSION:KERNEL | `linux_arm64:0.8.6:5.15.0-113` |\n| `Listen` | HTTP API endpoint for remote config | `localhost:28256` |\n| `BTF bytecode mode` | CO-RE (0) or Non-CO-RE (1) | `CORE. btfMode=0` |\n| `Hook masterKey function` | eBPF probe attachment points | `[\"SSL_get_wbio\",...]` |\n\n### Understanding Captured Events\n\nWhen traffic is captured, events appear with this structure:\n\n```\n2024-09-15T11:51:53Z ??? UUID:233851_233851_curl_5_1_172.16.71.1:51837, Name:HTTP2Request, Type:2, Length:304\n\nFrame Type\t=>\tHEADERS\nheader field \":method\" = \"GET\"\nheader field \":path\" = \"/\"\nheader field \":authority\" = \"google.com\"\n```\n\n**Event UUID Format**: `{pid}_{pid}_{comm}_{fd}_{direction}_{remote_addr}:{remote_port}`\n\n| Component | Meaning |\n|-----------|---------|\n| `233851` | Process ID |\n| `curl` | Process name (truncated to 16 chars) |\n| `5` | File descriptor |\n| `1` | Direction (0=read/response, 1=write/request) |\n| `172.16.71.1:51837` | Remote endpoint |\n\n**Sources**: [README.md:72-149](), [README_CN.md:73-126]()\n\n---\n\n## Common Usage Patterns\n\n### Capture Modes\n\neCapture TLS module supports three output modes:\n\n#### Text Mode (Default)\n\nDirect plaintext output to console or file:\n\n```bash\n# Output to console\nsudo ecapture tls\n\n# Output to file\nsudo ecapture tls > capture_output.txt\n\n# With specific PID filter\nsudo ecapture tls --pid=1234\n```\n\n#### PCAP Mode\n\nSave as packet capture file for Wireshark analysis:\n\n```bash\n# Basic pcap capture\nsudo ecapture tls -m pcap -i eth0 --pcapfile=capture.pcapng\n\n# With network filter\nsudo ecapture tls -m pcap -i eth0 --pcapfile=https.pcapng tcp port 443\n\n# Multiple interfaces\nsudo ecapture tls -m pcap -i eth0,wlan0 --pcapfile=multi.pcapng\n```\n\n**PCAP Filter Syntax**: Supports tcpdump/BPF filter expressions (e.g., `host 192.168.1.1 and tcp port 443`)\n\n#### Keylog Mode\n\nExport TLS master secrets for offline decryption:\n\n```bash\n# Generate keylog file\nsudo ecapture tls -m keylog --keylogfile=tls_keys.log\n\n# Use with tshark for real-time decryption\nsudo ecapture tls -m keylog --keylogfile=keys.log &\ntshark -o tls.keylog_file:keys.log -Y http -T fields -e http.file_data -f \"port 443\" -i eth0\n```\n\n**Sources**: [README.md:172-253](), [README_CN.md:150-219](), [CHANGELOG.md:688-757]()\n\n### Module Selection\n\neCapture provides specialized modules for different targets:\n\n```mermaid\ngraph LR\n    subgraph \"CLI Entry Point\"\n        ECAPTURE[\"ecapture<br/>main command\"]\n    end\n    \n    subgraph \"TLS/SSL Modules\"\n        TLS[\"ecapture tls<br/>OpenSSL/BoringSSL\"]\n        GOTLS[\"ecapture gotls<br/>Go crypto/tls\"]\n        GNUTLS[\"ecapture gnutls<br/>GnuTLS library\"]\n        NSS[\"ecapture nss<br/>NSS/NSPR/Firefox\"]\n    end\n    \n    subgraph \"Audit Modules\"\n        BASH[\"ecapture bash<br/>Bash commands\"]\n        ZSH[\"ecapture zsh<br/>Zsh commands\"]\n        MYSQLD[\"ecapture mysqld<br/>MySQL queries\"]\n        POSTGRES[\"ecapture postgres<br/>PostgreSQL queries\"]\n    end\n    \n    ECAPTURE --> TLS\n    ECAPTURE --> GOTLS\n    ECAPTURE --> GNUTLS\n    ECAPTURE --> NSS\n    ECAPTURE --> BASH\n    ECAPTURE --> ZSH\n    ECAPTURE --> MYSQLD\n    ECAPTURE --> POSTGRES\n```\n\n**Quick Module Examples**:\n\n```bash\n# Capture bash commands\nsudo ecapture bash\n\n# Capture MySQL queries\nsudo ecapture mysqld\n\n# Capture Go TLS traffic\nsudo ecapture gotls --elfpath=/path/to/go/binary\n```\n\n**Sources**: [README.md:151-161](), [README_CN.md:128-139](), [main.go:1-11]()\n\n---\n\n## Verification and Troubleshooting\n\n### Verify Installation\n\n```bash\n# Check version\nsudo ecapture --version\n\n# Display help\nsudo ecapture --help\n\n# Test module availability\nsudo ecapture tls --help\n```\n\n### Common Issues\n\n#### Issue: \"Kernel version too low\"\n\n**Solution**: Verify kernel version meets minimum requirements:\n\n```bash\nuname -r\n# Should be >= 4.18 for x86_64, >= 5.5 for aarch64\n```\n\n#### Issue: \"Permission denied\"\n\n**Solution**: eCapture requires ROOT privileges:\n\n```bash\n# Use sudo\nsudo ecapture tls\n\n# Or check capabilities\nsudo setcap cap_sys_admin,cap_bpf+ep ./ecapture\n./ecapture tls\n```\n\n#### Issue: \"OpenSSL version not found\"\n\n**Solution**: eCapture will use default version. You can specify library path:\n\n```bash\n# Auto-detect from ld.so.conf\nsudo ecapture tls\n\n# Manually specify library\nsudo ecapture tls --libssl=/usr/lib/x86_64-linux-gnu/libssl.so.3\n\n# For static binaries\nsudo ecapture tls --libssl=/path/to/static/binary\n```\n\n#### Issue: \"BTF not available\"\n\n**Solution**: Non-CO-RE mode automatically selected. For better compatibility:\n\n```bash\n# Install linux-headers\nsudo apt-get install linux-headers-$(uname -r)\n\n# Or use non-CO-RE build explicitly\n# (Binary includes both modes, selects automatically)\n```\n\n**Sources**: [README.md:163-170](), [.github/workflows/go-c-cpp.yml:16-33]()\n\n---\n\n## Environment Setup Script\n\nFor development environments, eCapture provides an automated setup script:\n\n```bash\n# Run initialization script (Ubuntu only)\n/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/gojue/ecapture/master/builder/init_env.sh)\"\n```\n\n**Script Actions**:\n\n1. Detects Ubuntu version and sets appropriate clang version\n2. Installs build dependencies (clang, llvm, linux-source, gcc cross-compilers)\n3. Extracts and prepares kernel headers\n4. Installs Go 1.24.6\n5. Clones eCapture repository\n6. Configures cross-compilation support\n\n**Supported Ubuntu Versions**:\n\n| Version | Clang Version |\n|---------|---------------|\n| 20.04, 20.10 | clang-10 |\n| 21.04 | clang-11 |\n| 21.10, 22.04, 22.10 | clang-12 |\n| 23.04, 23.10 | clang-15 |\n| 24.04 | clang-18 |\n\n**Sources**: [builder/init_env.sh:1-106]()\n\n---\n\n## CI/CD Build Verification\n\neCapture uses GitHub Actions for continuous integration. The build process validates:\n\n```mermaid\ngraph TB\n    subgraph \"CI Build Matrix\"\n        AMD64[\"ubuntu-22.04<br/>x86_64 host\"]\n        ARM64[\"ubuntu-22.04-arm<br/>aarch64 host\"]\n    end\n    \n    subgraph \"Build Steps\"\n        ENV[\"Install Compilers<br/>clang-14, linux-source\"]\n        CORE[\"Build CO-RE<br/>make all\"]\n        NONCORE[\"Build non-CO-RE<br/>make nocore\"]\n        CROSS[\"Cross-Compile<br/>CROSS_ARCH=\"]\n        ANDROID[\"Android Build<br/>ANDROID=1\"]\n        TEST[\"Run Tests<br/>go test -race\"]\n    end\n    \n    subgraph \"Outputs\"\n        BINARY[\"ecapture binary\"]\n        ARTIFACT[\"Build artifacts\"]\n    end\n    \n    AMD64 --> ENV\n    ARM64 --> ENV\n    \n    ENV --> CORE\n    CORE --> NONCORE\n    NONCORE --> CROSS\n    CROSS --> ANDROID\n    ANDROID --> TEST\n    \n    TEST --> BINARY\n    BINARY --> ARTIFACT\n```\n\n**Build Validation**:\n\n- **Native Compilation**: Both x86_64 and aarch64 runners\n- **Cross-Compilation**: Bidirectional (x86_64 ↔ aarch64)\n- **Multiple Modes**: CO-RE and non-CO-RE on both architectures\n- **Android Support**: Non-CO-RE for Android with BoringSSL focus\n- **Code Quality**: golangci-lint and race detector tests\n\n**Sources**: [.github/workflows/go-c-cpp.yml:1-128](), [.github/workflows/release.yml:1-129]()\n\n---\n\n## Next Steps\n\nAfter completing installation and running your first capture:\n\n- **Explore CLI Options**: See [Command Line Interface](#1.2) for detailed flag documentation\n- **Understand Architecture**: Learn how eCapture works in [Architecture](#2)\n- **Module Deep Dives**: \n  - [OpenSSL Module](#3.1.1) for TLS/SSL capture details\n  - [GoTLS Module](#3.1.2) for Go-specific captures\n  - [System Audit Modules](#3.2) for bash/database auditing\n- **Output Formats**: See [Output Formats](#4) for PCAP, keylog, and text mode details\n- **Custom Builds**: Refer to [Build System](#5.1) for compilation customization\n- **Dependencies**: Check [Dependencies and System Requirements](#1.3) for detailed prerequisites\n\n**Sources**: [README.md:1-335](), [README_CN.md:1-315](), [CHANGELOG.md:1-100]()"
          },
          {
            "page_plan": {
              "id": "1.2",
              "title": "Command Line Interface"
            },
            "content": "# Command Line Interface\n\n<details>\n<summary>Relevant source files</summary>\n\nThe following files were used as context for generating this wiki page:\n\n- [CHANGELOG.md](CHANGELOG.md)\n- [README.md](README.md)\n- [README_CN.md](README_CN.md)\n- [cli/cmd/bash.go](cli/cmd/bash.go)\n- [cli/cmd/gnutls.go](cli/cmd/gnutls.go)\n- [cli/cmd/gotls.go](cli/cmd/gotls.go)\n- [cli/cmd/mysqld.go](cli/cmd/mysqld.go)\n- [cli/cmd/nspr.go](cli/cmd/nspr.go)\n- [cli/cmd/postgres.go](cli/cmd/postgres.go)\n- [cli/cmd/tls.go](cli/cmd/tls.go)\n- [cli/cmd/zsh.go](cli/cmd/zsh.go)\n- [images/ecapture-help-v0.8.9.svg](images/ecapture-help-v0.8.9.svg)\n- [main.go](main.go)\n- [pkg/util/ws/client.go](pkg/util/ws/client.go)\n- [pkg/util/ws/client_test.go](pkg/util/ws/client_test.go)\n\n</details>\n\n\n\n## Purpose and Scope\n\nThis document describes the command-line interface (CLI) for eCapture, which provides the primary user interaction mechanism for controlling capture modules, configuring output formats, and filtering target processes. The CLI is built using the Cobra library and organizes functionality into module-specific subcommands.\n\nFor information about module lifecycle and initialization, see [Module System and Lifecycle](#2.4). For configuration options beyond CLI flags, see [Configuration System](#2.3).\n\n---\n\n## Command Structure Overview\n\neCapture uses a module-based command architecture where each subcommand corresponds to a specific capture module. The entry point invokes the Cobra command framework, which routes to module initialization functions.\n\n**CLI Command Hierarchy**\n\n```mermaid\ngraph TB\n    Main[\"main.go<br/>cli.Start()\"]\n    RootCmd[\"rootCmd<br/>(cli/cmd/root.go)\"]\n    \n    TLSCmd[\"tls (openssl)<br/>cli/cmd/tls.go\"]\n    GoTLSCmd[\"gotls (tlsgo)<br/>cli/cmd/gotls.go\"]\n    GnuTLSCmd[\"gnutls (gnu)<br/>cli/cmd/gnutls.go\"]\n    NSSCmd[\"nspr (nss)<br/>cli/cmd/nspr.go\"]\n    BashCmd[\"bash<br/>cli/cmd/bash.go\"]\n    ZshCmd[\"zsh<br/>cli/cmd/zsh.go\"]\n    MySQLCmd[\"mysqld<br/>cli/cmd/mysqld.go\"]\n    PostgresCmd[\"postgres<br/>cli/cmd/postgres.go\"]\n    \n    Main --> RootCmd\n    RootCmd --> TLSCmd\n    RootCmd --> GoTLSCmd\n    RootCmd --> GnuTLSCmd\n    RootCmd --> NSSCmd\n    RootCmd --> BashCmd\n    RootCmd --> ZshCmd\n    RootCmd --> MySQLCmd\n    RootCmd --> PostgresCmd\n    \n    TLSCmd --> RunModule[\"runModule()<br/>ModuleNameOpenssl<br/>config.OpensslConfig\"]\n    GoTLSCmd --> RunModule2[\"runModule()<br/>ModuleNameGotls<br/>config.GoTLSConfig\"]\n    GnuTLSCmd --> RunModule3[\"runModule()<br/>ModuleNameGnutls<br/>config.GnutlsConfig\"]\n    BashCmd --> RunModule4[\"runModule()<br/>ModuleNameBash<br/>config.BashConfig\"]\n```\n\nSources: [main.go:1-11](), [cli/cmd/tls.go:15-68](), [cli/cmd/gotls.go:15-59](), [cli/cmd/gnutls.go:18-65](), [cli/cmd/bash.go:15-56]()\n\n**Command to Module Mapping**\n\nEach subcommand creates a module-specific configuration object and invokes `runModule()` with the appropriate module name constant.\n\n| Command | Aliases | Module Name | Config Type | Command Function |\n|---------|---------|-------------|-------------|------------------|\n| `tls` | `openssl` | `ModuleNameOpenssl` | `OpensslConfig` | `openSSLCommandFunc` |\n| `gotls` | `tlsgo` | `ModuleNameGotls` | `GoTLSConfig` | `goTLSCommandFunc` |\n| `gnutls` | `gnu` | `ModuleNameGnutls` | `GnutlsConfig` | `gnuTlsCommandFunc` |\n| `nspr` | `nss` | `ModuleNameNspr` | `NsprConfig` | `nssCommandFunc` |\n| `bash` | - | `ModuleNameBash` | `BashConfig` | `bashCommandFunc` |\n| `zsh` | - | `ModuleNameZsh` | `ZshConfig` | `zshCommandFunc` |\n| `mysqld` | - | `ModuleNameMysqld` | `MysqldConfig` | `mysqldCommandFunc` |\n| `postgres` | - | `ModuleNamePostgres` | `PostgresConfig` | `postgresCommandFunc` |\n\nSources: [cli/cmd/tls.go:26-67](), [cli/cmd/gotls.go:26-58](), [cli/cmd/gnutls.go:29-64](), [cli/cmd/nspr.go:27-51](), [cli/cmd/bash.go:24-55](), [cli/cmd/zsh.go:27-57](), [cli/cmd/mysqld.go:27-49](), [cli/cmd/postgres.go:27-45]()\n\n---\n\n## Global Flags\n\nGlobal flags are defined at the root command level and apply to all subcommands. These are inherited by module-specific commands through Cobra's persistent flag mechanism.\n\n**Common Global Flags Hierarchy**\n\n```mermaid\ngraph LR\n    Root[\"rootCmd<br/>Global Flags\"]\n    \n    Output[\"Output Control<br/>--output-file<br/>--log-addr<br/>--hex\"]\n    Process[\"Process Filtering<br/>--pid<br/>--uid\"]\n    Performance[\"Performance<br/>--mapsize<br/>--event_chan_size\"]\n    Network[\"Network<br/>--pcap_size\"]\n    \n    Root --> Output\n    Root --> Process\n    Root --> Performance\n    Root --> Network\n```\n\n### Output Control Flags\n\n| Flag | Short | Type | Default | Description |\n|------|-------|------|---------|-------------|\n| `--output-file` | `-l` | string | - | File path for event output (text mode) |\n| `--logaddr` | - | string | `localhost:28256` | HTTP server address for config updates |\n| `--hex` | - | bool | `false` | Display data in hexadecimal format |\n| `--event_rotate_size` | - | uint64 | `0` | File rotation size (0=disabled) |\n| `--event_rotate_time` | - | uint64 | `0` | File rotation interval in seconds (0=disabled) |\n\n### Process Filtering Flags\n\n| Flag | Short | Type | Default | Description |\n|------|-------|------|---------|-------------|\n| `--pid` | `-p` | uint64 | `0` | Target process ID (0=all processes) |\n| `--uid` | `-u` | uint64 | `0` | Target user ID (0=all users) |\n\n### Performance Tuning Flags\n\n| Flag | Type | Default | Description |\n|------|------|---------|-------------|\n| `--mapsize` | uint64 | `5120` | eBPF map size in KB |\n| `--event_chan_size` | uint32 | `100` | Event channel buffer size |\n| `--pcap_size` | uint64 | `4096` | Network packet capture buffer size |\n\nSources: Based on common patterns in [cli/cmd/tls.go:50-57](), [cli/cmd/gotls.go:42-48](), [README.md:44]()\n\n---\n\n## TLS Module (`tls`/`openssl`)\n\nThe TLS module captures plaintext from OpenSSL/BoringSSL libraries, supporting versions 1.0.x through 3.5.x and BoringSSL on Android 12-16.\n\n### TLS-Specific Flags\n\n```mermaid\ngraph TB\n    TLSConfig[\"OpensslConfig<br/>cli/cmd/tls.go\"]\n    \n    Library[\"Library Path<br/>--libssl\"]\n    Mode[\"Capture Mode<br/>--model (-m)<br/>text|pcap|keylog\"]\n    Output[\"Output Files<br/>--keylogfile (-k)<br/>--pcapfile (-w)\"]\n    Network[\"Network Config<br/>--ifname (-i)<br/>--cgroup_path\"]\n    Version[\"Version Override<br/>--ssl_version\"]\n    \n    TLSConfig --> Library\n    TLSConfig --> Mode\n    TLSConfig --> Output\n    TLSConfig --> Network\n    TLSConfig --> Version\n```\n\n| Flag | Short | Type | Default | Description |\n|------|-------|------|---------|-------------|\n| `--libssl` | - | string | (auto-detected) | Path to `libssl.so` or statically-linked binary |\n| `--model` | `-m` | string | `text` | Capture mode: `text`, `pcap`/`pcapng`, `key`/`keylog` |\n| `--keylogfile` | `-k` | string | `ecapture_openssl_key.log` | Output file for TLS master secrets |\n| `--pcapfile` | `-w` | string | `save.pcapng` | Output file for PCAP-NG format packets |\n| `--ifname` | `-i` | string | - | Network interface for TC classifier hooks |\n| `--cgroup_path` | - | string | `/sys/fs/cgroup` | CGroup mount path for process filtering |\n| `--ssl_version` | - | string | (auto-detected) | Manual version override (e.g., `\"openssl 3.0.5\"`) |\n\n**Pcap Filter Expression**: The TLS command accepts a trailing pcap filter expression (tcpdump syntax) when in `pcap` mode. This is parsed from remaining command-line arguments.\n\nSources: [cli/cmd/tls.go:26-67]()\n\n### TLS Capture Modes\n\nThe `--model`/`-m` flag controls the capture and output behavior:\n\n**Mode Decision Flow**\n\n```mermaid\ngraph TB\n    Start[\"ecapture tls -m MODE\"]\n    \n    CheckMode{\"Model Flag\"}\n    \n    TextMode[\"text mode<br/>Direct plaintext output<br/>To stdout or --output-file\"]\n    PcapMode[\"pcap/pcapng mode<br/>Save packets + DSB blocks<br/>Requires --ifname, --pcapfile\"]\n    KeylogMode[\"keylog/key mode<br/>Save master secrets<br/>To --keylogfile\"]\n    \n    Start --> CheckMode\n    CheckMode -->|\"text (default)\"| TextMode\n    CheckMode -->|\"pcap/pcapng\"| PcapMode\n    CheckMode -->|\"keylog/key\"| KeylogMode\n    \n    PcapMode --> TCHook[\"Attach TC hooks<br/>Capture encrypted packets<br/>Embed master secrets\"]\n    KeylogMode --> UprobeOnly[\"Attach uprobes only<br/>Extract SSL_SESSION secrets<br/>NSS Key Log Format\"]\n    TextMode --> UprobeText[\"Attach uprobes only<br/>Capture plaintext directly<br/>Parse HTTP/HTTP2\"]\n```\n\nSources: [cli/cmd/tls.go:32-47](), [README.md:171-253]()\n\n### TLS Command Examples\n\n**Text Mode (Default)**\n```shell\nsudo ecapture tls --pid=1234 --hex\nsudo ecapture tls -l output.log --libssl=/lib/x86_64-linux-gnu/libssl.so.3\n```\n\n**Keylog Mode**\n```shell\nsudo ecapture tls -m keylog -k ecapture_key.log\nsudo ecapture tls -m key --keylogfile=/tmp/keys.log --pid=5678\n```\n\n**Pcap Mode**\n```shell\nsudo ecapture tls -m pcap -i eth0 -w capture.pcapng tcp port 443\nsudo ecapture tls -m pcapng -i wlan0 --pcapfile=save.pcapng host 192.168.1.1 and tcp port 443\n```\n\n**Android BoringSSL**\n```shell\nsudo ecapture tls -m pcap --pcapfile=android.pcapng -i wlan0 \\\n  --libssl=/apex/com.android.conscrypt/lib64/libssl.so \\\n  --ssl_version=\"boringssl 1.1.1\" tcp port 443\n```\n\nSources: [cli/cmd/tls.go:32-47](), [README.md:74-253]()\n\n---\n\n## GoTLS Module (`gotls`)\n\nThe GoTLS module captures plaintext from Go programs using the `crypto/tls` standard library, supporting both register-based and stack-based ABIs (Go 1.17+ PIE mode).\n\n### GoTLS-Specific Flags\n\n| Flag | Short | Type | Default | Description |\n|------|-------|------|---------|-------------|\n| `--elfpath` | `-e` | string | (required) | Path to Go binary (required for offset calculation) |\n| `--model` | `-m` | string | `text` | Capture mode: `text`, `pcap`/`pcapng`, `key`/`keylog` |\n| `--pcapfile` | `-w` | string | `ecapture_gotls.pcapng` | PCAP-NG output file path |\n| `--keylogfile` | `-k` | string | `ecapture_gotls_key.log` | Master secret keylog output file |\n| `--ifname` | `-i` | string | - | Network interface for TC hooks (pcap mode only) |\n\n**Pcap Filter Expression**: Similar to TLS module, trailing arguments are parsed as pcap filter expressions in `pcap` mode.\n\nSources: [cli/cmd/gotls.go:26-58]()\n\n### GoTLS Command Examples\n\n**Text Mode**\n```shell\nsudo ecapture gotls --elfpath=/usr/local/bin/go_app --hex\nsudo ecapture gotls -e /home/user/myapp --pid=9876 -l output.log\n```\n\n**Keylog Mode**\n```shell\nsudo ecapture gotls -m keylog -k gotls_keys.log --elfpath=/usr/bin/go_https_server\nsudo ecapture gotls -m key --keylogfile=/tmp/gotls.log -e /app/binary --pid=4321\n```\n\n**Pcap Mode**\n```shell\nsudo ecapture gotls -m pcap --pcapfile=go_capture.pcapng -i eth0 \\\n  --elfpath=/usr/bin/go_client tcp port 443\nsudo ecapture gotls -m pcapng -w output.pcapng -i wlan0 -e /app/server\n```\n\nSources: [cli/cmd/gotls.go:33-38](), [README.md:257-280]()\n\n---\n\n## Other SSL/TLS Modules\n\n### GnuTLS Module (`gnutls`)\n\nCaptures plaintext from GnuTLS library, supporting keylog and pcap modes.\n\n| Flag | Short | Type | Default | Description |\n|------|-------|------|---------|-------------|\n| `--gnutls` | - | string | (auto-detected) | Path to `libgnutls.so` |\n| `--model` | `-m` | string | `text` | Capture mode: `text`, `pcap`, `keylog` |\n| `--keylogfile` | `-k` | string | `ecapture_gnutls_key.log` | Keylog output file |\n| `--pcapfile` | `-w` | string | `save.pcapng` | PCAP output file |\n| `--ifname` | `-i` | string | - | Network interface |\n| `--ssl_version` | - | string | - | GnuTLS version (e.g., `\"3.7.9\"`) |\n\n**Example**:\n```shell\nsudo ecapture gnutls -m keylog -k gnutls_keys.log --ssl_version=3.7.9\nsudo ecapture gnutls -m pcap -i eth0 -w gnutls.pcapng tcp port 443\n```\n\nSources: [cli/cmd/gnutls.go:29-64](), [README.md:155-161](), [CHANGELOG.md:126]()\n\n### NSS/NSPR Module (`nspr`/`nss`)\n\nCaptures plaintext from NSS/NSPR libraries (used by Firefox, Thunderbird).\n\n| Flag | Short | Type | Default | Description |\n|------|-------|------|---------|-------------|\n| `--nspr` | - | string | (auto-detected) | Path to `libnspr44.so` |\n\n**Example**:\n```shell\nsudo ecapture nspr --hex --pid=3423\nsudo ecapture nss -l firefox_capture.log --pid=5678\n```\n\nSources: [cli/cmd/nspr.go:27-51](), [README.md:158]()\n\n---\n\n## System Audit Modules\n\n### Bash Module (`bash`)\n\nCaptures bash command input/output for security auditing.\n\n**Bash Command Flow**\n\n```mermaid\ngraph LR\n    CLI[\"ecapture bash\"]\n    \n    BashConfig[\"BashConfig<br/>cli/cmd/bash.go\"]\n    AutoDetect[\"Auto-detect<br/>$SHELL path<br/>readline.so\"]\n    ErrFilter[\"Error Number Filter<br/>--errnumber\"]\n    \n    CLI --> BashConfig\n    BashConfig --> AutoDetect\n    BashConfig --> ErrFilter\n    \n    RunModule[\"runModule()<br/>ModuleNameBash\"]\n    BashConfig --> RunModule\n```\n\n| Flag | Short | Type | Default | Description |\n|------|-------|------|---------|-------------|\n| `--bash` | - | string | (auto-detected) | Path to bash binary |\n| `--readlineso` | - | string | (auto-detected) | Path to `readline.so` |\n| `--errnumber` | `-e` | int | `BashErrnoDefault` | Filter commands by exit code |\n\n**Example**:\n```shell\nsudo ecapture bash\nsudo ecapture bash --bash=/bin/bash -l bash_audit.log\nsudo ecapture bash -e 0  # Only show successful commands\n```\n\nSources: [cli/cmd/bash.go:24-55](), [README.md:153-154]()\n\n### Zsh Module (`zsh`)\n\nSimilar to bash module, captures zsh command activity.\n\n| Flag | Short | Type | Default | Description |\n|------|-------|------|---------|-------------|\n| `--zsh` | - | string | (auto-detected) | Path to zsh binary |\n| `--errnumber` | `-e` | int | `ZshErrnoDefault` | Filter commands by exit code |\n\n**Example**:\n```shell\nsudo ecapture zsh\nsudo ecapture zsh --zsh=/usr/bin/zsh -l zsh_audit.log\n```\n\nSources: [cli/cmd/zsh.go:27-57](), [README.md:154]()\n\n### MySQL Module (`mysqld`)\n\nCaptures SQL queries from MySQL/MariaDB server processes, supporting versions 5.6, 5.7, 8.0, and MariaDB 10.5+.\n\n| Flag | Short | Type | Default | Description |\n|------|-------|------|---------|-------------|\n| `--mysqld` | `-m` | string | `/usr/sbin/mariadbd` | Path to mysqld binary |\n| `--offset` | - | uint64 | `0` | Manual offset for `dispatch_command` function |\n| `--funcname` | `-f` | string | - | Function name to hook (overrides auto-detection) |\n\n**Example**:\n```shell\nsudo ecapture mysqld -m /usr/sbin/mysqld -l mysql_queries.log\nsudo ecapture mysqld --mysqld=/usr/local/mysql/bin/mysqld --pid=1234\n```\n\nSources: [cli/cmd/mysqld.go:27-49](), [README.md:157]()\n\n### PostgreSQL Module (`postgres`)\n\nCaptures SQL queries from PostgreSQL server processes (version 10+).\n\n| Flag | Short | Type | Default | Description |\n|------|-------|------|---------|-------------|\n| `--postgres` | `-m` | string | `/usr/bin/postgres` | Path to postgres binary |\n| `--funcname` | `-f` | string | - | Function name to hook |\n\n**Example**:\n```shell\nsudo ecapture postgres -m /usr/lib/postgresql/14/bin/postgres\nsudo ecapture postgres --postgres=/opt/pgsql/bin/postgres -l pg_queries.log\n```\n\nSources: [cli/cmd/postgres.go:27-45](), [README.md:159]()\n\n---\n\n## Flag Processing and Pcap Filters\n\nThe TLS, GoTLS, and GnuTLS modules support pcap filter expressions in `pcap` mode. These are processed from trailing command-line arguments and stored in the `PcapFilter` field of the config struct.\n\n**Pcap Filter Processing Flow**\n\n```mermaid\ngraph TB\n    CmdArgs[\"Command Line Arguments<br/>cobra.Command args\"]\n    \n    CheckFilter{\"PcapFilter<br/>already set?\"}\n    \n    JoinArgs[\"strings.Join(args, ' ')<br/>Combine trailing args\"]\n    SetFilter[\"config.PcapFilter = joined\"]\n    \n    RunModule[\"runModule()<br/>Pass config to module\"]\n    \n    CmdArgs --> CheckFilter\n    CheckFilter -->|No| JoinArgs\n    CheckFilter -->|Yes| RunModule\n    JoinArgs --> SetFilter\n    SetFilter --> RunModule\n```\n\n**Filter Examples**:\n```shell\n# Single host filter\nsudo ecapture tls -m pcap -i eth0 -w out.pcapng host 192.168.1.1\n\n# Port and protocol filter\nsudo ecapture tls -m pcap -i wlan0 tcp port 443\n\n# Complex filter expression\nsudo ecapture gotls -m pcap -i eth0 -w output.pcapng \\\n  host 192.168.1.1 and tcp port 443 and not port 22\n```\n\nSources: [cli/cmd/tls.go:62-66](), [cli/cmd/gotls.go:52-56](), [cli/cmd/gnutls.go:59-64]()\n\n---\n\n## Command Execution Pattern\n\nAll module commands follow a consistent execution pattern through the `runModule()` function.\n\n**Module Execution Flow**\n\n```mermaid\ngraph TB\n    CobraCmd[\"Cobra Command Handler<br/>openSSLCommandFunc()<br/>goTLSCommandFunc()<br/>etc.\"]\n    \n    ParseFlags[\"Parse Flags<br/>Populate config struct<br/>OpensslConfig, GoTLSConfig, etc.\"]\n    \n    ParsePcapFilter[\"Parse Pcap Filter<br/>From trailing args<br/>If PcapFilter empty\"]\n    \n    RunModule[\"runModule()<br/>moduleName, config\"]\n    \n    ModuleFactory[\"Module Factory<br/>GetModuleFunc(moduleName)\"]\n    \n    ModuleInit[\"module.Init(config)<br/>Version detection<br/>Bytecode selection\"]\n    \n    ModuleRun[\"module.Run()<br/>Attach eBPF programs<br/>Start event processing\"]\n    \n    CobraCmd --> ParseFlags\n    ParseFlags --> ParsePcapFilter\n    ParsePcapFilter --> RunModule\n    RunModule --> ModuleFactory\n    ModuleFactory --> ModuleInit\n    ModuleInit --> ModuleRun\n```\n\nEach command function:\n1. Creates a module-specific config object (e.g., `OpensslConfig`)\n2. Parses pcap filter from trailing arguments if applicable\n3. Calls `runModule()` with the module name constant and config\n4. The factory creates and initializes the appropriate module\n5. Module performs version detection and bytecode selection\n6. Module runs until interrupted\n\nSources: [cli/cmd/tls.go:62-67](), [cli/cmd/gotls.go:52-58](), [cli/cmd/bash.go:53-55]()\n\n---\n\n## Docker Usage\n\nThe TLS module documentation includes Docker-specific usage patterns for containerized deployments.\n\n**Docker Volume Mounting Requirements**:\n```shell\ndocker run --rm --privileged=true --net=host \\\n  -v /etc:/etc \\\n  -v /usr:/usr \\\n  -v ${PWD}:/output \\\n  gojue/ecapture tls -m pcap -i eth0 \\\n    --pcapfile=/output/capture.pcapng tcp port 443\n```\n\nThe container requires:\n- `--privileged=true` for eBPF capabilities\n- `--net=host` to access host network interfaces\n- Mount `/etc` for `ld.so.conf` library path discovery\n- Mount `/usr` for accessing system libraries\n- Mount output directory for saving capture files\n\nSources: [cli/cmd/tls.go:42-44](), [README.md:59-68]()\n\n---\n\n## Help Text and Documentation\n\nEach command provides detailed help text accessible via the `-h` or `--help` flag:\n\n```shell\n# View all available commands\nsudo ecapture -h\n\n# View TLS module help\nsudo ecapture tls -h\n\n# View GoTLS module help\nsudo ecapture gotls -h\n```\n\nThe help system is built into Cobra's command structure, automatically generating usage information from flag definitions and command descriptions.\n\nSources: [cli/cmd/tls.go:29-47](), [cli/cmd/gotls.go:29-39](), [README.md:44]()"
          },
          {
            "page_plan": {
              "id": "1.3",
              "title": "Dependencies and System Requirements"
            },
            "content": "# Dependencies and System Requirements\n\n<details>\n<summary>Relevant source files</summary>\n\nThe following files were used as context for generating this wiki page:\n\n- [.github/workflows/codeql-analysis.yml](.github/workflows/codeql-analysis.yml)\n- [.github/workflows/go-c-cpp.yml](.github/workflows/go-c-cpp.yml)\n- [.github/workflows/release.yml](.github/workflows/release.yml)\n- [Makefile](Makefile)\n- [builder/Dockerfile](builder/Dockerfile)\n- [builder/Makefile.release](builder/Makefile.release)\n- [builder/init_env.sh](builder/init_env.sh)\n- [functions.mk](functions.mk)\n- [go.mod](go.mod)\n- [go.sum](go.sum)\n\n</details>\n\n\n\nThis page documents the system requirements, dependencies, and toolchain prerequisites for building and running eCapture. It covers kernel version requirements, supported architectures, build-time tooling, runtime dependencies, and Go package dependencies.\n\nFor information about the build process itself, see [Build System](#5.1). For installation instructions, see [Installation and Quick Start](#1.1).\n\n---\n\n## Overview\n\neCapture has distinct requirements for build-time (compiling eBPF programs and Go binary) and runtime (executing the compiled binary). The system supports two compilation modes with different requirements:\n\n- **CO-RE (Compile Once - Run Everywhere)**: Requires BTF-enabled kernels (≥5.2) at runtime, but produces portable binaries\n- **Non-CO-RE**: Requires kernel headers at build-time, produces kernel-specific binaries for older systems\n\n---\n\n## Kernel Requirements\n\n### Minimum Kernel Versions\n\n| Mode | Minimum Version | BTF Required | Notes |\n|------|----------------|--------------|-------|\n| CO-RE | 5.2+ | Yes | Recommended for portability |\n| CO-RE (legacy) | 4.18-5.1 | No | Special `_less52.o` bytecode variants |\n| Non-CO-RE | 4.18+ | No | Requires exact kernel headers |\n\nThe kernel version detection and handling is implemented in [variables.mk]() which sets `KERNEL_LESS_5_2_PREFIX` for kernels < 5.2.\n\n### BTF (BPF Type Format) Support\n\nBTF is a critical feature for CO-RE mode. The build system checks for BTF availability:\n\n```mermaid\ngraph TB\n    START[\"eCapture Binary Execution\"]\n    CHECK_BTF[\"Check /sys/kernel/btf/vmlinux\"]\n    BTF_YES[\"BTF Available\"]\n    BTF_NO[\"BTF Not Available\"]\n    LOAD_CORE[\"Load *_core.o bytecode<br/>CO-RE relocations\"]\n    LOAD_NONCORE[\"Load *_noncore.o bytecode<br/>Fixed offsets\"]\n    LOAD_LESS52[\"Load *_less52.o bytecode<br/>Legacy kernel support\"]\n    CHECK_KERNEL[\"Check kernel version\"]\n    \n    START --> CHECK_BTF\n    CHECK_BTF --> BTF_YES\n    CHECK_BTF --> BTF_NO\n    BTF_YES --> LOAD_CORE\n    BTF_NO --> CHECK_KERNEL\n    CHECK_KERNEL -->|\">=5.2\"| LOAD_NONCORE\n    CHECK_KERNEL -->|\"<5.2\"| LOAD_LESS52\n    \n    style LOAD_CORE fill:#e8f5e9\n    style LOAD_NONCORE fill:#fff9c4\n    style LOAD_LESS52 fill:#ffccbc\n```\n\n**BTF Detection**: The system checks for `/sys/kernel/btf/vmlinux` at runtime. If present, CO-RE bytecode is used; otherwise, non-CO-RE fallback is employed.\n\nSources: [Makefile:122-134](), [functions.mk:13-22]()\n\n---\n\n## Supported Architectures\n\n| Architecture | Status | Cross-Compilation | Notes |\n|--------------|--------|-------------------|-------|\n| x86_64 (amd64) | ✅ Full | To arm64 | Primary development platform |\n| aarch64 (arm64) | ✅ Full | To x86_64 | Full feature parity |\n| Android arm64 | ⚠️ Limited | From x86_64/arm64 | Non-CO-RE only, BoringSSL focus |\n\nArchitecture detection is handled in [variables.mk]() which sets `TARGET_ARCH`, `GOARCH`, `LINUX_ARCH`, and `LIBPCAP_ARCH` based on `uname -m` or `CROSS_ARCH` environment variable.\n\n```mermaid\ngraph LR\n    subgraph \"Native Build\"\n        X86_HOST[\"x86_64 Host\"]\n        ARM_HOST[\"arm64 Host\"]\n        X86_BIN[\"x86_64 Binary\"]\n        ARM_BIN[\"arm64 Binary\"]\n        \n        X86_HOST --> X86_BIN\n        ARM_HOST --> ARM_BIN\n    end\n    \n    subgraph \"Cross-Compilation\"\n        X86_CROSS[\"x86_64 Host<br/>CROSS_ARCH=arm64\"]\n        ARM_CROSS[\"arm64 Host<br/>CROSS_ARCH=amd64\"]\n        X86_TO_ARM[\"arm64 Binary\"]\n        ARM_TO_X86[\"x86_64 Binary\"]\n        \n        X86_CROSS --> X86_TO_ARM\n        ARM_CROSS --> ARM_TO_X86\n    end\n    \n    TOOLCHAIN[\"Cross Toolchains<br/>gcc-aarch64-linux-gnu<br/>gcc-x86-64-linux-gnu\"]\n    HEADERS[\"Architecture Headers<br/>kern/bpf/x86<br/>kern/bpf/arm64\"]\n    \n    TOOLCHAIN -.-> X86_TO_ARM\n    TOOLCHAIN -.-> ARM_TO_X86\n    HEADERS -.-> X86_TO_ARM\n    HEADERS -.-> ARM_TO_X86\n```\n\nSources: [.github/workflows/go-c-cpp.yml:59-65](), [.github/workflows/release.yml:93-97](), [builder/init_env.sh:43-61]()\n\n---\n\n## Build-Time Dependencies\n\n### Required Compilers and Tools\n\nThe following table lists all build-time dependencies with minimum versions:\n\n| Tool | Minimum Version | Purpose | Package Name (Ubuntu) |\n|------|----------------|---------|----------------------|\n| **clang** | 9.0+ | Compile eBPF C to bytecode | `clang-14` (recommended) |\n| **llc** | 9.0+ | LLVM compiler backend | `llvm-14` |\n| **llvm-strip** | 9.0+ | Strip debug symbols | `llvm-14` |\n| **gcc** | System default | C compilation | `build-essential` |\n| **go** | 1.24+ | Go compilation | N/A (install from golang.org) |\n| **bpftool** | Any | Generate vmlinux.h | `linux-tools-generic` |\n| **flex** | Any | Lexer for kernel builds | `flex` |\n| **bison** | Any | Parser for kernel builds | `bison` |\n| **elfutils** | Any | ELF file manipulation | `libelf-dev` |\n| **pkgconf** | Any | Package configuration | `pkgconf` |\n\nVersion checking is enforced at build time:\n\n[functions.mk:13-35]():\n```\nClang version check: CLANG_VERSION must be >= 9\nGo version check: GO_VERSION_MAJ=1, GO_VERSION_MIN >= 24\n```\n\nSources: [.github/workflows/go-c-cpp.yml:16-24](), [functions.mk:13-35](), [builder/init_env.sh:72-79]()\n\n### Kernel Headers (Non-CO-RE Only)\n\nFor non-CO-RE builds, kernel headers matching the target kernel are required. The build system searches for headers in multiple locations:\n\n```mermaid\ngraph TD\n    START[\"Non-CO-RE Build\"]\n    CHECK_SOURCE[\"Check LINUX_SOURCE_PATH<br/>/usr/src/linux-source-*\"]\n    SOURCE_FOUND[\"Headers Found\"]\n    SOURCE_NOT_FOUND[\"Headers Missing\"]\n    PREPARE[\"Run kernel header preparation<br/>make prepare ARCH=target\"]\n    COMPILE[\"Compile eBPF with headers<br/>-I KERN_SRC_PATH\"]\n    ERROR[\"Build Error:<br/>linux source not found\"]\n    \n    START --> CHECK_SOURCE\n    CHECK_SOURCE --> SOURCE_FOUND\n    CHECK_SOURCE --> SOURCE_NOT_FOUND\n    SOURCE_FOUND --> PREPARE\n    PREPARE --> COMPILE\n    SOURCE_NOT_FOUND --> ERROR\n    \n    style ERROR fill:#ffcdd2\n```\n\nHeader paths used during compilation [Makefile:154-161]():\n- `-I $(KERN_SRC_PATH)/arch/$(LINUX_ARCH)/include`\n- `-I $(KERN_BUILD_PATH)/arch/$(LINUX_ARCH)/include/generated`\n- `-I $(KERN_SRC_PATH)/include`\n- `-I $(KERN_BUILD_PATH)/include/generated/uapi`\n\nSources: [Makefile:98-104](), [Makefile:146-183](), [builder/init_env.sh:81-89]()\n\n### Cross-Compilation Dependencies\n\nCross-compilation requires architecture-specific toolchains:\n\n| Host → Target | Required Package | Notes |\n|---------------|-----------------|-------|\n| x86_64 → arm64 | `gcc-aarch64-linux-gnu` | Sets `CC=aarch64-linux-gnu-gcc` |\n| arm64 → x86_64 | `gcc-x86-64-linux-gnu` | Ubuntu 24.04+ package name |\n| Any → Android | NDK not required | Uses standard cross-compiler |\n\nSources: [.github/workflows/go-c-cpp.yml:19](), [builder/init_env.sh:46-58]()\n\n---\n\n## Go Dependencies\n\n### Core Dependencies\n\nThe project uses Go 1.24.3+ with the following major dependencies:\n\n```mermaid\ngraph TB\n    subgraph \"eBPF Framework\"\n        EBPF[\"cilium/ebpf<br/>v0.18.0\"]\n        EBPFMGR[\"gojue/ebpfmanager<br/>v0.5.0\"]\n    end\n    \n    subgraph \"Network Analysis\"\n        GOPACKET[\"google/gopacket<br/>v1.1.19→cfc4n/gopacket\"]\n        ELIBPCAP[\"jschwinger233/elibpcap<br/>v1.0.2\"]\n    end\n    \n    subgraph \"CLI & API\"\n        COBRA[\"spf13/cobra<br/>v1.9.1\"]\n        PFLAG[\"spf13/pflag<br/>v1.0.6\"]\n        GIN[\"gin-gonic/gin<br/>v1.10.0\"]\n    end\n    \n    subgraph \"Protocol & Data\"\n        PROTOBUF[\"google/protobuf<br/>v1.36.6\"]\n        CRYPTO[\"golang.org/x/crypto<br/>v0.45.0\"]\n    end\n    \n    subgraph \"Build Tools\"\n        BINDATA[\"shuLhan/go-bindata<br/>v4.0.0\"]\n    end\n    \n    EBPF --> EBPFMGR\n    GOPACKET --> ELIBPCAP\n```\n\n**Key Dependencies:**\n\n1. **cilium/ebpf v0.18.0**: Core eBPF library for loading programs, managing maps, and handling CO-RE relocations. Provides `ebpf.CollectionSpec` and map management.\n\n2. **gojue/ebpfmanager v0.5.0**: Higher-level eBPF lifecycle management. Wraps cilium/ebpf with probe attachment, TC hook management, and cleanup orchestration.\n\n3. **cfc4n/gopacket v1.1.20**: Forked version of `google/gopacket` with improvements for PCAP-NG format. Used for packet serialization and PCAP file generation.\n\n4. **jschwinger233/elibpcap v1.0.2**: BPF filter compiler for TC programs. Translates Berkeley Packet Filter (BPF) syntax to eBPF bytecode.\n\n5. **go-bindata**: Embeds compiled eBPF bytecode (`.o` files) into the Go binary as byte arrays in [assets/ebpf_probe.go]().\n\nSources: [go.mod:5-19](), [go.sum:8-14]()\n\n### Indirect Dependencies\n\nCritical indirect dependencies include:\n\n| Package | Version | Purpose |\n|---------|---------|---------|\n| `florianl/go-tc` | v0.4.5 | Linux Traffic Control netlink interface |\n| `vishvananda/netlink` | v1.3.1 | Generic netlink operations |\n| `mdlayher/netlink` | v1.7.2 | Low-level netlink socket library |\n| `hashicorp/go-multierror` | v1.1.1 | Error aggregation |\n\nSources: [go.mod:22-58]()\n\n---\n\n## Runtime Dependencies\n\n### Minimal Runtime Requirements\n\nThe compiled `ecapture` binary has **no runtime dependencies** beyond kernel features:\n\n| Requirement | Description |\n|-------------|-------------|\n| Linux kernel | 4.18+ (non-CO-RE) or 5.2+ (CO-RE) |\n| BTF support | For CO-RE mode only |\n| `CAP_SYS_ADMIN` | Or root privileges to load eBPF programs |\n| `CAP_BPF` + `CAP_PERFMON` | On kernels 5.8+ as alternative to `CAP_SYS_ADMIN` |\n\n**Static Linking**: The binary is statically linked with libpcap [functions.mk:48-53]():\n```\nCGO_LDFLAGS='-O2 -g -L$(CURDIR)/lib/libpcap/ -lpcap -static'\n-ldflags \"... -linkmode=external -extldflags -static\"\n```\n\nThis eliminates the need for libpcap at runtime.\n\n### Kernel Feature Requirements by Module\n\nDifferent capture modules require different kernel features:\n\n```mermaid\ngraph TB\n    subgraph \"TLS Modules\"\n        OPENSSL[\"OpenSSL Module\"]\n        GOTLS[\"GoTLS Module\"]\n        GNUTLS[\"GnuTLS Module\"]\n        \n        UPROBE[\"Uprobe Support<br/>CONFIG_UPROBE_EVENTS\"]\n    end\n    \n    subgraph \"Network Module\"\n        TC[\"TC Classifier\"]\n        \n        TC_FEATURE[\"TC eBPF Support<br/>CONFIG_NET_CLS_BPF\"]\n        SKB[\"sk_buff handling\"]\n    end\n    \n    subgraph \"System Audit\"\n        BASH[\"Bash/Zsh Module\"]\n        DB[\"MySQL/PostgreSQL Module\"]\n        \n        UPROBE2[\"Uprobe Support\"]\n    end\n    \n    OPENSSL --> UPROBE\n    GOTLS --> UPROBE\n    GNUTLS --> UPROBE\n    BASH --> UPROBE2\n    DB --> UPROBE2\n    TC --> TC_FEATURE\n    TC --> SKB\n    \n    UPROBE -.->|\"requires\"| KPROBE_REG[\"Kprobe Registration\"]\n    TC_FEATURE -.->|\"requires\"| NETFILTER[\"Netfilter Hooks\"]\n```\n\nSources: [variables.mk](), [Makefile:122-134]()\n\n---\n\n## Compilation Modes Comparison\n\n### CO-RE vs Non-CO-RE\n\n| Aspect | CO-RE Mode | Non-CO-RE Mode |\n|--------|-----------|----------------|\n| **Build Requirements** | clang, llc, BTF headers | clang, llc, full kernel headers |\n| **Runtime Requirements** | BTF-enabled kernel (5.2+) | Any kernel 4.18+ |\n| **Portability** | One binary for all kernels | Kernel-specific binary |\n| **Bytecode Size** | Larger (includes relocation info) | Smaller (fixed offsets) |\n| **Build Time** | Faster (no kernel prepare) | Slower (kernel header preparation) |\n| **Use Case** | General distribution | Legacy systems, Android |\n\n**Compilation Flags Comparison:**\n\nCO-RE [Makefile:122-134]():\n```\n-target bpfel -g -D__BPF_TARGET_MISSING=\"...\"\n# Uses BTF information for relocations\n```\n\nNon-CO-RE [Makefile:151-166]():\n```\n-I $(KERN_SRC_PATH)/arch/$(LINUX_ARCH)/include\n-I $(KERN_BUILD_PATH)/include/generated/uapi\n# Requires all kernel header paths\n```\n\nSources: [Makefile:122-183](), [variables.mk]()\n\n---\n\n## Development Environment Setup\n\n### Automated Setup (Ubuntu)\n\nThe project provides [builder/init_env.sh]() for automated environment setup:\n\n```mermaid\ngraph TD\n    START[\"Run init_env.sh\"]\n    DETECT[\"Detect Ubuntu Version\"]\n    SELECT_CLANG[\"Select Clang Version<br/>10-18 based on release\"]\n    INSTALL_DEPS[\"apt-get install<br/>compilers + tools\"]\n    SYMLINK[\"Create symlinks<br/>clang→clang-N\"]\n    PREPARE_KERNEL[\"Extract & prepare<br/>linux-source\"]\n    INSTALL_GO[\"Download Go 1.24.6\"]\n    CLONE[\"Clone ecapture repo\"]\n    DONE[\"Ready to build\"]\n    \n    START --> DETECT\n    DETECT --> SELECT_CLANG\n    SELECT_CLANG --> INSTALL_DEPS\n    INSTALL_DEPS --> SYMLINK\n    SYMLINK --> PREPARE_KERNEL\n    PREPARE_KERNEL --> INSTALL_GO\n    INSTALL_GO --> CLONE\n    CLONE --> DONE\n    \n    style DONE fill:#e8f5e9\n```\n\nVersion-specific clang selection [builder/init_env.sh:16-39]():\n- Ubuntu 20.04: clang-10\n- Ubuntu 22.04: clang-12\n- Ubuntu 23.04+: clang-15\n- Ubuntu 24.04: clang-18\n\nSources: [builder/init_env.sh:1-106]()\n\n### Manual Setup\n\nFor manual setup, install these package groups:\n\n**Essential Tools:**\n```bash\nsudo apt-get install build-essential pkgconf libelf-dev\n```\n\n**LLVM Toolchain:**\n```bash\nsudo apt-get install llvm-14 clang-14\nsudo ln -sf /usr/bin/clang-14 /usr/bin/clang\nsudo ln -sf /usr/bin/llc-14 /usr/bin/llc\nsudo ln -sf /usr/bin/llvm-strip-14 /usr/bin/llvm-strip\n```\n\n**Kernel Tools:**\n```bash\nsudo apt-get install linux-tools-common linux-tools-generic flex bison\n```\n\n**Cross-Compilation (optional):**\n```bash\n# For arm64 on x86_64\nsudo apt-get install gcc-aarch64-linux-gnu\n\n# For x86_64 on arm64  \nsudo apt-get install gcc-x86-64-linux-gnu\n```\n\n**Kernel Headers (for non-CO-RE):**\n```bash\nsudo apt-get install linux-source\ncd /usr/src\nsudo tar -xf linux-source-*.tar.bz2\ncd linux-source-*/\nsudo make oldconfig\nsudo make prepare\n```\n\nSources: [.github/workflows/go-c-cpp.yml:16-33](), [builder/init_env.sh:72-89]()\n\n---\n\n## Docker Build Environment\n\nThe project provides a Dockerfile for containerized builds:\n\n```mermaid\ngraph LR\n    subgraph \"Base Image\"\n        UBUNTU[\"ubuntu:22.04\"]\n    end\n    \n    subgraph \"Compiler Installation\"\n        COMPILERS[\"apt-get install<br/>llvm-14, clang-14<br/>build-essential\"]\n    end\n    \n    subgraph \"Go Installation\"\n        GO_INSTALL[\"Download Go 1.24.6<br/>Architecture: amd64/arm64\"]\n    end\n    \n    subgraph \"Build Stage\"\n        COPY_SRC[\"COPY source code\"]\n        MAKE[\"make all\"]\n        BINARY[\"bin/ecapture\"]\n    end\n    \n    subgraph \"Release Image\"\n        ALPINE[\"alpine:latest\"]\n        FINAL[\"Minimal image<br/>with binary only\"]\n    end\n    \n    UBUNTU --> COMPILERS\n    COMPILERS --> GO_INSTALL\n    GO_INSTALL --> COPY_SRC\n    COPY_SRC --> MAKE\n    MAKE --> BINARY\n    BINARY --> ALPINE\n    ALPINE --> FINAL\n```\n\nThe multi-stage build [builder/Dockerfile:1-39]():\n1. **Builder stage**: Full toolchain on Ubuntu 22.04\n2. **Release stage**: Minimal Alpine image with static binary\n\nBuild for multiple architectures:\n```bash\ndocker buildx build --platform linux/amd64,linux/arm64 -t ecapture:latest .\n```\n\nSources: [builder/Dockerfile:1-39](), [.github/workflows/release.yml:101-129]()\n\n---\n\n## Verification Commands\n\nAfter setup, verify dependencies:\n\n```bash\n# Check tool versions\nclang --version          # Should be >= 9.0\ngo version               # Should be >= 1.24.0\nllc --version            # Should match clang version\nbpftool version          # Any version\n\n# Check BTF support (runtime)\nls -l /sys/kernel/btf/vmlinux  # Should exist for CO-RE\n\n# Check eBPF kernel configs\ngrep CONFIG_BPF /boot/config-$(uname -r)\n# Should show:\n# CONFIG_BPF=y\n# CONFIG_BPF_SYSCALL=y\n# CONFIG_HAVE_EBPF_JIT=y\n```\n\nSources: [functions.mk:2-39](), [variables.mk]()\n\n---\n\n## Common Issues\n\n### Clang Version Too Old\n\n**Problem**: Build fails with \"you MUST use clang 9 or newer\"\n\n**Solution**: Install a newer clang version and create symlinks [builder/init_env.sh:75-79]():\n```bash\nsudo apt-get install clang-14 llc-14 llvm-strip-14\nsudo ln -sf /usr/bin/clang-14 /usr/bin/clang\n```\n\n### Missing Kernel Headers\n\n**Problem**: Non-CO-RE build fails with \"linux source not found\"\n\n**Solution**: Install and prepare kernel headers [Makefile:98-104]():\n```bash\nsudo apt-get install linux-source\ncd /usr/src && sudo tar -xf linux-source-*.tar.bz2\ncd linux-source-*/ && sudo make prepare\n```\n\n### Go Version Too Old\n\n**Problem**: Build fails with \"you MUST use golang 1.24 or newer\"\n\n**Solution**: Download Go 1.24.6+ from [golang.org/dl](https://golang.org/dl/) and update PATH.\n\nSources: [functions.mk:13-35](), [Makefile:98-104](), [builder/init_env.sh:72-89]()"
          },
          {
            "page_plan": {
              "id": "2",
              "title": "Architecture"
            },
            "content": "# Architecture\n\n<details>\n<summary>Relevant source files</summary>\n\nThe following files were used as context for generating this wiki page:\n\n- [CHANGELOG.md](CHANGELOG.md)\n- [README.md](README.md)\n- [README_CN.md](README_CN.md)\n- [cli/cmd/root.go](cli/cmd/root.go)\n- [images/ecapture-help-v0.8.9.svg](images/ecapture-help-v0.8.9.svg)\n- [main.go](main.go)\n- [user/config/iconfig.go](user/config/iconfig.go)\n- [user/module/imodule.go](user/module/imodule.go)\n- [user/module/probe_openssl.go](user/module/probe_openssl.go)\n\n</details>\n\n\n\nThis document describes the overall system architecture of eCapture, explaining how different layers and components interact to capture and decrypt SSL/TLS traffic without requiring CA certificates. The architecture follows a clear separation of concerns across six major layers, from user interface through eBPF execution to formatted output.\n\nFor information about specific capture modules and their implementation details, see [Capture Modules](#3). For eBPF program development details, see [eBPF Program Development](#5.2). For build system details, see [Build System](#5.1).\n\n## Layered Architecture Overview\n\neCapture implements a layered architecture where each layer has distinct responsibilities. The system processes data from user commands through kernel-space eBPF programs to formatted output files or real-time streams.\n\n**Diagram: eCapture Layered Architecture**\n\n## System Architecture Overview\n\neCapture implements a five-layer architecture with clear separation of concerns. Data flows from monitored applications through kernel-space eBPF hooks to userspace event processing, ultimately producing formatted output in multiple formats (text, PCAP-NG, keylog files, or protobuf streams).\n\n**Diagram: Five-Layer Architecture**\n\n```mermaid\ngraph TB\n    subgraph Layer1[\"1. User Interface Layer\"]\n        CLI[\"rootCmd<br/>cli/cmd/root.go:81<br/>cobra.Command\"]\n        HTTPServer[\"http.NewHttpServer<br/>cli/http/server.go<br/>localhost:28256\"]\n        eCaptureQ[\"eCaptureQ Mode<br/>ecaptureq.NewServer<br/>Tauri/React GUI\"]\n    end\n    \n    subgraph Layer2[\"2. Capture Module Layer\"]\n        ModuleFactory[\"module.GetModuleFunc<br/>user/module/imodule.go\"]\n        \n        TLSModule[\"MOpenSSLProbe<br/>user/module/probe_openssl.go:83<br/>OpenSSL/BoringSSL/NSS/GnuTLS\"]\n        GoTLSModule[\"MGoTLSProbe<br/>Go crypto/tls\"]\n        AuditModules[\"Bash/Zsh/MySQL/PostgreSQL<br/>System audit modules\"]\n    end\n    \n    subgraph Layer3[\"3. eBPF Runtime Layer\"]\n        VersionDetect[\"getSslBpfFile<br/>detectOpenssl<br/>user/module/probe_openssl.go:179\"]\n        BytecodeSelect[\"geteBPFName<br/>user/module/imodule.go:191<br/>CO-RE/_core.o vs non-CO-RE/_noncore.o\"]\n        Manager[\"manager.Manager<br/>ebpfmanager.InitWithOptions<br/>ebpfmanager.Start\"]\n        \n        Uprobes[\"Uprobe Programs<br/>SSL_read/SSL_write<br/>SSL_do_handshake\"]\n        TCProgs[\"TC Programs<br/>capture_packets<br/>ingress/egress\"]\n        Kprobes[\"Kprobe Programs<br/>tcp_sendmsg<br/>udp_sendmsg\"]\n    end\n    \n    subgraph Layer4[\"4. Event Processing Layer\"]\n        Readers[\"Event Readers<br/>perf.NewReader<br/>ringbuf.NewReader<br/>user/module/imodule.go:308\"]\n        Processor[\"EventProcessor<br/>event_processor.EventProcessor<br/>pkg/event_processor\"]\n        Workers[\"eventWorker<br/>UUID-based lifecycle<br/>Socket vs Default\"]\n        Parsers[\"Protocol Parsers<br/>IParser interface<br/>HTTP/HTTP2/H2C\"]\n    end\n    \n    subgraph Layer5[\"5. Output Layer\"]\n        TextOut[\"Text Mode<br/>TlsCaptureModelTypeText<br/>Direct console output\"]\n        PcapOut[\"PCAP Mode<br/>TlsCaptureModelTypePcap<br/>savePcapngSslKeyLog\"]\n        KeylogOut[\"Keylog Mode<br/>TlsCaptureModelTypeKeylog<br/>saveMasterSecret\"]\n        ProtobufOut[\"Protobuf Stream<br/>pb.LogEntry<br/>WebSocket/TCP\"]\n    end\n    \n    CLI --> ModuleFactory\n    HTTPServer -.->|runtime config| ModuleFactory\n    eCaptureQ -.->|remote mode| ProtobufOut\n    \n    ModuleFactory --> TLSModule\n    ModuleFactory --> GoTLSModule\n    ModuleFactory --> AuditModules\n    \n    TLSModule --> VersionDetect\n    GoTLSModule --> VersionDetect\n    VersionDetect --> BytecodeSelect\n    BytecodeSelect --> Manager\n    \n    Manager --> Uprobes\n    Manager --> TCProgs\n    Manager --> Kprobes\n    \n    Uprobes --> Readers\n    TCProgs --> Readers\n    Kprobes --> Readers\n    \n    Readers --> Processor\n    Processor --> Workers\n    Workers --> Parsers\n    \n    Parsers --> TextOut\n    Parsers --> PcapOut\n    Parsers --> KeylogOut\n    Parsers --> ProtobufOut\n```\n\nThe architecture makes several critical design decisions that enable its functionality:\n\nSources: [cli/cmd/root.go:80-153](), [user/module/probe_openssl.go:83-106](), [user/module/imodule.go:47-75](), [user/module/probe_openssl.go:178-278](), [user/module/imodule.go:191-214]()\n\n### Architectural Layers Explained\n\nEach layer has specific responsibilities:\n\n| Layer | Responsibilities | Key Components |\n|-------|------------------|----------------|\n| **1. User Interface** | Command parsing, configuration input, runtime updates | `rootCmd` (Cobra CLI), HTTP config server, eCaptureQ integration |\n| **2. Capture Modules** | Protocol-specific logic, bytecode selection, probe attachment | `IModule` interface, `MOpenSSLProbe`, `MGoTLSProbe`, etc. |\n| **3. eBPF Runtime** | Version detection, CO-RE/non-CO-RE selection, eBPF program lifecycle | `manager.Manager`, uprobe/TC/kprobe programs, BTF detection |\n| **4. Event Processing** | Event reading, aggregation, protocol parsing, connection tracking | `EventProcessor`, `eventWorker`, `IParser` implementations |\n| **5. Output** | Format conversion, file writing, network streaming | Text/PCAP/Keylog/Protobuf writers, PCAP-NG DSB blocks |\n\nSee [Module System and Lifecycle](#2.4) for details on the IModule interface and [Event Processing Pipeline](#2.2) for event flow details.\n\n### Key Architectural Decisions\n\n| Decision | Rationale | Implementation |\n|----------|-----------|----------------|\n| **Factory Pattern for Modules** | Enables dynamic module loading based on CLI command | `IModule` interface [user/module/imodule.go:47-75](); modules register via `RegisteFunc` at package init |\n| **Dual Bytecode Compilation** | Supports both BTF-enabled (CO-RE) and non-BTF kernels | Build system produces `*_core.o` and `*_noncore.o` variants; runtime selection via `geteBPFName` [user/module/imodule.go:191-214]() |\n| **Version Detection Layer** | Handles 20+ OpenSSL/BoringSSL versions with different struct layouts | `detectOpenssl` [user/module/probe_openssl.go:178-278]() parses ELF `.rodata`, maps version to bytecode via `sslVersionBpfMap` |\n| **Event Processing Pipeline** | Decouples capture from output formatting, enables protocol parsing | `EventProcessor` [user/module/imodule.go:104]() aggregates events by UUID, applies HTTP/HTTP2 parsers |\n| **Multiple Output Formats** | Supports live analysis (text), forensics (PCAP), decryption (keylog) | `TlsCaptureModelType` enum [user/module/probe_openssl.go:58-76]() controls capture mode |\n| **Connection Tracking** | Maps network packets to processes without userspace cooperation | Kprobes populate `network_map` LRU hash; TC hooks lookup PID/UID. See [Network Connection Tracking](#2.6) |\n| **Dual Worker Lifecycle** | Optimizes resource usage for different connection patterns | Socket-based lifecycle for persistent connections, default (10-tick timeout) for short-lived. See [Event Processing Pipeline](#2.2) |\n\nSources: [user/module/imodule.go:47-75](), [user/module/probe_openssl.go:58-76](), [user/module/probe_openssl.go:178-278](), [user/module/imodule.go:191-214]()\n\n## Data Flow Pipeline\n\nThe following diagram shows how data flows through the system from application to output:\n\n**Diagram: Complete Data Flow**\n\n```mermaid\ngraph LR\n    App[\"Monitored Application<br/>curl, browser, etc.<br/>Uses OpenSSL/Go TLS\"] --> LibraryCall[\"Library Call<br/>SSL_write/SSL_read<br/>tls.Conn.Write/Read\"]\n    \n    LibraryCall --> UprobeHook[\"Uprobe Hook<br/>kernel intercepts<br/>function entry/return\"]\n    \n    UprobeHook --> PlaintextCapture[\"Plaintext Capture<br/>Before encryption<br/>After decryption\"]\n    \n    PlaintextCapture --> eBPFMap[\"eBPF Map<br/>perf_event_array<br/>or ring_buffer\"]\n    \n    eBPFMap --> UserSpaceRead[\"perf.NewReader.Read<br/>user/module/imodule.go:308<br/>goroutine per map\"]\n    \n    UserSpaceRead --> DecodeEvent[\"Decode Event<br/>child.Decode(map, bytes)<br/>→ IEventStruct\"]\n    \n    DecodeEvent --> Dispatcher[\"Module.Dispatcher<br/>user/module/imodule.go:409<br/>Route by EventType\"]\n    \n    Dispatcher --> ProcessorQueue{\"EventType?\"}\n    ProcessorQueue -->|TypeEventProcessor| EventProcessor[\"EventProcessor.Write<br/>Aggregate by UUID\"]\n    ProcessorQueue -->|TypeOutput| DirectOutput[\"Direct Output\"]\n    ProcessorQueue -->|TypeModuleData| ModuleCache[\"Module Cache<br/>master secrets, tuples\"]\n    \n    EventProcessor --> WorkerPool[\"eventWorker pool<br/>Parse HTTP/HTTP2<br/>Format output\"]\n    \n    WorkerPool --> FinalOutput[\"Final Output\"]\n    DirectOutput --> FinalOutput\n    \n    FinalOutput --> OutputFormat{\"Output Mode\"}\n    OutputFormat -->|Text| Console[\"Console/File<br/>zerolog.Logger\"]\n    OutputFormat -->|PCAP| PcapFile[\"PCAP-NG File<br/>+ DSB keylog blocks\"]\n    OutputFormat -->|Keylog| KeylogFile[\"Keylog File<br/>CLIENT_RANDOM format\"]\n    OutputFormat -->|Protobuf| WebSocket[\"WebSocket/TCP<br/>pb.LogEntry messages\"]\n```\n\nSources: [user/module/imodule.go:285-391](), [user/module/imodule.go:409-448](), [cli/cmd/root.go:250-403]()\n\n## User Interface Layer\n\neCapture provides three interfaces for user interaction: CLI commands, HTTP configuration API, and eCaptureQ GUI integration.\n\n### CLI Entry Point\n\nThe CLI uses Cobra command framework. Each subcommand corresponds to a capture module.\n\n**Diagram: CLI Command Structure**\n\n```mermaid\ngraph TB\n    main[\"main()<br/>main.go:10\"] --> rootCmd[\"rootCmd.Execute<br/>cli/cmd/root.go:81\"]\n    \n    rootCmd --> SubCommands[\"Subcommands\"]\n    \n    SubCommands --> tls[\"tls<br/>OpenSSL/BoringSSL\"]\n    SubCommands --> gotls[\"gotls<br/>Go crypto/tls\"]\n    SubCommands --> gnutls[\"gnutls<br/>GnuTLS library\"]\n    SubCommands --> nss[\"nss<br/>NSS/NSPR\"]\n    SubCommands --> bash[\"bash<br/>Command audit\"]\n    SubCommands --> zsh[\"zsh<br/>Command audit\"]\n    SubCommands --> mysqld[\"mysqld<br/>Query audit\"]\n    SubCommands --> postgres[\"postgres<br/>Query audit\"]\n    \n    tls --> OpensslConfig[\"config.OpensslConfig<br/>--libssl, --model, --pcapfile\"]\n    gotls --> GotlsConfig[\"config.GoTLSConfig<br/>--elfpath, --model\"]\n    bash --> BashConfig[\"config.BashConfig<br/>--bashpath\"]\n    \n    OpensslConfig --> runModule[\"runModule<br/>cli/cmd/root.go:250\"]\n    GotlsConfig --> runModule\n    BashConfig --> runModule\n    \n    runModule --> SetModConfig[\"setModConfig<br/>PID, UID, BTF mode<br/>PerCpuMapSize\"]\n    SetModConfig --> GetModuleFunc[\"module.GetModuleFunc<br/>Factory lookup\"]\n    \n    GetModuleFunc --> ModInit[\"mod.Init()<br/>IModule.Init\"]\n    ModInit --> ModRun[\"mod.Run()<br/>Start eBPF, event loop\"]\n```\n\nSources: [main.go:9-11](), [cli/cmd/root.go:80-153](), [cli/cmd/root.go:250-403](), [cli/cmd/root.go:156-175]()\n\n**Persistent Flags** (apply to all modules) [cli/cmd/root.go:140-153]():\n\n| Flag | Type | Default | Purpose |\n|------|------|---------|---------|\n| `--pid` / `-p` | uint64 | 0 (all) | Target specific process ID |\n| `--uid` / `-u` | uint64 | 0 (all) | Target specific user ID |\n| `--btf` / `-b` | uint8 | 0 (auto) | BTF mode: 0=auto, 1=core, 2=non-core |\n| `--mapsize` | int | 1024 | eBPF map size per CPU (KB) |\n| `--logaddr` / `-l` | string | \"\" | Log destination: file path, `tcp://host:port`, or `ws://host:port/path` |\n| `--eventaddr` | string | \"\" | Event destination (separate from logs) |\n| `--listen` | string | `localhost:28256` | HTTP config server listen address |\n| `--tsize` / `-t` | uint64 | 0 | Truncate size in text mode (bytes, 0=no truncate) |\n| `--ecaptureq` | string | \"\" | Listen for eCaptureQ client connections |\n\n### HTTP Configuration Server\n\nAn HTTP server runs concurrently to accept runtime configuration updates without restarting.\n\n**Diagram: Runtime Configuration Update**\n\n```mermaid\ngraph TB\n    HTTPServer[\"http.NewHttpServer<br/>cli/http/server.go<br/>localhost:28256\"] --> ListenAddr[\"HTTP Listen<br/>POST /config endpoint\"]\n    \n    ListenAddr --> ReceiveJSON[\"Receive JSON<br/>updated config.IConfig\"]\n    \n    ReceiveJSON --> ReloadChannel[\"reRloadConfig chan<br/>cli/cmd/root.go:310<br/>buffered channel\"]\n    \n    ReloadChannel --> RunModuleLoop[\"runModule select loop<br/>cli/cmd/root.go:368\"]\n    \n    RunModuleLoop --> CloseModule[\"mod.Close()<br/>Detach eBPF programs\"]\n    \n    CloseModule --> Reinit[\"mod = modFunc()<br/>Create new instance\"]\n    \n    Reinit --> InitWithNewConfig[\"mod.Init(ctx, logger, newConfig)\"]\n    \n    InitWithNewConfig --> RestartModule[\"mod.Run()<br/>Resume with new config\"]\n```\n\nSources: [cli/cmd/root.go:313-322](), [cli/cmd/root.go:368-396]()\n\nThe HTTP server enables dynamic reconfiguration. When a POST request with updated configuration JSON arrives, the system:\n1. Closes the current module (detaches eBPF programs)\n2. Creates a new module instance\n3. Initializes with updated configuration\n4. Restarts event capture with new settings\n\nSee [Configuration System](#2.3) for configuration structure details and [HTTP API Documentation](../docs/remote-config-update-api.md) for API details.\n\n### Output Destinations\n\neCapture supports multiple output destinations for logs and events:\n\n**Diagram: Output Routing**\n\n```mermaid\ngraph TB\n    initLogger[\"initLogger()<br/>cli/cmd/root.go:178\"] --> CheckAddr{\"logaddr flag?\"}\n    \n    CheckAddr -->|\"\"| StdoutOnly[\"zerolog.ConsoleWriter<br/>os.Stdout only\"]\n    CheckAddr -->|file path| FileWriter[\"os.Create(addr)<br/>MultiLevelWriter\"]\n    CheckAddr -->|tcp://| TCPWriter[\"net.Dial('tcp', addr)<br/>TCP connection\"]\n    CheckAddr -->|ws://| WSWriter[\"ws.NewClient<br/>WebSocket connection\"]\n    \n    FileWriter --> MultiWriter[\"zerolog.MultiLevelWriter<br/>Console + File/TCP/WS\"]\n    TCPWriter --> MultiWriter\n    WSWriter --> MultiWriter\n    \n    MultiWriter --> LoggerInstance[\"zerolog.Logger<br/>Used by modules\"]\n    StdoutOnly --> LoggerInstance\n    \n    LoggerInstance --> EventCollector[\"eventCollector io.Writer<br/>event.CollectorWriter or ecaptureQEventWriter\"]\n    \n    EventCollector --> ModuleInit[\"mod.Init(ctx, logger, conf, eventCollector)<br/>user/module/imodule.go:111\"]\n```\n\nSources: [cli/cmd/root.go:178-247](), [cli/cmd/root.go:255-295]()\n\nOutput types [cli/cmd/root.go:69-73]():\n- **Stdout** (type 0): Console output only\n- **File** (type 1): Write to local file, optionally with rotation via `--eventroratesize` and `--eventroratetime`\n- **TCP** (type 2): Stream to `tcp://host:port`\n- **WebSocket** (type 3): Stream to `ws://host:port/path` or `wss://` (TLS)\n\nThe `eventCollector` receives captured events while the `logger` receives operational logs. They can use the same or different destinations via `--logaddr` and `--eventaddr` flags.\n\n## Capture Module Layer\n\nThe module system uses a factory pattern for dynamic module instantiation. Each module implements the `IModule` interface and embeds the base `Module` struct for common functionality.\n\n### Module Factory and Registration\n\nModules self-register at package initialization time.\n\n**Diagram: Module Factory Pattern**\n\n```mermaid\ngraph TB\n    InitFuncs[\"init() functions<br/>user/module/probe_*.go\"] --> CallRegisteFunc[\"RegisteFunc(NewModuleProbe)<br/>Register constructor\"]\n    \n    CallRegisteFunc --> ModuleFactories[\"moduleFactories map<br/>Global registry\"]\n    \n    ModuleFactories --> RegisteredModules[\"Registered Constructors\"]\n    \n    RegisteredModules --> NewOpenSSLProbe[\"NewOpenSSLProbe<br/>user/module/probe_openssl.go:781\"]\n    RegisteredModules --> NewGoTLSProbe[\"NewGoTLSProbe<br/>user/module/probe_gotls.go\"]\n    RegisteredModules --> NewGnuTLSProbe[\"NewGnuTLSProbe\"]\n    RegisteredModules --> NewNSSProbe[\"NewNSSProbe\"]\n    RegisteredModules --> NewBashProbe[\"NewBashProbe\"]\n    RegisteredModules --> NewMysqldProbe[\"NewMysqldProbe\"]\n    RegisteredModules --> NewPostgresProbe[\"NewPostgresProbe\"]\n    RegisteredModules --> NewZshProbe[\"NewZshProbe\"]\n    \n    CLIRunModule[\"runModule<br/>cli/cmd/root.go:250\"] --> GetModuleFunc[\"module.GetModuleFunc(modName)<br/>Lookup in registry\"]\n    \n    GetModuleFunc --> RetrieveConstructor[\"moduleFactories[modName]<br/>Return func() IModule\"]\n    \n    RetrieveConstructor --> CreateInstance[\"modFunc()<br/>Create module instance\"]\n```\n\nSources: [user/module/probe_openssl.go:777-786](), [cli/cmd/root.go:344-347]()\n\nExample registration from OpenSSL module [user/module/probe_openssl.go:777-786]():\n```go\nfunc init() {\n    RegisteFunc(NewOpenSSLProbe)\n}\n\nfunc NewOpenSSLProbe() IModule {\n    mod := &MOpenSSLProbe{}\n    mod.name = ModuleNameOpenssl\n    mod.mType = ProbeTypeUprobe\n    return mod\n}\n```\n\nThe CLI retrieves the constructor via `module.GetModuleFunc(modName)` [cli/cmd/root.go:344]() and invokes it to create an instance.\n\n### IModule Interface\n\nAll modules implement the `IModule` interface [user/module/imodule.go:47-75](), which defines lifecycle and event processing methods.\n\n**IModule Interface Methods**\n\n| Method | Purpose | Phase | Responsibility |\n|--------|---------|-------|----------------|\n| `Init(context.Context, *zerolog.Logger, config.IConfig, io.Writer)` | Initialize module, setup EventProcessor, BTF detection | Initialization | Base `Module` + child overrides |\n| `Start()` | Load eBPF bytecode, attach probes/hooks | Start | Child implements |\n| `Run()` | Start event readers, begin processing loop | Run | Base `Module` (calls child.Start) |\n| `Events() []*ebpf.Map` | Return eBPF maps to read events from | Run | Child implements |\n| `Decode(*ebpf.Map, []byte) (event.IEventStruct, error)` | Parse raw event bytes into struct | Event Processing | Base delegates to child.DecodeFun |\n| `DecodeFun(*ebpf.Map) (event.IEventStruct, bool)` | Return decoder for specific map | Event Processing | Child implements |\n| `Dispatcher(event.IEventStruct)` | Route events (cache, process, output) | Event Processing | Base + child both implement |\n| `Close()` | Stop eBPF programs, cleanup resources | Shutdown | Base + child both implement |\n\nSee [Module System and Lifecycle](#2.4) for detailed lifecycle information.\n\nSources: [user/module/imodule.go:47-75](), [user/module/imodule.go:110-171]()\n\n### Base Module Implementation\n\nThe `Module` struct [user/module/imodule.go:83-108]() provides common functionality that all probes inherit through embedding.\n\n**Diagram: Module Struct Composition**\n\n```mermaid\ngraph TB\n    BaseModule[\"Module struct<br/>user/module/imodule.go:83<br/>Embedded by all probes\"] --> CoreFields[\"Core Fields\"]\n    BaseModule --> CoreMethods[\"Core Methods\"]\n    \n    CoreFields --> ctx[\"ctx context.Context<br/>Cancellation signal\"]\n    CoreFields --> logger[\"logger *zerolog.Logger<br/>Logging interface\"]\n    CoreFields --> conf[\"conf config.IConfig<br/>Module configuration\"]\n    CoreFields --> processor[\"processor *EventProcessor<br/>pkg/event_processor\"]\n    CoreFields --> reader[\"reader []IClose<br/>perf/ringbuf readers\"]\n    CoreFields --> child[\"child IModule<br/>Actual probe (e.g., MOpenSSLProbe)\"]\n    CoreFields --> eventCollector[\"eventCollector io.Writer<br/>Output destination\"]\n    CoreFields --> flags[\"isCoreUsed bool<br/>isKernelLess5_2 bool\"]\n    \n    CoreMethods --> InitMethod[\"Init()<br/>BTF detection<br/>EventProcessor setup<br/>user/module/imodule.go:111\"]\n    CoreMethods --> RunMethod[\"Run()<br/>Start child.Start()<br/>readEvents()<br/>user/module/imodule.go:236\"]\n    CoreMethods --> readEvents[\"readEvents()<br/>perfEventReader<br/>ringbufEventReader<br/>user/module/imodule.go:285\"]\n    CoreMethods --> DecodeMethod[\"Decode()<br/>Delegates to child.DecodeFun<br/>user/module/imodule.go:393\"]\n    CoreMethods --> DispatcherMethod[\"Dispatcher()<br/>Routes events<br/>user/module/imodule.go:409\"]\n    CoreMethods --> CloseMethod[\"Close()<br/>Cleanup readers<br/>user/module/imodule.go:450\"]\n    \n    ProbeModules[\"Probe Modules\"] --> MOpenSSL[\"MOpenSSLProbe<br/>user/module/probe_openssl.go:83<br/>embeds Module\"]\n    ProbeModules --> MGoTLS[\"MGoTLSProbe<br/>embeds Module\"]\n    ProbeModules --> MGnuTLS[\"MGnuTLSProbe<br/>embeds Module\"]\n    ProbeModules --> MBash[\"MBashProbe<br/>embeds Module\"]\n    \n    MOpenSSL --> ImplStart[\"Implements Start()<br/>setupManagers*<br/>Load eBPF bytecode\"]\n    MOpenSSL --> ImplEvents[\"Implements Events()<br/>Returns event maps\"]\n    MOpenSSL --> ImplDecodeFun[\"Implements DecodeFun()<br/>Map → event struct type\"]\n    MOpenSSL --> ImplDispatcher[\"Implements Dispatcher()<br/>saveMasterSecret<br/>AddConn/DelConn\"]\n```\n\nSources: [user/module/imodule.go:83-108](), [user/module/probe_openssl.go:83-106]()\n\n**Base Module Responsibilities** [user/module/imodule.go:83-460]():\n\n1. **BTF Detection**: `autoDetectBTF()` checks `/sys/kernel/btf/vmlinux` and container environment [user/module/imodule.go:173-190]()\n2. **Bytecode Selection**: `geteBPFName()` appends `_core.o`/`_noncore.o` and `_less52.o` suffixes [user/module/imodule.go:191-214]()\n3. **Event Readers**: `perfEventReader()` and `ringbufEventReader()` setup goroutines per eBPF map [user/module/imodule.go:308-391]()\n4. **EventProcessor**: Initialized with truncate size and hex mode [user/module/imodule.go:127]()\n5. **Output Routing**: Detects `eventCollector` type to select text vs protobuf encoding [user/module/imodule.go:122-126](), [user/module/imodule.go:461-479]()\n6. **Lifecycle Management**: Coordinates child module's lifecycle through `Start()`, `Run()`, `Close()` [user/module/imodule.go:236-262]()\n\n### Module-Specific Implementations\n\nEach probe module embeds `Module` and adds module-specific state and logic. See [Capture Modules](#3) for detailed implementation information.\n\n**Key Module Types**\n\n| Module | Purpose | Target Libraries/Binaries | Key State | See Also |\n|--------|---------|---------------------------|-----------|----------|\n| `MOpenSSLProbe` | TLS plaintext capture | libssl.so, libcrypto.so, BoringSSL | `sslVersionBpfMap`, `pidConns`, `masterKeys`, `eBPFProgramType` | [OpenSSL Module](#3.1.1) |\n| `MGoTLSProbe` | Go TLS plaintext capture | Go binaries (crypto/tls) | `isRegisterABI`, `tcPacketsChan`, `keylogger` | [Go TLS Module](#3.1.2) |\n| `MGnuTLSProbe` | GnuTLS plaintext capture | libgnutls.so | `keylogger`, `masterKeys` | [GnuTLS and NSS Modules](#3.1.3) |\n| `MNSSProbe` | NSS/NSPR plaintext capture | libnss3.so, libnspr4.so | Master secret extraction | [GnuTLS and NSS Modules](#3.1.3) |\n| `MBashProbe` | Bash command audit | bash binary | Command filtering via readline hooks | [Shell Command Auditing](#3.2.1) |\n| `MZshProbe` | Zsh command audit | zsh binary | Command filtering via zle hooks | [Shell Command Auditing](#3.2.1) |\n| `MMysqldProbe` | MySQL query audit | mysqld binary | `funcName`, SQL extraction from dispatch_command | [Database Query Auditing](#3.2.2) |\n| `MPostgresProbe` | PostgreSQL query audit | postgres binary | Query extraction from exec_simple_query | [Database Query Auditing](#3.2.2) |\n\nSources: [user/module/probe_openssl.go:83-106]()\n\n**Example: MOpenSSLProbe State** [user/module/probe_openssl.go:83-106]():\n\n| Field | Type | Purpose |\n|-------|------|---------|\n| `pidConns` | `map[uint32]map[uint32]ConnInfo` | Maps PID → FD → connection tuple and socket [user/module/probe_openssl.go:91]() |\n| `sock2pidFd` | `map[uint64][2]uint32` | Reverse map: socket → [PID, FD] for connection cleanup [user/module/probe_openssl.go:93]() |\n| `masterKeys` | `map[string]bool` | Deduplicates TLS master secrets by client random [user/module/probe_openssl.go:98]() |\n| `sslVersionBpfMap` | `map[string]string` | Maps SSL version string to bytecode filename [user/module/probe_openssl.go:101]() |\n| `eBPFProgramType` | `TlsCaptureModelType` | Determines capture mode (Text/Pcap/Keylog) [user/module/probe_openssl.go:99]() |\n| `keylogger` | `*os.File` | File handle for keylog mode output [user/module/probe_openssl.go:96]() |\n| `bpfManager` | `*manager.Manager` | eBPF program lifecycle manager [user/module/probe_openssl.go:85]() |\n\nThese maps enable correlation between SSL data events (identified by PID/FD) and network tuples captured by TC hooks. See [Version Detection and Bytecode Selection](#2.5) for `sslVersionBpfMap` usage and [Network Connection Tracking](#2.6) for connection mapping details.\n\n## eBPF Runtime Layer\n\nThe eBPF runtime layer bridges userspace modules with kernel-space instrumentation. It handles version detection, bytecode selection, and eBPF program lifecycle through the `ebpfmanager` library.\n\nFor comprehensive details on eBPF programs and hooks, see [eBPF Engine](#2.1). For version detection algorithms, see [Version Detection and Bytecode Selection](#2.5).\n\n### Overview of eBPF Runtime Components\n\n**Diagram: eBPF Runtime Components**\n\n```mermaid\ngraph TB\n    Module[\"Capture Module<br/>(e.g., MOpenSSLProbe)\"] --> VersionDetection[\"Version Detection<br/>getSslBpfFile()<br/>detectOpenssl()\"]\n    \n    VersionDetection --> BytecodeSelection[\"Bytecode Selection<br/>geteBPFName()<br/>CO-RE vs non-CO-RE\"]\n    \n    BytecodeSelection --> AssetLoad[\"Asset Loading<br/>assets.Asset(bpfFileName)<br/>Embedded bytecode\"]\n    \n    AssetLoad --> ManagerInit[\"Manager Init<br/>manager.InitWithOptions()<br/>eBPF verifier\"]\n    \n    ManagerInit --> ManagerStart[\"Manager Start<br/>manager.Start()<br/>Attach probes\"]\n    \n    ManagerStart --> ProbeTypes[\"Probe Types\"]\n    \n    ProbeTypes --> Uprobes[\"Uprobes<br/>User function hooks<br/>SSL_read, SSL_write\"]\n    ProbeTypes --> TC[\"TC Classifiers<br/>Network packet capture<br/>ingress/egress\"]\n    ProbeTypes --> Kprobes[\"Kprobes<br/>Kernel function hooks<br/>tcp_sendmsg, etc.\"]\n    \n    Uprobes --> eBPFMaps[\"eBPF Maps<br/>perf_event_array<br/>ring_buffer\"]\n    TC --> eBPFMaps\n    Kprobes --> eBPFMaps\n    \n    eBPFMaps --> UserSpaceRead[\"User Space Read<br/>Module.readEvents()<br/>perfEventReader, ringbufEventReader\"]\n```\n\nSources: [user/module/probe_openssl.go:178-278](), [user/module/imodule.go:191-214](), [user/module/probe_openssl.go:312-331](), [user/module/imodule.go:285-391]()\n\nThe runtime layer performs these operations:\n\n1. **Version Detection**: Determine target library version (see [Version Detection and Bytecode Selection](#2.5))\n2. **Bytecode Selection**: Choose CO-RE or non-CO-RE bytecode based on BTF availability\n3. **Asset Loading**: Load embedded bytecode from `assets` package\n4. **eBPF Verification**: Kernel verifies program safety\n5. **Probe Attachment**: Attach uprobes, TC classifiers, kprobes\n6. **Event Reading**: Setup readers for eBPF maps\n\n### BTF Detection and Bytecode Selection\n\neCapture compiles two variants of each eBPF program: **CO-RE** (BTF-enabled, kernel >= 5.2) and **non-CO-RE** (traditional, all kernels). Runtime selection is based on kernel BTF support.\n\n**Diagram: BTF Detection and Bytecode Mode Selection**\n\n```mermaid\ngraph TB\n    ModuleInit[\"Module.Init()<br/>user/module/imodule.go:111\"] --> CheckBTFMode{\"conf.GetBTF()\"}\n    \n    CheckBTFMode -->|0: BTFModeAutoDetect| AutoDetect[\"autoDetectBTF()<br/>user/module/imodule.go:173\"]\n    CheckBTFMode -->|1: BTFModeCore| ForceCore[\"m.isCoreUsed = true\"]\n    CheckBTFMode -->|2: BTFModeNonCore| ForceNonCore[\"m.isCoreUsed = false\"]\n    \n    AutoDetect --> CheckContainer[\"ebpfenv.IsContainer()<br/>Detect container env\"]\n    CheckContainer --> CheckBTFFile[\"ebpfenv.IsEnableBTF()<br/>Check /sys/kernel/btf/vmlinux\"]\n    CheckBTFFile --> SetCoreFlag[\"m.isCoreUsed = (BTF available)\"]\n    \n    ForceCore --> ApplyFilename[\"geteBPFName()<br/>user/module/imodule.go:191\"]\n    ForceNonCore --> ApplyFilename\n    SetCoreFlag --> ApplyFilename\n    \n    ApplyFilename --> CheckMode{\"m.isCoreUsed?\"}\n    CheckMode -->|true| AppendCore[\"filename.o<br/>→ filename_core.o\"]\n    CheckMode -->|false| AppendNonCore[\"filename.o<br/>→ filename_noncore.o\"]\n    \n    AppendCore --> CheckKernel{\"Kernel < 5.2?\"}\n    AppendNonCore --> CheckKernel\n    \n    CheckKernel -->|Yes| AppendLess52[\"Append _less52.o<br/>e.g., filename_core_less52.o\"]\n    CheckKernel -->|No| FinalFilename[\"Final bytecode filename\"]\n    \n    AppendLess52 --> FinalFilename\n    \n    FinalFilename --> AssetLookup[\"assets.Asset(bpfFileName)<br/>Load from embedded FS\"]\n```\n\nSources: [user/module/imodule.go:154-170](), [user/module/imodule.go:173-190](), [user/module/imodule.go:191-214]()\n\n**BTF Detection Logic** [user/module/imodule.go:173-190]():\n1. Check if running in container (BTF detection may be unreliable in containers)\n2. Look for `/sys/kernel/btf/vmlinux` file to confirm BTF support\n3. Set `m.isCoreUsed` flag based on detection result\n\n**Filename Transformation Examples** [user/module/imodule.go:191-214]():\n- `openssl_3_0_0_kern.o` → `openssl_3_0_0_kern_core.o` (BTF kernel >= 5.2)\n- `openssl_3_0_0_kern.o` → `openssl_3_0_0_kern_noncore.o` (non-BTF kernel >= 5.2)\n- `openssl_3_0_0_kern.o` → `openssl_3_0_0_kern_core_less52.o` (BTF kernel < 5.2)\n- `openssl_3_0_0_kern.o` → `openssl_3_0_0_kern_noncore_less52.o` (non-BTF kernel < 5.2)\n\nCO-RE bytecode uses BTF type information for structure layout resolution at load time, enabling **Compile Once - Run Everywhere**. Non-CO-RE bytecode has hardcoded offsets for specific kernel versions. See [Build System](#5.1) for compilation details.\n\n### eBPF Program Lifecycle\n\nThe `ebpfmanager.Manager` [user/module/probe_openssl.go:85]() manages eBPF program loading, verification, attachment, and cleanup.\n\n```mermaid\ngraph TB\n\t%% **Diagram: eBPF Lifecycle Management**\n\n    ModuleStart[\"child.Start()<br/>e.g., probe_openssl.go:280\"] --> SetupManagers[\"setupManagers*()<br/>Mode-specific setup<br/>Text/Pcap/Keylog\"]\n    \n    SetupManagers --> DefineManager[\"Create manager.Manager<br/>Define Probes, Maps, ConstantEditors\"]\n    \n    DefineManager --> LoadBytecode[\"assets.Asset(bpfFileName)<br/>Load from embedded FS<br/>user/module/probe_openssl.go:312\"]\n    \n    LoadBytecode --> ManagerInit[\"bpfManager.InitWithOptions()<br/>bytes.NewReader(byteBuf)<br/>user/module/probe_openssl.go:320\"]\n    \n    ManagerInit --> eBPFVerifier[\"eBPF Verifier<br/>Kernel validates program<br/>Checks safety, loops, permissions\"]\n    \n    eBPFVerifier --> ManagerStart[\"bpfManager.Start()<br/>Attach all probes<br/>user/module/probe_openssl.go:329\"]\n    \n    ManagerStart --> AttachProbes[\"Attach Probes\"]\n    \n    AttachProbes --> Uprobes[\"Uprobes<br/>SSL_read, SSL_write<br/>SSL_do_handshake, etc.\"]\n    AttachProbes --> TCProgs[\"TC Classifiers<br/>ingress_cls_func<br/>egress_cls_func\"]\n    AttachProbes --> Kprobes[\"Kprobes<br/>tcp_sendmsg<br/>__sys_connect\"]\n    \n    Uprobes --> RegisterMaps[\"initDecodeFun*()<br/>Register event maps<br/>user/module/probe_openssl.go:336\"]\n    TCProgs --> RegisterMaps\n    Kprobes --> RegisterMaps\n    \n    RegisterMaps --> EventMaps[\"m.eventMaps<br/>[]*ebpf.Map\"]\n    RegisterMaps --> EventFuncMaps[\"m.eventFuncMaps<br/>map[*ebpf.Map]IEventStruct\"]\n    \n    EventMaps --> ModuleRun[\"Module.Run()<br/>Event processing<br/>user/module/imodule.go:236\"]\n    EventFuncMaps --> ModuleRun\n    \n    ModuleRun --> Running[\"Running State<br/>Read events from maps\"]\n    \n    Running --> Shutdown[\"Module.Close()<br/>Shutdown signal\"]\n    \n    Shutdown --> ManagerStop[\"bpfManager.Stop<br/>(manager.CleanAll)<br/>user/module/probe_openssl.go:354\"]\n    \n    ManagerStop --> DetachAll[\"Detach all probes<br/>Unload eBPF programs<br/>Close file descriptors\"]\n```\n\nSources: [user/module/probe_openssl.go:280-357](), [user/module/imodule.go:236-262]()\n\n**Lifecycle Phases**:\n\n1. **Setup**: `Start()` calls mode-specific setup (`setupManagersText`, `setupManagersPcap`, `setupManagersKeylog`)\n2. **Bytecode Load**: `assets.Asset(bpfFileName)` retrieves embedded bytecode [user/module/probe_openssl.go:312-317]()\n3. **Initialization**: `bpfManager.InitWithOptions()` loads bytecode, kernel verifies program [user/module/probe_openssl.go:320-326]()\n4. **Attachment**: `bpfManager.Start()` attaches uprobes/TC/kprobes [user/module/probe_openssl.go:329-331]()\n5. **Map Registration**: `initDecodeFun*()` populates `eventMaps` and `eventFuncMaps` [user/module/probe_openssl.go:333-348]()\n6. **Running**: Base `Module.Run()` spawns event readers and EventProcessor [user/module/imodule.go:236-262]()\n7. **Shutdown**: `bpfManager.Stop(manager.CleanAll)` detaches and cleans up [user/module/probe_openssl.go:352-357]()\n\n### Configuration Injection via Constant Editors\n\neBPF programs define constant variables that are rewritten at load time to inject runtime configuration (PID, UID filters).\n\n**Constant Editor Mechanism**\n\n| Constant Name | Purpose | Type | Value Source | Effect |\n|---------------|---------|------|--------------|--------|\n| `target_pid` | Filter by process ID | `uint64` | `conf.GetPid()` | 0 = capture all PIDs, non-zero = specific PID only |\n| `target_uid` | Filter by user ID | `uint64` | `conf.GetUid()` | 0 = capture all UIDs, non-zero = specific UID only |\n\nSources: [user/module/probe_openssl.go:361-387]()\n\nThe `constantEditor()` method [user/module/probe_openssl.go:361-387]() returns a slice of `manager.ConstantEditor` structs. The eBPF manager rewrites these constants in the bytecode **before** loading into the kernel. This enables parameterized filtering without recompiling eBPF programs.\n\nFor kernels < 5.2, global variable support is limited. The `EnableGlobalVar()` check [user/config/iconfig.go:194-203]() returns false, disabling certain features.\n\n### Uprobe Attachments\n\nUprobes instrument user-space library functions to capture plaintext data before/after encryption.\n\n**Diagram: Uprobe Hook Points**\n\n```mermaid\ngraph TB\n    subgraph \"OpenSSL/BoringSSL Uprobes\"\n        SSLRead[\"uprobe/SSL_read<br/>uprobe/SSL_read_ex<br/>capture received plaintext\"]\n        SSLWrite[\"uprobe/SSL_write<br/>uprobe/SSL_write_ex<br/>capture sent plaintext\"]\n        SSLHandshake[\"uprobe/SSL_do_handshake<br/>capture TLS handshake\"]\n        SSLGetWbio[\"uprobe/SSL_get_wbio<br/>extract BIO file descriptor\"]\n    end\n    \n    subgraph \"Go TLS Uprobes\"\n        GoTLSWrite[\"uprobe/crypto/tls.(*Conn).Write<br/>capture sent plaintext\"]\n        GoTLSRead[\"uprobe/crypto/tls.(*Conn).Read<br/>capture received plaintext\"]\n    end\n    \n    subgraph \"Bash Uprobes\"\n        Readline[\"uprobe/readline<br/>capture shell commands\"]\n    end\n    \n    subgraph \"MySQL Uprobes\"\n        DispatchCommand[\"uprobe/dispatch_command<br/>capture SQL queries\"]\n    end\n    \n    SSLRead --> SSLDataEvent[\"SSLDataEvent<br/>events map\"]\n    SSLWrite --> SSLDataEvent\n    SSLHandshake --> MasterSecretEvent[\"MasterSecretEvent<br/>mastersecret_events map\"]\n    SSLGetWbio --> ConnDataEvent[\"ConnDataEvent<br/>connection tracking\"]\n    \n    GoTLSWrite --> GoTLSDataEvent[\"TLS event struct\"]\n    GoTLSRead --> GoTLSDataEvent\n    \n    Readline --> BashEvent[\"Bash command event\"]\n    DispatchCommand --> MySQLEvent[\"MySQL query event\"]\n```\n\nSources: [user/module/probe_openssl.go:85-96]()\n\nEach uprobe captures function arguments and return values from target library functions. For OpenSSL, key hooks include:\n- `SSL_read` / `SSL_read_ex`: Intercepts plaintext after decryption\n- `SSL_write` / `SSL_write_ex`: Intercepts plaintext before encryption  \n- `SSL_do_handshake`: Captures TLS handshake for master secret extraction\n- `SSL_get_wbio`: Extracts BIO structure to get socket file descriptor\n\n### TC (Traffic Control) Hooks\n\nTC classifier programs attach to network interfaces to capture encrypted packets with network metadata.\n\n**Diagram: TC Hook Architecture**\n\n```mermaid\ngraph LR\n    NetworkInterface[\"Network Interface<br/>eth0, wlan0\"] --> IngressPath[\"Ingress Path<br/>incoming packets\"]\n    NetworkInterface --> EgressPath[\"Egress Path<br/>outgoing packets\"]\n    \n    IngressPath --> IngressTC[\"tc/ingress_cls_func<br/>BPF_PROG_TYPE_SCHED_CLS\"]\n    EgressPath --> EgressTC[\"tc/egress_cls_func<br/>BPF_PROG_TYPE_SCHED_CLS\"]\n    \n    IngressTC --> ExtractTuple[\"Extract 5-tuple<br/>src/dst IP:port + proto\"]\n    EgressTC --> ExtractTuple\n    \n    ExtractTuple --> LookupPID[\"network_map lookup<br/>LRU_HASH map\"]\n    LookupPID --> FilterCheck[\"Filter by PID/UID<br/>target_pid, target_uid\"]\n    \n    FilterCheck --> CaptureSKB[\"Capture skb<br/>packet data + metadata\"]\n    CaptureSKB --> TcSkbEvent[\"TcSkbEvent<br/>skb_events map\"]\n```\n\nSources: TC hooks capture complete packets including:\n- Ethernet, IP, and TCP/UDP headers\n- Encrypted TLS payload\n- 5-tuple (source IP:port, dest IP:port, protocol)\n- Timestamp and packet length\n\nThe TC programs lookup the network tuple in `network_map` to determine which process owns the connection, enabling process-level filtering even for encrypted traffic.\n\n### Kprobe Attachments\n\nKprobes hook kernel functions to build network context mappings that correlate packets with processes.\n\n**Diagram: Kprobe Context Tracking**\n\n```mermaid\ngraph TB\n    Kprobe[\"kprobe/tcp_sendmsg<br/>kprobe/udp_sendmsg\"] --> ExtractSocket[\"Extract sock structure<br/>from kernel args\"]\n    \n    ExtractSocket --> GetPIDUID[\"bpf_get_current_pid_tgid<br/>bpf_get_current_uid_gid\"]\n    GetPIDUID --> Extract5Tuple[\"Extract 5-tuple<br/>from sock->sk_common\"]\n    \n    Extract5Tuple --> BuildKey[\"Build network_map key<br/>saddr, daddr, sport, dport, proto\"]\n    BuildKey --> StoreMapping[\"network_map[key] = {pid, uid}<br/>LRU_HASH map\"]\n    \n    StoreMapping --> TCLookup[\"TC hooks lookup<br/>correlate packets to processes\"]\n```\n\nSources: Kprobes populate the `network_map` LRU hash map with entries mapping network 5-tuples to process identifiers. This enables TC hooks to:\n1. Capture encrypted packets at the network layer\n2. Look up which process owns the connection\n3. Filter packets based on target PID/UID\n4. Associate captured packets with the correct capture session\n\n### eBPF Map Types\n\nDifferent map types serve different purposes in the data pipeline.\n\n**Map Type Summary**\n\n| Map Type | Purpose | Examples |\n|----------|---------|----------|\n| `BPF_MAP_TYPE_PERF_EVENT_ARRAY` | Stream events to userspace | `events`, `mastersecret_events`, `skb_events` |\n| `BPF_MAP_TYPE_RINGBUF` | High-performance event streaming (kernel >= 5.8) | Alternative to perf arrays |\n| `BPF_MAP_TYPE_LRU_HASH` | Connection tracking with automatic eviction | `network_map`, `pidConns`, `sock2pidFd` |\n| `BPF_MAP_TYPE_ARRAY` | Configuration and constants | `target_pid`, `target_uid` |\n| `BPF_MAP_TYPE_HASH` | General key-value storage | Various module-specific maps |\n\nSources: [user/module/imodule.go:294-306]()\n\n## Event Processing Pipeline\n\nOnce events are captured in kernel space, they flow through userspace processing to produce formatted output.\n\n### Event Reading from eBPF Maps\n\nThe base `Module` struct sets up readers for each eBPF map based on its type.\n\n**Diagram: Event Reader Setup**\n\n```mermaid\ngraph TB\n    readEvents[\"Module.readEvents<br/>user/module/imodule.go:285\"] --> IterateMaps[\"for _, e := range child.Events()\"]\n    \n    IterateMaps --> CheckMapType{\"e.Type()\"}\n    CheckMapType -->|PerfEventArray| PerfReader[\"perfEventReader<br/>user/module/imodule.go:308\"]\n    CheckMapType -->|RingBuf| RingReader[\"ringbufEventReader<br/>user/module/imodule.go:353\"]\n    \n    PerfReader --> CreatePerfReader[\"perf.NewReader<br/>conf.GetPerCpuMapSize()\"]\n    RingReader --> CreateRingReader[\"ringbuf.NewReader\"]\n    \n    CreatePerfReader --> PerfLoop[\"Goroutine: for loop<br/>rd.Read()\"]\n    CreateRingReader --> RingLoop[\"Goroutine: for loop<br/>rd.Read()\"]\n    \n    PerfLoop --> ReadRecord[\"record.RawSample<br/>[]byte\"]\n    RingLoop --> ReadRecord\n    \n    ReadRecord --> DecodeEvent[\"child.Decode<br/>(em, record.RawSample)\"]\n    DecodeEvent --> IEventStruct[\"IEventStruct<br/>event.IEventStruct\"]\n    \n    IEventStruct --> DispatchEvent[\"Module.Dispatcher<br/>(evt)\"]\n```\n\nSources: [user/module/imodule.go:285-391]()\n\nThe event reading process [user/module/imodule.go:285-391]():\n\n1. **Map Iteration**: Call `child.Events()` to get list of eBPF maps to read\n2. **Reader Creation**: Create appropriate reader (perf or ringbuf) based on map type\n3. **Goroutine Per Map**: Spawn goroutine for each map to read events concurrently\n4. **Read Loop**: Continuously call `rd.Read()` to fetch raw event bytes\n5. **Decode**: Call `child.Decode(em, rawBytes)` to parse into `IEventStruct`\n6. **Dispatch**: Route event via `Module.Dispatcher(evt)`\n\nThe perf event reader [user/module/imodule.go:308-351]() creates a buffer of configurable size (via `--mapsize` flag) per CPU core. Lost samples are logged when the buffer fills.\n\n### Event Decoding\n\nEach module implements its own `Decode` method that parses raw bytes into structured events.\n\n**Diagram: Decode Function Dispatch**\n\n```mermaid\ngraph TB\n    ModuleDecode[\"Module.Decode<br/>user/module/imodule.go:393\"] --> DecodeFun[\"child.DecodeFun(em)<br/>get decoder for this map\"]\n    \n    DecodeFun --> EventStructMap{\"m.eventFuncMaps[em]\"}\n    EventStructMap --> CloneStruct[\"es.Clone()<br/>create new event instance\"]\n    \n    CloneStruct --> DecodeBytes[\"te.Decode(b)<br/>parse raw bytes\"]\n    DecodeBytes --> ReturnEvent[\"return IEventStruct\"]\n    \n    subgraph \"Example: OpenSSL Module\"\n        OpensslDecodeFun[\"DecodeFun<br/>probe_openssl.go:389\"] --> CheckMap{\"which eBPF map?\"}\n        CheckMap -->|events| SSLDataDecoder[\"event.SSLDataEvent\"]\n        CheckMap -->|mastersecret_events| MasterSecretDecoder[\"event.MasterSecretEvent\"]\n        CheckMap -->|skb_events| TcSkbDecoder[\"event.TcSkbEvent\"]\n    end\n```\n\nSources: [user/module/imodule.go:393-406](), [user/module/probe_openssl.go:389-392]()\n\nThe decode process:\n1. Module's `DecodeFun` returns the appropriate event struct type for a given eBPF map\n2. Call `es.Clone()` to create a new instance of the event struct\n3. Call `te.Decode(b)` which uses `encoding/binary` to parse the raw bytes\n4. Return the populated `IEventStruct`\n\nEach event type implements the `IEventStruct` interface which defines `Decode([]byte) error`, `Clone() IEventStruct`, `EventType()`, and output methods.\n\n### Event Dispatcher and Routing\n\nThe `Dispatcher` method routes decoded events to appropriate handlers based on event type.\n\n**Diagram: Event Routing Logic**\n\n```mermaid\ngraph TB\n    Dispatcher[\"Module.Dispatcher<br/>user/module/imodule.go:409\"] --> CheckClosed{\"isClosed.Load()\"}\n    CheckClosed -->|true| DropEvent[\"Drop event<br/>module shutting down\"]\n    CheckClosed -->|false| CheckHex{\"conf.GetHex()\"}\n    \n    CheckHex -->|true| CheckEventType1{\"EventType?\"}\n    CheckEventType1 -->|TypeEventProcessor| HexOutput1[\"e.StringHex()<br/>direct hex output\"]\n    CheckEventType1 -->|TypeOutput| HexOutput1\n    CheckEventType1 -->|Other| ContinueRouting[\"Continue to switch\"]\n    \n    CheckHex -->|false| ContinueRouting\n    \n    ContinueRouting --> SwitchEventType{\"e.EventType()\"}\n    SwitchEventType -->|TypeOutput| EncodeOutput[\"output(e)<br/>text or protobuf\"]\n    SwitchEventType -->|TypeEventProcessor| WriteProcessor[\"processor.Write(e)\"]\n    SwitchEventType -->|TypeModuleData| WriteChild[\"child.Dispatcher(e)<br/>module-specific handling\"]\n    \n    EncodeOutput --> WriteCollector[\"eventCollector.Write(b)\"]\n    WriteProcessor --> EventProcessorQueue[\"EventProcessor queue\"]\n    WriteChild --> ModuleCache[\"Module caches<br/>e.g., master secrets, connections\"]\n```\n\nSources: [user/module/imodule.go:409-448]()\n\nThe dispatcher [user/module/imodule.go:409-448]() implements three routing paths:\n\n1. **TypeOutput**: Events ready for direct output (e.g., parsed HTTP requests/responses)\n   - Encoded as text or protobuf based on `eventOutputType` [user/module/imodule.go:461-479]()\n   - Written directly to `eventCollector` (logger or WebSocket)\n\n2. **TypeEventProcessor**: Events needing further processing (e.g., SSL data fragments)\n   - Sent to `EventProcessor` for aggregation and protocol parsing\n   - `processor.Write(e)` queues event for worker processing\n\n3. **TypeModuleData**: Events containing metadata (e.g., master secrets, connections)\n   - Routed to child module's `Dispatcher` for module-specific handling\n   - OpenSSL module saves master secrets [user/module/probe_openssl.go:733-754]()\n   - Connection info cached for tuple resolution [user/module/probe_openssl.go:398-416]()\n\n### EventProcessor and Worker Lifecycle\n\nThe `EventProcessor` aggregates fragmented events by connection and applies protocol-aware parsing.\n\n**Diagram: EventProcessor Architecture**\n\n```mermaid\ngraph TB\n    ProcessorWrite[\"processor.Write<br/>IEventStruct\"] --> ExtractUUID[\"e.GetUUID()<br/>connection identifier\"]\n    \n    ExtractUUID --> LookupWorker{\"workers[uuid]<br/>exists?\"}\n    LookupWorker -->|No| CreateWorker[\"newEventWorker<br/>lifecycle management\"]\n    LookupWorker -->|Yes| ExistingWorker[\"Existing eventWorker\"]\n    \n    CreateWorker --> DetermineLifecycle{\"UUID prefix?\"}\n    DetermineLifecycle -->|\"sock:\"| SocketLifecycle[\"Socket-based lifecycle<br/>explicit cleanup via sock\"]\n    DetermineLifecycle -->|Other| DefaultLifecycle[\"Default lifecycle<br/>10-tick timeout, auto-cleanup\"]\n    \n    SocketLifecycle --> WorkerQueue[\"worker.incomingChan<br/>queue event\"]\n    DefaultLifecycle --> WorkerQueue\n    ExistingWorker --> WorkerQueue\n    \n    WorkerQueue --> WorkerLoop[\"Goroutine: worker.Run()\"]\n    WorkerLoop --> ParseEvent[\"Parse event data<br/>detect protocol\"]\n    \n    ParseEvent --> CheckParser{\"IParser?\"}\n    CheckParser -->|HTTPRequest| HTTPRequestParser[\"HTTPRequest parser\"]\n    CheckParser -->|HTTPResponse| HTTPResponseParser[\"HTTPResponse parser\"]\n    CheckParser -->|HTTP2| HTTP2Parser[\"HTTP2 HPACK parser\"]\n    CheckParser -->|Default| DefaultParser[\"Raw payload output\"]\n    \n    HTTPRequestParser --> FormatOutput[\"Format and write<br/>to eventCollector\"]\n    HTTPResponseParser --> FormatOutput\n    HTTP2Parser --> FormatOutput\n    DefaultParser --> FormatOutput\n    \n    FormatOutput --> OutputEvent[\"TypeOutput event\"]\n    OutputEvent --> DispatcherAgain[\"Module.Dispatcher<br/>TypeOutput branch\"]\n```\n\nSources: The `EventProcessor` manages a pool of `eventWorker` goroutines, each responsible for a specific connection UUID. Workers implement two lifecycle models:\n\n1. **Default Lifecycle**: Auto-cleanup after 10 idle ticks (no events received)\n2. **Socket Lifecycle**: Persists until explicit cleanup via socket destruction\n\nEach worker maintains a queue and processes events sequentially to preserve ordering. Protocol parsers detect HTTP/1.1, HTTP/2, and other protocols, applying format-specific decoding (e.g., HPACK decompression for HTTP/2).\n\n## Configuration and Capture Modes\n\neCapture supports multiple capture modes that determine how data is processed and output.\n\n```mermaid\ngraph LR\n    ConfigSystem[\"config.IConfig<br/>Configuration Interface\"] --> CaptureTypes[\"Capture Types\"]\n    \n    CaptureTypes --> TLSCapture[\"TLS Capture<br/>TlsCaptureModelType\"]\n    CaptureTypes --> SystemCapture[\"System Capture<br/>Bash, MySQL, PostgreSQL\"]\n    \n    TLSCapture --> TextMode[\"TlsCaptureModelTypeText<br/>Live plaintext output\"]\n    TLSCapture --> PcapMode[\"TlsCaptureModelTypePcap<br/>PCAP-NG file output\"]\n    TLSCapture --> KeylogMode[\"TlsCaptureModelTypeKeylog<br/>Master key extraction\"]\n    \n    TextMode --> TextProcessor[\"Direct text processing\"]\n    PcapMode --> PcapProcessor[\"PCAP packet construction\"]\n    KeylogMode --> KeylogProcessor[\"Master secret extraction\"]\n    \n    SystemCapture --> AuditMode[\"Audit Mode<br/>Command/Query logging\"]\n    AuditMode --> AuditProcessor[\"Event-based logging\"]\n```\n\nSources: [user/module/probe_openssl.go:58-76](), [user/module/probe_openssl.go:127-154]()\n\n## Module Lifecycle\n\nEach module follows a standardized lifecycle managed by the base `Module` struct and implemented by specific probes.\n\n```mermaid\ngraph TB\n    ModuleCreation[\"Module Creation<br/>NewOpenSSLProbe()\"] --> InitPhase[\"Init Phase<br/>Module.Init()\"]\n    \n    InitPhase --> ConfigSetup[\"Configuration Setup<br/>config.IConfig processing\"]\n    InitPhase --> eBPFSetup[\"eBPF Setup<br/>bytecode loading, BTF detection\"]\n    InitPhase --> EventSetup[\"Event Setup<br/>EventProcessor initialization\"]\n    \n    ConfigSetup --> StartPhase[\"Start Phase<br/>Module.Start()\"]\n    eBPFSetup --> StartPhase\n    EventSetup --> StartPhase\n    \n    StartPhase --> ManagerSetup[\"Manager Setup<br/>setupManagers()\"]\n    ManagerSetup --> ProgramLoad[\"Program Load<br/>bpfManager.InitWithOptions()\"]\n    ProgramLoad --> ProgramStart[\"Program Start<br/>bpfManager.Start()\"]\n    \n    ProgramStart --> RunPhase[\"Run Phase<br/>Module.Run()\"]\n    \n    RunPhase --> EventReading[\"Event Reading<br/>perfEventReader, ringbufEventReader\"]\n    RunPhase --> EventProcessing[\"Event Processing<br/>EventProcessor.Serve()\"]\n    RunPhase --> EventDispatching[\"Event Dispatching<br/>Module.Dispatcher()\"]\n    \n    EventReading --> ClosePhase[\"Close Phase<br/>Module.Close()\"]\n    EventProcessing --> ClosePhase\n    EventDispatching --> ClosePhase\n    \n    ClosePhase --> ManagerStop[\"Manager Stop<br/>bpfManager.Stop()\"]\n    ClosePhase --> ReaderClose[\"Reader Close<br/>perf/ringbuf reader cleanup\"]\n    ClosePhase --> ProcessorClose[\"Processor Close<br/>EventProcessor.Close()\"]\n```\n\nSources: [user/module/imodule.go:99-152](), [user/module/imodule.go:218-244](), [user/module/probe_openssl.go:285-355](), [user/module/imodule.go:430-440]()"
          },
          {
            "page_plan": {
              "id": "2.1",
              "title": "eBPF Engine"
            },
            "content": "# eBPF Engine\n\n<details>\n<summary>Relevant source files</summary>\n\nThe following files were used as context for generating this wiki page:\n\n- [.github/workflows/codeql-analysis.yml](.github/workflows/codeql-analysis.yml)\n- [.github/workflows/go-c-cpp.yml](.github/workflows/go-c-cpp.yml)\n- [.github/workflows/release.yml](.github/workflows/release.yml)\n- [Makefile](Makefile)\n- [builder/Dockerfile](builder/Dockerfile)\n- [builder/Makefile.release](builder/Makefile.release)\n- [builder/init_env.sh](builder/init_env.sh)\n- [cli/cmd/root.go](cli/cmd/root.go)\n- [functions.mk](functions.mk)\n- [user/config/iconfig.go](user/config/iconfig.go)\n- [user/module/imodule.go](user/module/imodule.go)\n- [user/module/probe_openssl.go](user/module/probe_openssl.go)\n\n</details>\n\n\n\nThe eBPF Engine is the foundational runtime layer of eCapture that manages the lifecycle of eBPF programs, handles kernel compatibility through CO-RE/non-CO-RE modes, and facilitates communication between kernel and user space. This document covers the technical implementation of eBPF program loading, BTF detection, bytecode selection, and event map management.\n\nFor information about how individual capture modules use the eBPF engine, see [Module System and Lifecycle](#2.4). For details on version detection and bytecode mapping strategies, see [Version Detection and Bytecode Selection](#2.5). For event processing after eBPF maps deliver data to user space, see [Event Processing Pipeline](#2.2).\n\n## eBPF Program Types and Attachment\n\neCapture employs three primary eBPF program types to capture different aspects of system behavior:\n\n**Program Type Architecture**\n\n```mermaid\ngraph TB\n    subgraph \"User Space Applications\"\n        APP1[\"OpenSSL/BoringSSL<br/>libssl.so\"]\n        APP2[\"Go TLS Applications<br/>PIE binaries\"]\n        APP3[\"Database Servers<br/>mysqld/postgres\"]\n        APP4[\"Shell Processes<br/>bash/zsh\"]\n    end\n    \n    subgraph \"Kernel Space - eBPF Programs\"\n        UPROBE[\"Uprobe Programs<br/>openssl_kern.c<br/>gotls_kern.c<br/>bash_kern.c\"]\n        TC[\"TC Classifier<br/>tc_kern.c<br/>capture_packets\"]\n        KPROBE[\"Kprobe Programs<br/>conn_kern.c<br/>tcp_sendmsg<br/>tcp_close\"]\n    end\n    \n    subgraph \"eBPF Maps\"\n        PERF[\"Perf Event Arrays<br/>BPF_MAP_TYPE_PERF_EVENT_ARRAY\"]\n        RING[\"Ring Buffers<br/>BPF_MAP_TYPE_RINGBUF\"]\n        HASH[\"Hash Maps<br/>Connection tracking<br/>Process filtering\"]\n    end\n    \n    APP1 -->|\"uretprobe<br/>SSL_read/SSL_write\"| UPROBE\n    APP2 -->|\"uprobe<br/>crypto/tls.(*Conn).Read\"| UPROBE\n    APP3 -->|\"uprobe<br/>dispatch_command\"| UPROBE\n    APP4 -->|\"uretprobe<br/>readline\"| UPROBE\n    \n    APP1 -.->|\"network packets\"| TC\n    APP2 -.->|\"network packets\"| TC\n    \n    APP1 -.->|\"socket operations\"| KPROBE\n    APP2 -.->|\"socket operations\"| KPROBE\n    \n    UPROBE --> PERF\n    UPROBE --> RING\n    TC --> PERF\n    KPROBE --> HASH\n    \n    UPROBE --> HASH\n```\n\nSources: [Makefile:118-183](), [user/module/probe_openssl.go:83-106]()\n\n### Uprobe Programs\n\nUprobes attach to user-space functions in dynamically linked libraries and executables. The primary use cases are:\n\n| Function Hook | Purpose | eBPF Program |\n|--------------|---------|--------------|\n| `SSL_read` / `SSL_write` | Capture TLS plaintext | `openssl_kern.c` |\n| `SSL_do_handshake` | Extract master secrets | `openssl_kern.c` |\n| `crypto/tls.(*Conn).Read` | Go TLS capture | `gotls_kern.c` |\n| `dispatch_command` | MySQL query audit | `mysqld_kern.c` |\n| `readline` | Bash command audit | `bash_kern.c` |\n\nThe module manages uprobe attachment through `github.com/gojue/ebpfmanager`, which handles probe lifecycle, error recovery, and cleanup.\n\nSources: [user/module/probe_openssl.go:280-350]()\n\n### TC (Traffic Control) Classifiers\n\nTC eBPF programs attach to network interfaces at the Traffic Control layer, enabling packet-level capture with process attribution:\n\n```mermaid\ngraph LR\n    NET[\"Network Interface<br/>eth0/wlan0\"]\n    INGRESS[\"TC Ingress Hook<br/>capture_packets_ingress\"]\n    EGRESS[\"TC Egress Hook<br/>capture_packets_egress\"]\n    FILTER[\"Packet Filtering<br/>PID/UID/4-tuple\"]\n    PERF[\"Perf Event Array<br/>tc_events\"]\n    \n    NET -->|\"incoming packets\"| INGRESS\n    NET -->|\"outgoing packets\"| EGRESS\n    INGRESS --> FILTER\n    EGRESS --> FILTER\n    FILTER --> PERF\n```\n\nTC programs implement BPF cgroup socket filtering when a cgroup path is specified, and can apply Berkeley Packet Filter expressions for advanced filtering.\n\nSources: [user/module/probe_openssl.go:302-307]()\n\n### Kprobe Programs\n\nKprobes attach to kernel functions for connection tracking and socket lifecycle monitoring:\n\n- `tcp_sendmsg`: Correlate TCP connections to process IDs\n- `tcp_close`: Detect connection termination\n- `udp_sendmsg`: UDP connection tracking\n\nThe connection mapping enables TC programs to attribute packets to specific processes, which is critical for the PCAP output mode.\n\nSources: Architecture diagrams, common pattern in kernel tracing\n\n## CO-RE and BTF Mode\n\neCapture implements a dual-compilation strategy to maximize kernel compatibility: CO-RE (Compile Once - Run Everywhere) for modern kernels with BTF support, and traditional non-CO-RE for older or custom kernels.\n\n**Compilation and Runtime Mode Selection**\n\n```mermaid\ngraph TB\n    START[\"Build System<br/>Makefile\"]\n    \n    subgraph \"Compilation Phase\"\n        CORE_COMP[\"CO-RE Compilation<br/>clang -target bpfel<br/>-g for BTF debug info\"]\n        NONCORE_COMP[\"Non-CO-RE Compilation<br/>clang + kernel headers<br/>-I /usr/src/linux\"]\n        LESS52[\"Kernel < 5.2 Variants<br/>-DKERNEL_LESS_5_2\"]\n    end\n    \n    subgraph \"Bytecode Artifacts\"\n        CORE_OBJ[\"*_core.o<br/>BTF relocations\"]\n        NONCORE_OBJ[\"*_noncore.o<br/>Hardcoded offsets\"]\n        LESS52_CORE[\"*_core_less52.o\"]\n        LESS52_NONCORE[\"*_noncore_less52.o\"]\n    end\n    \n    EMBED[\"go-bindata<br/>assets/ebpf_probe.go\"]\n    \n    subgraph \"Runtime Detection\"\n        BTF_CHECK[\"BTF Availability Check<br/>IsEnableBTF\"]\n        KVER_CHECK[\"Kernel Version Check<br/>HostVersion\"]\n        MODE_SELECT[\"Mode Selection<br/>isCoreUsed flag\"]\n    end\n    \n    subgraph \"Bytecode Selection\"\n        GETEBPF[\"geteBPFName<br/>String replacement\"]\n        LOAD[\"assets.Asset<br/>bytecode loading\"]\n    end\n    \n    START --> CORE_COMP\n    START --> NONCORE_COMP\n    CORE_COMP --> LESS52\n    NONCORE_COMP --> LESS52\n    \n    CORE_COMP --> CORE_OBJ\n    NONCORE_COMP --> NONCORE_OBJ\n    LESS52 --> LESS52_CORE\n    LESS52 --> LESS52_NONCORE\n    \n    CORE_OBJ --> EMBED\n    NONCORE_OBJ --> EMBED\n    LESS52_CORE --> EMBED\n    LESS52_NONCORE --> EMBED\n    \n    EMBED --> BTF_CHECK\n    BTF_CHECK --> KVER_CHECK\n    KVER_CHECK --> MODE_SELECT\n    MODE_SELECT --> GETEBPF\n    GETEBPF --> LOAD\n```\n\nSources: [Makefile:118-183](), [user/module/imodule.go:173-214]()\n\n### BTF (BPF Type Format)\n\nBTF is a metadata format that describes the layout of kernel data structures, enabling eBPF programs to be portable across kernel versions. eCapture's BTF detection logic:\n\n**BTF Detection Process**\n\n| Step | Function | Location |\n|------|----------|----------|\n| 1. Container detection | `ebpfenv.IsContainer()` | [user/module/imodule.go:175-179]() |\n| 2. BTF availability check | `ebpfenv.IsEnableBTF()` | [user/module/imodule.go:180-186]() |\n| 3. Mode override | `conf.GetBTF()` | [user/module/imodule.go:154-164]() |\n\nBTF modes are defined in the configuration system:\n\n```\nBTFModeAutoDetect = 0  // Auto-detect (default)\nBTFModeCore       = 1  // Force CO-RE mode\nBTFModeNonCore    = 2  // Force non-CO-RE mode\n```\n\nSources: [user/config/iconfig.go:82-86](), [user/module/imodule.go:154-190]()\n\n### CO-RE Compilation\n\nCO-RE bytecode compilation uses LLVM's BTF generation and relocation capabilities:\n\n**Compilation Flags**\n\n```\nclang -D__TARGET_ARCH_x86 \\\n      -target bpfel \\           # Little-endian BPF target\n      -fno-ident \\              # Omit compiler identification\n      -fdebug-compilation-dir . \\\n      -g \\                       # Generate debug info (BTF)\n      -D__BPF_TARGET_MISSING=\"...\" \\\n      -MD -MP                    # Dependency generation\n```\n\nThe resulting `*_core.o` files contain BTF information that the kernel's BTF loader uses to perform field offset relocations at load time.\n\nSources: [Makefile:122-134](), [.github/workflows/go-c-cpp.yml:42]()\n\n### Non-CO-RE Compilation\n\nNon-CO-RE mode requires kernel headers at compile time to determine exact structure offsets:\n\n**Non-CO-RE Build Process**\n\n```mermaid\ngraph LR\n    HEADERS[\"Kernel Headers<br/>/usr/src/linux-source\"]\n    KERN_PREP[\"Kernel Preparation<br/>make prepare<br/>ARCH=arm64/x86\"]\n    CLANG[\"clang Compilation<br/>Include kernel headers\"]\n    LLC[\"llc Assembly<br/>-march=bpf<br/>-filetype=obj\"]\n    NONCORE[\"*_noncore.o<br/>Fixed offsets\"]\n    \n    HEADERS --> KERN_PREP\n    KERN_PREP --> CLANG\n    CLANG --> LLC\n    LLC --> NONCORE\n```\n\nThe Makefile explicitly includes architecture-specific header paths:\n\n```\n-I $(KERN_SRC_PATH)/arch/$(LINUX_ARCH)/include\n-I $(KERN_BUILD_PATH)/arch/$(LINUX_ARCH)/include/generated\n-I $(KERN_SRC_PATH)/include\n```\n\nSources: [Makefile:146-183](), [.github/workflows/go-c-cpp.yml:16-33]()\n\n### Kernel < 5.2 Support\n\nKernels older than 5.2.0 lack certain eBPF features (global variables, bounded loops). eCapture generates separate bytecode variants with the `KERNEL_LESS_5_2` macro defined:\n\n```c\n#ifdef KERNEL_LESS_5_2\n    // Use alternative implementation without global variables\n#else\n    // Modern kernel implementation\n#endif\n```\n\nThe runtime detects kernel version and selects the appropriate suffix:\n\nSources: [Makefile:131-134](), [user/module/imodule.go:140-149](), [user/module/imodule.go:208-211]()\n\n## Bytecode Asset Embedding\n\nAll compiled eBPF bytecode is embedded into the Go binary using `go-bindata`, eliminating runtime dependencies:\n\n**Asset Embedding Pipeline**\n\n```mermaid\ngraph LR\n    BYTECODE[\"user/bytecode/<br/>*.o files\"]\n    GOBINDATA[\"go-bindata Tool<br/>Generate Go code\"]\n    ASSET_GO[\"assets/ebpf_probe.go<br/>Asset function\"]\n    GOBUILD[\"Go Build<br/>Statically link\"]\n    BINARY[\"ecapture Binary<br/>Self-contained\"]\n    \n    BYTECODE --> GOBINDATA\n    GOBINDATA --> ASSET_GO\n    ASSET_GO --> GOBUILD\n    GOBUILD --> BINARY\n```\n\nThe embedded assets are accessed via:\n\n```go\nbyteBuf, err := assets.Asset(\"user/bytecode/openssl_3_2_0_kern_core.o\")\n```\n\nThis approach ensures the binary can run on any compatible system without requiring external bytecode files.\n\nSources: [Makefile:186-195](), [user/module/probe_openssl.go:310-317]()\n\n## eBPF Program Lifecycle\n\nThe eBPF program lifecycle is managed through the `ebpfmanager` library, which provides a structured approach to loading, attaching, and managing multiple eBPF programs and maps.\n\n**Module Initialization and Start Flow**\n\n```mermaid\ngraph TB\n    INIT[\"Module.Init<br/>Context setup<br/>Logger initialization\"]\n    \n    CHILD_INIT[\"Child Module Init<br/>e.g., MOpenSSLProbe\"]\n    \n    VERSION[\"Version Detection<br/>detectOpenssl<br/>getSslBpfFile\"]\n    \n    SETUP[\"Setup Managers<br/>setupManagersText<br/>setupManagersPcap<br/>setupManagersKeylog\"]\n    \n    BYTECODE[\"Bytecode Selection<br/>geteBPFName<br/>assets.Asset\"]\n    \n    INIT_MGR[\"Manager Initialization<br/>bpfManager.InitWithOptions\"]\n    \n    START_MGR[\"Manager Start<br/>bpfManager.Start\"]\n    \n    ATTACH[\"Probe Attachment<br/>Uprobes<br/>TC hooks<br/>Kprobes\"]\n    \n    DECODE[\"Initialize Decode Maps<br/>eventFuncMaps<br/>eventMaps\"]\n    \n    RUN[\"Module.Run<br/>Start event readers\"]\n    \n    INIT --> CHILD_INIT\n    CHILD_INIT --> VERSION\n    VERSION --> SETUP\n    SETUP --> BYTECODE\n    BYTECODE --> INIT_MGR\n    INIT_MGR --> START_MGR\n    START_MGR --> ATTACH\n    ATTACH --> DECODE\n    DECODE --> RUN\n```\n\nSources: [user/module/imodule.go:110-171](), [user/module/probe_openssl.go:109-176](), [user/module/probe_openssl.go:280-350]()\n\n### Manager Initialization\n\nThe `ebpfmanager.Manager` structure centralizes eBPF program and map management:\n\n**Manager Configuration**\n\n```go\ntype MOpenSSLProbe struct {\n    bpfManager        *manager.Manager\n    bpfManagerOptions manager.Options\n    eventFuncMaps     map[*ebpf.Map]event.IEventStruct\n    eventMaps         []*ebpf.Map\n}\n```\n\nThe manager options include:\n\n- **ConstantEditors**: Pass user-space values to eBPF (PID/UID filters)\n- **Probes**: Define uprobe/kprobe attachment points\n- **Maps**: Specify eBPF map configurations\n- **ActivatedProbes**: Control which probes are enabled\n\nSources: [user/module/probe_openssl.go:83-106](), [user/module/probe_openssl.go:361-387]()\n\n### Constant Editors\n\nConstant editors allow passing configuration values from user space to eBPF programs:\n\n```go\nfunc (m *MOpenSSLProbe) constantEditor() []manager.ConstantEditor {\n    return []manager.ConstantEditor{\n        {\n            Name:  \"target_pid\",\n            Value: uint64(m.conf.GetPid()),\n        },\n        {\n            Name:  \"target_uid\",\n            Value: uint64(m.conf.GetUid()),\n        },\n    }\n}\n```\n\nThe eBPF program checks these constants for filtering:\n\n```c\nconst volatile u64 target_pid = 0;\nconst volatile u64 target_uid = 0;\n\n// In probe function:\nif (target_pid != 0 && current_pid != target_pid) {\n    return 0;  // Filter out\n}\n```\n\nSources: [user/module/probe_openssl.go:361-387]()\n\n### Bytecode Loading\n\nThe bytecode selection algorithm considers multiple factors:\n\n```go\nfunc (m *Module) geteBPFName(filename string) string {\n    var newFilename = filename\n    \n    // Select CO-RE vs non-CO-RE\n    switch m.conf.GetByteCodeFileMode() {\n    case config.ByteCodeFileCore:\n        newFilename = strings.Replace(newFilename, \".o\", \"_core.o\", 1)\n    case config.ByteCodeFileNonCore:\n        newFilename = strings.Replace(newFilename, \".o\", \"_noncore.o\", 1)\n    default:\n        if m.isCoreUsed {\n            newFilename = strings.Replace(newFilename, \".o\", \"_core.o\", 1)\n        } else {\n            newFilename = strings.Replace(newFilename, \".o\", \"_noncore.o\", 1)\n        }\n    }\n    \n    // Kernel version suffix\n    if m.isKernelLess5_2 {\n        newFilename = strings.Replace(newFilename, \".o\", \"_less52.o\", 1)\n    }\n    \n    return newFilename\n}\n```\n\nThis produces filenames like:\n- `openssl_3_2_0_kern_core.o` (CO-RE, kernel >= 5.2)\n- `openssl_3_2_0_kern_noncore.o` (non-CO-RE, kernel >= 5.2)\n- `openssl_3_2_0_kern_core_less52.o` (CO-RE, kernel < 5.2)\n- `openssl_3_2_0_kern_noncore_less52.o` (non-CO-RE, kernel < 5.2)\n\nSources: [user/module/imodule.go:191-214](), [user/module/probe_openssl.go:311-312]()\n\n### Manager Start\n\nThe `bpfManager.Start()` call performs:\n\n1. Load eBPF programs into the kernel using the `bpf()` syscall\n2. Verify program bytecode against the kernel's eBPF verifier\n3. Attach probes to their target functions/tracepoints\n4. Create and configure eBPF maps\n5. Enable cgroup-based filtering if specified\n\nIf verification fails, the error includes verifier logs for debugging.\n\nSources: [user/module/probe_openssl.go:328-331]()\n\n## eBPF Map Communication\n\neBPF maps are the primary mechanism for kernel-to-user space data transfer. eCapture uses two map types for events:\n\n**Event Map Architecture**\n\n```mermaid\ngraph TB\n    subgraph \"Kernel Space - eBPF Programs\"\n        UPROBE[\"Uprobe Handler<br/>probe_entry/probe_ret\"]\n        TC[\"TC Classifier<br/>capture_packets\"]\n        EVENT[\"Event Structure<br/>ssl_data_event_t<br/>tc_skb_event_t\"]\n    end\n    \n    subgraph \"eBPF Maps\"\n        PERF[\"Perf Event Array<br/>BPF_MAP_TYPE_PERF_EVENT_ARRAY<br/>Per-CPU buffers\"]\n        RING[\"Ring Buffer<br/>BPF_MAP_TYPE_RINGBUF<br/>Shared memory\"]\n    end\n    \n    subgraph \"User Space - Event Readers\"\n        PERF_RD[\"perfEventReader<br/>perf.NewReader\"]\n        RING_RD[\"ringbufEventReader<br/>ringbuf.NewReader\"]\n        DECODE[\"Module.Decode<br/>IEventStruct\"]\n        DISPATCH[\"Module.Dispatcher<br/>Event routing\"]\n    end\n    \n    UPROBE --> EVENT\n    TC --> EVENT\n    EVENT -->|\"bpf_perf_event_output\"| PERF\n    EVENT -->|\"bpf_ringbuf_submit\"| RING\n    \n    PERF --> PERF_RD\n    RING --> RING_RD\n    \n    PERF_RD --> DECODE\n    RING_RD --> DECODE\n    DECODE --> DISPATCH\n```\n\nSources: [user/module/imodule.go:285-306](), [user/module/imodule.go:308-391]()\n\n### Perf Event Arrays\n\nPerf event arrays provide per-CPU ring buffers for high-throughput event delivery:\n\n**Perf Event Reader Configuration**\n\n| Parameter | Configuration | Location |\n|-----------|---------------|----------|\n| Map size | `conf.GetPerCpuMapSize()` | [user/module/imodule.go:309]() |\n| Default size | 1024 * PAGE_SIZE per CPU | [cli/cmd/root.go:143]() |\n| Reader type | `perf.NewReader(em, size)` | [user/module/imodule.go:310]() |\n\nThe reader loop:\n\n```go\nfunc (m *Module) perfEventReader(errChan chan error, em *ebpf.Map) {\n    rd, err := perf.NewReader(em, m.conf.GetPerCpuMapSize())\n    // ...\n    go func() {\n        for {\n            select {\n            case <-m.ctx.Done():\n                return\n            default:\n            }\n            \n            record, err := rd.Read()\n            if record.LostSamples != 0 {\n                m.logger.Warn().Uint64(\"lostSamples\", record.LostSamples)\n                continue\n            }\n            \n            evt, err := m.child.Decode(em, record.RawSample)\n            m.Dispatcher(evt)\n        }\n    }()\n}\n```\n\nSources: [user/module/imodule.go:308-351]()\n\n### Ring Buffers\n\nRing buffers (kernel >= 5.8) provide a shared memory region with better memory efficiency:\n\n```go\nfunc (m *Module) ringbufEventReader(errChan chan error, em *ebpf.Map) {\n    rd, err := ringbuf.NewReader(em)\n    // ...\n    go func() {\n        for {\n            select {\n            case <-m.ctx.Done():\n                return\n            default:\n            }\n            \n            record, err := rd.Read()\n            e, err := m.child.Decode(em, record.RawSample)\n            m.Dispatcher(e)\n        }\n    }()\n}\n```\n\nRing buffers offer advantages:\n- Better memory efficiency (single shared buffer vs per-CPU)\n- Lower overhead for variable-sized events\n- Guaranteed ordering within a single buffer\n\nSources: [user/module/imodule.go:353-391]()\n\n### Event Decoding\n\nEach module registers decode functions for its maps:\n\n```go\ntype MOpenSSLProbe struct {\n    eventFuncMaps map[*ebpf.Map]event.IEventStruct\n    eventMaps     []*ebpf.Map\n}\n\nfunc (m *MOpenSSLProbe) DecodeFun(p *ebpf.Map) (event.IEventStruct, bool) {\n    fun, found := m.eventFuncMaps[em]\n    return fun, found\n}\n```\n\nThe decode process:\n1. Lookup decoder by map pointer\n2. Clone the event structure template\n3. Call `Decode([]byte)` to unmarshal binary data\n4. Return typed event structure\n\nSources: [user/module/probe_openssl.go:389-396](), [user/module/imodule.go:393-406]()\n\n### Hash Maps for State\n\nHash maps store state that eBPF programs query or update:\n\n**Common Hash Map Uses**\n\n| Map Purpose | Key | Value | Usage |\n|-------------|-----|-------|-------|\n| Connection tracking | `(pid, fd)` | `(tuple, sock)` | Map FD to 4-tuple |\n| Socket lookup | `sock` | `(pid, fd)` | Reverse mapping |\n| PID filtering | `pid` | `1` | Whitelist processes |\n| Master key dedup | `client_random` | `1` | Prevent duplicates |\n\nExample from OpenSSL module:\n\n```go\n// User space state synchronized with eBPF maps\ntype MOpenSSLProbe struct {\n    pidConns   map[uint32]map[uint32]ConnInfo  // pid -> (fd -> ConnInfo)\n    sock2pidFd map[uint64][2]uint32            // sock -> (pid, fd)\n}\n```\n\nSources: [user/module/probe_openssl.go:90-94](), [user/module/probe_openssl.go:398-480]()\n\n## Kernel Compatibility Strategy\n\neCapture's compatibility matrix spans multiple dimensions:\n\n**Compatibility Matrix**\n\n| Dimension | Options | Detection Method |\n|-----------|---------|------------------|\n| Kernel version | < 5.2, >= 5.2 | `kernel.HostVersion()` |\n| BTF support | Enabled, Disabled | `ebpfenv.IsEnableBTF()` |\n| Architecture | x86_64, aarch64 | Build-time `GOARCH` |\n| SSL library | OpenSSL 1.0.x-3.5.x, BoringSSL | ELF parsing |\n\n### Kernel Version Detection\n\n```go\nkv, err := kernel.HostVersion()\nif kv < kernel.VersionCode(5, 2, 0) {\n    m.isKernelLess5_2 = true\n    m.logger.Warn().Str(\"kernel\", kv.String()).\n        Msg(\"Kernel version is less than 5.2, Process filtering parameters do not take effect\")\n}\n```\n\nKernels < 5.2 limitations:\n- No global variables in eBPF (must use maps)\n- No bounded loops (must unroll)\n- Limited helper functions\n- PID/UID filtering less effective\n\nSources: [user/module/imodule.go:140-149]()\n\n### Build-Time Architecture Handling\n\nThe build system generates architecture-specific bytecode:\n\n```makefile\nTARGET_ARCH = $(if $(filter $(CROSS_ARCH),arm64),arm64,x86_64)\nLINUX_ARCH  = $(if $(filter $(CROSS_ARCH),arm64),arm64,x86)\nGOARCH      = $(if $(filter $(CROSS_ARCH),arm64),arm64,amd64)\n```\n\nArchitecture-specific considerations:\n- Different instruction sets (x86 vs ARM)\n- Varied structure padding and alignment\n- Architecture-specific kernel headers\n\nSources: [variables.mk (referenced in Makefile)](), [.github/workflows/go-c-cpp.yml:31](), [.github/workflows/release.yml:45]()\n\n### Container and BTF Detection\n\nSpecial handling for containerized environments:\n\n```go\nisContainer, err := ebpfenv.IsContainer()\nif isContainer {\n    m.logger.Warn().Msg(\"Your environment is like a container. \" +\n        \"We won't be able to detect the BTF configuration.\")\n}\n```\n\nContainers may not have:\n- `/sys/kernel/btf/vmlinux` file\n- Access to host kernel headers\n- Proper `/proc/kallsyms` access\n\nThe `-b` flag allows manual BTF mode specification to override detection.\n\nSources: [user/module/imodule.go:174-189](), [cli/cmd/root.go:141]()\n\n## Cross-Compilation Support\n\nThe build system supports bidirectional cross-compilation (x86_64 ↔ aarch64):\n\n**Cross-Compilation Architecture**\n\n```mermaid\ngraph TB\n    subgraph \"Build Configuration\"\n        CROSS_VAR[\"CROSS_ARCH=arm64<br/>or amd64\"]\n        MAKE_ENV[\"make env<br/>Detect cross-compile\"]\n    end\n    \n    subgraph \"Toolchain Selection\"\n        GCC_SELECT[\"Select Cross-GCC<br/>aarch64-linux-gnu-gcc<br/>x86_64-linux-gnu-gcc\"]\n        CLANG[\"LLVM/Clang<br/>-target bpfel/bpfeb\"]\n    end\n    \n    subgraph \"Kernel Headers\"\n        KERN_PREP[\"Kernel Preparation<br/>make ARCH=arm64 prepare<br/>make ARCH=x86 prepare\"]\n        HEADERS[\"Architecture Headers<br/>arch/arm64/include<br/>arch/x86/include\"]\n    end\n    \n    subgraph \"Build Artifacts\"\n        EBPF[\"eBPF Bytecode<br/>arch-independent\"]\n        BINARY[\"Go Binary<br/>arch-specific\"]\n    end\n    \n    CROSS_VAR --> MAKE_ENV\n    MAKE_ENV --> GCC_SELECT\n    MAKE_ENV --> CLANG\n    MAKE_ENV --> KERN_PREP\n    \n    KERN_PREP --> HEADERS\n    GCC_SELECT --> BINARY\n    CLANG --> EBPF\n    HEADERS --> EBPF\n```\n\nSources: [.github/workflows/go-c-cpp.yml:56-65](), [.github/workflows/release.yml:93-97](), [Makefile:92-93]()\n\n### Cross-Compilation Workflow\n\nBuilding for ARM64 on x86_64:\n\n```bash\n# Prepare ARM64 kernel headers\ncd /usr/src/linux-source-X.Y.Z\nmake ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- prepare\n\n# Build eCapture\nCROSS_ARCH=arm64 make env\nCROSS_ARCH=arm64 make\n```\n\nThe build system:\n1. Detects `CROSS_ARCH` environment variable\n2. Selects appropriate cross-compiler and libc\n3. Configures libpcap for target architecture\n4. Compiles eBPF programs (architecture-neutral)\n5. Links Go binary with cross-compiled libpcap\n\nSources: [.github/workflows/go-c-cpp.yml:16-33](), [Makefile:98-104](), [builder/init_env.sh:43-61]()\n\n### Android Support\n\nAndroid builds use BoringSSL-specific bytecode and require non-CO-RE mode:\n\n```bash\nANDROID=1 CROSS_ARCH=arm64 make nocore\n```\n\nAndroid-specific considerations:\n- BoringSSL instead of OpenSSL\n- No BTF support (SELinux restrictions)\n- Limited kernel headers\n- Version-specific BoringSSL offsets (A12-A16)\n\nSources: [.github/workflows/go-c-cpp.yml:61-65](), [user/module/probe_openssl.go:247-262]()\n\n## Error Handling and Verification\n\neBPF programs undergo strict verification before loading. Common failure modes:\n\n**Verification Errors**\n\n| Error Type | Cause | Resolution |\n|------------|-------|------------|\n| Invalid memory access | Out-of-bounds read/write | Fix boundary checks |\n| Unbounded loop | Loop without guaranteed termination | Unroll or bound iterations |\n| Invalid helper call | Helper not allowed in context | Use alternative helper |\n| Register spill/fill | Too many variables | Reduce local variables |\n| BTF mismatch | Structure layout changed | Update BTF info or offsets |\n\nThe module logs detailed verifier errors:\n\n```go\nif err = m.bpfManager.InitWithOptions(bytes.NewReader(byteBuf), m.bpfManagerOptions); err != nil {\n    var ve *ebpf.VerifierError\n    if errors.As(err, &ve) {\n        m.logger.Error().Err(ve).Msg(\"couldn't verify bpf prog\")\n    }\n    return fmt.Errorf(\"couldn't init manager %w\", err)\n}\n```\n\nSources: [user/module/probe_openssl.go:320-326]()\n\n## Summary\n\nThe eBPF Engine provides a robust foundation for eCapture's capture capabilities through:\n\n1. **Multi-mode Compilation**: CO-RE and non-CO-RE bytecode for broad kernel compatibility\n2. **Automatic Detection**: BTF availability, kernel version, and architecture detection\n3. **Flexible Attachment**: Uprobe, TC, and kprobe program types for diverse monitoring needs\n4. **Efficient Communication**: Perf event arrays and ring buffers for high-throughput data transfer\n5. **Cross-Platform Support**: x86_64, aarch64, Linux, and Android builds\n\nThe engine abstracts eBPF complexity from higher-level modules through the `IModule` interface, enabling developers to focus on capture logic rather than low-level eBPF details.\n\nSources: [user/module/imodule.go:47-75](), [user/module/probe_openssl.go:83-106](), [Makefile:1-269](), [user/config/iconfig.go:24-70]()"
          },
          {
            "page_plan": {
              "id": "2.2",
              "title": "Event Processing Pipeline"
            },
            "content": "# Event Processing Pipeline\n\n<details>\n<summary>Relevant source files</summary>\n\nThe following files were used as context for generating this wiki page:\n\n- [pkg/event_processor/base_event.go](pkg/event_processor/base_event.go)\n- [pkg/event_processor/http_request.go](pkg/event_processor/http_request.go)\n- [pkg/event_processor/http_response.go](pkg/event_processor/http_response.go)\n- [pkg/event_processor/iparser.go](pkg/event_processor/iparser.go)\n- [pkg/event_processor/iworker.go](pkg/event_processor/iworker.go)\n- [pkg/event_processor/processor.go](pkg/event_processor/processor.go)\n- [user/event/event_bash.go](user/event/event_bash.go)\n- [user/event/event_gnutls.go](user/event/event_gnutls.go)\n- [user/event/event_masterkey.go](user/event/event_masterkey.go)\n- [user/event/event_mysqld.go](user/event/event_mysqld.go)\n- [user/event/event_nspr.go](user/event/event_nspr.go)\n- [user/event/event_openssl.go](user/event/event_openssl.go)\n- [user/event/event_openssl_tc.go](user/event/event_openssl_tc.go)\n- [user/event/event_postgres.go](user/event/event_postgres.go)\n- [user/event/ievent.go](user/event/ievent.go)\n\n</details>\n\n\n\n## Purpose and Scope\n\nThe Event Processing Pipeline transforms raw eBPF events from kernel space into formatted, protocol-aware output. This pipeline sits between the eBPF data collection layer (see [2.1 eBPF Engine](#2.1)) and output systems (see [4 Output Formats](#4)), handling:\n\n- **Event routing**: Dispatch events to per-connection workers via `EventProcessor.dispatch()`\n- **Payload aggregation**: Accumulate data chunks in `eventWorker` instances\n- **Protocol detection**: Identify HTTP/1.1, HTTP/2, or raw data via `IParser` interface\n- **Lifecycle management**: Support both timeout-based and socket-lifecycle-based worker cleanup\n- **Output formatting**: Convert binary payloads to text, hex, or Protobuf formats\n\nEvents flow from eBPF maps → module decoders → `EventProcessor` → `eventWorker` instances → `IParser` implementations → output writers.\n\n---\n\n## Architecture Overview\n\nThe event processing pipeline consists of three primary layers: event reception, worker-based aggregation, and protocol-aware parsing.\n\n**Event Processing Pipeline Architecture**\n\n```mermaid\ngraph TB\n    subgraph \"eBPF Maps (Kernel Space)\"\n        PerfArray[\"Perf Event Arrays<br/>or Ring Buffers\"]\n    end\n    \n    subgraph \"Module Layer (User Space)\"\n        ModuleDecode[\"Module.Decode()<br/>SSLDataEvent.Decode()<br/>ConnDataEvent.Decode()\"]\n        ModuleWrite[\"Module calls<br/>processor.Write(IEventStruct)\"]\n    end\n    \n    subgraph \"EventProcessor\"\n        Incoming[\"incoming chan event.IEventStruct<br/>capacity: 1024\"]\n        Serve[\"Serve() loop<br/>select on 4 channels\"]\n        Dispatch[\"dispatch(e event.IEventStruct)<br/>UUID routing\"]\n        WorkerQueue[\"workerQueue map[string]IWorker<br/>UUID → worker mapping\"]\n        OutComing[\"outComing chan []byte<br/>capacity: 1024\"]\n        DestroyConn[\"destroyConn chan uint64<br/>socket destruction signals\"]\n    end\n    \n    subgraph \"eventWorker Goroutines\"\n        Worker1[\"eventWorker #1<br/>UUID: 1234_1234_curl_3_0\"]\n        Worker2[\"eventWorker #2<br/>UUID: sock:5678_5678_nginx_5_0_..._140234567890\"]\n        WorkerIncoming[\"incoming chan event.IEventStruct<br/>capacity: 1024\"]\n        PayloadBuf[\"payload *bytes.Buffer<br/>accumulated data\"]\n        Ticker[\"ticker *time.Ticker<br/>100ms, tickerCount 0-10\"]\n        WorkerRun[\"Run() loop<br/>3 select cases\"]\n    end\n    \n    subgraph \"Parser Registry\"\n        NewParser[\"NewParser(payload []byte)<br/>protocol detection\"]\n        HTTPRequest[\"HTTPRequest<br/>http.ReadRequest()\"]\n        HTTPResponse[\"HTTPResponse<br/>http.ReadResponse()\"]\n        HTTP2Request[\"HTTP2Request<br/>HPACK decode\"]\n        HTTP2Response[\"HTTP2Response<br/>HPACK decode\"]\n        DefaultParser[\"DefaultParser<br/>hex.Dump() fallback\"]\n    end\n    \n    subgraph \"Output Writers\"\n        Logger[\"io.Writer logger<br/>file or stdout\"]\n        CollectorWriter[\"CollectorWriter<br/>zerolog.Logger\"]\n    end\n    \n    PerfArray -->|\"read events\"| ModuleDecode\n    ModuleDecode --> ModuleWrite\n    ModuleWrite --> Incoming\n    \n    Incoming --> Serve\n    Serve --> Dispatch\n    Dispatch -->|\"getWorkerByUUID()<br/>or NewEventWorker()\"| WorkerQueue\n    \n    WorkerQueue --> Worker1\n    WorkerQueue --> Worker2\n    \n    Worker1 --> WorkerIncoming\n    WorkerIncoming --> PayloadBuf\n    Ticker -.\"|MaxTickerCount<br/>triggers Display()\"| PayloadBuf\n    \n    PayloadBuf --> NewParser\n    NewParser -->|\"detect() success\"| HTTPRequest\n    NewParser -->|\"detect() success\"| HTTPResponse\n    NewParser -->|\"detect() success\"| HTTP2Request\n    NewParser -->|\"detect() success\"| HTTP2Response\n    NewParser -->|\"no match\"| DefaultParser\n    \n    HTTPRequest --> OutComing\n    HTTPResponse --> OutComing\n    HTTP2Request --> OutComing\n    HTTP2Response --> OutComing\n    DefaultParser --> OutComing\n    \n    OutComing --> Serve\n    Serve --> Logger\n    Logger -.\"|type assertion\"| CollectorWriter\n    \n    DestroyConn --> Serve\n    Serve -.\"|destroyWorkers()\"| WorkerQueue\n```\n\n**Sources:** [pkg/event_processor/processor.go:30-63](), [pkg/event_processor/processor.go:66-89](), [pkg/event_processor/iworker.go:70-89](), [pkg/event_processor/iworker.go:262-306](), [pkg/event_processor/iparser.go:85-115]()\n\n---\n\n## Event Flow\n\nEvents traverse the pipeline through distinct stages: ingestion, routing, aggregation, parsing, and output.\n\n**Event Flow Through Pipeline**\n\n```mermaid\nsequenceDiagram\n    participant eBPF as eBPF Perf/Ring Buffer\n    participant Module as Module Reader<br/>(MOpenSSLProbe)\n    participant EP as EventProcessor\n    participant WQ as workerQueue<br/>map[string]IWorker\n    participant EW as eventWorker\n    participant Parser as IParser<br/>(HTTPRequest/etc)\n    participant Logger as io.Writer\n    \n    Note over eBPF: Events generated by<br/>uprobe/kprobe/TC programs\n    \n    eBPF->>Module: Read from perf/ring buffer\n    Module->>Module: event.Decode(payload)\n    Module->>EP: processor.Write(IEventStruct)\n    EP->>EP: incoming <- event (chan)\n    \n    Note over EP: Serve() loop select\n    EP->>EP: case event := <-incoming\n    EP->>EP: dispatch(event)\n    EP->>EP: uuid := event.GetUUID()\n    EP->>WQ: found, worker := getWorkerByUUID(uuid)\n    \n    alt Worker exists\n        WQ-->>EP: found=true, worker\n        EP->>WQ: worker.Get() (ref count)\n    else Worker not found\n        EP->>EW: NewEventWorker(uuid, ep)\n        EW->>EW: init(uuid, processor)\n        EW->>EW: go Run() (new goroutine)\n        EP->>WQ: addWorkerByUUID(worker)\n        WQ-->>EP: worker\n    end\n    \n    EP->>EW: worker.Write(event)\n    EP->>WQ: worker.Put() (release ref)\n    EW->>EW: incoming <- event (chan)\n    \n    Note over EW: Run() loop select\n    EW->>EW: case e := <-incoming\n    EW->>EW: writeEvent(e)\n    EW->>EW: payload.Write(e.Payload())\n    EW->>EW: tickerCount = 0\n    \n    Note over EW: No new events for 1s<br/>(10 ticks × 100ms)\n    EW->>EW: case <-ticker.C\n    EW->>EW: tickerCount++\n    EW->>EW: if tickerCount > MaxTickerCount\n    EW->>EW: Display()\n    EW->>EW: parserEvents()\n    \n    alt Parser not initialized (LifeCycleStateSock)\n        EW->>Parser: NewParser(payload.Bytes())\n        Parser->>Parser: Loop through parsers registry\n        Parser->>Parser: parser.detect(payload)\n        Parser-->>EW: Return HTTPRequest or Default\n        EW->>EW: ew.parser = newParser\n    end\n    \n    EW->>Parser: parser.Write(payload.Bytes())\n    Parser->>Parser: Accumulate in internal buffer\n    EW->>Parser: parser.Display()\n    Parser->>Parser: Format output (DumpRequest/DumpResponse)\n    Parser-->>EW: []byte formatted\n    \n    alt logger is CollectorWriter\n        EW->>EW: Format with metadata (PID, Comm, Tuple)\n    else logger is other io.Writer\n        EW->>EW: Marshal to protobuf LogEntry\n    end\n    \n    EW->>EP: outComing <- []byte (chan)\n    \n    Note over EP: Serve() loop select\n    EP->>EP: case s := <-outComing\n    EP->>Logger: logger.Write(s)\n```\n\n**Sources:** [pkg/event_processor/processor.go:65-109](), [pkg/event_processor/iworker.go:91-136](), [pkg/event_processor/iworker.go:154-162](), [pkg/event_processor/iworker.go:262-306](), [pkg/event_processor/iworker.go:175-228](), [pkg/event_processor/iparser.go:85-115]()\n\n---\n\n## EventProcessor: Central Dispatcher\n\nThe `EventProcessor` manages the global event routing system and maintains the lifecycle of all active workers.\n\n### Structure and Channels\n\n| Field | Type | Purpose |\n|-------|------|---------|\n| `incoming` | `chan event.IEventStruct` | Receives events from modules (capacity: 1024) |\n| `outComing` | `chan []byte` | Sends formatted output to logger (capacity: 1024) |\n| `destroyConn` | `chan uint64` | Signals connection destruction by socket address |\n| `workerQueue` | `map[string]IWorker` | Maps UUIDs to active workers (capacity: 1024) |\n| `closeChan` | `chan bool` | Signals shutdown to `Serve()` loop |\n| `errChan` | `chan error` | Reports dispatch errors (capacity: 16) |\n| `logger` | `io.Writer` | Output destination (console or file) |\n\n**Sources:** [pkg/event_processor/processor.go:30-50]()\n\n### Core Methods\n\n**`Serve()` Method - Main Event Loop**\n\nThe `Serve()` method runs continuously, processing four channel types using a `select` statement:\n\n```mermaid\nflowchart TD\n    Start[\"EventProcessor.Serve()\"]\n    Select[\"select on 4 channels\"]\n    \n    Start --> Loop[\"for { }\"]\n    Loop --> Select\n    \n    Select -->|\"case eventStruct := <-incoming\"| DispatchCall[\"err = ep.dispatch(eventStruct)\"]\n    Select -->|\"case destroyUUID := <-destroyConn\"| DestroyCall[\"ep.destroyWorkers(destroyUUID)\"]\n    Select -->|\"case s := <-outComing\"| WriteCall[\"_, _ = ep.GetLogger().Write(s)\"]\n    Select -->|\"case _ = <-closeChan\"| CloseCall[\"ep.clearAllWorkers()<br/>return nil\"]\n    \n    DispatchCall --> ErrorCheck{\"err != nil?\"}\n    ErrorCheck -->|Yes| ErrorChan[\"select errChan <- err<br/>or default (drop)\"]\n    ErrorCheck -->|No| Loop\n    ErrorChan --> Loop\n    \n    DestroyCall --> Loop\n    WriteCall --> Loop\n    CloseCall --> Return[\"Return to caller\"]\n    \n    subgraph \"dispatch(eventStruct) Details\"\n        D1[\"uuid := e.GetUUID()\"]\n        D2[\"found, eWorker := ep.getWorkerByUUID(uuid)\"]\n        D3{\"found?\"}\n        D4[\"eWorker = NewEventWorker(uuid, ep)\"]\n        D5[\"ep.addWorkerByUUID(eWorker)\"]\n        D6[\"err := eWorker.Write(e)\"]\n        D7[\"eWorker.Put()\"]\n        \n        D1 --> D2\n        D2 --> D3\n        D3 -->|No| D4\n        D4 --> D5\n        D5 --> D6\n        D3 -->|Yes| D6\n        D6 --> D7\n    end\n    \n    subgraph \"destroyWorkers(destroyUUID) Details\"\n        Dst1[\"ep.Lock()\"]\n        Dst2[\"for _, ew := range workerQueue\"]\n        Dst3{\"destroyUUID == ew.GetDestroyUUID()?\"}\n        Dst4[\"ew.CloseEventWorker()<br/>break\"]\n        Dst5[\"ep.Unlock()\"]\n        \n        Dst1 --> Dst2\n        Dst2 --> Dst3\n        Dst3 -->|Yes| Dst4\n        Dst3 -->|No| Dst2\n        Dst4 --> Dst5\n    end\n```\n\n**Key behaviors:**\n- **Non-blocking error reporting**: If `errChan` is full, errors are dropped via `default` case\n- **Worker cleanup on socket destroy**: `destroyWorkers()` matches by `DestroyUUID` (socket address)\n- **Graceful shutdown**: `closeChan` signal clears all workers and returns from `Serve()`\n\n**Sources:** [pkg/event_processor/processor.go:66-89](), [pkg/event_processor/processor.go:91-109](), [pkg/event_processor/processor.go:115-128]()\n\n**`dispatch(e event.IEventStruct)`** - Routes events to appropriate workers:\n\n1. Extract UUID from event via `e.GetUUID()`\n2. Look up existing worker in `workerQueue`\n3. If not found, create new `eventWorker` via `NewEventWorker(uuid, ep)`\n4. Call `worker.Write(e)` to enqueue event\n5. Release worker reference via `worker.Put()`\n\n**Sources:** [pkg/event_processor/processor.go:91-109]()\n\n**Worker lifecycle methods:**\n\n- `getWorkerByUUID(uuid string)` - Thread-safe lookup with reference counting\n- `addWorkerByUUID(worker IWorker)` - Thread-safe insertion\n- `delWorkerByUUID(worker IWorker)` - Called by workers to self-destruct\n- `destroyWorkers(destroyUUID uint64)` - Signals socket-based workers to close\n\n**Sources:** [pkg/event_processor/processor.go:130-155]()\n\n---\n\n## eventWorker: Per-Connection Aggregator\n\nEach `eventWorker` aggregates events for a single logical connection or data stream, identified by a unique UUID. Workers operate as independent goroutines with internal state machines.\n\n### UUID Formats and Lifecycle States\n\nWorkers support two lifecycle models based on UUID format:\n\n| Lifecycle State | UUID Format | Example | Destruction Trigger |\n|----------------|-------------|---------|---------------------|\n| `LifeCycleStateDefault` | `{Pid}_{Tid}_{Comm}_{Fd}_{DataType}` | `1234_1234_curl_3_0` | 10 tick timeout (1 second idle) |\n| `LifeCycleStateSock` | `sock:{Pid}_{Tid}_{Comm}_{Fd}_{DataType}_{Tuple}_{Sock}` | `sock:1234_1234_curl_3_0_1.2.3.4:80-5.6.7.8:443_140234567890` | External signal via `CloseEventWorker()` |\n\n**Sources:** [pkg/event_processor/iworker.go:57-63](), [pkg/event_processor/iworker.go:100-123]()\n\n### Structure and State\n\n```mermaid\ngraph TB\n    subgraph \"eventWorker Fields\"\n        UUID[\"UUID string<br/>Connection identifier\"]\n        DestroyUUID[\"DestroyUUID uint64<br/>Socket address for lifecycle\"]\n        State[\"ewLifeCycleState<br/>Default or Sock\"]\n        \n        Incoming[\"incoming chan<br/>IEventStruct<br/>capacity: 1024\"]\n        OutComing[\"outComing chan<br/>[]byte<br/>shared with EventProcessor\"]\n        \n        Payload[\"payload *bytes.Buffer<br/>Accumulated data\"]\n        Parser[\"parser IParser<br/>Protocol handler\"]\n        \n        Ticker[\"ticker *time.Ticker<br/>100ms intervals\"]\n        TickerCount[\"tickerCount uint8<br/>0-10 range\"]\n        \n        CloseChan[\"closeChan chan struct{}<br/>Shutdown signal\"]\n        Used[\"used atomic.Bool<br/>Reference counting\"]\n    end\n    \n    UUID --> State\n    State -.determines.-> DestroyUUID\n    \n    Incoming --> Payload\n    Payload --> Parser\n    Parser --> OutComing\n    \n    Ticker --> TickerCount\n    TickerCount -.triggers.-> Parser\n    \n    CloseChan -.external signal.-> State\n```\n\n**Sources:** [pkg/event_processor/iworker.go:70-89]()\n\n### Run Loop and Lifecycle\n\nThe `Run()` method implements the worker's event loop with three select cases and lifecycle-dependent timeout handling:\n\n```mermaid\nstateDiagram-v2\n    [*] --> Init: \"NewEventWorker(uuid, ep)<br/>go ew.Run()\"\n    \n    Init --> SelectLoop: \"tickerRestartFlag = false\"\n    \n    SelectLoop --> TickerCase: \"case <-ew.ticker.C\"\n    SelectLoop --> IncomingCase: \"case e := <-ew.incoming\"\n    SelectLoop --> CloseCase: \"case <-ew.closeChan\"\n    \n    TickerCase --> IncrementCount: \"ew.tickerCount++\"\n    IncrementCount --> CheckThreshold: \"tickerCount > MaxTickerCount (10)?\"\n    \n    CheckThreshold --> CheckLifecycle: \"Yes\"\n    CheckThreshold --> SelectLoop: \"No\"\n    \n    CheckLifecycle --> SocketLifecycle: \"ew.ewLifeCycleState == LifeCycleStateSock\"\n    CheckLifecycle --> DefaultLifecycle: \"ew.ewLifeCycleState == LifeCycleStateDefault\"\n    \n    SocketLifecycle --> DrainAndCloseSock: \"ew.drainAndClose()\"\n    DrainAndCloseSock --> ResetCount: \"ew.tickerCount = 0\"\n    ResetCount --> SetRestartFlag: \"tickerRestartFlag = true\"\n    SetRestartFlag --> SelectLoop: \"continue (keep running)\"\n    \n    DefaultLifecycle --> DeleteWorker: \"ew.processor.delWorkerByUUID(ew)\"\n    DeleteWorker --> DrainAndCloseFinal: \"ew.drainAndClose()\"\n    DrainAndCloseFinal --> [*]: \"return (goroutine exits)\"\n    \n    IncomingCase --> CheckRestart: \"tickerRestartFlag?\"\n    CheckRestart --> RestartTicker: \"Yes: ew.ticker = time.NewTicker(100ms)\"\n    CheckRestart --> WriteEventCall: \"No\"\n    RestartTicker --> ClearFlag: \"tickerRestartFlag = false\"\n    ClearFlag --> WriteEventCall: \"ew.tickerCount = 0\"\n    WriteEventCall --> WriteEvent: \"ew.writeEvent(e)\"\n    WriteEvent --> SelectLoop\n    \n    CloseCase --> DeleteWorkerClose: \"ew.processor.delWorkerByUUID(ew)\"\n    DeleteWorkerClose --> DrainAndCloseFinal\n    \n    note right of SocketLifecycle\n        Socket lifecycle workers (UUID starts with \"sock:\")\n        persist until explicit CloseEventWorker() call\n    end note\n    \n    note right of DefaultLifecycle\n        Default workers (UUID: Pid_Tid_Comm_Fd)\n        self-destruct after 1s idle (10 × 100ms)\n    end note\n```\n\n**Critical timing details:**\n- **Ticker interval**: `100ms` per tick ([pkg/event_processor/iworker.go:126]())\n- **Timeout threshold**: `MaxTickerCount = 10` ticks = 1 second idle ([pkg/event_processor/iworker.go:52]())\n- **Ticker restart**: Socket workers recreate ticker after `drainAndClose()` to avoid stale ticker channel ([pkg/event_processor/iworker.go:293-296]())\n\n**Lifecycle state determination:**\n- UUID format parsed in `uuidParse()` ([pkg/event_processor/iworker.go:100-123]())\n- If UUID starts with `\"sock:\"` and ends with valid socket address: `LifeCycleStateSock`\n- Otherwise: `LifeCycleStateDefault`\n\n**Sources:** [pkg/event_processor/iworker.go:262-306](), [pkg/event_processor/iworker.go:51-63](), [pkg/event_processor/iworker.go:100-123]()\n\n### Event Aggregation and Display\n\n**`writeEvent(e event.IEventStruct)`** - Accumulates payload data:\n\n1. Check status is `ProcessStateInit` (prevents mid-processing writes)\n2. Apply truncation if `truncateSize > 0` and payload exceeds limit\n3. Store `originEvent` for metadata\n4. Append `e.Payload()` to internal `bytes.Buffer`\n\n**Sources:** [pkg/event_processor/iworker.go:230-245]()\n\n**`Display()`** - Triggers parsing and output:\n\n1. Check if payload has data (`payload.Len() > 0`)\n2. Call `parserEvents()` to process accumulated buffer\n3. Apply hex dump if `processor.isHex` is true\n4. Format output with metadata (PID, Comm, Src/Dst IP:Port)\n5. Write to `outComing` channel as `[]byte` or `Protobuf`\n6. Reset parser, payload buffer, and state\n\n**Sources:** [pkg/event_processor/iworker.go:175-228]()\n\n**`drainAndClose()`** - Ensures clean shutdown:\n\nLoops until `incoming` channel is empty AND no external routine holds a reference (`IfUsed() == false`). This prevents data loss when worker is being destroyed while another routine is attempting to write to it.\n\n**Sources:** [pkg/event_processor/iworker.go:308-337]()\n\n---\n\n## Protocol Detection and Parsing\n\nThe parser subsystem automatically identifies protocols from raw payload bytes and applies appropriate formatting.\n\n### IParser Interface\n\n```mermaid\ngraph TB\n    subgraph \"IParser Methods\"\n        Init[\"Init()<br/>Initialize buffers\"]\n        Detect[\"detect([]byte) error<br/>Protocol identification\"]\n        Write[\"Write([]byte) (int, error)<br/>Accumulate data\"]\n        IsDone[\"IsDone() bool<br/>Check completion\"]\n        Display[\"Display() []byte<br/>Format output\"]\n        Reset[\"Reset()<br/>Prepare for reuse\"]\n        ParserType[\"ParserType() ParserType<br/>Get parser ID\"]\n    end\n    \n    subgraph \"ParserType Enum\"\n        PT0[\"ParserTypeNull = 0\"]\n        PT1[\"ParserTypeHttpRequest = 1\"]\n        PT2[\"ParserTypeHttp2Request = 2\"]\n        PT3[\"ParserTypeHttpResponse = 3\"]\n        PT4[\"ParserTypeHttp2Response = 4\"]\n        PT5[\"ParserTypeWebSocket = 5\"]\n    end\n    \n    Init -.sequence 1.-> Detect\n    Detect -.sequence 2.-> Write\n    Write -.sequence 3.-> IsDone\n    IsDone -.sequence 4.-> Display\n    Display -.sequence 5.-> Reset\n```\n\n**Sources:** [pkg/event_processor/iparser.go:49-60]()\n\n### Parser Registration and Selection\n\n**Global Parser Registry**\n\nParsers register themselves during package initialization:\n\n```go\n// In pkg/event_processor/iparser.go\nvar parsers = make(map[string]IParser)\n\nfunc Register(p IParser) {\n    if p == nil {\n        panic(\"Register Parser is nil\")\n    }\n    name := p.Name()\n    if _, dup := parsers[name]; dup {\n        panic(fmt.Sprintf(\"Register called twice for Parser %s\", name))\n    }\n    parsers[name] = p\n}\n\n// In each parser file's init()\nfunc init() {\n    hr := &HTTPRequest{}\n    hr.Init()\n    Register(hr)\n}\n```\n\n**Sources:** [pkg/event_processor/iparser.go:62-73](), [pkg/event_processor/http_request.go:159-163](), [pkg/event_processor/http_response.go:177-181]()\n\n**`NewParser(payload []byte)` - Protocol Detection Algorithm**\n\n```mermaid\nflowchart TD\n    Entry[\"NewParser(payload []byte)\"]\n    CheckEmpty{\"len(payload) > 0?\"}\n    \n    CheckEmpty -->|No| CreateDefault[\"newParser = new(DefaultParser)\"]\n    CreateDefault --> InitDefault[\"newParser.Init()\"]\n    InitDefault --> ReturnParser[\"return newParser\"]\n    \n    CheckEmpty -->|Yes| GetRegistry[\"parsers := GetAllModules()\"]\n    GetRegistry --> InitVars[\"var newParser IParser\"]\n    InitVars --> LoopStart[\"for _, parser := range parsers\"]\n    \n    LoopStart --> CallDetect[\"err := parser.detect(payload)\"]\n    CallDetect --> CheckError{\"err == nil?\"}\n    \n    CheckError -->|No| NextIter[\"continue to next parser\"]\n    NextIter --> LoopStart\n    \n    CheckError -->|Yes| SwitchType[\"switch parser.ParserType()\"]\n    \n    SwitchType -->|\"ParserTypeHttpRequest\"| NewHTTPReq[\"newParser = new(HTTPRequest)\"]\n    SwitchType -->|\"ParserTypeHttpResponse\"| NewHTTPResp[\"newParser = new(HTTPResponse)\"]\n    SwitchType -->|\"ParserTypeHttp2Request\"| NewHTTP2Req[\"newParser = new(HTTP2Request)\"]\n    SwitchType -->|\"ParserTypeHttp2Response\"| NewHTTP2Resp[\"newParser = new(HTTP2Response)\"]\n    SwitchType -->|\"default\"| NewDefault[\"newParser = new(DefaultParser)\"]\n    \n    NewHTTPReq --> Break[\"break (exit loop)\"]\n    NewHTTPResp --> Break\n    NewHTTP2Req --> Break\n    NewHTTP2Resp --> Break\n    NewDefault --> Break\n    \n    Break --> CheckNil{\"newParser == nil?\"}\n    NextIter -.\"|no match found\"| CheckNil\n    \n    CheckNil -->|Yes| FallbackDefault[\"newParser = new(DefaultParser)\"]\n    CheckNil -->|No| InitNew[\"newParser.Init()\"]\n    FallbackDefault --> InitNew\n    \n    InitNew --> ReturnParser\n```\n\n**Detection order**: Parsers are tested in map iteration order (non-deterministic). Each parser's `detect()` method is called with the payload. First successful detection wins.\n\n**Example detection methods:**\n- `HTTPRequest.detect()`: Calls `http.ReadRequest()` ([pkg/event_processor/http_request.go:83-92]())\n- `HTTPResponse.detect()`: Calls `http.ReadResponse()` ([pkg/event_processor/http_response.go:94-102]())\n- `DefaultParser.detect()`: Always returns `nil` (matches everything) ([pkg/event_processor/iparser.go:136-138]())\n\n**Sources:** [pkg/event_processor/iparser.go:85-115](), [pkg/event_processor/iparser.go:136-138]()\n\n### HTTP/1.1 Request Parser\n\nThe `HTTPRequest` parser leverages Go's standard `net/http` package:\n\n**Structure:**\n```go\ntype HTTPRequest struct {\n    request    *http.Request   // Parsed HTTP request\n    packerType PacketType      // PacketTypeNull or PacketTypeGzip\n    isDone     bool            // Completion flag (currently unused)\n    isInit     bool            // True after first Write() call\n    reader     *bytes.Buffer   // Accumulator for raw bytes\n    bufReader  *bufio.Reader   // Buffered reader over reader\n}\n```\n\n**Sources:** [pkg/event_processor/http_request.go:28-35]()\n\n**Protocol Detection**\n\nThe `detect()` method attempts HTTP parsing:\n\n```go\nfunc (hr *HTTPRequest) detect(payload []byte) error {\n    rd := bytes.NewReader(payload)\n    buf := bufio.NewReader(rd)\n    _, err := http.ReadRequest(buf)\n    if err != nil {\n        return err\n    }\n    return nil\n}\n```\n\nSuccess indicates valid HTTP/1.1 request format. **Sources:** [pkg/event_processor/http_request.go:83-92]()\n\n**Processing Lifecycle**\n\n| Stage | Method | Operation | Key Lines |\n|-------|--------|-----------|-----------|\n| Initialization | `Init()` | Create `bytes.Buffer` and `bufio.Reader` | [pkg/event_processor/http_request.go:37-40]() |\n| First Write | `Write(b)` (isInit=false) | Write to buffer, call `http.ReadRequest()`, store result, set `isInit=true` | [pkg/event_processor/http_request.go:56-67]() |\n| Subsequent Writes | `Write(b)` (isInit=true) | Append additional body data to buffer | [pkg/event_processor/http_request.go:71-78]() |\n| Output | `Display()` | Read body, decompress gzip if present, call `httputil.DumpRequest(false)` | [pkg/event_processor/http_request.go:105-157]() |\n| Cleanup | `Reset()` | Set `isDone=false`, `isInit=false`, reset buffers | [pkg/event_processor/http_request.go:98-103]() |\n\n**Gzip Decompression**\n\nIf `Content-Encoding: gzip` header is present:\n1. Read raw body via `io.ReadAll(hr.request.Body)` \n2. Create `gzip.NewReader(bytes.NewReader(rawData))`\n3. Decompress: `rawData, err = io.ReadAll(reader)`\n4. Set `hr.packerType = PacketTypeGzip`\n\n**Sources:** [pkg/event_processor/http_request.go:123-142]()\n\n**HTTP/2.0 Detection**\n\nIf `hr.request.Proto == \"HTTP/2.0\"`, returns raw bytes without processing. HTTP/2 requires specialized frame handling. **Sources:** [pkg/event_processor/http_request.go:106-108]()\n\n### HTTP/1.1 Response Parser\n\nSimilar to request parser but uses `http.ReadResponse()`:\n\n**Key differences:**\n- Handles chunked responses (negative `ContentLength`)\n- Logs truncated responses when body is incomplete\n- Supports HTTP/2.0 detection (returns raw bytes without processing)\n\n**Sources:** [pkg/event_processor/http_response.go:28-37](), [pkg/event_processor/http_response.go:58-92](), [pkg/event_processor/http_response.go:115-175]()\n\n### HTTP/2 Parsers\n\nHTTP/2 parsers are defined but implementation details are in separate files not provided. They handle:\n- HPACK header compression/decompression\n- Binary frame format\n- Stream multiplexing\n\n**Sources:** Referenced in [pkg/event_processor/iparser.go:96-99]()\n\n### DefaultParser\n\nFallback parser for unrecognized protocols:\n\n- Accumulates all bytes in `bytes.Buffer`\n- On `Display()`, checks if first byte is printable ASCII (32-126)\n- If non-ASCII, outputs hex dump via `hex.Dump()`\n- If ASCII, outputs as string (C-style null termination via `CToGoString()`)\n\n**Sources:** [pkg/event_processor/iparser.go:117-166]()\n\n---\n\n## Event Types and Structure\n\nAll events implement the `IEventStruct` interface, enabling polymorphic handling in the pipeline.\n\n### IEventStruct Interface\n\n```mermaid\nclassDiagram\n    class IEventStruct {\n        <<interface>>\n        +Decode(payload []byte) error\n        +Payload() []byte\n        +PayloadLen() int\n        +String() string\n        +StringHex() string\n        +Clone() IEventStruct\n        +EventType() Type\n        +GetUUID() string\n        +Base() Base\n        +ToProtobufEvent() *pb.Event\n    }\n    \n    class Base {\n        +Timestamp int64\n        +UUID string\n        +SrcIP string\n        +SrcPort uint32\n        +DstIP string\n        +DstPort uint32\n        +PID int64\n        +PName string\n        +Type uint32\n    }\n    \n    class SSLDataEvent {\n        +DataType int64\n        +Timestamp uint64\n        +Pid uint32\n        +Tid uint32\n        +Data [16384]byte\n        +DataLen int32\n        +Comm [16]byte\n        +Fd uint32\n        +Version int32\n        +Tuple string\n        +Sock uint64\n    }\n    \n    class ConnDataEvent {\n        +Saddr [16]byte\n        +Daddr [16]byte\n        +Comm [16]byte\n        +Sock uint64\n        +Pid uint32\n        +Tid uint32\n        +Fd uint32\n        +Family uint16\n        +Sport uint16\n        +Dport uint16\n        +IsDestroy uint8\n        +Tuple string\n    }\n    \n    class MasterSecretEvent {\n        +Version int32\n        +ClientRandom [32]byte\n        +MasterKey [48]byte\n        +CipherId uint32\n        +EarlyTrafficSecret [64]byte\n        +HandshakeSecret [64]byte\n        +ClientAppTrafficSecret [64]byte\n        +ServerAppTrafficSecret [64]byte\n        +ExporterMasterSecret [64]byte\n    }\n    \n    class BashEvent {\n        +BashType uint32\n        +Pid uint32\n        +Uid uint32\n        +Line [256]uint8\n        +ReturnValue uint32\n        +Comm [16]byte\n    }\n    \n    class MysqldEvent {\n        +Pid uint64\n        +Timestamp uint64\n        +Query [256]uint8\n        +Alllen uint64\n        +Len uint64\n        +Comm [16]uint8\n        +Retval int8\n    }\n    \n    IEventStruct <|.. SSLDataEvent\n    IEventStruct <|.. ConnDataEvent\n    IEventStruct <|.. MasterSecretEvent\n    IEventStruct <|.. BashEvent\n    IEventStruct <|.. MysqldEvent\n    \n    SSLDataEvent --> Base\n    ConnDataEvent --> Base\n```\n\n**Sources:** [user/event/ievent.go:26-52]()\n\n### Event Type Classification\n\nEvents are classified by their processing destination:\n\n```mermaid\ngraph TB\n    subgraph \"Type Enum\"\n        T0[\"TypeOutput = 0<br/>Direct to logger\"]\n        T1[\"TypeModuleData = 1<br/>Module-specific handling\"]\n        T2[\"TypeEventProcessor = 2<br/>Protocol parsing\"]\n    end\n    \n    subgraph \"TypeOutput Events\"\n        Bash[\"BashEvent<br/>Shell commands\"]\n        Mysqld[\"MysqldEvent<br/>SQL queries\"]\n        Postgres[\"PostgresEvent<br/>SQL queries\"]\n    end\n    \n    subgraph \"TypeModuleData Events\"\n        MasterSecret[\"MasterSecretEvent<br/>TLS keys\"]\n        TcSkb[\"TcSkbEvent<br/>Network packets\"]\n        Conn[\"ConnDataEvent<br/>Connection metadata\"]\n    end\n    \n    subgraph \"TypeEventProcessor Events\"\n        SSL[\"SSLDataEvent<br/>TLS plaintext\"]\n        Gnutls[\"GnutlsDataEvent<br/>GnuTLS plaintext\"]\n        Nspr[\"NsprDataEvent<br/>NSS/NSPR plaintext\"]\n    end\n    \n    T0 --> Bash\n    T0 --> Mysqld\n    T0 --> Postgres\n    \n    T1 --> MasterSecret\n    T1 --> TcSkb\n    T1 --> Conn\n    \n    T2 --> SSL\n    T2 --> Gnutls\n    T2 --> Nspr\n```\n\n**Sources:** [user/event/ievent.go:26-37](), [user/event/event_openssl.go:77-92](), [user/event/event_bash.go:37-47](), [user/event/event_masterkey.go:37-55]()\n\n### SSLDataEvent Structure\n\nPrimary event type for OpenSSL/BoringSSL captures:\n\n**Fields:**\n- **DataType**: 0 (ProbeEntry/Received) or 1 (ProbeRet/Sent)\n- **Timestamp**: Kernel time decoded to Unix nanoseconds\n- **Pid/Tid/Comm**: Process identification\n- **Data**: Payload buffer (max 16384 bytes)\n- **DataLen**: Actual data length\n- **Fd**: File descriptor\n- **Version**: TLS version constant (0x0303 = TLS 1.2, etc.)\n- **Tuple**: Network 5-tuple string (`srcip:port-dstip:port`)\n- **Sock**: Socket pointer address (for lifecycle tracking)\n\n**UUID format:**\n- Default: `{Pid}_{Tid}_{Comm}_{Fd}_{DataType}`\n- Socket lifecycle: `sock:{Pid}_{Tid}_{Comm}_{Fd}_{DataType}_{Tuple}_{Sock}`\n\n**Sources:** [user/event/event_openssl.go:77-92](), [user/event/event_openssl.go:138-141]()\n\n### ConnDataEvent Structure\n\nConnection lifecycle event for socket tracking:\n\n**Purpose:** Provides network 5-tuple information when socket is created or destroyed, enabling correlation with `SSLDataEvent` via socket address.\n\n**Fields:**\n- **Saddr/Daddr**: Source/destination IP (16 bytes for IPv6)\n- **Sport/Dport**: Source/destination port\n- **Family**: `AF_INET` (2) or `AF_INET6` (10)\n- **Sock**: Socket pointer (matches `SSLDataEvent.Sock`)\n- **IsDestroy**: 1 if connection being destroyed, 0 if created\n\n**Tuple generation:** Formats as `ip:port-ip:port` with bracket notation for IPv6.\n\n**Sources:** [user/event/event_openssl.go:272-310]()\n\n---\n\n## Output Routing\n\nEvents reach different destinations based on their `EventType` and the configured logger type.\n\n### Output Decision Flow\n\n```mermaid\nflowchart TD\n    Worker[\"eventWorker.Display()\"]\n    Format[\"parserEvents()<br/>Get formatted bytes\"]\n    CheckLogger{\"logger type?\"}\n    \n    Worker --> Format\n    Format --> CheckLogger\n    \n    CheckLogger -->|CollectorWriter| FormatBase[\"Format with Base metadata\"]\n    CheckLogger -->|Default io.Writer| FormatProto[\"Format as Protobuf\"]\n    \n    FormatBase --> BuildText[\"fmt.Fprintf():<br/>PID, Comm, Src:Port, Dest:Port,<br/>Payload\"]\n    BuildText --> WriteChan[\"outComing <- bytes\"]\n    \n    FormatProto --> BuildPB[\"pb.LogEntry{<br/>LogType: LOG_TYPE_EVENT,<br/>EventPayload: ep<br/>}\"]\n    BuildPB --> Marshal[\"proto.Marshal()\"]\n    Marshal --> WriteChan\n    \n    WriteChan --> Serve[\"EventProcessor.Serve()\"]\n    Serve --> LoggerWrite[\"logger.Write(bytes)\"]\n```\n\n**Sources:** [pkg/event_processor/iworker.go:175-228]()\n\n### Output Format Examples\n\n**Text mode (CollectorWriter):**\n```\nPID:1234, Comm:curl, Src:192.168.1.10:54321, Dest:93.184.216.34:443,\nGET / HTTP/1.1\nHost: example.com\nUser-Agent: curl/7.81.0\nAccept: */*\n```\n\n**Protobuf mode:**\n```protobuf\nmessage LogEntry {\n  LogType log_type = 1;  // LOG_TYPE_EVENT\n  oneof payload {\n    Event event_payload = 2;\n  }\n}\n\nmessage Event {\n  int64 timestamp = 1;\n  string uuid = 2;\n  int64 pid = 3;\n  string pname = 4;\n  string src_ip = 5;\n  uint32 src_port = 6;\n  string dst_ip = 7;\n  uint32 dst_port = 8;\n  uint32 type = 9;\n  uint32 length = 10;\n  bytes payload = 11;\n}\n```\n\n**Sources:** [pkg/event_processor/iworker.go:198-227](), [user/event/event_openssl.go:237-266]()\n\n### CollectorWriter Integration\n\nThe `CollectorWriter` wraps `zerolog.Logger` for structured logging:\n\n```go\ntype CollectorWriter struct {\n    logger *zerolog.Logger\n}\n\nfunc (e CollectorWriter) Write(p []byte) (n int, err error) {\n    return e.logger.Write(p)\n}\n```\n\nUsed when output needs JSON formatting or log level filtering. Otherwise, standard `io.Writer` (file, stdout) is used directly.\n\n**Sources:** [user/event/ievent.go:54-70]()\n\n---\n\n## Performance Characteristics\n\nThe pipeline is designed for high-throughput event processing with bounded memory usage.\n\n### Buffer Capacities and Limits\n\n| Component | Buffer Type | Capacity | Purpose |\n|-----------|-------------|----------|---------|\n| EventProcessor.incoming | Buffered channel | 1024 events | Event reception from modules |\n| EventProcessor.outComing | Buffered channel | 1024 messages | Formatted output to logger |\n| EventProcessor.destroyConn | Buffered channel | 1024 signals | Connection destruction signals |\n| EventProcessor.errChan | Buffered channel | 16 errors | Error reporting |\n| eventWorker.incoming | Buffered channel | 1024 events | Per-worker event queue |\n| eventWorker.payload | bytes.Buffer | Unbounded* | Payload accumulation |\n\n*Bounded by `truncateSize` configuration parameter.\n\n**Sources:** [pkg/event_processor/processor.go:25-28](), [pkg/event_processor/iworker.go:51-54]()\n\n### Backpressure Handling\n\nThe pipeline uses non-blocking channel writes with `select` + `default` to prevent stalls:\n\n**EventProcessor.Write() - Module to Processor**\n\n```go\nfunc (ep *EventProcessor) Write(e event.IEventStruct) {\n    if ep.isClosed {\n        return\n    }\n    select {\n    case ep.incoming <- e:\n        return\n    default:\n        // Queue full: drop event silently\n    }\n}\n```\n\n**Sources:** [pkg/event_processor/processor.go:165-175]()\n\n**eventWorker.Write() - Processor to Worker**\n\n```go\nfunc (ew *eventWorker) Write(e event.IEventStruct) error {\n    var err error\n    select {\n    case ew.incoming <- e:\n    default:\n        err = ErrEventWorkerIncomingFull\n    }\n    return err\n}\n```\n\nReturns `ErrEventWorkerIncomingFull` when worker queue is full (capacity: 1024). Error is propagated to `EventProcessor.errChan` but does not block. **Sources:** [pkg/event_processor/iworker.go:154-162](), [pkg/event_processor/iworker.go:66]()\n\n**eventWorker.writeToChan() - Worker to Processor Output**\n\n```go\nfunc (ew *eventWorker) writeToChan(b []byte) error {\n    var err error\n    select {\n    case ew.outComing <- b:\n    default:\n        err = ErrEventWorkerOutcomingFull\n    }\n    return err\n}\n```\n\nReturns `ErrEventWorkerOutcomingFull` when processor output queue is full (capacity: 1024). **Sources:** [pkg/event_processor/iworker.go:164-172](), [pkg/event_processor/iworker.go:67]()\n\n**Rationale**: Non-blocking operation prevents blocking the eBPF event readers (which would cause kernel-space ring buffer overruns). In monitoring scenarios, dropping a small percentage of events under extreme load is acceptable.\n\n### Truncation Behavior\n\nIf `EventProcessor.truncateSize > 0`:\n- Workers check payload size before each write\n- If `payload.Len() >= truncateSize`, truncate to exact size\n- Log message: `\"Events truncated, size: %d bytes\\n\"`\n- Prevents unbounded memory growth for long-lived connections with large transfers\n\n**Sources:** [pkg/event_processor/iworker.go:236-242]()\n\n---\n\n## Thread Safety and Synchronization\n\nThe pipeline employs multiple synchronization mechanisms to ensure correctness under concurrent access.\n\n### EventProcessor Locking\n\nAll `workerQueue` operations are protected by `sync.Mutex`:\n\n```mermaid\ngraph TB\n    subgraph \"Thread-Safe Operations\"\n        Get[\"getWorkerByUUID()\"]\n        Add[\"addWorkerByUUID()\"]\n        Del[\"delWorkerByUUID()\"]\n        Destroy[\"destroyWorkers()\"]\n        Clear[\"clearAllWorkers()\"]\n    end\n    \n    subgraph \"Lock Scope\"\n        Lock[\"Lock()\"]\n        MapOp[\"workerQueue access\"]\n        RefCount[\"worker.Get() for ref counting\"]\n        Unlock[\"Unlock()\"]\n    end\n    \n    Get --> Lock\n    Add --> Lock\n    Del --> Lock\n    Destroy --> Lock\n    Clear --> Lock\n    \n    Lock --> MapOp\n    MapOp --> RefCount\n    RefCount --> Unlock\n```\n\n**Sources:** [pkg/event_processor/processor.go:130-161]()\n\n### Worker Reference Counting\n\n`eventWorker.used` is an `atomic.Bool` that tracks external references:\n\n**Get/Put pattern:**\n```go\n// In EventProcessor.dispatch()\nworker.Get()      // Atomically set used = true\ndefer worker.Put() // Atomically set used = false\n\n// In eventWorker.drainAndClose()\nfor {\n    if ew.IfUsed() {\n        time.Sleep(10 * time.Millisecond)\n        continue  // Wait for Put()\n    }\n    ew.Close()\n    return\n}\n```\n\n**Purpose:** Prevents worker from being destroyed while `dispatch()` is writing to it. Uses busy-wait with 10ms sleep to ensure reference is released before final cleanup.\n\n**Sources:** [pkg/event_processor/iworker.go:346-360](), [pkg/event_processor/iworker.go:308-337]()\n\n### Channel-Based Signaling\n\nSocket-lifecycle workers use `closeChan` for clean shutdown:\n\n```go\ncloseChan chan struct{}  // nil for default lifecycle, initialized for socket lifecycle\ncloseOnce sync.Once      // Ensures close() called only once\n\nfunc (ew *eventWorker) CloseEventWorker() {\n    if ew.closeChan != nil {\n        ew.closeOnce.Do(func() {\n            close(ew.closeChan)\n        })\n    }\n}\n```\n\n**Pattern:** Closing a channel signals all readers simultaneously. `sync.Once` prevents panic from double-close.\n\n**Sources:** [pkg/event_processor/iworker.go:86-88](), [pkg/event_processor/iworker.go:142-148]()\n\n---\n\n## Summary\n\nThe Event Processing Pipeline transforms raw eBPF events into protocol-aware, formatted output through a three-stage architecture:\n\n1. **EventProcessor** routes incoming events to UUID-keyed workers\n2. **eventWorker** instances accumulate payloads and manage connection lifecycles\n3. **IParser** implementations detect protocols and format output\n\nKey design principles:\n- **Non-blocking operation**: Full channels drop events rather than stalling\n- **Automatic lifecycle management**: Workers self-destruct after idle periods or external signals\n- **Protocol-agnostic core**: Parser registration system supports arbitrary protocol handlers\n- **Thread-safe access**: Mutex-protected maps and atomic reference counting prevent races\n\nThe pipeline supports output to console, files, PCAP, keylog, and Protobuf streams, enabling integration with external analysis tools.\n\n**Sources:** [pkg/event_processor/processor.go:1-216](), [pkg/event_processor/iworker.go:1-366](), [pkg/event_processor/iparser.go:1-167]()"
          },
          {
            "page_plan": {
              "id": "2.3",
              "title": "Configuration System"
            },
            "content": "# Configuration System\n\n<details>\n<summary>Relevant source files</summary>\n\nThe following files were used as context for generating this wiki page:\n\n- [cli/cmd/bash.go](cli/cmd/bash.go)\n- [cli/cmd/gnutls.go](cli/cmd/gnutls.go)\n- [cli/cmd/gotls.go](cli/cmd/gotls.go)\n- [cli/cmd/mysqld.go](cli/cmd/mysqld.go)\n- [cli/cmd/nspr.go](cli/cmd/nspr.go)\n- [cli/cmd/postgres.go](cli/cmd/postgres.go)\n- [cli/cmd/root.go](cli/cmd/root.go)\n- [cli/cmd/tls.go](cli/cmd/tls.go)\n- [cli/cmd/zsh.go](cli/cmd/zsh.go)\n- [pkg/util/ws/client.go](pkg/util/ws/client.go)\n- [pkg/util/ws/client_test.go](pkg/util/ws/client_test.go)\n- [user/config/iconfig.go](user/config/iconfig.go)\n- [user/module/imodule.go](user/module/imodule.go)\n- [user/module/probe_openssl.go](user/module/probe_openssl.go)\n\n</details>\n\n\n\nThe Configuration System manages module-specific settings, platform detection, library discovery, and parameter validation for ecapture's various capture modules. This system provides a unified interface for configuring TLS/SSL interception across different libraries (OpenSSL, Go TLS, GnuTLS, NSPR) and platforms (Linux, Android).\n\nFor information about how configurations are applied during module execution, see [Capture Modules](#3). For build-time configuration and compilation settings, see [Build System](#5.1).\n\n## Architecture Overview\n\nThe configuration system follows a hierarchical design with base configuration inherited by module-specific implementations:\n\n```mermaid\ngraph TB\n    BaseConfig[\"BaseConfig<br/>Common settings\"]\n    \n    subgraph \"Module Configurations\"\n        GoTLSConfig[\"GoTLSConfig<br/>Go binary analysis\"]\n        OpensslConfig[\"OpensslConfig<br/>OpenSSL/BoringSSL\"]\n        GnutlsConfig[\"GnutlsConfig<br/>GnuTLS library\"]\n        NsprConfig[\"NsprConfig<br/>NSPR/Firefox\"]\n    end\n    \n    subgraph \"Platform Implementations\"\n        LinuxOpenSSL[\"config_openssl_linux.go<br/>Linux library detection\"]\n        AndroidOpenSSL[\"config_openssl_androidgki.go<br/>Android paths\"]\n        LinuxGnuTLS[\"config_gnutls_linux.go<br/>GnuTLS discovery\"]\n        LinuxNSPR[\"config_nspr_linux.go<br/>Firefox NSPR\"]\n    end\n    \n    subgraph \"Configuration Flow\"\n        CLI[\"CLI Flags<br/>cobra commands\"]\n        Validation[\"Check() methods<br/>Platform detection\"]\n        ModuleSetup[\"Module Setup<br/>eBPF manager config\"]\n    end\n    \n    BaseConfig --> GoTLSConfig\n    BaseConfig --> OpensslConfig\n    BaseConfig --> GnutlsConfig\n    BaseConfig --> NsprConfig\n    \n    OpensslConfig --> LinuxOpenSSL\n    OpensslConfig --> AndroidOpenSSL\n    GnutlsConfig --> LinuxGnuTLS\n    NsprConfig --> LinuxNSPR\n    \n    CLI --> Validation\n    Validation --> ModuleSetup\n```\n\n**Sources:** [user/config/config_gotls.go:77-93](), [user/config/config_openssl.go:39-53](), [user/config/config_gnutls.go:20-31](), [user/config/config_nspr.go:20-25]()\n\n## Base Configuration Structure\n\nAll module configurations inherit from `BaseConfig`, which provides common functionality:\n\n| Field | Type | Purpose |\n|-------|------|---------|\n| `PerCpuMapSize` | `int` | eBPF map size per CPU core |\n| `Pid` | `uint32` | Target process ID filter |\n| `Uid` | `uint32` | Target user ID filter |\n| `Debug` | `bool` | Enable debug logging |\n\n```mermaid\ngraph LR\n    subgraph \"BaseConfig Fields\"\n        PerCpuMapSize[\"PerCpuMapSize<br/>DefaultMapSizePerCpu\"]\n        ProcessFilters[\"Process Filters<br/>Pid, Uid\"]\n        GlobalVars[\"Global Variables<br/>EnableGlobalVar()\"]\n    end\n    \n    subgraph \"Module Extensions\"\n        GoTLS[\"GoTLSConfig<br/>+ binary analysis\"]\n        OpenSSL[\"OpensslConfig<br/>+ library detection\"]\n        GnuTLS[\"GnutlsConfig<br/>+ version checking\"]\n    end\n    \n    PerCpuMapSize --> GoTLS\n    ProcessFilters --> OpenSSL\n    GlobalVars --> GnuTLS\n```\n\n**Sources:** [user/config/config_gotls.go:96-100](), [user/config/config_openssl.go:55-59](), [user/config/config_gnutls.go:33-37]()\n\n## Go TLS Configuration\n\nThe `GoTLSConfig` provides the most complex configuration logic, performing binary analysis of Go applications to extract symbol addresses and function offsets:\n\n### Binary Analysis Pipeline\n\n```mermaid\ngraph TD\n    ElfOpen[\"elf.Open(path)<br/>Parse ELF header\"]\n    BuildInfo[\"buildinfo.ReadFile()<br/>Extract Go build info\"]\n    ArchCheck[\"Architecture validation<br/>amd64/arm64 support\"]\n    \n    subgraph \"PIE Mode Detection\"\n        PIECheck[\"Check buildmode=pie<br/>from BuildInfo.Settings\"]\n        SymTabRead[\"ReadTable()<br/>Parse .gopclntab section\"]\n        MagicFind[\"Find magic number<br/>Go version specific\"]\n    end\n    \n    subgraph \"Symbol Resolution\"\n        WriteAddr[\"findPieSymbolAddr()<br/>GoTlsWriteFunc\"]\n        MasterAddr[\"findPieSymbolAddr()<br/>GoTlsMasterSecretFunc\"]\n        RetOffsets[\"findRetOffsetsPie()<br/>GoTlsReadFunc returns\"]\n    end\n    \n    ElfOpen --> BuildInfo\n    BuildInfo --> ArchCheck\n    ArchCheck --> PIECheck\n    PIECheck --> SymTabRead\n    SymTabRead --> MagicFind\n    MagicFind --> WriteAddr\n    WriteAddr --> MasterAddr\n    MasterAddr --> RetOffsets\n```\n\n**Sources:** [user/config/config_gotls.go:102-190](), [user/config/config_gotls.go:281-325](), [user/config/config_gotls.go:327-357]()\n\n### Symbol Address Resolution\n\nThe Go configuration resolves specific function addresses for uprobe attachment:\n\n| Function | Constant | Purpose |\n|----------|----------|---------|\n| `crypto/tls.(*Conn).Read` | `GoTlsReadFunc` | TLS read interception |\n| `crypto/tls.(*Conn).writeRecordLocked` | `GoTlsWriteFunc` | TLS write interception |\n| `crypto/tls.(*Config).writeKeyLog` | `GoTlsMasterSecretFunc` | Master secret extraction |\n\n```mermaid\ngraph LR\n    subgraph \"Function Symbols\"\n        ReadFunc[\"GoTlsReadFunc<br/>crypto/tls.(*Conn).Read\"]\n        WriteFunc[\"GoTlsWriteFunc<br/>writeRecordLocked\"]\n        MasterFunc[\"GoTlsMasterSecretFunc<br/>writeKeyLog\"]\n    end\n    \n    subgraph \"Address Resolution\"\n        ReadAddrs[\"ReadTlsAddrs[]<br/>Return instruction offsets\"]\n        WriteAddr[\"GoTlsWriteAddr<br/>Function entry point\"]\n        MasterAddr[\"GoTlsMasterSecretAddr<br/>Keylog function\"]\n    end\n    \n    ReadFunc --> ReadAddrs\n    WriteFunc --> WriteAddr\n    MasterFunc --> MasterAddr\n```\n\n**Sources:** [user/config/config_gotls.go:31-35](), [user/config/config_gotls.go:88-91](), [user/config/config_gotls.go:168-182]()\n\n## OpenSSL Configuration\n\nOpenSSL configuration handles library discovery across different platforms and versions:\n\n### Library Discovery Process\n\n```mermaid\ngraph TD\n    UserPath[\"User specified path<br/>--openssl flag\"]\n    AutoDetect[\"Automatic detection<br/>checkOpenssl()\"]\n    \n    subgraph \"Linux Detection\"\n        DynLibDirs[\"GetDynLibDirs()<br/>System library paths\"]\n        LibSearch[\"Search libraries<br/>libssl.so.3, libssl.so.1.1\"]\n        PathFound[\"Set Openssl path<br/>ElfType = ElfTypeSo\"]\n    end\n    \n    subgraph \"Android Detection\"  \n        AndroidPath[\"DefaultOpensslPath<br/>/apex/com.android.conscrypt/\"]\n        AndroidVer[\"Parse build.prop<br/>ro.build.version.release\"]\n    end\n    \n    UserPath --> PathFound\n    AutoDetect --> DynLibDirs\n    DynLibDirs --> LibSearch\n    LibSearch --> PathFound\n    \n    AutoDetect --> AndroidPath\n    AndroidPath --> AndroidVer\n```\n\n**Sources:** [user/config/config_openssl_linux.go:38-67](), [user/config/config_openssl_androidgki.go:34-71](), [user/config/config_openssl.go:74-111]()\n\n### Platform-Specific Paths\n\n| Platform | Default Library Path | Interface |\n|----------|---------------------|-----------|\n| Linux | `/usr/lib/x86_64-linux-gnu/libssl.so.3` | `eth0` |\n| Android | `/apex/com.android.conscrypt/lib64/libssl.so` | `wlan0` |\n\n**Sources:** [user/config/config_openssl_linux.go:28-36](), [user/config/config_openssl_androidgki.go:26-32]()\n\n## Capture Model Selection\n\nAll TLS modules support multiple capture models through the `checkModel()` method:\n\n```mermaid\ngraph TD\n    ModelInput[\"User Model Input<br/>--model flag\"]\n    \n    subgraph \"Model Types\"\n        TextModel[\"TlsCaptureModelText<br/>Default: plain text output\"]\n        KeyModel[\"TlsCaptureModelKey<br/>keylog/key: extract secrets\"]\n        PcapModel[\"TlsCaptureModelPcap<br/>pcap/pcapng: packet capture\"]\n    end\n    \n    subgraph \"Validation\"\n        IfnameCheck[\"Pcap mode requires<br/>--ifname interface\"]\n        FileCheck[\"Key mode sets<br/>keylog file path\"]\n    end\n    \n    ModelInput --> TextModel\n    ModelInput --> KeyModel\n    ModelInput --> PcapModel\n    \n    PcapModel --> IfnameCheck\n    KeyModel --> FileCheck\n```\n\n**Sources:** [user/config/config_gotls.go:264-279](), [user/config/config_openssl.go:61-72](), [user/config/config_gnutls.go:39-50]()\n\n## Configuration Validation\n\nEach module implements a `Check()` method that performs comprehensive validation:\n\n### Validation Flow\n\n```mermaid\ngraph TD\n    CheckStart[\"config.Check()\"]\n    \n    subgraph \"Common Validation\"\n        ModelCheck[\"checkModel()<br/>Validate capture mode\"]\n        PathCheck[\"os.Stat(path)<br/>Verify file exists\"]\n        PermCheck[\"Permission validation\"]\n    end\n    \n    subgraph \"Go-Specific\"\n        BuildInfoRead[\"buildinfo.ReadFile()<br/>Go binary metadata\"]\n        ElfOpen[\"elf.Open()<br/>ELF parsing\"]\n        ArchMatch[\"Architecture matching<br/>runtime.GOARCH\"]\n        SymbolResolve[\"Symbol resolution<br/>PIE mode handling\"]\n    end\n    \n    subgraph \"SSL-Specific\"\n        LibDetect[\"Library auto-detection<br/>System path search\"]\n        VersionCheck[\"SSL version detection\"]\n        CgroupSetup[\"CGroup path setup<br/>Process filtering\"]\n    end\n    \n    CheckStart --> ModelCheck\n    ModelCheck --> PathCheck\n    PathCheck --> PermCheck\n    \n    CheckStart --> BuildInfoRead\n    BuildInfoRead --> ElfOpen\n    ElfOpen --> ArchMatch\n    ArchMatch --> SymbolResolve\n    \n    CheckStart --> LibDetect\n    LibDetect --> VersionCheck\n    VersionCheck --> CgroupSetup\n```\n\n**Sources:** [user/config/config_gotls.go:102-190](), [user/config/config_openssl_linux.go:69-103](), [user/config/config_gnutls_linux.go:27-63]()\n\n## Module Integration\n\nConfiguration objects are created and used by CLI commands and passed to modules:\n\n```mermaid\ngraph LR\n    subgraph \"CLI Layer\"\n        Flags[\"CLI Flags<br/>cobra.Command\"]\n        ConfigNew[\"NewGoTLSConfig()<br/>Constructor\"]\n    end\n    \n    subgraph \"Module Layer\"  \n        RunModule[\"runModule()<br/>Module orchestrator\"]\n        ProbeSetup[\"setupManagers()<br/>eBPF configuration\"]\n        EventMaps[\"Event map setup<br/>Based on model\"]\n    end\n    \n    Flags --> ConfigNew\n    ConfigNew --> RunModule\n    RunModule --> ProbeSetup\n    ProbeSetup --> EventMaps\n```\n\n**Sources:** [cli/cmd/gotls.go:26-58](), [user/module/probe_gotls_text.go:31-118](), [user/module/probe_gotls_keylog.go:31-104]()"
          },
          {
            "page_plan": {
              "id": "2.4",
              "title": "Module System and Lifecycle"
            },
            "content": "# Module System and Lifecycle\n\n<details>\n<summary>Relevant source files</summary>\n\nThe following files were used as context for generating this wiki page:\n\n- [CHANGELOG.md](CHANGELOG.md)\n- [README.md](README.md)\n- [README_CN.md](README_CN.md)\n- [cli/cmd/root.go](cli/cmd/root.go)\n- [images/ecapture-help-v0.8.9.svg](images/ecapture-help-v0.8.9.svg)\n- [main.go](main.go)\n- [user/config/iconfig.go](user/config/iconfig.go)\n- [user/module/imodule.go](user/module/imodule.go)\n- [user/module/probe_openssl.go](user/module/probe_openssl.go)\n\n</details>\n\n\n\nThis document explains the module system architecture in eCapture, including the `IModule` interface contract, module registration patterns, and the complete lifecycle from initialization through shutdown. For details on how modules configure themselves, see [Configuration System](#2.3). For information on eBPF program loading within modules, see [eBPF Engine](#2.1).\n\n## IModule Interface Contract\n\nThe `IModule` interface defines the standard contract that all capture modules must implement. This interface enables polymorphic module handling throughout the system, allowing the CLI and HTTP API to instantiate and manage different capture types (TLS, Bash, MySQL, etc.) uniformly.\n\n**Core Interface Definition**\n\n| Method | Purpose | Called By |\n|--------|---------|-----------|\n| `Init(context.Context, *zerolog.Logger, config.IConfig, io.Writer)` | Initialize module with context, logger, config, and event writer | CLI/HTTP handler before starting |\n| `Name()` | Return module name (e.g., \"openssl\", \"gotls\") | Logging and identification |\n| `Run()` | Start event processing pipeline | CLI after initialization completes |\n| `Start()` | Load and attach eBPF programs | `Module.Run()` internally |\n| `Stop()` | Gracefully stop capture | Signal handlers |\n| `Close()` | Release all resources | Shutdown sequence |\n| `SetChild(IModule)` | Register concrete implementation for parent-child pattern | `Init()` phase |\n| `Events()` | Return list of eBPF maps for event reading | Event reader setup |\n| `DecodeFun(*ebpf.Map)` | Get decoder for specific eBPF map | Event decoding |\n| `Decode(*ebpf.Map, []byte)` | Decode raw bytes to event struct | Event processing |\n| `Dispatcher(event.IEventStruct)` | Handle decoded events | Event routing |\n\n**Sources:** [user/module/imodule.go:47-75]()\n\n```mermaid\nclassDiagram\n    class IModule {\n        <<interface>>\n        +Init(context, logger, config, writer) error\n        +Name() string\n        +Run() error\n        +Start() error\n        +Stop() error\n        +Close() error\n        +SetChild(module)\n        +Decode(map, bytes) IEventStruct\n        +Events() []*ebpf.Map\n        +DecodeFun(map) IEventStruct\n        +Dispatcher(event)\n    }\n    \n    class Module {\n        -isClosed atomic.Bool\n        -ctx context.Context\n        -logger *zerolog.Logger\n        -eventCollector io.Writer\n        -child IModule\n        -name string\n        -mType string\n        -conf config.IConfig\n        -processor *EventProcessor\n        -isKernelLess5_2 bool\n        -isCoreUsed bool\n        -errChan chan error\n        +Init()\n        +Run()\n        +Close()\n        +Decode()\n        +Dispatcher()\n        -autoDetectBTF()\n        -geteBPFName()\n        -readEvents()\n        -perfEventReader()\n        -ringbufEventReader()\n    }\n    \n    class MOpenSSLProbe {\n        +MTCProbe\n        -bpfManager *manager.Manager\n        -eventFuncMaps map\n        -eventMaps []*ebpf.Map\n        -pidConns map\n        -sock2pidFd map\n        -keylogger *os.File\n        -masterKeys map\n        -sslVersionBpfMap map\n        +Init()\n        +Start()\n        +Close()\n        +Events()\n        +DecodeFun()\n        +Dispatcher()\n        +AddConn()\n        +GetConn()\n        +DelConn()\n    }\n    \n    class MGoTLSProbe {\n        +Module\n        +Start()\n        +Events()\n    }\n    \n    class MBashProbe {\n        +Module\n        +Start()\n        +Events()\n    }\n    \n    IModule <|.. Module : implements\n    Module <|-- MOpenSSLProbe : embeds\n    Module <|-- MGoTLSProbe : embeds\n    Module <|-- MBashProbe : embeds\n    \n    Module o-- IModule : child reference\n```\n\n**Diagram: IModule Interface Hierarchy**\n\nThe parent-child pattern allows the base `Module` struct to provide common functionality (BTF detection, event reading, context management) while delegating module-specific operations (eBPF program setup, event decoding) to concrete implementations via the `child` field.\n\n**Sources:** [user/module/imodule.go:83-108](), [user/module/probe_openssl.go:83-106]()\n\n## Module Registration and Factory Pattern\n\neCapture uses a factory pattern for module instantiation, enabling dynamic module loading based on CLI commands. Each module registers a factory function during package initialization.\n\n**Registration Mechanism**\n\n```mermaid\ngraph LR\n    subgraph \"Package Initialization\"\n        Init1[\"module/probe_openssl.go init()\"]\n        Init2[\"module/probe_gotls.go init()\"]\n        Init3[\"module/probe_bash.go init()\"]\n    end\n    \n    subgraph \"Registry\"\n        RegisteFunc[\"RegisteFunc(GetModuleFunc)\"]\n        Registry[\"moduleRegistry map[string]GetModuleFunc\"]\n    end\n    \n    subgraph \"CLI Invocation\"\n        CLI[\"cobra command\"]\n        RunModule[\"runModule(modName, config)\"]\n        GetFunc[\"GetModuleFunc(modName)\"]\n    end\n    \n    subgraph \"Module Creation\"\n        Factory[\"modFunc() IModule\"]\n        Instance[\"module instance\"]\n    end\n    \n    Init1 --> RegisteFunc\n    Init2 --> RegisteFunc\n    Init3 --> RegisteFunc\n    RegisteFunc --> Registry\n    \n    CLI --> RunModule\n    RunModule --> GetFunc\n    GetFunc --> Registry\n    Registry --> Factory\n    Factory --> Instance\n```\n\n**Diagram: Module Registration and Factory Flow**\n\n**Sources:** [user/module/probe_openssl.go:777-786]()\n\n**Module Name Constants**\n\nEach module is identified by a unique string constant used for registry lookups:\n\n| Module Name | Constant | Target |\n|-------------|----------|--------|\n| `ModuleNameOpenssl` | \"openssl\" | OpenSSL/BoringSSL |\n| `ModuleNameGotls` | \"gotls\" | Go crypto/tls |\n| `ModuleNameGnutls` | \"gnutls\" | GnuTLS |\n| `ModuleNameNspr` | \"nspr\" | NSS/NSPR |\n| `ModuleNameBash` | \"bash\" | Bash shell |\n| `ModuleNameZsh` | \"zsh\" | Zsh shell |\n| `ModuleNameMysqld` | \"mysqld\" | MySQL server |\n| `ModuleNamePostgres` | \"postgres\" | PostgreSQL |\n\n**CLI-to-Module Mapping**\n\nThe CLI layer maps cobra commands to modules via the `runModule()` function:\n\n- `ecapture tls` → `runModule(ModuleNameOpenssl, oc)` [cli/cmd/tls.go:62-67]()\n- `ecapture gotls` → `runModule(ModuleNameGotls, goc)` [cli/cmd/gotls.go:52-58]()\n- `ecapture bash` → `runModule(ModuleNameBash, bc)` [cli/cmd/bash.go:53-55]()\n- `ecapture mysqld` → `runModule(ModuleNameMysqld, myc)` [cli/cmd/mysqld.go:47-49]()\n\n**Sources:** [cli/cmd/tls.go:62-67](), [cli/cmd/gotls.go:52-58](), [cli/cmd/bash.go:53-55]()\n\n## Module Lifecycle Stages\n\nThe module lifecycle consists of five distinct phases, each with specific responsibilities. Modules progress through these stages sequentially, with error handling at each transition point.\n\n```mermaid\nstateDiagram-v2\n    [*] --> Uninitialized\n    \n    Uninitialized --> Initialized: Init()\n    note right of Initialized\n        - Logger setup\n        - Config validation\n        - BTF detection\n        - EventProcessor creation\n        - Context inheritance\n    end note\n    \n    Initialized --> Started: Start()\n    note right of Started\n        - eBPF bytecode loading\n        - Program attachment\n        - Map initialization\n        - Hook registration\n    end note\n    \n    Started --> Running: Run()\n    note right of Running\n        - Event reader goroutines\n        - EventProcessor serving\n        - Perf/Ring buffer reading\n        - Event dispatching\n    end note\n    \n    Running --> Stopping: ctx.Done() or Signal\n    \n    Stopping --> Closed: Close()\n    note right of Closed\n        - Stop event readers\n        - Detach eBPF programs\n        - Close file handles\n        - Cleanup resources\n    end note\n    \n    Closed --> [*]\n    \n    Initialized --> Error: Init() fails\n    Started --> Error: Start() fails\n    Running --> Error: errChan receives error\n    Error --> [*]\n```\n\n**Diagram: Module Lifecycle State Machine**\n\n**Sources:** [cli/cmd/root.go:336-397](), [user/module/imodule.go:110-171]()\n\n### Initialization Phase (Init)\n\nThe `Init()` method prepares the module for execution. This is where the module receives its dependencies and performs environment detection.\n\n**Initialization Responsibilities:**\n\n1. **Context Inheritance**: Store parent context for cancellation propagation\n2. **Logger Configuration**: Set up zerolog instance for module-specific logging\n3. **Config Storage**: Save `IConfig` reference for runtime parameter access\n4. **BTF Mode Detection**: Determine whether to use CO-RE or non-CO-RE bytecode\n5. **Kernel Version Check**: Detect if kernel version < 5.2 (affects PID filtering)\n6. **EventProcessor Creation**: Initialize event aggregation and formatting pipeline\n7. **Output Format Selection**: Choose between text/protobuf based on event collector type\n\n**Base Module Init Implementation:**\n\n[user/module/imodule.go:111-171]() shows the common initialization logic:\n\n```\nm.isClosed.Store(false)\nm.ctx = ctx\nm.logger = logger\nm.errChan = make(chan error, 16)\n\n// BTF auto-detection\nif conf.GetBTF() == config.BTFModeAutoDetect {\n    m.autoDetectBTF()\n} else {\n    m.isCoreUsed = (conf.GetBTF() == config.BTFModeCore)\n}\n\n// Kernel version detection\nkv, err := kernel.HostVersion()\nif kv < kernel.VersionCode(5, 2, 0) {\n    m.isKernelLess5_2 = true\n}\n\n// EventProcessor with truncation support\nm.processor = event_processor.NewEventProcessor(eventCollector, conf.GetHex(), tsize)\n```\n\n**Module-Specific Init Extensions:**\n\nConcrete modules extend initialization with their own setup. For example, `MOpenSSLProbe.Init()`:\n\n[user/module/probe_openssl.go:109-176]() adds:\n\n- Connection tracking map initialization (`pidConns`, `sock2pidFd`)\n- Capture mode selection (Text/Pcap/Keylog)\n- File handle creation for keylog/pcap files\n- Clock synchronization for timestamp conversion\n- SSL version offset map initialization\n\n**Sources:** [user/module/imodule.go:110-171](), [user/module/probe_openssl.go:109-176]()\n\n### Start Phase\n\nThe `Start()` method loads and attaches eBPF programs. This is where module-specific hooking logic executes.\n\n**Start Phase Operations:**\n\n1. **Manager Setup**: Configure `ebpfmanager.Manager` with probes and maps\n2. **Bytecode Selection**: Choose appropriate `.o` file based on version detection\n3. **Program Loading**: Parse ELF bytecode and create eBPF programs\n4. **Constant Editing**: Inject runtime values (target PID, UID) into eBPF constants\n5. **Program Attachment**: Attach uprobes/kprobes/TC hooks to target functions\n6. **Map Registration**: Store references to eBPF maps for event reading\n\n**OpenSSL Module Start Example:**\n\n[user/module/probe_openssl.go:280-350]() demonstrates the flow:\n\n```\n1. setupManagers() - Configure manager based on capture mode (Text/Pcap/Keylog)\n2. geteBPFName() - Select bytecode file (core vs non-core, version-specific)\n3. assets.Asset(bpfFileName) - Load embedded bytecode\n4. bpfManager.InitWithOptions() - Initialize with bytecode and options\n5. bpfManager.Start() - Attach all programs\n6. initDecodeFun() - Register event decoders for each eBPF map\n```\n\n**Manager Configuration by Mode:**\n\n| Mode | Manager Setup | Maps Used | TC Hooks |\n|------|---------------|-----------|----------|\n| Text | `setupManagersText()` | `events` | No |\n| Pcap | `setupManagersPcap()` | `events`, `mastersecret_events`, `skb_events` | Yes |\n| Keylog | `setupManagersKeylog()` | `mastersecret_events` | No |\n\n**Sources:** [user/module/probe_openssl.go:280-350]()\n\n### Run Phase\n\nThe `Run()` method starts the event processing pipeline, launching goroutines for event reading and dispatching.\n\n**Run Phase Components:**\n\n```mermaid\ngraph TB\n    Run[\"Module.Run()\"]\n    \n    subgraph \"Goroutine 1: Module Monitoring\"\n        Monitor[\"m.run()\"]\n        CtxDone[\"<-ctx.Done()\"]\n        ErrChan[\"<-errChan\"]\n    end\n    \n    subgraph \"Goroutine 2: EventProcessor\"\n        ProcessorServe[\"processor.Serve()\"]\n        WorkerPool[\"Event worker pool\"]\n        Aggregation[\"Event aggregation\"]\n    end\n    \n    subgraph \"Goroutine 3-N: Event Readers\"\n        ReadEvents[\"m.readEvents()\"]\n        PerfReader[\"perfEventReader()\"]\n        RingReader[\"ringbufEventReader()\"]\n        Decode[\"Decode() events\"]\n        Dispatch[\"Dispatcher()\"]\n    end\n    \n    Run --> Monitor\n    Run --> ProcessorServe\n    Run --> ReadEvents\n    \n    Monitor --> CtxDone\n    Monitor --> ErrChan\n    \n    ProcessorServe --> WorkerPool\n    WorkerPool --> Aggregation\n    \n    ReadEvents --> PerfReader\n    ReadEvents --> RingReader\n    PerfReader --> Decode\n    RingReader --> Decode\n    Decode --> Dispatch\n```\n\n**Diagram: Run Phase Goroutine Architecture**\n\n**Event Reading Implementation:**\n\n[user/module/imodule.go:285-306]() iterates over `Events()` maps and creates readers:\n\n- **Perf Event Arrays**: Uses `perf.NewReader()` with configurable buffer size [user/module/imodule.go:308-351]()\n- **Ring Buffers**: Uses `ringbuf.NewReader()` for newer kernels [user/module/imodule.go:353-391]()\n\nEach reader runs in a goroutine that:\n1. Blocks on `rd.Read()`\n2. Decodes raw bytes via `child.Decode(em, record.RawSample)`\n3. Dispatches events via `Dispatcher(evt)`\n4. Monitors context cancellation\n\n**Error Handling:**\n\n- Lost samples logged with `record.LostSamples` count\n- Reader errors sent to `errChan`\n- Decode errors logged but don't stop processing\n- Context cancellation cleanly exits reader loops\n\n**Sources:** [user/module/imodule.go:236-262](), [user/module/imodule.go:285-391]()\n\n### Stop and Cleanup Phase\n\nThe `Close()` method performs graceful shutdown, releasing all acquired resources.\n\n**Cleanup Sequence:**\n\n1. **Set Closed Flag**: `isClosed.Store(true)` prevents new event dispatch [user/module/imodule.go:451]()\n2. **Close Event Readers**: Stop perf/ring buffer readers [user/module/imodule.go:453-457]()\n3. **Stop EventProcessor**: Flush pending events and close workers [user/module/imodule.go:458-459]()\n4. **Detach eBPF Programs**: Unload programs and maps via `bpfManager.Stop()` [user/module/probe_openssl.go:352-358]()\n5. **Close File Handles**: Flush and close keylog/pcap files\n6. **Cleanup Maps**: Clear connection tracking and master key maps\n\n**Module Close Example (OpenSSL):**\n\n[user/module/probe_openssl.go:352-358]():\n\n```\nm.logger.Info().Msg(\"module close.\")\nif err := m.bpfManager.Stop(manager.CleanAll); err != nil {\n    return fmt.Errorf(\"couldn't stop manager %w .\", err)\n}\nreturn m.Module.Close()  // Call parent cleanup\n```\n\n**Parent Module Close:**\n\n[user/module/imodule.go:450-460]():\n\n```\nm.isClosed.Store(true)  // Prevent new event dispatch\nfor _, iClose := range m.reader {\n    if err := iClose.Close(); err != nil {\n        return err\n    }\n}\nerr := m.processor.Close()  // Flush remaining events\nreturn err\n```\n\n**Sources:** [user/module/imodule.go:450-460](), [user/module/probe_openssl.go:352-358]()\n\n## Base Module Implementation\n\nThe `Module` struct provides common functionality shared across all capture modules, implementing the IModule interface partially and delegating specialized operations to child modules.\n\n**Shared Capabilities:**\n\n| Capability | Implementation | Purpose |\n|------------|----------------|---------|\n| BTF Detection | `autoDetectBTF()` | Determine CO-RE support [user/module/imodule.go:173-190]() |\n| Bytecode Selection | `geteBPFName()` | Choose _core.o vs _noncore.o variant [user/module/imodule.go:191-214]() |\n| Event Reading | `perfEventReader()`, `ringbufEventReader()` | Read from eBPF maps [user/module/imodule.go:308-391]() |\n| Event Decoding | `Decode()` | Deserialize eBPF events [user/module/imodule.go:393-406]() |\n| Event Routing | `Dispatcher()` | Route events by type [user/module/imodule.go:408-448]() |\n| Output Encoding | `output()` | Format as text or protobuf [user/module/imodule.go:461-479]() |\n| Context Management | `run()` | Monitor for shutdown signals [user/module/imodule.go:268-283]() |\n\n**Parent-Child Delegation Pattern:**\n\nThe base `Module` stores a reference to the concrete implementation via `child IModule`. Operations that require module-specific logic are delegated:\n\n[user/module/imodule.go:393-406]() shows delegation in `Decode()`:\n\n```\nes, found := m.child.DecodeFun(em)  // Get module-specific decoder\nif !found {\n    return error\n}\nte := es.Clone()  // Clone event struct\nerr = te.Decode(b)  // Deserialize\n```\n\n**Initialization Flow with Delegation:**\n\n[user/module/probe_openssl.go:109-176]():\n\n```\nfunc (m *MOpenSSLProbe) Init(...) error {\n    err = m.Module.Init(ctx, logger, conf, ecw)  // Call parent\n    if err != nil {\n        return err\n    }\n    m.Module.SetChild(m)  // Register self as child\n    \n    // Module-specific initialization\n    m.eventMaps = make([]*ebpf.Map, 0, 2)\n    m.eventFuncMaps = make(map[*ebpf.Map]event.IEventStruct)\n    ...\n}\n```\n\n**Sources:** [user/module/imodule.go:83-108](), [user/module/imodule.go:110-171](), [user/module/probe_openssl.go:109-176]()\n\n## Module Configuration Integration\n\nModules receive configuration through the `IConfig` interface, allowing runtime behavior customization. Each module type has a corresponding config struct.\n\n**Config to Module Mapping:**\n\n| Module | Config Type | CLI Command | Key Flags |\n|--------|-------------|-------------|-----------|\n| MOpenSSLProbe | `OpensslConfig` | `tls` | `--libssl`, `--model`, `--pcapfile` |\n| MGoTLSProbe | `GoTLSConfig` | `gotls` | `--elfpath`, `--model` |\n| MGnuTLSProbe | `GnutlsConfig` | `gnutls` | `--gnutls`, `--ssl_version` |\n| MBashProbe | `BashConfig` | `bash` | `--bash`, `--errnumber` |\n| MMysqldProbe | `MysqldConfig` | `mysqld` | `--mysqld`, `--offset` |\n| MPostgresProbe | `PostgresConfig` | `postgres` | `--postgres` |\n\n**Global Config Application:**\n\n[cli/cmd/root.go:156-175]() applies global settings to module configs:\n\n```\nfunc setModConfig(globalConf config.BaseConfig, modConf config.IConfig) {\n    modConf.SetPid(globalConf.Pid)\n    modConf.SetUid(globalConf.Uid)\n    modConf.SetDebug(globalConf.Debug)\n    modConf.SetHex(globalConf.IsHex)\n    modConf.SetBTF(globalConf.BtfMode)\n    modConf.SetPerCpuMapSize(globalConf.PerCpuMapSize)\n    modConf.SetTruncateSize(globalConf.TruncateSize)\n    ...\n}\n```\n\n**Runtime Configuration Updates:**\n\nThe HTTP server supports runtime config reloads via `POST /config` [cli/cmd/root.go:375-396]():\n\n1. New config received on `reRloadConfig` channel\n2. `mod.Close()` called to stop current module\n3. `goto reload` jumps back to initialization\n4. New config applied and module restarted\n\n**Sources:** [cli/cmd/root.go:156-175](), [cli/cmd/root.go:336-397](), [user/config/iconfig.go:24-70]()\n\n## Event Dispatch and Processing\n\nThe `Dispatcher()` method routes decoded events to appropriate handlers based on event type. This implements a three-way routing strategy.\n\n```mermaid\ngraph TD\n    Dispatch[\"Dispatcher(IEventStruct)\"]\n    \n    CheckClosed{\"isClosed.Load()\"}\n    CheckHex{\"conf.GetHex() && event.EventType() in [TypeEventProcessor, TypeOutput]\"}\n    \n    TypeSwitch{\"event.EventType()\"}\n    \n    TypeOutput[\"TypeOutput\"]\n    TypeProcessor[\"TypeEventProcessor\"]\n    TypeModuleData[\"TypeModuleData\"]\n    \n    HexOutput[\"StringHex() → eventCollector\"]\n    TextOutput[\"output() → encode → eventCollector\"]\n    ProcessorWrite[\"processor.Write(event)\"]\n    ChildDispatch[\"child.Dispatcher(event)\"]\n    \n    Dispatch --> CheckClosed\n    CheckClosed -->|true| Return[\"Return (module shutting down)\"]\n    CheckClosed -->|false| CheckHex\n    \n    CheckHex -->|true| HexOutput\n    CheckHex -->|false| TypeSwitch\n    \n    TypeSwitch --> TypeOutput\n    TypeSwitch --> TypeProcessor\n    TypeSwitch --> TypeModuleData\n    \n    TypeOutput --> TextOutput\n    TypeProcessor --> ProcessorWrite\n    TypeModuleData --> ChildDispatch\n```\n\n**Diagram: Event Dispatch Routing Logic**\n\n**Event Type Categories:**\n\n[user/module/imodule.go:408-448]() routes events by type:\n\n- **`TypeOutput`**: Final formatted events ready for display → `eventCollector.Write()`\n- **`TypeEventProcessor`**: Events requiring aggregation/parsing → `processor.Write()`\n- **`TypeModuleData`**: Module-specific data (connections, master secrets) → `child.Dispatcher()`\n\n**Module-Specific Dispatch Example:**\n\n[user/module/probe_openssl.go:733-754]() handles OpenSSL-specific events:\n\n```\nfunc (m *MOpenSSLProbe) Dispatcher(eventStruct event.IEventStruct) {\n    switch ev := eventStruct.(type) {\n    case *event.ConnDataEvent:\n        if ev.IsDestroy == 0 {\n            m.AddConn(ev.Pid, ev.Fd, ev.Tuple, ev.Sock)  // Track connection\n        } else {\n            m.DelConn(ev.Sock)  // Remove connection\n        }\n    case *event.MasterSecretEvent:\n        m.saveMasterSecret(ev)  // Write to keylog\n    case *event.TcSkbEvent:\n        m.dumpTcSkb(ev)  // Write to PCAP\n    case *event.SSLDataEvent:\n        m.dumpSslData(ev)  // Process plaintext data\n    }\n}\n```\n\n**Sources:** [user/module/imodule.go:408-448](), [user/module/probe_openssl.go:733-754]()\n\n## Complete System Integration Flow\n\nThis diagram shows how modules integrate with the broader eCapture system from CLI invocation through event output.\n\n```mermaid\nsequenceDiagram\n    participant CLI as \"cobra.Command\"\n    participant Root as \"runModule()\"\n    participant Factory as \"GetModuleFunc()\"\n    participant Module as \"IModule (concrete)\"\n    participant eBPF as \"ebpfmanager\"\n    participant Reader as \"Event Readers\"\n    participant Processor as \"EventProcessor\"\n    participant Output as \"io.Writer\"\n    \n    CLI->>Root: Execute command\n    Root->>Root: setModConfig()\n    Root->>Root: initLogger()\n    Root->>Factory: GetModuleFunc(modName)\n    Factory-->>Root: modFunc()\n    Root->>Module: modFunc() creates instance\n    \n    Note over Root,Module: Initialization Phase\n    Root->>Module: Init(ctx, logger, config, ecw)\n    Module->>Module: autoDetectBTF()\n    Module->>Module: Create EventProcessor\n    Module-->>Root: nil (success)\n    \n    Note over Root,Module: Start Phase\n    Root->>Module: Run()\n    Module->>Module: child.Start()\n    Module->>eBPF: bpfManager.InitWithOptions(bytecode)\n    Module->>eBPF: bpfManager.Start()\n    eBPF-->>Module: Programs attached\n    \n    Note over Module,Output: Run Phase\n    par Event Reading\n        Module->>Reader: perfEventReader(em)\n        Reader->>Reader: rd.Read() [loop]\n        Reader->>Module: Decode(em, bytes)\n        Reader->>Module: Dispatcher(event)\n    and EventProcessor\n        Module->>Processor: processor.Serve()\n        Processor->>Processor: Worker pool running\n    end\n    \n    Note over Module,Output: Dispatch Phase\n    Module->>Module: Dispatcher(event)\n    alt TypeOutput\n        Module->>Output: output() → Write()\n    else TypeEventProcessor\n        Module->>Processor: Write(event)\n        Processor->>Processor: Aggregate/Parse\n        Processor->>Output: Write(formatted)\n    else TypeModuleData\n        Module->>Module: child.Dispatcher(event)\n        Module->>Module: Save to cache/file\n    end\n    \n    Note over CLI,Output: Cleanup Phase\n    CLI->>Root: Signal received\n    Root->>Module: Close()\n    Module->>Reader: Close all readers\n    Module->>Processor: Close()\n    Module->>eBPF: bpfManager.Stop()\n    Module-->>Root: nil (cleanup done)\n```\n\n**Diagram: Complete Module Integration Sequence**\n\n**Sources:** [cli/cmd/root.go:249-403](), [user/module/imodule.go:236-262]()\n\n## Module List and Capabilities\n\nThe following table summarizes all available modules and their key characteristics:\n\n| Module | Name Constant | Primary Target | eBPF Programs | Event Types | Output Modes |\n|--------|---------------|----------------|---------------|-------------|--------------|\n| MOpenSSLProbe | `openssl` | libssl.so, libcrypto.so | Uprobes (SSL_read/write), TC | SSLDataEvent, MasterSecretEvent, TcSkbEvent, ConnDataEvent | Text, PCAP, Keylog |\n| MGoTLSProbe | `gotls` | Go crypto/tls | Uprobes (crypto/tls funcs), TC | TlsDataEvent, MasterSecretEvent, TcSkbEvent | Text, PCAP, Keylog |\n| MGnuTLSProbe | `gnutls` | libgnutls.so | Uprobes (gnutls_record funcs), TC | SSLDataEvent, MasterSecretEvent | Text, PCAP, Keylog |\n| MNSSProbe | `nspr` | libnspr4.so | Uprobes (PR_Read/Write) | NsprDataEvent | Text |\n| MBashProbe | `bash` | /bin/bash | Uprobes (readline funcs) | BashEvent | Text |\n| MZshProbe | `zsh` | /bin/zsh | Uprobes (readline funcs) | ZshEvent | Text |\n| MMysqldProbe | `mysqld` | mysqld binary | Uprobes (dispatch_command) | MysqldEvent | Text |\n| MPostgresProbe | `postgres` | postgres binary | Uprobes (PostgresMain) | PostgresEvent | Text |\n\n**Sources:** Module files across [user/module/]() directory"
          },
          {
            "page_plan": {
              "id": "2.5",
              "title": "Version Detection and Bytecode Selection"
            },
            "content": "# Version Detection and Bytecode Selection\n\n<details>\n<summary>Relevant source files</summary>\n\nThe following files were used as context for generating this wiki page:\n\n- [cli/cmd/root.go](cli/cmd/root.go)\n- [user/config/iconfig.go](user/config/iconfig.go)\n- [user/module/imodule.go](user/module/imodule.go)\n- [user/module/probe_openssl.go](user/module/probe_openssl.go)\n- [user/module/probe_openssl_lib.go](user/module/probe_openssl_lib.go)\n- [variables.mk](variables.mk)\n\n</details>\n\n\n\n## Purpose and Scope\n\nThis page documents eCapture's sophisticated version detection and bytecode selection system, which enables the tool to work across multiple SSL/TLS library versions and kernel configurations without requiring manual version specification. The system automatically identifies the target library version, selects compatible eBPF bytecode, and falls back to safe defaults when exact matches are unavailable.\n\nFor information about the eBPF compilation process that produces these bytecode variants, see [Build System](#5.1). For details on module initialization and lifecycle, see [Module System and Lifecycle](#2.4).\n\n## System Overview\n\neCapture compiles over 130 different eBPF bytecode variants to support:\n- **OpenSSL**: versions 1.0.2a through 3.5.4\n- **BoringSSL**: Android 12-16 variants and non-Android versions\n- **GnuTLS**: versions 3.6.12 through 3.8.7\n- **Go TLS**: built-in crypto/tls library\n- **System utilities**: bash, zsh, mysqld, postgres\n\nEach SSL/TLS library version has different internal structure layouts (offsets), requiring version-specific bytecode. The system performs runtime detection to select the correct variant.\n\n**Sources:** [variables.mk:189-228](), [user/module/probe_openssl_lib.go:30-42](), [CHANGELOG.md:14-23]()\n\n## Version Detection Architecture\n\n```mermaid\nflowchart TB\n    Init[\"Module.Init()\"]\n    \n    subgraph Detection[\"Version Detection Phase\"]\n        FindLib[\"Locate SSL Library<br/>--libssl flag or /etc/ld.so.conf search\"]\n        OpenELF[\"Open ELF Binary<br/>elf.NewFile()\"]\n        CheckArch[\"Verify Architecture<br/>EM_X86_64 or EM_AARCH64\"]\n        ReadRodata[\"Read .rodata Section<br/>1MB chunks with overlap\"]\n        RegexScan[\"Regex: OpenSSL\\s\\d\\.\\d\\.[0-9a-z]+<br/>Extract version string\"]\n        VersionKey[\"Version Key<br/>e.g., 'openssl 3.0.12'\"]\n    end\n    \n    subgraph Selection[\"Bytecode Selection Phase\"]\n        MapLookup[\"sslVersionBpfMap Lookup<br/>100+ version entries\"]\n        ExactMatch{\"Exact Match?\"}\n        DowngradeTry[\"downgradeOpensslVersion()<br/>Progressive truncation\"]\n        DowngradeFound{\"Downgrade<br/>Found?\"}\n        DefaultFallback[\"Apply Default Fallback<br/>libssl.so.3 → openssl_3_0_0<br/>Android → boringssl_a_13\"]\n        OffsetValidation[\"autoDetectBytecode()<br/>Validate compatibility\"]\n        FinalBytecode[\"Selected Bytecode File<br/>e.g., openssl_3_0_0_kern.o\"]\n    end\n    \n    Init --> FindLib\n    FindLib --> OpenELF\n    OpenELF --> CheckArch\n    CheckArch --> ReadRodata\n    ReadRodata --> RegexScan\n    RegexScan --> VersionKey\n    \n    VersionKey --> MapLookup\n    MapLookup --> ExactMatch\n    ExactMatch -->|Yes| FinalBytecode\n    ExactMatch -->|No| DowngradeTry\n    DowngradeTry --> DowngradeFound\n    DowngradeFound -->|Yes| FinalBytecode\n    DowngradeFound -->|No| DefaultFallback\n    DefaultFallback --> OffsetValidation\n    OffsetValidation --> FinalBytecode\n```\n\n**Sources:** [user/module/probe_openssl_lib.go:189-282](), [user/module/probe_openssl_lib.go:284-317](), [user/module/probe_openssl_lib.go:341-369]()\n\n## ELF Parsing and Version Extraction\n\nThe `detectOpenssl()` function implements a robust version string extraction mechanism:\n\n### Process Steps\n\n1. **ELF File Opening**: Opens the target shared library using `os.OpenFile()` and `elf.NewFile()`\n2. **Architecture Validation**: Ensures the binary is `EM_X86_64` or `EM_AARCH64`\n3. **Section Location**: Finds the `.rodata` section containing read-only data (version strings)\n4. **Chunk Reading**: Reads in 1MB chunks with 30-byte overlap to handle edge cases\n5. **Regex Matching**: Applies pattern `OpenSSL\\s\\d\\.\\d\\.[0-9a-z]+` to extract version\n\n### Edge Case Handling\n\n| Scenario | Solution |\n|----------|----------|\n| Version string spans buffer boundary | 30-byte overlap (`OpenSslVersionLen`) ensures capture |\n| `.rodata` section not found | Returns `ErrProbeOpensslVerNotFound` |\n| Multiple version strings in binary | Uses first match found |\n| BoringSSL without version string | Falls back to Android detection or default |\n\n**Example version strings extracted:**\n- `\"OpenSSL 1.1.1j  16 Feb 2021\"` → `\"openssl 1.1.1j\"`\n- `\"OpenSSL 3.2.0 23 Nov 2023\"` → `\"openssl 3.2.0\"`\n\n**Sources:** [user/module/probe_openssl_lib.go:189-282](), [user/module/probe_openssl_lib.go:41-42]()\n\n### Detection Flow Diagram\n\n```mermaid\nflowchart LR\n    Start[\"detectOpenssl(soPath)\"]\n    OpenFile[\"os.OpenFile(soPath)\"]\n    NewELF[\"elf.NewFile(f)\"]\n    GetRodata[\"r.Section('.rodata')\"]\n    \n    subgraph ChunkReading[\"Chunk Reading Loop\"]\n        Seek[\"Seek to offset\"]\n        Read[\"Read 1MB buffer\"]\n        Regex[\"rex.Find(buf)\"]\n        Found{\"Match?\"}\n        Overlap[\"Adjust offset -30 bytes\"]\n    end\n    \n    Lower[\"strings.ToLower()\"]\n    Return[\"Return versionKeyLower\"]\n    \n    Start --> OpenFile\n    OpenFile --> NewELF\n    NewELF --> GetRodata\n    GetRodata --> Seek\n    Seek --> Read\n    Read --> Regex\n    Regex --> Found\n    Found -->|Yes| Lower\n    Found -->|No| Overlap\n    Overlap --> Seek\n    Lower --> Return\n```\n\n**Sources:** [user/module/probe_openssl_lib.go:206-282]()\n\n## Version-to-Bytecode Mapping System\n\nThe `initOpensslOffset()` function initializes the `sslVersionBpfMap` with 100+ version mappings. This map serves as the authoritative source for version-to-bytecode associations.\n\n### Mapping Table Structure\n\n| Version Family | Version Range | Bytecode File | Notes |\n|----------------|---------------|---------------|-------|\n| OpenSSL 1.0.2 | 1.0.2a - 1.0.2u | `openssl_1_0_2a_kern.o` | All 1.0.2 versions share offsets |\n| OpenSSL 1.1.0 | 1.1.0a - 1.1.0l | `openssl_1_1_0a_kern.o` | All 1.1.0 versions share offsets |\n| OpenSSL 1.1.1a | 1.1.1a only | `openssl_1_1_1a_kern.o` | Unique offset group |\n| OpenSSL 1.1.1b-c | 1.1.1b - 1.1.1c | `openssl_1_1_1b_kern.o` | Second offset group |\n| OpenSSL 1.1.1d-i | 1.1.1d - 1.1.1i | `openssl_1_1_1d_kern.o` | Third offset group |\n| OpenSSL 1.1.1j+ | 1.1.1j - 1.1.1w | `openssl_1_1_1j_kern.o` | Most common 1.1.1 variant |\n| OpenSSL 3.0.x | 3.0.0 - 3.0.11, 3.0.13+ | `openssl_3_0_0_kern.o` | Default for 3.0 series |\n| OpenSSL 3.0.12 | 3.0.12 only | `openssl_3_0_12_kern.o` | Special case with unique offsets |\n| OpenSSL 3.1.x | 3.1.0 - 3.1.8 | `openssl_3_1_0_kern.o` | Shares base with 3.0 series |\n| OpenSSL 3.2.0-2 | 3.2.0 - 3.2.2 | `openssl_3_2_0_kern.o` | Early 3.2 series |\n| OpenSSL 3.2.3 | 3.2.3 only | `openssl_3_2_3_kern.o` | Structure changes |\n| OpenSSL 3.2.5 | 3.2.5 only | `openssl_3_2_4_kern.o` | Additional changes |\n| OpenSSL 3.3.0-1 | 3.3.0 - 3.3.1 | `openssl_3_3_0_kern.o` | Early 3.3 series |\n| OpenSSL 3.3.2 | 3.3.2 only | `openssl_3_3_2_kern.o` | Mid-series changes |\n| OpenSSL 3.3.3-4 | 3.3.3 - 3.3.4 | `openssl_3_3_3_kern.o` | Latest 3.3 series |\n| OpenSSL 3.4.0 | 3.4.0 only | `openssl_3_4_0_kern.o` | Initial 3.4 release |\n| OpenSSL 3.4.1+ | 3.4.1 - 3.4.2 | `openssl_3_4_1_kern.o` | Updated 3.4 series |\n| OpenSSL 3.5.x | 3.5.0 - 3.5.4 | `openssl_3_5_0_kern.o` | Latest supported |\n| BoringSSL A12-13 | Android 12-13 | `boringssl_a_13_kern.o` | Google's fork |\n| BoringSSL A14 | Android 14 | `boringssl_a_14_kern.o` | Updated structures |\n| BoringSSL A15 | Android 15 | `boringssl_a_15_kern.o` | Latest Android |\n| BoringSSL A16 | Android 16 | `boringssl_a_16_kern.o` | Upcoming Android |\n| BoringSSL NA | Non-Android | `boringssl_na_kern.o` | Generic BoringSSL |\n\n### Mapping Code Structure\n\n```mermaid\ngraph TB\n    subgraph Initialization[\"initOpensslOffset()\"]\n        CreateMap[\"Create sslVersionBpfMap<br/>map[string]string\"]\n        \n        subgraph DefaultMappings[\"Default Mappings\"]\n            D102[\"linux_default_1_0_2<br/>→ openssl_1_0_2a_kern.o\"]\n            D110[\"linux_default_1_1_0<br/>→ openssl_1_1_0a_kern.o\"]\n            D111[\"linux_default_1_1_1<br/>→ openssl_1_1_1j_kern.o\"]\n            D30[\"linux_default_3_0<br/>→ openssl_3_0_0_kern.o\"]\n            DAndroid[\"android_default<br/>→ boringssl_a_13_kern.o\"]\n        end\n        \n        subgraph LoopMappings[\"Loop-Generated Mappings\"]\n            L111[\"for ch := 'j'; ch <= 'w'<br/>openssl 1.1.1{ch}\"]\n            L30[\"for ch := 0; ch <= 17<br/>openssl 3.0.{ch}\"]\n            L31[\"for ch := 0; ch <= 8<br/>openssl 3.1.{ch}\"]\n            L32[\"for ch := 0; ch <= 5<br/>openssl 3.2.{ch}\"]\n            L33[\"for ch := 0; ch <= 4<br/>openssl 3.3.{ch}\"]\n            L34[\"for ch := 0; ch <= 2<br/>openssl 3.4.{ch}\"]\n            L35[\"for ch := 0; ch <= 4<br/>openssl 3.5.{ch}\"]\n        end\n        \n        subgraph SpecialCases[\"Special Case Mappings\"]\n            S3012[\"openssl 3.0.12<br/>→ openssl_3_0_12_kern.o\"]\n            S323[\"openssl 3.2.3<br/>→ openssl_3_2_3_kern.o\"]\n            S325[\"openssl 3.2.5<br/>→ openssl_3_2_4_kern.o\"]\n        end\n    end\n    \n    CreateMap --> DefaultMappings\n    DefaultMappings --> LoopMappings\n    LoopMappings --> SpecialCases\n```\n\n**Sources:** [user/module/probe_openssl_lib.go:73-187](), [user/module/probe_openssl_lib.go:44-62]()\n\n## Downgrade Version Selection Algorithm\n\nWhen an exact version match is not found in `sslVersionBpfMap`, the `downgradeOpensslVersion()` function implements a progressive truncation algorithm to find the closest compatible older version.\n\n### Algorithm Steps\n\n```mermaid\nflowchart TD\n    Start[\"downgradeOpensslVersion(ver, soPath)\"]\n    InitCandidates[\"candidates = []\"]\n    \n    subgraph TruncateLoop[\"Progressive Truncation Loop\"]\n        LoopStart[\"for i := len(ver)-1; i > 0; i--\"]\n        Truncate[\"prefix = ver[:i]\"]\n        \n        subgraph MapScan[\"Scan sslVersionBpfMap\"]\n            CheckPrefix[\"strings.HasPrefix(libKey, prefix)\"]\n            CheckLessEqual[\"isVersionLessOrEqual(libKey, ver)\"]\n            AddCandidate[\"candidates.append(libKey)\"]\n        end\n        \n        HasCandidates{\"len(candidates) > 0?\"}\n        Sort[\"sort.Strings(candidates)\"]\n        ReturnMax[\"Return candidates[len-1]\"]\n    end\n    \n    subgraph Fallback[\"Default Fallback\"]\n        CheckSO3{\"Contains 'libssl.so.3'?\"}\n        Use30[\"Use linux_default_3_0\"]\n        Use111[\"Use linux_default_1_1_1\"]\n    end\n    \n    Start --> InitCandidates\n    InitCandidates --> LoopStart\n    LoopStart --> Truncate\n    Truncate --> CheckPrefix\n    CheckPrefix --> CheckLessEqual\n    CheckLessEqual --> AddCandidate\n    AddCandidate --> HasCandidates\n    HasCandidates -->|Yes| Sort\n    HasCandidates -->|No| LoopStart\n    Sort --> ReturnMax\n    LoopStart -->|i=0| CheckSO3\n    CheckSO3 -->|Yes| Use30\n    CheckSO3 -->|No| Use111\n```\n\n**Sources:** [user/module/probe_openssl_lib.go:341-369]()\n\n### Version Comparison Logic\n\nThe `isVersionLessOrEqual()` function performs lexicographic version comparison:\n\n1. **Extract version parts**: Split by dots (`\"3.0.12\"` → `[\"3\", \"0\", \"12\"]`)\n2. **Parse numeric and suffix**: `\"1a\"` → `num=1, suffix=\"a\"`\n3. **Compare iteratively**: Compare numbers first, then suffixes\n\n**Example comparisons:**\n- `isVersionLessOrEqual(\"openssl 3.0.11\", \"openssl 3.0.12\")` → `true`\n- `isVersionLessOrEqual(\"openssl 3.0.12\", \"openssl 3.0.11\")` → `false`\n- `isVersionLessOrEqual(\"openssl 1.1.1j\", \"openssl 1.1.1k\")` → `true`\n\n**Sources:** [user/module/probe_openssl_lib.go:371-448]()\n\n## Default Fallback Behavior\n\nWhen all detection and downgrade attempts fail, the system applies platform-specific defaults:\n\n### Linux Platform Defaults\n\n```mermaid\ngraph LR\n    CheckLibName{\"soPath contains<br/>'libssl.so.3'?\"}\n    Use30[\"SslVersion = linux_default_3_0<br/>openssl_3_0_0_kern.o\"]\n    Use111[\"SslVersion = linux_default_1_1_1<br/>openssl_1_1_1j_kern.o\"]\n    \n    CheckLibName -->|Yes| Use30\n    CheckLibName -->|No| Use111\n```\n\n**Rationale:**\n- `libssl.so.3` indicates OpenSSL 3.x series (most likely 3.0.x)\n- Older library names default to 1.1.1j (most stable/common 1.1.1 variant)\n\n### Android Platform Defaults\n\n```mermaid\ngraph TD\n    CheckAndroidVer{\"AndroidVer flag set?\"}\n    UseSpecific[\"Use boringssl_a_{AndroidVer}<br/>e.g., boringssl_a_14_kern.o\"]\n    UseDefault[\"Use android_default<br/>boringssl_a_13_kern.o\"]\n    \n    CheckAndroidVer -->|Yes| UseSpecific\n    CheckAndroidVer -->|No| UseDefault\n```\n\n**Android version mapping:**\n- `--android_ver=13` → `boringssl_a_13_kern.o`\n- `--android_ver=14` → `boringssl_a_14_kern.o`\n- `--android_ver=15` → `boringssl_a_15_kern.o`\n- `--android_ver=16` → `boringssl_a_16_kern.o`\n\n**Sources:** [user/module/probe_openssl_lib.go:284-317](), [user/module/probe_openssl_lib.go:361-368]()\n\n## CO-RE vs Non-CO-RE Bytecode Selection\n\neCapture maintains two bytecode variants for each version: CO-RE (Compile Once, Run Everywhere) and non-CO-RE (kernel-specific). The selection happens automatically based on kernel BTF support.\n\n### Selection Criteria\n\n| Criterion | CO-RE Mode | Non-CO-RE Mode |\n|-----------|------------|----------------|\n| Kernel BTF Support | `CONFIG_DEBUG_INFO_BTF=y` | Not required |\n| Minimum Kernel Version | 5.2+ (x86_64), 5.5+ (aarch64) | 4.18+ (x86_64), 5.5+ (aarch64) |\n| Bytecode Suffix | `_core.o` | `_noncore.o` |\n| Relocation | Runtime via libbpf | Compile-time via kernel headers |\n| Portability | Works across kernel versions | Tied to specific kernel |\n\n### BTF Detection Flow\n\n```mermaid\nflowchart TB\n    Start[\"Program Start\"]\n    CheckBTF[\"Check /sys/kernel/btf/vmlinux\"]\n    BTFExists{\"BTF File Exists?\"}\n    \n    subgraph COREPath[\"CO-RE Path\"]\n        SetCORE[\"btfMode = CORE\"]\n        SelectCORE[\"Select *_core.o bytecode\"]\n        LoadCORE[\"Load with libbpf BTF relocation\"]\n    end\n    \n    subgraph NonCOREPath[\"Non-CO-RE Path\"]\n        SetNonCORE[\"btfMode = Non-CORE\"]\n        SelectNonCORE[\"Select *_noncore.o bytecode\"]\n        LoadNonCORE[\"Load without relocation\"]\n    end\n    \n    Start --> CheckBTF\n    CheckBTF --> BTFExists\n    BTFExists -->|Yes| SetCORE\n    BTFExists -->|No| SetNonCORE\n    SetCORE --> SelectCORE\n    SelectCORE --> LoadCORE\n    SetNonCORE --> SelectNonCORE\n    SelectNonCORE --> LoadNonCORE\n```\n\n### Compilation Targets\n\nThe build system generates both variants simultaneously:\n\n**CO-RE compilation (x86_64 example):**\n```\nclang -target bpfel -D__TARGET_ARCH_x86 -I./kern/bpf/x86 \\\n      -O2 -g -c -o openssl_3_0_0_kern_core.o openssl_3_0_0_kern.c\n```\n\n**Non-CO-RE compilation (x86_64 example):**\n```\nclang -D__TARGET_ARCH_x86 -I/lib/modules/$(uname -r)/build/include \\\n      -DNOCORE -emit-llvm -S -o openssl_3_0_0_kern.ll openssl_3_0_0_kern.c\nllc -march=bpf -filetype=obj -o openssl_3_0_0_kern_noncore.o openssl_3_0_0_kern.ll\n```\n\n**Sources:** [variables.mk:236-268](), [README.md:86-101]()\n\n## Bytecode Loading and Validation\n\nAfter bytecode selection, the module performs validation before attachment:\n\n### Loading Process\n\n```mermaid\nsequenceDiagram\n    participant M as Module\n    participant S as Selector\n    participant A as Assets\n    participant E as ebpfmanager\n    \n    M->>S: detectOpenssl(soPath)\n    S->>S: Extract version from .rodata\n    S->>S: Lookup in sslVersionBpfMap\n    S-->>M: Return bytecode filename\n    \n    M->>A: bytecode.GetAsset(filename)\n    A-->>M: Return []byte bytecode\n    \n    M->>E: InitWithOptions(bytecode)\n    E->>E: Parse BPF program\n    E->>E: Apply relocations (CO-RE)\n    E-->>M: Manager ready\n    \n    M->>E: Start()\n    E->>E: Attach uprobes/TC hooks\n    E-->>M: Programs attached\n```\n\n### Error Handling Strategy\n\n| Error Condition | Recovery Action | Log Message |\n|-----------------|-----------------|-------------|\n| Version not found in `.rodata` | Use default based on library name | `\"OpenSSL/BoringSSL version not found, used default version\"` |\n| Bytecode file not found | Fatal error, exit | `\"BPF bytecode file is not matched\"` |\n| Uprobe attachment failed | Log warning, continue | `\"attach uprobe failed\"` |\n| Symbol not found | Skip that hook | `\"symbol not found, ignored\"` |\n\n**Sources:** [user/module/probe_openssl_lib.go:189-282](), [user/module/probe_openssl_lib.go:284-317]()\n\n## Version Support Matrix\n\nThis table summarizes the complete version support landscape:\n\n| Library | Minimum Version | Maximum Version | Total Variants | Notes |\n|---------|----------------|-----------------|----------------|-------|\n| OpenSSL 1.0.2 | 1.0.2a | 1.0.2u | 1 | Legacy support |\n| OpenSSL 1.1.0 | 1.1.0a | 1.1.0l | 1 | Legacy support |\n| OpenSSL 1.1.1 | 1.1.1a | 1.1.1w | 4 | Most common in production |\n| OpenSSL 3.0 | 3.0.0 | 3.0.17 | 2 | Default for Ubuntu 22.04+ |\n| OpenSSL 3.1 | 3.1.0 | 3.1.8 | 1 | Shares base with 3.0 |\n| OpenSSL 3.2 | 3.2.0 | 3.2.5 | 3 | Multiple structure changes |\n| OpenSSL 3.3 | 3.3.0 | 3.3.4 | 3 | Latest stable |\n| OpenSSL 3.4 | 3.4.0 | 3.4.2 | 2 | Recent release |\n| OpenSSL 3.5 | 3.5.0 | 3.5.4 | 1 | Newest supported |\n| BoringSSL Android | 12 | 16 | 4 | Per-Android-version |\n| BoringSSL | Non-Android | N/A | 1 | Generic variant |\n\n**Total bytecode files:** 22 SSL/TLS variants × 2 modes (CO-RE + non-CO-RE) = **44 bytecode files** just for OpenSSL/BoringSSL\n\n**Sources:** [user/module/probe_openssl_lib.go:44-62](), [variables.mk:189-228](), [CHANGELOG.md:14-23]()\n\n## Configuration Options\n\nUsers can override automatic detection using CLI flags:\n\n### Command-Line Overrides\n\n| Flag | Purpose | Example | Use Case |\n|------|---------|---------|----------|\n| `--ssl_version` | Force specific version | `--ssl_version=\"openssl 3.0.12\"` | Known version, skip detection |\n| `--libssl` | Specify library path | `--libssl=/opt/openssl/lib/libssl.so` | Non-standard installation |\n| `--android_ver` | Set Android version | `--android_ver=14` | Android BoringSSL detection |\n| `--nocore` | Disable CO-RE mode | `--nocore` | Force non-CO-RE bytecode |\n\n### Example Usage\n\n**Manual version specification:**\n```bash\nsudo ecapture tls --ssl_version=\"openssl 3.2.3\" --libssl=/usr/local/lib/libssl.so.3\n```\n\n**Android device:**\n```bash\nadb shell \"ecapture tls --android_ver=14\"\n```\n\n**Force non-CO-RE mode (older kernels):**\n```bash\nsudo ecapture tls --nocore\n```\n\n**Sources:** [README.md:165-169](), [README_CN.md:144-149]()\n\n## Logging and Diagnostics\n\nThe version detection system provides detailed logging at multiple stages:\n\n### Log Message Categories\n\n| Stage | Log Level | Example Message | Interpretation |\n|-------|-----------|----------------|----------------|\n| Detection Success | INFO | `\"Openssl Version=openssl 3.0.12\"` | Exact version found |\n| Default Fallback | WARN | `\"OpenSSL/BoringSSL version not found, used default version OpenSSL Version=linux_default_3_0\"` | Using generic default |\n| Downgrade Applied | ERROR | `\"OpenSSL Version=openssl 3.6.0, used downgrade version openssl 3.5.4\"` | Newer version, using closest older |\n| Bytecode Match | INFO | `\"BPF bytecode file is matched. bpfFileName=openssl_3_0_0_kern_core.o\"` | Bytecode selection complete |\n| BTF Mode | INFO | `\"BTF bytecode mode: CORE. btfMode=0\"` | CO-RE enabled |\n\n### Troubleshooting Guide\n\n**Problem:** `\"OpenSSL/BoringSSL version not found\"`\n\n**Solutions:**\n1. Check if `.rodata` section exists: `readelf -S /path/to/libssl.so | grep rodata`\n2. Manually specify version: `--ssl_version=\"openssl x.x.x\"`\n3. For BoringSSL, use: `--ssl_version=\"boringssl_a_13\"`\n\n**Problem:** `\"BPF bytecode file is not matched\"`\n\n**Solutions:**\n1. Verify bytecode files exist: `ls user/bytecode/*.o`\n2. Check build completed: `make`\n3. Try forcing version: `--ssl_version`\n\n**Problem:** Capture works but data is garbled\n\n**Cause:** Incorrect version/offset mismatch\n\n**Solutions:**\n1. Enable debug mode: `ecapture tls --debug`\n2. Try adjacent versions: `--ssl_version=\"openssl 3.0.11\"` vs `\"openssl 3.0.13\"`\n3. Check library version: `openssl version` or `strings /lib/libssl.so.3 | grep \"OpenSSL\"`\n\n**Sources:** [user/module/probe_openssl_lib.go:300-316](), [README.md:89-101]()"
          },
          {
            "page_plan": {
              "id": "2.6",
              "title": "Network Connection Tracking"
            },
            "content": "# Network Connection Tracking\n\n<details>\n<summary>Relevant source files</summary>\n\nThe following files were used as context for generating this wiki page:\n\n- [cli/cmd/root.go](cli/cmd/root.go)\n- [kern/common.h](kern/common.h)\n- [kern/ecapture.h](kern/ecapture.h)\n- [kern/tc.h](kern/tc.h)\n- [user/config/iconfig.go](user/config/iconfig.go)\n- [user/module/imodule.go](user/module/imodule.go)\n- [user/module/probe_openssl.go](user/module/probe_openssl.go)\n\n</details>\n\n\n\n## Purpose and Scope\n\nThis document explains eCapture's network connection tracking system, which associates captured network packets with the processes that generated them. The system enables packet-level capture (via TC eBPF programs) to be correlated with SSL/TLS plaintext data (via uprobe hooks) by maintaining bidirectional mappings between network 4-tuples (protocol, source/destination IP/port) and process identifiers (PID, UID, file descriptors).\n\nFor information about the overall eBPF architecture, see [eBPF Engine](#2.1). For details on SSL/TLS capture and master secret extraction, see [TLS/SSL Modules](#3.1). For PCAP output integration, see [PCAP Integration](#4.2).\n\n---\n\n## Overview\n\nNetwork connection tracking in eCapture serves two primary functions:\n\n1. **Process Attribution for Network Packets**: When TC (Traffic Control) programs capture packets at the network layer, they need to determine which process sent/received the packet to apply filters and enrich metadata.\n\n2. **Connection Context for Plaintext Data**: When uprobe hooks capture SSL/TLS plaintext data, they need to associate the data with network connection tuples for PCAP reconstruction and protocol parsing.\n\nThe tracking system uses a combination of:\n- **Kernel-space**: Kprobes on `tcp_sendmsg`/`udp_sendmsg` populate a shared eBPF map\n- **Kernel-space**: TC classifiers query the map to attribute packets to processes\n- **User-space**: Connection state tracking for SSL/TLS file descriptor to socket mapping\n\nSources: [kern/tc.h:1-398](), [user/module/probe_openssl.go:78-481]()\n\n---\n\n## Architecture Overview\n\n```mermaid\ngraph TB\n    subgraph \"Application Layer\"\n        APP[\"Application Process<br/>(OpenSSL/Go TLS/etc)\"]\n    end\n    \n    subgraph \"System Call Layer\"\n        SSL_WRITE[\"SSL_write()<br/>SSL_read()\"]\n        TCP_SEND[\"tcp_sendmsg()<br/>udp_sendmsg()\"]\n    end\n    \n    subgraph \"Kernel eBPF Layer\"\n        KPROBE[\"Kprobe Hooks<br/>tcp_sendmsg<br/>udp_sendmsg\"]\n        UPROBE[\"Uprobe Hooks<br/>SSL functions\"]\n        TC[\"TC Classifiers<br/>egress_cls_func<br/>ingress_cls_func\"]\n        \n        NET_MAP[\"network_map<br/>BPF_MAP_TYPE_LRU_HASH<br/>net_id_t → net_ctx_t\"]\n    end\n    \n    subgraph \"User Space Tracking\"\n        CONN_INFO[\"Connection State<br/>pidConns<br/>sock2pidFd\"]\n        CONN_EVENT[\"ConnDataEvent<br/>Add/Destroy signals\"]\n    end\n    \n    subgraph \"Data Flow\"\n        PKT[\"Packet Capture<br/>with PID/UID\"]\n        SSL_DATA[\"SSL Data Event<br/>with tuple/sock\"]\n    end\n    \n    APP --> SSL_WRITE\n    APP --> TCP_SEND\n    \n    SSL_WRITE --> UPROBE\n    TCP_SEND --> KPROBE\n    \n    KPROBE -->|\"Insert\"| NET_MAP\n    NET_MAP -->|\"Lookup\"| TC\n    \n    TC --> PKT\n    UPROBE --> CONN_EVENT\n    CONN_EVENT --> CONN_INFO\n    \n    UPROBE --> SSL_DATA\n    CONN_INFO -->|\"Enrich\"| SSL_DATA\n    \n    style NET_MAP fill:#f9f9f9,stroke:#333,stroke-width:2px\n    style CONN_INFO fill:#f9f9f9,stroke:#333,stroke-width:2px\n```\n\n**Diagram**: Network Connection Tracking Architecture\n\nThe diagram shows the dual-layer tracking system. Kprobes populate the kernel `network_map` when connections are established, allowing TC programs to attribute packets. Separately, user-space maintains connection state to enrich SSL/TLS data events with network tuples.\n\nSources: [kern/tc.h:57-77](), [kern/tc.h:290-397](), [user/module/probe_openssl.go:78-106]()\n\n---\n\n## Kernel-Space Connection Tracking\n\n### Network Identity Structure\n\nThe kernel tracks connections using a 4-tuple identifier that supports both IPv4 and IPv6:\n\n```mermaid\ngraph LR\n    subgraph \"struct net_id_t\"\n        PROTO[\"protocol<br/>(IPPROTO_TCP/UDP)\"]\n        SRC_PORT[\"src_port\"]\n        DST_PORT[\"dst_port\"]\n        \n        subgraph \"IPv4 Fields\"\n            SRC_IP4[\"src_ip4\"]\n            DST_IP4[\"dst_ip4\"]\n        end\n        \n        subgraph \"IPv6 Fields\"\n            SRC_IP6[\"src_ip6[4]\"]\n            DST_IP6[\"dst_ip6[4]\"]\n        end\n    end\n    \n    PROTO --> SRC_PORT\n    SRC_PORT --> DST_PORT\n    DST_PORT --> SRC_IP4\n    DST_PORT --> SRC_IP6\n```\n\n**Diagram**: Network Identity Structure (4-tuple)\n\nThe `net_id_t` structure [kern/tc.h:39-47]() serves as the key in the eBPF map. It contains fields for both IPv4 and IPv6 addresses, with only the relevant fields populated based on the address family.\n\n| Field | Type | Description |\n|-------|------|-------------|\n| `protocol` | `u32` | IPPROTO_TCP (6) or IPPROTO_UDP (17) |\n| `src_port` | `u32` | Source port number (host byte order) |\n| `dst_port` | `u32` | Destination port number (host byte order) |\n| `src_ip4` | `u32` | Source IPv4 address |\n| `dst_ip4` | `u32` | Destination IPv4 address |\n| `src_ip6[4]` | `u32[4]` | Source IPv6 address (128 bits) |\n| `dst_ip6[4]` | `u32[4]` | Destination IPv6 address (128 bits) |\n\nSources: [kern/tc.h:39-47]()\n\n### Process Context Structure\n\nEach connection is associated with process context information:\n\n```mermaid\ngraph LR\n    subgraph \"struct net_ctx_t\"\n        PID[\"pid<br/>(Process ID)\"]\n        UID[\"uid<br/>(User ID)\"]\n        COMM[\"comm[16]<br/>(Command name)\"]\n    end\n    \n    PID --> UID\n    UID --> COMM\n```\n\n**Diagram**: Process Context Structure\n\nThe `net_ctx_t` structure [kern/tc.h:49-54]() stores the process information that is later used by TC programs for filtering and attribution.\n\nSources: [kern/tc.h:49-54]()\n\n### Kprobe-Based Connection Registration\n\nThe system hooks `tcp_sendmsg` and `udp_sendmsg` kernel functions to capture connection establishment:\n\n```mermaid\nsequenceDiagram\n    participant App as Application\n    participant Kernel as Kernel (tcp_sendmsg)\n    participant Kprobe as tcp_sendmsg Kprobe\n    participant NetMap as network_map\n\n    App->>Kernel: send() system call\n    Kernel->>Kprobe: Hook triggered\n    \n    Note over Kprobe: Extract sock structure\n    Kprobe->>Kprobe: Read sk_family (AF_INET/AF_INET6)\n    Kprobe->>Kprobe: Read src/dst IP and port from sock\n    Kprobe->>Kprobe: Get PID/UID from current task\n    \n    Note over Kprobe: Build net_id_t key\n    Note over Kprobe: Build net_ctx_t value\n    \n    Kprobe->>NetMap: bpf_map_update_elem()\n    Note over NetMap: Store conn_id → net_ctx\n    \n    Kprobe-->>Kernel: Return\n    Kernel-->>App: Continue execution\n```\n\n**Diagram**: Kprobe Connection Registration Sequence\n\nThe kprobe implementation [kern/tc.h:290-347]() performs the following steps:\n\n1. **Extract Process Context**: Get PID from `bpf_get_current_pid_tgid()` and UID from `bpf_get_current_uid_gid()`\n2. **Read Socket Structure**: Extract the `struct sock *` parameter and read network fields using `bpf_probe_read()`\n3. **Determine Address Family**: Check `sk->__sk_common.skc_family` for AF_INET (2) or AF_INET6 (10)\n4. **Extract Connection Tuple**:\n   - Local port: `sk->__sk_common.skc_num` (already in host byte order)\n   - Remote port: `sk->__sk_common.skc_dport` (needs `bpf_ntohs()`)\n   - Local IP: `skc_rcv_saddr` (IPv4) or `skc_v6_rcv_saddr` (IPv6)\n   - Remote IP: `skc_daddr` (IPv4) or `skc_v6_daddr` (IPv6)\n5. **Update eBPF Map**: Insert the mapping into `network_map` with BPF_ANY flag\n\nImportant implementation details:\n\n- **No PID/UID filtering in kprobes**: Unlike other eBPF programs, the kprobes do NOT filter by target_pid/target_uid [kern/tc.h:296-302](). This ensures all connections are tracked, allowing TC programs to perform filtering later.\n- **LRU eviction**: The map type `BPF_MAP_TYPE_LRU_HASH` [kern/tc.h:73]() automatically evicts least-recently-used entries when full (10240 max entries).\n- **Separate UDP handler**: The `udp_sendmsg` kprobe [kern/tc.h:349-397]() uses identical logic but sets `protocol = IPPROTO_UDP`.\n\nSources: [kern/tc.h:290-347](), [kern/tc.h:349-397]()\n\n### TC-Based Packet Capture and Attribution\n\nTraffic Control (TC) eBPF classifiers capture packets at ingress and egress points:\n\n```mermaid\ngraph TB\n    subgraph \"Packet Arrival\"\n        PKT_IN[\"Network Packet\"]\n    end\n    \n    subgraph \"TC Classifier Logic\"\n        PARSE_L2[\"Parse Ethernet<br/>Check ETH_P_IP/ETH_P_IPV6\"]\n        PARSE_L3[\"Parse IP Header<br/>Extract protocol\"]\n        PARSE_L4[\"Parse TCP/UDP Header<br/>Extract ports\"]\n        \n        BUILD_KEY[\"Build net_id_t key\"]\n        LOOKUP[\"Lookup network_map\"]\n        \n        FOUND{\"Entry<br/>Found?\"}\n        SWAP[\"Try reverse lookup<br/>(swap src/dst)\"]\n        FILTER[\"Apply PID/UID filters\"]\n        \n        EVENT[\"Build skb_data_event_t\"]\n        OUTPUT[\"bpf_perf_event_output()\"]\n    end\n    \n    PKT_IN --> PARSE_L2\n    PARSE_L2 -->|\"Valid\"| PARSE_L3\n    PARSE_L3 -->|\"TCP/UDP/ICMP\"| PARSE_L4\n    PARSE_L4 --> BUILD_KEY\n    \n    BUILD_KEY --> LOOKUP\n    LOOKUP --> FOUND\n    FOUND -->|\"No\"| SWAP\n    SWAP --> LOOKUP\n    FOUND -->|\"Yes\"| FILTER\n    FILTER -->|\"Pass\"| EVENT\n    EVENT --> OUTPUT\n    \n    PARSE_L2 -->|\"Invalid\"| DROP[\"Return TC_ACT_OK\"]\n    PARSE_L3 -->|\"Invalid\"| DROP\n    FILTER -->|\"Fail\"| DROP\n```\n\n**Diagram**: TC Packet Capture and Attribution Flow\n\nThe `capture_packets()` function [kern/tc.h:135-276]() implements the packet capture logic:\n\n**Step 1: Packet Parsing**\n- Validate packet length: Must be at least `sizeof(ethhdr) + sizeof(iphdr)` [kern/tc.h:141-144]()\n- Parse Ethernet header to determine IPv4 vs IPv6 [kern/tc.h:156-236]()\n- Use `skb_revalidate_data()` [kern/tc.h:102-119]() to ensure sufficient data is available before accessing headers\n- Extract protocol (TCP/UDP/ICMP) and connection tuple\n\n**Step 2: Connection Lookup**\n- Build `net_id_t` key from packet headers\n- Call `bpf_map_lookup_elem(&network_map, &conn_id)` [kern/tc.h:188-198]() \n- If not found, swap source/destination fields and retry (handles bidirectional traffic)\n\n**Step 3: Process Filtering**\n- If connection found, check against `target_pid` and `target_uid` constants [kern/tc.h:243-250]()\n- These filters are only effective on kernels >= 5.2 (KERNEL_LESS_5_2 check)\n\n**Step 4: Event Generation**\n- Create `skb_data_event_t` with timestamp, PID, command, packet length, interface index [kern/tc.h:30-37]()\n- Use `bpf_perf_event_output()` [kern/tc.h:271]() to send minimal event data (36 bytes) plus packet data to user space\n\n**Optional: PCAP Filtering**\nThe TC programs support runtime PCAP filter injection via the `filter_pcap_l2()` function [kern/tc.h:128-132](). This is implemented as a stub function `filter_pcap_ebpf_l2()` [kern/tc.h:122-126]() that gets replaced at load time by the instruction patcher [user/module/probe_openssl.go:303-306]().\n\nSources: [kern/tc.h:135-276](), [kern/tc.h:279-288]()\n\n### Map Configuration\n\nThe network tracking map is defined as:\n\n```c\nstruct {\n    __uint(type, BPF_MAP_TYPE_LRU_HASH);\n    __type(key, struct net_id_t);\n    __type(value, struct net_ctx_t);\n    __uint(max_entries, 10240);\n} network_map SEC(\".maps\");\n```\n\n| Parameter | Value | Rationale |\n|-----------|-------|-----------|\n| Type | `BPF_MAP_TYPE_LRU_HASH` | Automatic eviction of old entries prevents memory exhaustion |\n| Max Entries | 10,240 | Balances memory usage with capacity for concurrent connections |\n| Key Size | 56 bytes | `net_id_t` structure (protocol + ports + IPs) |\n| Value Size | 20 bytes | `net_ctx_t` structure (pid + uid + comm) |\n\nSources: [kern/tc.h:72-77]()\n\n---\n\n## User-Space Connection Tracking\n\n### Connection State Management\n\nThe OpenSSL probe maintains additional connection state in user space to correlate SSL/TLS operations with network connections:\n\n```mermaid\ngraph TB\n    subgraph \"MOpenSSLProbe State\"\n        PID_CONNS[\"pidConns<br/>map[pid]map[fd]ConnInfo\"]\n        SOCK_MAP[\"sock2pidFd<br/>map[sock][pid,fd]\"]\n        LOCKER[\"pidLocker<br/>(sync.Mutex)\"]\n    end\n    \n    subgraph \"ConnInfo Structure\"\n        TUPLE[\"tuple: string<br/>(e.g. 192.168.1.1:443-10.0.0.1:54321)\"]\n        SOCK[\"sock: uint64<br/>(kernel socket pointer)\"]\n    end\n    \n    PID_CONNS -->|\"Contains\"| TUPLE\n    PID_CONNS -->|\"Contains\"| SOCK\n    SOCK_MAP -->|\"Reverse lookup\"| PID_CONNS\n    LOCKER -.->|\"Protects\"| PID_CONNS\n    LOCKER -.->|\"Protects\"| SOCK_MAP\n```\n\n**Diagram**: User-Space Connection State Structures\n\nThe user-space tracking system [user/module/probe_openssl.go:78-106]() maintains two synchronized maps:\n\n**1. Primary Map: `pidConns`**\n- Type: `map[uint32]map[uint32]ConnInfo`\n- Structure: PID → File Descriptor → Connection Info\n- Purpose: Fast lookup by process and file descriptor for SSL operations\n\n**2. Reverse Map: `sock2pidFd`**\n- Type: `map[uint64][2]uint32`\n- Structure: Socket Pointer → [PID, FD]\n- Purpose: Enables connection cleanup when kernel notifies socket destruction\n\n**Connection Info Fields:**\n- `tuple`: Human-readable connection string (format: \"src_ip:src_port-dst_ip:dst_port\")\n- `sock`: Kernel socket pointer (used for consistency checking)\n\nSources: [user/module/probe_openssl.go:78-106]()\n\n### Connection Lifecycle Operations\n\n```mermaid\nstateDiagram-v2\n    [*] --> Established: AddConn(pid,fd,tuple,sock)\n    \n    Established --> Active: GetConn(pid,fd)\n    Active --> Established: Return ConnInfo\n    \n    Established --> Delayed: DelConn(sock)\n    Delayed --> Destroyed: 3 second delay\n    \n    Destroyed --> [*]: DestroyConn(sock)\n    \n    note right of Delayed\n        Delayed destruction allows\n        event processor to merge\n        pending events\n    end note\n```\n\n**Diagram**: Connection Lifecycle State Machine\n\n#### AddConn: Connection Registration\n\n```mermaid\nsequenceDiagram\n    participant eBPF as eBPF Program\n    participant Dispatcher as Dispatcher()\n    participant AddConn as AddConn()\n    participant Maps as Connection Maps\n\n    eBPF->>Dispatcher: ConnDataEvent(IsDestroy=0)\n    Dispatcher->>AddConn: (pid, fd, tuple, sock)\n    \n    Note over AddConn: Lock pidLocker\n    AddConn->>Maps: Get/Create pidConns[pid]\n    AddConn->>Maps: Set pidConns[pid][fd] = ConnInfo\n    AddConn->>Maps: Set sock2pidFd[sock] = [pid,fd]\n    Note over AddConn: Unlock pidLocker\n    \n    AddConn-->>Dispatcher: Success\n```\n\n**Diagram**: AddConn Sequence\n\nThe `AddConn()` method [user/module/probe_openssl.go:398-416]() is called when a new connection is detected:\n\n1. **Validation**: Reject if `fd <= 0` [user/module/probe_openssl.go:399-402]()\n2. **Lock Acquisition**: Use mutex to prevent concurrent modification [user/module/probe_openssl.go:404]()\n3. **Map Initialization**: Create nested map for PID if it doesn't exist [user/module/probe_openssl.go:406-409]()\n4. **Store Connection**: Add `ConnInfo` with tuple and socket pointer [user/module/probe_openssl.go:410-411]()\n5. **Reverse Mapping**: Store socket → [pid, fd] for cleanup [user/module/probe_openssl.go:413]()\n\nSources: [user/module/probe_openssl.go:398-416]()\n\n#### GetConn: Connection Retrieval\n\nThe `GetConn()` method [user/module/probe_openssl.go:464-480]() retrieves connection information for SSL/TLS data events:\n\n1. **Fast Validation**: Return nil if `fd <= 0` [user/module/probe_openssl.go:465-467]()\n2. **Locked Lookup**: Access maps under mutex protection [user/module/probe_openssl.go:469-470]()\n3. **Two-Level Lookup**: First find PID's map, then find FD's connection [user/module/probe_openssl.go:471-479]()\n\nThis method is called by `dumpSslData()` [user/module/probe_openssl.go:762]() to enrich SSL data events with network tuple information.\n\nSources: [user/module/probe_openssl.go:464-480](), [user/module/probe_openssl.go:756-775]()\n\n#### DelConn: Delayed Destruction\n\n```mermaid\nsequenceDiagram\n    participant eBPF as eBPF Program\n    participant Dispatcher as Dispatcher()\n    participant DelConn as DelConn()\n    participant Timer as time.AfterFunc\n    participant DestroyConn as DestroyConn()\n\n    eBPF->>Dispatcher: ConnDataEvent(IsDestroy=1)\n    Dispatcher->>DelConn: (sock)\n    \n    Note over DelConn: Schedule delayed cleanup\n    DelConn->>Timer: After 3 seconds\n    DelConn-->>Dispatcher: Return immediately\n    \n    Note over Timer: Wait 3 seconds...\n    \n    Timer->>DestroyConn: Execute cleanup\n    Note over DestroyConn: Remove from maps\n```\n\n**Diagram**: Delayed Connection Destruction\n\nThe `DelConn()` method [user/module/probe_openssl.go:455-462]() implements delayed cleanup:\n\n- **3-Second Delay**: Uses `time.AfterFunc()` to defer actual destruction [user/module/probe_openssl.go:459]()\n- **Rationale**: The delay must exceed the event processor's merge interval [user/module/probe_openssl.go:456-458](). This ensures all pending events are processed before connection state is removed.\n\nSources: [user/module/probe_openssl.go:455-462]()\n\n#### DestroyConn: Actual Cleanup\n\nThe `DestroyConn()` method [user/module/probe_openssl.go:418-452]() performs the actual cleanup:\n\n1. **Notify Processor**: Signal the event processor to flush connection data [user/module/probe_openssl.go:423-424]()\n2. **Reverse Lookup**: Use `sock2pidFd` to find [pid, fd] [user/module/probe_openssl.go:426-429]()\n3. **Consistency Check**: Verify socket pointer matches before deletion [user/module/probe_openssl.go:441-445]() (prevents race conditions)\n4. **Cleanup Maps**: Remove from `pidConns` and potentially entire PID map if empty [user/module/probe_openssl.go:446-449]()\n\nSources: [user/module/probe_openssl.go:418-452]()\n\n---\n\n## Integration with SSL/TLS Data Capture\n\n### Enriching SSL Data Events\n\nWhen uprobe hooks capture SSL/TLS plaintext data, the connection tracking system enriches the event with network context:\n\n```mermaid\nsequenceDiagram\n    participant Uprobe as SSL_write Uprobe\n    participant Dispatcher as Dispatcher()\n    participant DumpSslData as dumpSslData()\n    participant GetConn as GetConn()\n    participant Processor as Event Processor\n\n    Uprobe->>Dispatcher: SSLDataEvent(pid, fd, data)\n    Dispatcher->>DumpSslData: Process event\n    \n    DumpSslData->>GetConn: (pid, fd)\n    \n    alt Connection Found\n        GetConn-->>DumpSslData: ConnInfo{tuple, sock}\n        Note over DumpSslData: Set event.Tuple<br/>Set event.Sock\n    else Connection Not Found\n        Note over DumpSslData: Set tuple = \"0.0.0.0:0-0.0.0.0:0\"<br/>Set sock = 0\n    end\n    \n    DumpSslData->>Processor: Write enriched event\n```\n\n**Diagram**: SSL Data Event Enrichment Flow\n\nThe `dumpSslData()` method [user/module/probe_openssl.go:756-775]() performs the enrichment:\n\n1. **Validation**: Check if FD is valid and BIO type is appropriate [user/module/probe_openssl.go:758-761]()\n2. **Connection Lookup**: Call `GetConn(pid, fd)` [user/module/probe_openssl.go:762]()\n3. **Fallback Handling**: If no connection found, use default tuple `\"0.0.0.0:0-0.0.0.0:0\"` [user/module/probe_openssl.go:763-766]()\n4. **Event Enrichment**: Set `tuple` and `sock` fields on the event [user/module/probe_openssl.go:769-770]()\n5. **Forward to Processor**: Send enriched event to the event processor [user/module/probe_openssl.go:774]()\n\n**Default Tuple Constant:**\nThe constant `DefaultTuple = \"0.0.0.0:0-0.0.0.0:0\"` [user/module/probe_openssl.go:43]() is used when connection information is unavailable, typically for:\n- Memory BIO operations (no network socket)\n- Connections established before eCapture started\n- File descriptor mismatches\n\nSources: [user/module/probe_openssl.go:756-775](), [user/module/probe_openssl.go:42-43]()\n\n### Connection Event Dispatching\n\nThe dispatcher routes connection-related events to appropriate handlers:\n\n```mermaid\ngraph TB\n    DISPATCHER[\"Dispatcher()<br/>event.IEventStruct\"]\n    \n    TYPE_CHECK{\"Event<br/>Type?\"}\n    \n    CONN_DATA[\"ConnDataEvent\"]\n    MASTER_SECRET[\"MasterSecretEvent\"]\n    TC_SKB[\"TcSkbEvent\"]\n    SSL_DATA[\"SSLDataEvent\"]\n    \n    CHECK_DESTROY{\"IsDestroy<br/>== 0?\"}\n    \n    ADD_CONN[\"AddConn()\"]\n    DEL_CONN[\"DelConn()\"]\n    \n    SAVE_MASTER[\"saveMasterSecret()\"]\n    DUMP_TC[\"dumpTcSkb()\"]\n    DUMP_SSL[\"dumpSslData()\"]\n    \n    DISPATCHER --> TYPE_CHECK\n    \n    TYPE_CHECK -->|\"ConnDataEvent\"| CONN_DATA\n    TYPE_CHECK -->|\"MasterSecretEvent\"| MASTER_SECRET\n    TYPE_CHECK -->|\"TcSkbEvent\"| TC_SKB\n    TYPE_CHECK -->|\"SSLDataEvent\"| SSL_DATA\n    \n    CONN_DATA --> CHECK_DESTROY\n    CHECK_DESTROY -->|\"Yes\"| ADD_CONN\n    CHECK_DESTROY -->|\"No\"| DEL_CONN\n    \n    MASTER_SECRET --> SAVE_MASTER\n    TC_SKB --> DUMP_TC\n    SSL_DATA --> DUMP_SSL\n```\n\n**Diagram**: Event Dispatcher Routing\n\nThe `Dispatcher()` method [user/module/probe_openssl.go:733-754]() uses type switches to route events:\n\n- **ConnDataEvent**: Connection lifecycle events from TC or socket operations\n  - `IsDestroy == 0`: New connection → `AddConn()` [user/module/probe_openssl.go:738]()\n  - `IsDestroy != 0`: Closing connection → `DelConn()` [user/module/probe_openssl.go:740]()\n- **MasterSecretEvent**: TLS master secrets → `saveMasterSecret()` [user/module/probe_openssl.go:743]()\n- **TcSkbEvent**: TC packet captures → `dumpTcSkb()` [user/module/probe_openssl.go:747]()\n- **SSLDataEvent**: SSL/TLS plaintext data → `dumpSslData()` [user/module/probe_openssl.go:752]()\n\nSources: [user/module/probe_openssl.go:733-754]()\n\n---\n\n## PCAP Mode Integration\n\nIn PCAP mode, the connection tracking system enables packet-level reconstruction:\n\n```mermaid\ngraph TB\n    subgraph \"TC Layer\"\n        TC_CAPTURE[\"TC Packet Capture\"]\n        NET_MAP_LOOKUP[\"network_map Lookup\"]\n        TC_EVENT[\"TcSkbEvent<br/>(with PID/tuple)\"]\n    end\n    \n    subgraph \"SSL Layer\"\n        SSL_CAPTURE[\"SSL Uprobe Capture\"]\n        CONN_LOOKUP[\"GetConn(pid, fd)\"]\n        SSL_EVENT[\"SSLDataEvent<br/>(with tuple/sock)\"]\n    end\n    \n    subgraph \"User Space Processing\"\n        TC_HANDLER[\"dumpTcSkb()\"]\n        SSL_HANDLER[\"dumpSslData()\"]\n        \n        PCAP_WRITER[\"PCAP-NG Writer\"]\n        DSB_WRITER[\"DSB Block Writer<br/>(Decryption Secrets)\"]\n    end\n    \n    TC_CAPTURE --> NET_MAP_LOOKUP\n    NET_MAP_LOOKUP --> TC_EVENT\n    TC_EVENT --> TC_HANDLER\n    \n    SSL_CAPTURE --> CONN_LOOKUP\n    CONN_LOOKUP --> SSL_EVENT\n    SSL_EVENT --> SSL_HANDLER\n    \n    TC_HANDLER --> PCAP_WRITER\n    SSL_HANDLER --> DSB_WRITER\n    DSB_WRITER --> PCAP_WRITER\n```\n\n**Diagram**: PCAP Mode Connection Tracking Integration\n\nIn PCAP mode (`TlsCaptureModelTypePcap`), the system:\n\n1. **Captures Network Packets**: TC programs capture raw packets with process attribution\n2. **Captures TLS Secrets**: Uprobe hooks extract master secrets with connection tuples\n3. **Correlates by Tuple**: Both data streams are written to the same PCAP-NG file, allowing Wireshark to decrypt TLS traffic by matching tuples in packet headers with keys in DSB (Decryption Secrets Block) records\n\nThe connection tuple serves as the correlation key between:\n- Encrypted network packets (from TC layer)\n- TLS master secrets (from SSL/TLS layer)\n\nFor detailed PCAP output format, see [PCAP Integration](#4.2).\n\nSources: [user/module/probe_openssl.go:137-154]()\n\n---\n\n## Performance Considerations\n\n### Map Size and Eviction\n\nThe `network_map` uses LRU (Least Recently Used) eviction with a maximum of 10,240 entries:\n\n| Scenario | Map Behavior | Impact |\n|----------|-------------|--------|\n| Low connection count | All connections tracked | Full attribution for all packets |\n| High connection churn | Older connections evicted | Recent connections prioritized |\n| Map full | LRU entry replaced | May lose attribution for idle connections |\n\n**Mitigation**: The LRU strategy ensures active connections remain in the map, while idle connections that haven't sent packets recently are candidates for eviction.\n\nSources: [kern/tc.h:72-77]()\n\n### Lock Contention\n\nThe user-space connection state uses a single mutex (`pidLocker`) to protect both maps [user/module/probe_openssl.go:94]():\n\n**Lock Points:**\n- `AddConn()`: Held during map insertion [user/module/probe_openssl.go:404]()\n- `GetConn()`: Held during map lookup [user/module/probe_openssl.go:469]()\n- `DestroyConn()`: Held during map cleanup [user/module/probe_openssl.go:419]()\n\n**Optimization Opportunity**: The current implementation uses a global lock. High-concurrency scenarios could benefit from:\n- Per-PID locks (sharding)\n- Read-write locks (many lookups, few modifications)\n- Lock-free concurrent maps\n\nHowever, for typical workloads, contention is minimal since most operations complete quickly (simple map operations).\n\nSources: [user/module/probe_openssl.go:404](), [user/module/probe_openssl.go:419](), [user/module/probe_openssl.go:469]()\n\n### Delayed Destruction Rationale\n\nThe 3-second delay in `DelConn()` [user/module/probe_openssl.go:459]() serves a specific purpose:\n\n**Problem**: Events may arrive out of order or be buffered in the eBPF perf/ring buffer\n**Solution**: Keep connection state alive briefly after closure to ensure all events are enriched\n**Trade-off**: Increased memory usage (short-lived) vs. data completeness\n\nThe delay is chosen to exceed the event processor's merge interval, ensuring connection state is available for all events that reference it.\n\nSources: [user/module/probe_openssl.go:455-462]()\n\n---\n\n## Limitations and Edge Cases\n\n### Kernel Version Constraints\n\nProcess filtering in TC programs only works on kernels >= 5.2:\n\n```c\n#ifndef KERNEL_LESS_5_2\n    if (target_pid != 0 && target_pid != net_ctx->pid) {\n        return TC_ACT_OK;\n    }\n    if (target_uid != 0 && target_uid != net_ctx->uid) {\n        return TC_ACT_OK;\n    }\n#endif\n```\n\nOn older kernels, TC programs capture all packets regardless of PID/UID filters [kern/tc.h:147-150](), [kern/tc.h:243-250]().\n\nSources: [kern/tc.h:243-250]()\n\n### Connection Tuple Matching\n\nThe bidirectional lookup [kern/tc.h:188-198]() handles packets in both directions:\n\n1. First lookup with packet's (src, dst)\n2. If not found, swap and lookup with (dst, src)\n\n**Edge Case**: ICMP packets don't have port numbers, so the tuple may be ambiguous for multi-connection scenarios.\n\nSources: [kern/tc.h:188-198](), [kern/tc.h:226-235]()\n\n### Race Conditions\n\n**Socket Reuse**: If a socket pointer is reused by the kernel between close and new allocation, the consistency check in `DestroyConn()` [user/module/probe_openssl.go:441-445]() prevents incorrect deletion:\n\n```go\nif connInfo.sock != sock {\n    m.logger.Debug().Msg(\"DestroyConn skip\")\n    return\n}\n```\n\nThis ensures that only the exact connection instance is destroyed, not a new connection that happens to use the same socket pointer.\n\nSources: [user/module/probe_openssl.go:441-445]()\n\n### Missing Connection State\n\nWhen `GetConn()` returns nil, `dumpSslData()` uses a default tuple [user/module/probe_openssl.go:763-766]():\n\n**Causes:**\n- BIO operations without network sockets (memory BIO, file BIO)\n- Connections established before eCapture attached\n- File descriptor closed/reused between events\n\n**Impact:**\n- PCAP reconstruction impossible (no tuple for correlation)\n- Text mode output still works (shows default tuple)\n- Event processor can still merge events by sock field\n\nSources: [user/module/probe_openssl.go:763-766]()\n\n---\n\n## Summary\n\nThe network connection tracking system in eCapture implements a sophisticated multi-layer correlation mechanism:\n\n**Kernel Space:**\n- Kprobes on `tcp_sendmsg`/`udp_sendmsg` populate connection map\n- TC classifiers query the map for packet attribution\n- LRU eviction manages memory with 10K connection limit\n\n**User Space:**\n- Bidirectional maps (pid/fd → conn, sock → pid/fd) enable fast lookups\n- Delayed cleanup (3 seconds) prevents premature state removal\n- Connection enrichment correlates SSL/TLS data with network tuples\n\n**Key Design Principles:**\n1. **Separation of Concerns**: Kernel tracks network, user space tracks SSL/TLS\n2. **Bidirectional Lookup**: Support both packet→process and fd→connection flows\n3. **Graceful Degradation**: Missing connections use default tuples\n4. **Performance Optimization**: LRU eviction, minimal locking, targeted filtering\n\nThis architecture enables eCapture to provide complete visibility into TLS traffic by correlating encrypted network packets with plaintext application data and decryption keys.\n\nSources: [kern/tc.h:1-398](), [user/module/probe_openssl.go:1-787]()"
          },
          {
            "page_plan": {
              "id": "3",
              "title": "Capture Modules"
            },
            "content": "# Capture Modules\n\n<details>\n<summary>Relevant source files</summary>\n\nThe following files were used as context for generating this wiki page:\n\n- [CHANGELOG.md](CHANGELOG.md)\n- [README.md](README.md)\n- [README_CN.md](README_CN.md)\n- [cli/cmd/bash.go](cli/cmd/bash.go)\n- [cli/cmd/gnutls.go](cli/cmd/gnutls.go)\n- [cli/cmd/gotls.go](cli/cmd/gotls.go)\n- [cli/cmd/mysqld.go](cli/cmd/mysqld.go)\n- [cli/cmd/nspr.go](cli/cmd/nspr.go)\n- [cli/cmd/postgres.go](cli/cmd/postgres.go)\n- [cli/cmd/tls.go](cli/cmd/tls.go)\n- [cli/cmd/zsh.go](cli/cmd/zsh.go)\n- [images/ecapture-help-v0.8.9.svg](images/ecapture-help-v0.8.9.svg)\n- [main.go](main.go)\n- [pkg/util/ws/client.go](pkg/util/ws/client.go)\n- [pkg/util/ws/client_test.go](pkg/util/ws/client_test.go)\n\n</details>\n\n\n\n## Purpose and Scope\n\nThis page provides an overview of eCapture's capture module system, which implements specialized data capture capabilities for different protocols, libraries, and applications. Each module targets a specific technology (OpenSSL, GnuTLS, Go TLS, Bash, MySQL, etc.) and implements a common interface to integrate with eCapture's event processing pipeline.\n\nFor detailed information about specific module types, see:\n- TLS/SSL capture implementations: [TLS/SSL Modules](#3.1)\n- Shell and database auditing: [System Audit Modules](#3.2)\n- Network packet capture mechanisms: [Network Packet Capture with TC](#3.3)\n- Module interface and lifecycle management: [Module System and Lifecycle](#2.4)\n\n## Module System Overview\n\neCapture's modular architecture allows it to capture data from diverse sources through a unified interface. Each module is responsible for:\n\n1. **Target Detection**: Locating the appropriate binary or shared library to instrument\n2. **eBPF Program Management**: Loading and attaching version-specific eBPF bytecode\n3. **Event Processing**: Decoding and formatting captured data\n4. **Output Generation**: Producing data in text, pcap, or keylog formats\n\nThe system currently implements **eight capture modules**, each registered via CLI subcommands and accessible through the module registry.\n\nSources: [README.md:152-161](), [cli/cmd/tls.go:29-48](), [cli/cmd/gotls.go:29-40]()\n\n## Module Registry and Architecture\n\n```mermaid\ngraph TB\n    subgraph \"CLI Layer\"\n        rootCmd[\"rootCmd<br/>(cobra.Command)\"]\n        tlsCmd[\"opensslCmd<br/>'tls' subcommand\"]\n        gotlsCmd[\"gotlsCmd<br/>'gotls' subcommand\"]\n        gnutlsCmd[\"gnutlsCmd<br/>'gnutls' subcommand\"]\n        nssCmd[\"nssCmd<br/>'nspr' subcommand\"]\n        bashCmd[\"bashCmd<br/>'bash' subcommand\"]\n        zshCmd[\"zshCmd<br/>'zsh' subcommand\"]\n        mysqldCmd[\"mysqldCmd<br/>'mysqld' subcommand\"]\n        postgresCmd[\"postgresCmd<br/>'postgres' subcommand\"]\n    end\n    \n    subgraph \"Configuration Layer\"\n        oc[\"OpensslConfig<br/>oc variable\"]\n        goc[\"GoTLSConfig<br/>goc variable\"]\n        gc[\"GnutlsConfig<br/>gc variable\"]\n        nc[\"NsprConfig<br/>nc variable\"]\n        bc[\"BashConfig<br/>bc variable\"]\n        zc[\"ZshConfig<br/>zc variable\"]\n        myc[\"MysqldConfig<br/>myc variable\"]\n        pgc[\"PostgresConfig<br/>pgc variable\"]\n    end\n    \n    subgraph \"Module Layer\"\n        modOpenssl[\"ModuleNameOpenssl<br/>constant\"]\n        modGotls[\"ModuleNameGotls<br/>constant\"]\n        modGnutls[\"ModuleNameGnutls<br/>constant\"]\n        modNspr[\"ModuleNameNspr<br/>constant\"]\n        modBash[\"ModuleNameBash<br/>constant\"]\n        modZsh[\"ModuleNameZsh<br/>constant\"]\n        modMysqld[\"ModuleNameMysqld<br/>constant\"]\n        modPostgres[\"ModuleNamePostgres<br/>constant\"]\n    end\n    \n    subgraph \"Execution\"\n        runModule[\"runModule()<br/>function\"]\n    end\n    \n    rootCmd --> tlsCmd\n    rootCmd --> gotlsCmd\n    rootCmd --> gnutlsCmd\n    rootCmd --> nssCmd\n    rootCmd --> bashCmd\n    rootCmd --> zshCmd\n    rootCmd --> mysqldCmd\n    rootCmd --> postgresCmd\n    \n    tlsCmd --> oc\n    gotlsCmd --> goc\n    gnutlsCmd --> gc\n    nssCmd --> nc\n    bashCmd --> bc\n    zshCmd --> zc\n    mysqldCmd --> myc\n    postgresCmd --> pgc\n    \n    oc --> modOpenssl\n    goc --> modGotls\n    gc --> modGnutls\n    nc --> modNspr\n    bc --> modBash\n    zc --> modZsh\n    myc --> modMysqld\n    pgc --> modPostgres\n    \n    modOpenssl --> runModule\n    modGotls --> runModule\n    modGnutls --> runModule\n    modNspr --> runModule\n    modBash --> runModule\n    modZsh --> runModule\n    modMysqld --> runModule\n    modPostgres --> runModule\n```\n\n**Module Registration Architecture**: Each module is registered as a Cobra CLI subcommand with its own configuration object. When invoked, the command function calls `runModule()` with the module name constant and configuration, which instantiates the appropriate module implementation via the module registry.\n\nSources: [cli/cmd/tls.go:26-67](), [cli/cmd/gotls.go:26-58](), [cli/cmd/bash.go:24-55](), [cli/cmd/mysqld.go:27-49](), [cli/cmd/postgres.go:27-45](), [cli/cmd/nspr.go:27-51](), [cli/cmd/gnutls.go:29-64](), [cli/cmd/zsh.go:27-57]()\n\n## Module Categories\n\neCapture's eight modules are organized into three functional categories based on their capture targets and techniques:\n\n### TLS/SSL Encryption Libraries\n\nThese modules intercept cryptographic functions to capture plaintext data before encryption or after decryption:\n\n| Module | CLI Command | Target Library | Supported Versions | Primary Use Case |\n|--------|-------------|----------------|-------------------|------------------|\n| **OpenSSL** | `tls`, `openssl` | libssl.so | 1.0.x, 1.1.x, 3.0.x+ | General TLS/HTTPS capture |\n| **BoringSSL** | `tls` | libssl.so | Android 12-16 | Android HTTPS capture |\n| **Go TLS** | `gotls`, `tlsgo` | Built-in crypto/tls | All Go versions | Go application capture |\n| **GnuTLS** | `gnutls`, `gnu` | libgnutls.so | 3.x | Alternative TLS library |\n| **NSPR/NSS** | `nspr`, `nss` | libnspr4.so | All versions | Firefox/Thunderbird |\n\nSources: [README.md:152-161](), [README_CN.md:128-138](), [cli/cmd/tls.go:29-33](), [cli/cmd/gotls.go:29-33](), [cli/cmd/gnutls.go:32-36](), [cli/cmd/nspr.go:30-34]()\n\n### System Audit and Command Capture\n\nThese modules hook into command interpreters and database servers for security auditing:\n\n| Module | CLI Command | Target Binary | Hook Points | Audit Capability |\n|--------|-------------|---------------|-------------|------------------|\n| **Bash** | `bash` | /bin/bash | readline library | Command input/output |\n| **Zsh** | `zsh` | /bin/zsh | readline functions | Command execution |\n| **MySQL** | `mysqld` | /usr/sbin/mysqld | dispatch_command | SQL query logging |\n| **PostgreSQL** | `postgres` | /usr/bin/postgres | Query execution | SQL audit |\n\nSources: [README.md:152-161](), [cli/cmd/bash.go:27-32](), [cli/cmd/zsh.go:30-35](), [cli/cmd/mysqld.go:30-36](), [cli/cmd/postgres.go:30-33]()\n\n### Network Packet Capture\n\nNetwork-level capture is integrated into TLS/SSL modules via Traffic Control (TC) eBPF classifiers. See [Network Packet Capture with TC](#3.3) for details.\n\n## Detailed Module Descriptions\n\n```mermaid\ngraph LR\n    subgraph \"TLS/SSL Modules\"\n        direction TB\n        M1[\"MOpenSSLProbe\"]\n        M1_desc[\"Hooks: SSL_read/SSL_write<br/>SSL_do_handshake<br/>Master key extraction\"]\n        \n        M2[\"MGoTLSProbe\"]\n        M2_desc[\"Hooks: crypto/tls.Conn.Read<br/>crypto/tls.Conn.Write<br/>PIE binary support\"]\n        \n        M3[\"MGnuTLSProbe\"]\n        M3_desc[\"Hooks: gnutls_record_recv<br/>gnutls_record_send<br/>Early secret support\"]\n        \n        M4[\"MNSPRProbe\"]\n        M4_desc[\"Hooks: PR_Read/PR_Write<br/>NSS/Firefox encryption\"]\n        \n        M1 -.-> M1_desc\n        M2 -.-> M2_desc\n        M3 -.-> M3_desc\n        M4 -.-> M4_desc\n    end\n    \n    subgraph \"System Audit Modules\"\n        direction TB\n        M5[\"MBashProbe\"]\n        M5_desc[\"Hook: readline()<br/>Command line input<br/>Return value filtering\"]\n        \n        M6[\"MZshProbe\"]\n        M6_desc[\"Hook: zsh readline<br/>Zsh command capture\"]\n        \n        M7[\"MMysqldProbe\"]\n        M7_desc[\"Hook: dispatch_command()<br/>MySQL 5.6/5.7/8.0<br/>MariaDB 10.5+\"]\n        \n        M8[\"MPostgresProbe\"]\n        M8_desc[\"Hook: exec_simple_query<br/>PostgreSQL 10+\"]\n        \n        M5 -.-> M5_desc\n        M6 -.-> M6_desc\n        M7 -.-> M7_desc\n        M8 -.-> M8_desc\n    end\n```\n\n**Module Implementation Details**: Each module is implemented as a separate struct that embeds common functionality and implements module-specific hook points and event processing logic.\n\n### OpenSSL/BoringSSL Module\n\nThe `tls` command targets OpenSSL and BoringSSL libraries, providing the most comprehensive TLS capture capabilities. It supports:\n\n- **Version Detection**: Automatic detection of OpenSSL 1.0.2 through 3.5.x and Android BoringSSL A12-A16\n- **Three Capture Modes**:\n  - `text`: Direct plaintext capture with HTTP/HTTP2 parsing\n  - `pcap`/`pcapng`: Network packet capture with embedded decryption keys\n  - `keylog`/`key`: TLS master secret extraction for external decryption\n- **Hook Points**: `SSL_read`, `SSL_write`, `SSL_do_handshake`, `SSL_get_wbio`, `SSL_in_before`\n- **Connection Tracking**: 4-tuple network tracking via TC and kprobe hooks\n\nSources: [cli/cmd/tls.go:29-48](), [README.md:163-253](), [CHANGELOG.md:14-24]()\n\n### Go TLS Module\n\nThe `gotls` command captures plaintext from Go applications using the standard `crypto/tls` package:\n\n- **Binary Analysis**: Parses Go binary metadata to locate TLS functions\n- **PIE Support**: Handles Position Independent Executables with dynamic offset calculation\n- **ABI Compatibility**: Supports both register-based and stack-based calling conventions\n- **Capture Modes**: Same three modes as OpenSSL (text, pcap, keylog)\n\nSources: [cli/cmd/gotls.go:29-40](), [README.md:254-276](), [CHANGELOG.md:21-29]()\n\n### GnuTLS Module\n\nThe `gnutls` command targets the GnuTLS library used by wget and other applications:\n\n- **Hook Points**: `gnutls_record_recv`, `gnutls_record_send`\n- **Version Support**: GnuTLS 3.x with automatic version detection\n- **Early Secret Support**: Captures TLS 1.3 early secrets for 0-RTT decryption\n- **Capture Modes**: text, pcap, keylog\n\nSources: [cli/cmd/gnutls.go:32-45](), [CHANGELOG.md:126-127]()\n\n### NSPR/NSS Module\n\nThe `nspr` command captures traffic from Firefox, Thunderbird, and other Mozilla applications:\n\n- **Target**: NSPR (Netscape Portable Runtime) library used by NSS\n- **Hook Points**: `PR_Read`, `PR_Write` functions\n- **Application Support**: Firefox browser, Thunderbird email client\n\nSources: [cli/cmd/nspr.go:30-40](), [README.md:158]()\n\n### Bash Module\n\nThe `bash` command provides command-line auditing for Bash shells:\n\n- **Hook Points**: `readline()` function from libreadline\n- **Capture Data**: Command input before execution, return value after execution\n- **Filtering**: Optional errno filtering to capture only failed commands\n- **Auto-detection**: Automatically locates bash binary from `$SHELL` environment\n\nCommand usage:\n```\necapture bash [--bash=/bin/bash] [--errnumber=N]\n```\n\nSources: [cli/cmd/bash.go:27-55](), [README.md:153]()\n\n### Zsh Module\n\nThe `zsh` command provides similar auditing capabilities for Zsh shells:\n\n- **Hook Points**: Zsh-specific readline implementations\n- **Features**: Command capture, return value tracking, errno filtering\n- **Platform Support**: Linux only (excluded from Android builds via build tags)\n\nSources: [cli/cmd/zsh.go:30-57](), [README.md:154](), [CHANGELOG.md:369]()\n\n### MySQL Module\n\nThe `mysqld` command captures SQL queries from MySQL and MariaDB servers:\n\n- **Version Support**: MySQL 5.6, 5.7, 8.0 and MariaDB 10.5+\n- **Hook Points**: `dispatch_command()` function at version-specific offsets\n- **Capture Data**: Full SQL query text with timestamp and connection info\n- **Offset Support**: Manual offset specification for custom builds\n\nCommand usage:\n```\necapture mysqld [--mysqld=/usr/sbin/mysqld] [--funcname=dispatch_command]\n```\n\nSources: [cli/cmd/mysqld.go:30-49](), [README.md:157]()\n\n### PostgreSQL Module\n\nThe `postgres` command provides query auditing for PostgreSQL databases:\n\n- **Version Support**: PostgreSQL 10 and newer\n- **Hook Points**: Query execution functions\n- **Function Customization**: Allows specifying custom function names for different builds\n\nSources: [cli/cmd/postgres.go:30-45](), [README.md:159]()\n\n## Common Module Features\n\nAll capture modules share a common set of capabilities through the eCapture framework:\n\n### Configuration Interface\n\nEach module implements an `IConfig` interface with common parameters:\n\n| Parameter | Flag | Description | Default |\n|-----------|------|-------------|---------|\n| PID Filter | `--pid` | Target specific process ID | All processes |\n| UID Filter | `--uid` | Target specific user ID | All users |\n| Output File | `-l`, `--logaddr` | Save events to file | stdout |\n| Hex Mode | `--hex` | Display data in hexadecimal | false |\n| BTF Mode | `--btf` | Specify BTF bytecode mode | Auto-detect |\n| Map Size | `--mapsize` | eBPF map size in KB | 5120 |\n\nSources: [cli/cmd/tls.go:50-58](), [cli/cmd/gotls.go:42-48]()\n\n### Output Modes\n\nTLS/SSL modules support three output modes controlled by the `-m`/`--model` flag:\n\n1. **Text Mode** (`-m text`): Direct plaintext output with HTTP/HTTP2 parsing\n2. **PCAP Mode** (`-m pcap`): Network packet capture with decryption keys embedded\n3. **Keylog Mode** (`-m keylog`): TLS master secret extraction only\n\nSee [Output Formats](#4) for detailed information on each mode.\n\nSources: [cli/cmd/tls.go:53](), [cli/cmd/gotls.go:45](), [README.md:171-253]()\n\n### Network Integration\n\nTLS/SSL modules can attach TC (Traffic Control) eBPF classifiers for network packet capture:\n\n- **Interface Selection**: `-i`/`--ifname` specifies the network interface\n- **PCAP Filters**: Optional BPF filter expressions (e.g., `tcp port 443`)\n- **Connection Mapping**: Maps network flows to processes via kprobe hooks\n\nSources: [cli/cmd/tls.go:56](), [README.md:180-229]()\n\n## Module Selection and Invocation\n\n```mermaid\nsequenceDiagram\n    participant User\n    participant CLI as \"Cobra CLI\"\n    participant Cmd as \"Command Function\"\n    participant Run as \"runModule()\"\n    participant Registry as \"Module Registry\"\n    participant Module as \"IModule Implementation\"\n    participant eBPF as \"eBPF Manager\"\n    \n    User->>CLI: ecapture tls -m pcap -i eth0\n    CLI->>Cmd: opensslCmd.RunE()\n    Cmd->>Cmd: Parse args into OpensslConfig\n    Cmd->>Run: runModule(ModuleNameOpenssl, oc)\n    Run->>Registry: GetModuleFunc(ModuleNameOpenssl)\n    Registry->>Module: NewOpenSSLProbe(oc)\n    Module->>Module: Init()\n    Module->>eBPF: Load bytecode, attach probes\n    Module->>Module: Start()\n    Module->>Module: Run() - event loop\n    Note over Module: Capture and process events\n    User->>Module: Ctrl+C signal\n    Module->>Module: Close()\n    Module->>eBPF: Detach probes\n    Module-->>User: Cleanup complete\n```\n\n**Module Invocation Flow**: The CLI framework routes subcommands to their respective handler functions, which create module-specific configurations and call `runModule()` to instantiate and execute the appropriate module implementation.\n\nThe module selection process:\n\n1. **CLI Parsing**: User invokes a subcommand (e.g., `ecapture tls`)\n2. **Configuration Creation**: Command handler creates module-specific config object\n3. **Module Instantiation**: `runModule()` looks up the module by name constant\n4. **Lifecycle Execution**: Module progresses through Init → Start → Run → Close phases\n5. **Event Processing**: Module processes events until interrupted\n\nSources: [cli/cmd/tls.go:62-67](), [cli/cmd/gotls.go:52-58](), [main.go:1-11]()\n\n## Module Build Configuration\n\nModules can be conditionally compiled based on platform and feature requirements:\n\n- **Build Tags**: `//go:build !androidgki` excludes modules from Android kernel builds\n- **Platform-Specific**: Some modules (bash, gnutls, nspr, mysqld, postgres, zsh) are Linux-only\n- **Universal Modules**: OpenSSL and GoTLS modules support both Linux and Android\n\nAndroid-excluded modules:\n- GnuTLS: [cli/cmd/gnutls.go:1-2]()\n- NSPR/NSS: [cli/cmd/nspr.go:1-2]()\n- MySQL: [cli/cmd/mysqld.go:1-2]()\n- PostgreSQL: [cli/cmd/postgres.go:1-2]()\n- Zsh: [cli/cmd/zsh.go:1-2]()\n\nSources: [cli/cmd/gnutls.go:1-2](), [cli/cmd/nspr.go:1-2](), [cli/cmd/mysqld.go:1-2](), [cli/cmd/postgres.go:1-2](), [cli/cmd/zsh.go:1-2]()\n\n## Version History and Evolution\n\nRecent module enhancements documented in the changelog:\n\n- **v1.5.0**: OpenSSL 3.5.4 support, Android 16 BoringSSL, HTTP/2 parser improvements\n- **v1.4.0**: WebSocket event forwarding, OpenSSL version downgrade logic\n- **v1.3.0**: GnuTLS early secret support, keylog improvements\n- **v1.2.0**: Dual lifecycle management for event workers\n- **v1.0.0**: Stable release with multi-protocol support\n- **v0.9.0**: Zsh command capture, connection cleanup improvements\n- **v0.7.0**: Module split (OpenSSL/GnuTLS/NSPR separated), keylog mode introduced\n\nSources: [CHANGELOG.md:11-757]()"
          },
          {
            "page_plan": {
              "id": "3.1",
              "title": "TLS/SSL Modules"
            },
            "content": "# TLS/SSL Modules\n\n<details>\n<summary>Relevant source files</summary>\n\nThe following files were used as context for generating this wiki page:\n\n- [CHANGELOG.md](CHANGELOG.md)\n- [README.md](README.md)\n- [README_CN.md](README_CN.md)\n- [cli/cmd/root.go](cli/cmd/root.go)\n- [images/ecapture-help-v0.8.9.svg](images/ecapture-help-v0.8.9.svg)\n- [main.go](main.go)\n- [user/config/iconfig.go](user/config/iconfig.go)\n- [user/module/imodule.go](user/module/imodule.go)\n- [user/module/probe_openssl.go](user/module/probe_openssl.go)\n\n</details>\n\n\n\n## Purpose and Scope\n\nThis document provides an overview of eCapture's TLS/SSL capture modules, which enable plaintext capture of encrypted network traffic without requiring CA certificates or SSL/TLS library modifications. The TLS/SSL modules collectively support multiple encryption libraries including OpenSSL, BoringSSL, GnuTLS, and NSS/NSPR, offering three distinct capture modes: text output, PCAP packet capture, and keylog generation.\n\nFor detailed implementation of specific modules, see:\n- OpenSSL/BoringSSL implementation: [OpenSSL Module](#3.1.1)\n- Go TLS implementation: [Go TLS Module](#3.1.2)\n- GnuTLS and NSS implementations: [GnuTLS and NSS Modules](#3.1.3)\n- Master secret extraction mechanics: [Master Secret Extraction](#3.1.4)\n\nFor network packet capture details, see [Network Packet Capture with TC](#3.3).\n\n---\n\n## Supported TLS/SSL Libraries\n\neCapture supports multiple TLS/SSL library implementations through dedicated modules. Each module uses eBPF uprobes to intercept encryption library functions and extract plaintext data or master secrets.\n\n| Module Name | Supported Libraries | Version Coverage | Platform Support |\n|-------------|-------------------|------------------|------------------|\n| `tls` | OpenSSL, LibreSSL, BoringSSL | OpenSSL 1.0.2 - 3.5.x<br/>BoringSSL Android 12-16 | Linux x86_64/aarch64<br/>Android |\n| `gotls` | Go crypto/tls | Go 1.8+ (all versions) | Linux x86_64/aarch64 |\n| `gnutls` | GnuTLS | 3.x series | Linux x86_64/aarch64 |\n| `nss` | NSS/NSPR (Firefox, Chrome) | NSS 3.x series | Linux x86_64/aarch64 |\n\n**Sources:** [README.md:38-42](), [CHANGELOG.md:202-204](), [cli/cmd/root.go:152-161]()\n\n---\n\n## Capture Modes\n\nAll TLS/SSL modules support three operational modes that determine how captured data is processed and output. The mode is selected via the `-m` command-line flag.\n\n### Capture Mode Comparison\n\n```mermaid\ngraph TB\n    subgraph \"Input: Encrypted TLS Traffic\"\n        APP[\"Application using<br/>OpenSSL/GnuTLS/NSS\"]\n    end\n    \n    subgraph \"eCapture TLS Module\"\n        UPROBE[\"eBPF Uprobes<br/>SSL_read/SSL_write<br/>SSL_do_handshake\"]\n        DETECT[\"Version Detection<br/>Bytecode Selection\"]\n        \n        APP --> UPROBE\n        UPROBE --> DETECT\n    end\n    \n    subgraph \"Capture Mode Selection\"\n        TEXT[\"Text Mode<br/>-m text\"]\n        PCAP[\"PCAP Mode<br/>-m pcap\"]\n        KEYLOG[\"Keylog Mode<br/>-m keylog\"]\n        \n        DETECT --> TEXT\n        DETECT --> PCAP\n        DETECT --> KEYLOG\n    end\n    \n    subgraph \"Output Formats\"\n        TEXT_OUT[\"Console/File<br/>HTTP/HTTP2 Parsed<br/>Direct Plaintext\"]\n        PCAP_OUT[\"PCAP-NG File<br/>Network Packets<br/>+ DSB Key Block\"]\n        KEYLOG_OUT[\"SSLKEYLOGFILE<br/>Master Secrets<br/>CLIENT_RANDOM format\"]\n        \n        TEXT --> TEXT_OUT\n        PCAP --> PCAP_OUT\n        KEYLOG --> KEYLOG_OUT\n    end\n    \n    subgraph \"Use Cases\"\n        TEXT_OUT --> UC1[\"Real-time Monitoring<br/>Security Analysis\"]\n        PCAP_OUT --> UC2[\"Wireshark Analysis<br/>Network Debugging\"]\n        KEYLOG_OUT --> UC3[\"Offline Decryption<br/>tshark Integration\"]\n    end\n```\n\n**Sources:** [user/module/probe_openssl.go:58-76](), [user/config/iconfig.go:73-79](), [README.md:171-252]()\n\n### Mode Configuration Types\n\nThe capture mode is represented by the `TlsCaptureModelType` enumeration:\n\n```go\ntype TlsCaptureModelType uint8\n\nconst (\n    TlsCaptureModelTypePcap   TlsCaptureModelType = iota  // PCAP-NG format\n    TlsCaptureModelTypeText                                // Text output\n    TlsCaptureModelTypeKeylog                             // Keylog format\n)\n```\n\n**Mode Selection Logic:**\n\n1. **Text Mode** (`-m text` or default): Captures plaintext data and outputs directly to console or file. Supports HTTP/1.x and HTTP/2 protocol parsing for structured output.\n\n2. **PCAP Mode** (`-m pcap` or `-m pcapng`): Captures network packets with plaintext payload and master secrets in PCAP-NG format. Requires `-i` (interface) and `--pcapfile` parameters. Supports Wireshark-compatible Decryption Secrets Block (DSB) for automatic decryption.\n\n3. **Keylog Mode** (`-m keylog` or `-m key`): Captures only TLS master secrets in `SSLKEYLOGFILE` format compatible with Wireshark and tshark. Requires `--keylogfile` parameter (default: `ecapture_masterkey.log`).\n\n**Sources:** [user/module/probe_openssl.go:128-154](), [README_CN.md:150-220]()\n\n---\n\n## Architecture Overview\n\n### Module Initialization and Configuration Flow\n\n```mermaid\ngraph TB\n    CLI[\"CLI Entry<br/>cobra.Command<br/>cli/cmd/root.go\"]\n    \n    subgraph \"Configuration Layer\"\n        BASE_CONF[\"BaseConfig<br/>user/config/iconfig.go<br/>Pid, Uid, BTF Mode\"]\n        MOD_CONF[\"OpensslConfig<br/>TlsCaptureModel<br/>PcapFile, KeylogFile\"]\n    end\n    \n    subgraph \"Module Factory\"\n        FACTORY[\"GetModuleFunc()<br/>user/module/imodule.go\"]\n        NEW_OPENSSL[\"NewOpenSSLProbe()<br/>user/module/probe_openssl.go:781\"]\n        NEW_GOTLS[\"NewGoTLSProbe()\"]\n        NEW_GNUTLS[\"NewGnuTLSProbe()\"]\n    end\n    \n    subgraph \"Module Instance: MOpenSSLProbe\"\n        INIT[\"Init()<br/>line 109-176\"]\n        VERSION_DETECT[\"getSslBpfFile()<br/>line 178-278<br/>Version Detection\"]\n        BYTECODE_SELECT[\"Bytecode Selection<br/>sslVersionBpfMap\"]\n        SETUP[\"setupManagers*()<br/>Text/Pcap/Keylog\"]\n    end\n    \n    subgraph \"Runtime Components\"\n        EBPF_MGR[\"ebpfmanager<br/>bpfManager\"]\n        EVENT_PROC[\"EventProcessor<br/>event_processor\"]\n        CONN_TRACK[\"Connection Tracking<br/>pidConns, sock2pidFd\"]\n    end\n    \n    CLI --> BASE_CONF\n    CLI --> MOD_CONF\n    BASE_CONF --> FACTORY\n    MOD_CONF --> FACTORY\n    \n    FACTORY --> NEW_OPENSSL\n    FACTORY --> NEW_GOTLS\n    FACTORY --> NEW_GNUTLS\n    \n    NEW_OPENSSL --> INIT\n    INIT --> VERSION_DETECT\n    VERSION_DETECT --> BYTECODE_SELECT\n    BYTECODE_SELECT --> SETUP\n    \n    SETUP --> EBPF_MGR\n    SETUP --> EVENT_PROC\n    SETUP --> CONN_TRACK\n```\n\n**Sources:** [cli/cmd/root.go:249-403](), [user/module/probe_openssl.go:109-176](), [user/module/imodule.go:47-75]()\n\n### TLS Module State Management\n\nThe `MOpenSSLProbe` struct maintains critical state for TLS capture operations:\n\n**Key Data Structures:**\n\n| Field | Type | Purpose |\n|-------|------|---------|\n| `pidConns` | `map[uint32]map[uint32]ConnInfo` | Tracks connections by PID and file descriptor |\n| `sock2pidFd` | `map[uint64][2]uint32` | Reverse lookup from socket to PID/FD for cleanup |\n| `masterKeys` | `map[string]bool` | Deduplicates master secrets by client random |\n| `eBPFProgramType` | `TlsCaptureModelType` | Active capture mode (Text/Pcap/Keylog) |\n| `sslVersionBpfMap` | `map[string]string` | Maps SSL versions to eBPF bytecode files |\n| `isBoringSSL` | `bool` | Indicates BoringSSL library detection |\n\n**Connection Tracking Operations:**\n\n- `AddConn(pid, fd, tuple, sock)`: Registers new connection from TC hook or connect syscall\n- `GetConn(pid, fd)`: Retrieves connection tuple for data event correlation\n- `DelConn(sock)`: Schedules connection cleanup after 3-second delay\n- `DestroyConn(sock)`: Immediately removes connection from tracking maps\n\n**Sources:** [user/module/probe_openssl.go:83-106](), [user/module/probe_openssl.go:398-481]()\n\n---\n\n## Version Detection and Bytecode Selection\n\neCapture automatically detects the SSL/TLS library version and selects appropriate eBPF bytecode to handle version-specific structure layouts.\n\n### Version Detection Flow\n\n```mermaid\nflowchart TD\n    START[\"Start Capture<br/>tls/gotls/gnutls/nss\"]\n    \n    DETECT_LIB[\"Detect Library Path<br/>/etc/ld.so.conf<br/>--libssl flag\"]\n    \n    PARSE_ELF[\"Parse ELF Binary<br/>detectOpenssl()<br/>probe_openssl.go:line 207\"]\n    \n    CHECK_VER{\"Version String<br/>Found?\"}\n    \n    TRY_CRYPTO[\"Try libcrypto.so<br/>if libssl.so.3<br/>getImpNeeded()\"]\n    \n    MAP_LOOKUP[\"Lookup in sslVersionBpfMap<br/>map[version]bytecode\"]\n    \n    FOUND{\"Bytecode<br/>Exists?\"}\n    \n    AUTO_DETECT[\"autoDetectBytecode()<br/>Try versions in order<br/>line 273\"]\n    \n    DEFAULT[\"Use Default Version<br/>linux_default_3_0\"]\n    \n    LOAD_BPF[\"Load eBPF Bytecode<br/>assets.Asset(filename)\"]\n    \n    INIT_MANAGER[\"Initialize bpfManager<br/>InitWithOptions()\"]\n    \n    START --> DETECT_LIB\n    DETECT_LIB --> PARSE_ELF\n    PARSE_ELF --> CHECK_VER\n    \n    CHECK_VER -->|No| TRY_CRYPTO\n    CHECK_VER -->|Yes| MAP_LOOKUP\n    TRY_CRYPTO --> MAP_LOOKUP\n    \n    MAP_LOOKUP --> FOUND\n    FOUND -->|Yes| LOAD_BPF\n    FOUND -->|No| AUTO_DETECT\n    AUTO_DETECT --> DEFAULT\n    DEFAULT --> LOAD_BPF\n    \n    LOAD_BPF --> INIT_MANAGER\n```\n\n**Sources:** [user/module/probe_openssl.go:178-278](), [user/module/probe_openssl.go:280-350]()\n\n### Bytecode Naming Convention\n\neBPF bytecode files are named according to a specific pattern that encodes version, kernel compatibility, and CO-RE mode:\n\n**Pattern:** `<library>_<version>_kern[_core|_noncore][_less52].o`\n\n**Examples:**\n- `openssl_3_0_0_kern_core.o` - OpenSSL 3.0.x, CO-RE mode, kernel ≥5.2\n- `openssl_1_1_1_kern_noncore.o` - OpenSSL 1.1.x, non-CO-RE, kernel ≥5.2\n- `boringssl_a_14_kern_core_less52.o` - BoringSSL Android 14, CO-RE, kernel <5.2\n\n**Version Map Initialization:**\n\nThe `initOpensslOffset()` method populates `sslVersionBpfMap` with mappings like:\n\n```\n\"openssl 1.1.1a\" -> \"openssl_1_1_1_kern.o\"\n\"openssl 3.0.0\"  -> \"openssl_3_0_0_kern.o\"\n\"boringssl\"      -> \"boringssl_a_13_kern.o\"\n```\n\n**Sources:** [user/module/imodule.go:191-214](), [CHANGELOG.md:14-24]()\n\n---\n\n## Module Variants\n\n### OpenSSL/BoringSSL Module (`tls`)\n\n**Primary Implementation:** `MOpenSSLProbe` in [user/module/probe_openssl.go]()\n\n**Supported Versions:**\n- OpenSSL: 1.0.2 through 3.5.x\n- BoringSSL: Android 12 (A12) through Android 16 (A16)\n- LibreSSL: Compatible versions\n\n**Key Hook Points:**\n- `SSL_read` / `SSL_write` - Data capture\n- `SSL_do_handshake` - Master secret extraction (OpenSSL)\n- `SSL_get_wbio` - Bio/FD correlation\n- `SSL_in_before` / `SSL_state` - Handshake state (version dependent)\n\n**BoringSSL Specifics:**\n- Uses `SSL_get_session` for master secret extraction\n- Android version detection via `--androidver` flag\n- Special offset handling for Android 12-16 variants\n\n**Sources:** [user/module/probe_openssl.go:83-106](), [CHANGELOG.md:305-309](), [README.md:163-169]()\n\n### Go TLS Module (`gotls`)\n\n**Primary Implementation:** `MGoTLSProbe` (referenced but not in provided files)\n\n**Capabilities:**\n- Go binary analysis for TLS structure offsets\n- PIE (Position Independent Executable) support\n- Register vs Stack ABI detection\n- Automatic `crypto/tls` version compatibility\n\n**Hook Strategy:**\n- `crypto/tls.(*Conn).Read` / `Write` for data\n- `crypto/tls.(*Conn).handshakeContext` for keys\n- Structure offset calculation from Go debug info\n\n**Limitations:**\n- Requires debug symbols or known Go version\n- May need `--elfpath` parameter for stripped binaries\n\n**Sources:** [README.md:254-276](), [cli/cmd/root.go:156]()\n\n### GnuTLS Module (`gnutls`)\n\n**Support Status:** Full capture support including keylog mode as of v1.3.0\n\n**Hook Functions:**\n- `gnutls_record_send` / `gnutls_record_recv` - Data capture\n- `gnutls_handshake` - Master secret extraction\n- Early secret support for TLS 1.3\n\n**Output Modes:** Text, PCAP, Keylog (added in v1.3.0)\n\n**Sources:** [README.md:155](), [CHANGELOG.md:126-127]()\n\n### NSS/NSPR Module (`nss`)\n\n**Target Applications:**\n- Firefox browser\n- Chrome/Chromium (when built with NSS)\n- Applications using NSS crypto library\n\n**Hook Functions:**\n- `PR_Read` / `PR_Write` (NSPR layer)\n- `SSL_ImportFD` - Session initialization\n- NSS-specific handshake functions\n\n**Considerations:**\n- May require special handling for `libnss3.so` path detection\n- Chrome may use BoringSSL instead of NSS on some platforms\n\n**Sources:** [README.md:158](), [CHANGELOG.md:402]()\n\n---\n\n## Key Capabilities\n\n### 1. Master Secret Extraction\n\nAll TLS/SSL modules extract master secrets for both TLS 1.2 and TLS 1.3 protocols:\n\n**TLS 1.2:**\n- Client Random (32 bytes)\n- Master Secret (48 bytes)\n- Output format: `CLIENT_RANDOM <random> <master_key>`\n\n**TLS 1.3:**\n- Client Random (32 bytes)\n- Handshake Secret\n- Client/Server Handshake Traffic Secrets\n- Client/Server Application Traffic Secrets\n- Exporter Secret\n- HKDF derivation using SHA256/SHA384\n\n**Secret Storage:**\n- Deduplication via `masterKeys` map keyed by client random\n- Format compatible with `SSLKEYLOGFILE` environment variable\n- Can be used with Wireshark's \"Pre-Master-Secret log filename\" setting\n\n**Sources:** [user/module/probe_openssl.go:482-642](), [README.md:234-247]()\n\n### 2. Protocol Parsing\n\n**Text Mode HTTP Support:**\n\nThe modules include built-in HTTP/1.x and HTTP/2 protocol parsers:\n\n- HTTP/1.x: Request/response parsing with headers and body\n- HTTP/2: Frame parsing including HEADERS, DATA, SETTINGS, PING\n- HPACK header decompression for HTTP/2\n- Automatic content-type detection and display\n\n**Sources:** [CHANGELOG.md:487](), [cli/cmd/root.go:152]()\n\n### 3. Multi-Architecture Support\n\n**Supported Platforms:**\n- Linux x86_64: Kernel 4.18+\n- Linux aarch64: Kernel 5.5+\n- Android x86_64: Android 12+\n- Android aarch64: Android 12+\n\n**Cross-Compilation:**\n- Dual-mode bytecode (CO-RE and non-CO-RE) in single binary\n- Automatic BTF detection and mode selection\n- Kernel version-specific bytecode variants (<5.2)\n\n**Sources:** [README.md:14-16](), [CHANGELOG.md:553-561]()\n\n### 4. Filtering and Targeting\n\n**Process Filtering:**\n- `--pid` flag: Target specific process ID\n- `--uid` flag: Target specific user ID\n- Default: Capture all processes/users\n\n**Network Filtering (PCAP mode):**\n- PCAP filter expression support (tcpdump syntax)\n- Example: `tcp port 443`\n- Applied via TC eBPF program instruction patching\n\n**Sources:** [user/module/probe_openssl.go:361-387](), [README.md:183-184]()\n\n### 5. Connection Lifecycle Tracking\n\n**4-Tuple Generation:**\n\nThe modules track network connections using 4-tuple information:\n- Source IP:Port\n- Destination IP:Port\n- IPv4 and IPv6 support\n\n**Tracking Mechanism:**\n1. TC hook captures packets and generates 4-tuple\n2. Kprobe on `tcp_sendmsg` / `__sys_connect` associates socket with PID/FD\n3. SSL data events correlate with tuple via `pidConns` map\n4. Connection cleanup on socket destroy or process exit\n\n**Delayed Cleanup:**\n- 3-second delay via `time.AfterFunc()` to handle race conditions\n- Prevents premature deletion while events are in-flight\n- Coordinated with EventProcessor merge interval\n\n**Sources:** [user/module/probe_openssl.go:398-462](), [CHANGELOG.md:306-309]()\n\n---\n\n## Configuration Parameters\n\n### Common TLS Module Flags\n\n| Flag | Type | Default | Description |\n|------|------|---------|-------------|\n| `-m, --model` | string | `text` | Capture mode: text/pcap/pcapng/keylog/key |\n| `--libssl` | string | auto-detect | Path to SSL library or statically linked binary |\n| `--pcapfile` | string | `ecapture_openssl.pcapng` | PCAP output file (pcap mode) |\n| `--keylogfile` | string | `ecapture_masterkey.log` | Keylog output file (keylog mode) |\n| `-i, --ifname` | string | - | Network interface (pcap mode, required) |\n| `--pid` | uint64 | 0 | Target process ID (0 = all) |\n| `--uid` | uint64 | 0 | Target user ID (0 = all) |\n| `-b, --btf` | uint8 | 0 | BTF mode: 0=auto, 1=core, 2=non-core |\n\n### Android-Specific Flags\n\n| Flag | Type | Description |\n|------|------|-------------|\n| `--android` | bool | Enable Android/BoringSSL mode |\n| `--androidver` | string | Android version (12-16) for bytecode selection |\n\n**Sources:** [user/config/iconfig.go:73-93](), [cli/cmd/root.go:140-152]()\n\n---\n\n## Output Examples\n\n### Text Mode Output\n\n```\nUUID:233479_233479_curl_5_1_39.156.66.10:443, Name:HTTPRequest, Type:1, Length:73\nGET / HTTP/1.1\nHost: baidu.com\nAccept: */*\nUser-Agent: curl/7.81.0\n```\n\n**UUID Format:** `<pid>_<tid>_<comm>_<fd>_<direction>_<tuple>`\n\n**Sources:** [README_CN.md:103-125]()\n\n### PCAP Mode Output\n\n- File format: PCAP-NG\n- Contains: Network packets with plaintext payload\n- Decryption Secrets Block (DSB): Embedded master secrets\n- Compatible with: Wireshark, tshark, tcpdump\n\n**Sources:** [README.md:187-232]()\n\n### Keylog Mode Output\n\n```\nCLIENT_RANDOM 5a6f2b3c... 1d8e9f0a...\nCLIENT_HANDSHAKE_TRAFFIC_SECRET 5a6f2b3c... 8c7d6e5f...\nSERVER_HANDSHAKE_TRAFFIC_SECRET 5a6f2b3c... 3b2a1c0d...\nCLIENT_TRAFFIC_SECRET_0 5a6f2b3c... f9e8d7c6...\nSERVER_TRAFFIC_SECRET_0 5a6f2b3c... b5a49382...\nEXPORTER_SECRET 5a6f2b3c... 71625348...\n```\n\n**Usage with tshark:**\n```bash\ntshark -o tls.keylog_file:ecapture_masterkey.log -Y http -T fields -e http.file_data -f \"port 443\" -i eth0\n```\n\n**Sources:** [README.md:239-247](), [user/module/probe_openssl.go:492-554]()"
          },
          {
            "page_plan": {
              "id": "3.1.1",
              "title": "OpenSSL Module"
            },
            "content": "# OpenSSL Module\n\n<details>\n<summary>Relevant source files</summary>\n\nThe following files were used as context for generating this wiki page:\n\n- [cli/cmd/root.go](cli/cmd/root.go)\n- [kern/boringssl_const.h](kern/boringssl_const.h)\n- [kern/boringssl_masterkey.h](kern/boringssl_masterkey.h)\n- [kern/openssl_masterkey.h](kern/openssl_masterkey.h)\n- [kern/openssl_masterkey_3.0.h](kern/openssl_masterkey_3.0.h)\n- [user/config/iconfig.go](user/config/iconfig.go)\n- [user/module/imodule.go](user/module/imodule.go)\n- [user/module/probe_openssl.go](user/module/probe_openssl.go)\n- [user/module/probe_openssl_lib.go](user/module/probe_openssl_lib.go)\n- [utils/boringssl-offset.c](utils/boringssl-offset.c)\n- [variables.mk](variables.mk)\n\n</details>\n\n\n\nThe OpenSSL Module captures SSL/TLS plaintext traffic and master secrets from applications using OpenSSL or BoringSSL libraries. It supports multiple capture modes (text, pcap, keylog) and handles both TLS 1.2 and TLS 1.3 protocols across a wide range of library versions.\n\nFor information about other TLS/SSL modules, see Go TLS Module [3.1.2](#3.1.2) and GnuTLS/NSS modules [3.1.3](#3.1.3). For details on master secret extraction techniques, see [3.1.4](#3.1.4).\n\n---\n\n## Architecture Overview\n\nThe OpenSSL module consists of three primary subsystems: version detection and bytecode selection, eBPF probes for data capture, and userspace processing for output generation.\n\n### Core Components\n\n```mermaid\ngraph TB\n    subgraph \"Module Initialization\"\n        INIT[MOpenSSLProbe.Init]\n        CONFIG[OpensslConfig]\n        DETECT[detectOpenssl]\n        SELECT[getSslBpfFile]\n    end\n    \n    subgraph \"Version to Bytecode Mapping\"\n        VMAP[sslVersionBpfMap]\n        BYTECODE[\"Bytecode Selection<br/>openssl_X_X_X_kern.o<br/>boringssl_a_XX_kern.o\"]\n    end\n    \n    subgraph \"eBPF Probes\"\n        HOOKS[\"Function Hooks<br/>SSL_write/SSL_read<br/>SSL_do_handshake<br/>SSL_get_wbio\"]\n        MASTERKEY[\"Master Key Hook<br/>probe_ssl_master_key\"]\n        TC[\"TC Hooks<br/>Packet Capture\"]\n    end\n    \n    subgraph \"Data Structures\"\n        PIDCONNS[\"pidConns<br/>map[pid]map[fd]ConnInfo\"]\n        SOCK2PID[\"sock2pidFd<br/>map[sock][pid,fd]\"]\n        MASTERKEYS[\"masterKeys<br/>Deduplication Map\"]\n    end\n    \n    subgraph \"Output Processing\"\n        TEXT[\"Text Mode<br/>dumpSslData\"]\n        PCAP[\"PCAP Mode<br/>dumpTcSkb\"]\n        KEYLOG[\"Keylog Mode<br/>saveMasterSecret\"]\n    end\n    \n    INIT --> CONFIG\n    INIT --> DETECT\n    DETECT --> VMAP\n    VMAP --> SELECT\n    SELECT --> BYTECODE\n    \n    BYTECODE --> HOOKS\n    BYTECODE --> MASTERKEY\n    BYTECODE --> TC\n    \n    HOOKS --> PIDCONNS\n    TC --> SOCK2PID\n    MASTERKEY --> MASTERKEYS\n    \n    PIDCONNS --> TEXT\n    PIDCONNS --> PCAP\n    MASTERKEYS --> KEYLOG\n    MASTERKEYS --> PCAP\n    \n    style VMAP fill:#f9f9f9\n    style BYTECODE fill:#f9f9f9\n    style PIDCONNS fill:#f9f9f9\n```\n\n**MOpenSSLProbe Structure**: The main module struct `MOpenSSLProbe` embeds `MTCProbe` (for TC-based packet capture) and maintains several critical data structures for connection tracking and key management.\n\nSources: [user/module/probe_openssl.go:83-106]()\n\n---\n\n## Supported Library Versions\n\nThe module supports an extensive range of OpenSSL and BoringSSL versions through version-specific bytecode variants.\n\n### Version Support Matrix\n\n| Library | Version Range | Bytecode Files | Notes |\n|---------|--------------|----------------|-------|\n| OpenSSL | 1.0.2a-1.0.2u | `openssl_1_0_2a_kern.o` | Requires `SSL_state` hook |\n| OpenSSL | 1.1.0a-1.1.0l | `openssl_1_1_0a_kern.o` | Standard hooks |\n| OpenSSL | 1.1.1a-1.1.1w | `openssl_1_1_1{a,b,d,j}_kern.o` | Four offset groups |\n| OpenSSL | 3.0.0-3.0.17 | `openssl_3_0_{0,12}_kern.o` | 3.0.12 has unique offsets |\n| OpenSSL | 3.1.0-3.1.8 | `openssl_3_1_0_kern.o` | Shares offsets with 3.0 |\n| OpenSSL | 3.2.0-3.2.5 | `openssl_3_2_{0,3,4}_kern.o` | Three offset variants |\n| OpenSSL | 3.3.0-3.3.4 | `openssl_3_3_{0,2,3}_kern.o` | Three offset variants |\n| OpenSSL | 3.4.0-3.4.2 | `openssl_3_4_{0,1}_kern.o` | Two offset variants |\n| OpenSSL | 3.5.0-3.5.4 | `openssl_3_5_0_kern.o` | Latest supported |\n| BoringSSL | Android 12-16 | `boringssl_a_{13,14,15,16}_kern.o` | Android-specific |\n| BoringSSL | Non-Android | `boringssl_na_kern.o` | General BoringSSL |\n\nThe version mapping is initialized in `initOpensslOffset()` which populates the `sslVersionBpfMap` with version-to-bytecode mappings.\n\nSources: [user/module/probe_openssl_lib.go:73-187](), [variables.mk:190-213]()\n\n---\n\n## Version Detection Mechanism\n\nVersion detection is a critical phase that determines which eBPF bytecode to load for proper structure offset handling.\n\n### Detection Flow\n\n```mermaid\nflowchart TD\n    START[\"Start: getSslBpfFile<br/>soPath, sslVersion\"]\n    \n    CHECK_PARAM{\"sslVersion<br/>parameter set?\"}\n    USE_PARAM[\"Use provided version<br/>lookup in sslVersionBpfMap\"]\n    \n    DETECT[\"detectOpenssl(soPath)<br/>Parse ELF .rodata section\"]\n    \n    REGEX[\"Regex match:<br/>'OpenSSL \\\\d\\\\.\\\\d\\\\.[0-9a-z]+'\"]\n    \n    FOUND{\"Version string<br/>found?\"}\n    \n    ANDROID{\"isAndroid<br/>flag?\"}\n    \n    ANDROID_VER[\"Use androidVer parameter<br/>boringssl_a_{ver}\"]\n    DEFAULT_ANDROID[\"Default: boringssl_a_13\"]\n    \n    DOWNGRADE[\"downgradeOpensslVersion<br/>Find closest match\"]\n    \n    DEFAULT_LINUX[\"Default based on soPath:<br/>libssl.so.3 → openssl_3_0_0<br/>other → openssl_1_1_1j\"]\n    \n    ADJUST_HOOKS[\"Adjust masterHookFuncs<br/>OpenSSL 1.0.x: SSL_state<br/>BoringSSL: specific hook\"]\n    \n    RETURN[\"Return bytecode filename\"]\n    \n    START --> CHECK_PARAM\n    CHECK_PARAM -->|Yes| USE_PARAM\n    CHECK_PARAM -->|No| DETECT\n    \n    USE_PARAM --> ADJUST_HOOKS\n    \n    DETECT --> REGEX\n    REGEX --> FOUND\n    \n    FOUND -->|Yes| ANDROID\n    FOUND -->|No| ANDROID\n    \n    ANDROID -->|Yes, with androidVer| ANDROID_VER\n    ANDROID -->|Yes, no androidVer| DEFAULT_ANDROID\n    ANDROID -->|No| DOWNGRADE\n    \n    ANDROID_VER --> ADJUST_HOOKS\n    DEFAULT_ANDROID --> ADJUST_HOOKS\n    \n    DOWNGRADE -->|Match found| ADJUST_HOOKS\n    DOWNGRADE -->|No match| DEFAULT_LINUX\n    DEFAULT_LINUX --> ADJUST_HOOKS\n    \n    ADJUST_HOOKS --> RETURN\n```\n\n**ELF Parsing**: The `detectOpenssl()` function opens the shared library as an ELF file and searches the `.rodata` section for the OpenSSL version string using regex pattern `(OpenSSL\\s\\d\\.\\d\\.[0-9a-z]+)`.\n\n**Fallback Strategy**: When version detection fails, the module attempts progressively:\n1. Check for `libcrypto.so.3` if `libssl.so.3` doesn't contain version info\n2. Use Android-specific bytecode if `isAndroid` flag is set\n3. Apply `downgradeOpensslVersion()` to find closest matching version\n4. Fall back to default bytecode based on library path\n\n**Special Cases**:\n- OpenSSL 1.0.x requires using `SSL_state` hook instead of `SSL_in_before` (a macro)\n- OpenSSL 3.0.12 has unique offsets different from 3.0.0-3.0.11 and 3.0.13-3.0.17\n- BoringSSL version is often \"1.1.1\" but requires Android version-specific bytecode\n\nSources: [user/module/probe_openssl.go:179-278](), [user/module/probe_openssl_lib.go:189-282](), [user/module/probe_openssl_lib.go:284-369]()\n\n---\n\n## Hook Points and eBPF Probes\n\nThe module attaches uprobes to strategic SSL/TLS library functions to intercept plaintext data and master secrets.\n\n### Primary Hook Functions\n\n```mermaid\ngraph TB\n    subgraph \"SSL/TLS Functions\"\n        SSL_WRITE[\"SSL_write<br/>Captures outbound data\"]\n        SSL_READ[\"SSL_read<br/>Captures inbound data\"]\n        SSL_HANDSHAKE[\"SSL_do_handshake<br/>Tracks handshake state\"]\n        SSL_WBIO[\"SSL_get_wbio<br/>Extracts file descriptor\"]\n    end\n    \n    subgraph \"Master Key Functions\"\n        SSL_STATE[\"SSL_in_before / SSL_state<br/>Master key extraction point\"]\n        BORING_HOOK[\"tls13_advance_key_schedule<br/>BoringSSL specific\"]\n    end\n    \n    subgraph \"eBPF Programs\"\n        DATA_PROBE[\"uprobe/uprobe_ssl_write<br/>uprobe/uprobe_ssl_read<br/>Extracts plaintext\"]\n        KEY_PROBE[\"uprobe/SSL_write_key<br/>probe_ssl_master_key<br/>Extracts secrets\"]\n    end\n    \n    subgraph \"Data Captured\"\n        PLAINTEXT[\"SSLDataEvent<br/>pid, fd, data, length\"]\n        KEYS[\"MasterSecretEvent<br/>MasterSecretBSSLEvent<br/>client_random, secrets\"]\n    end\n    \n    SSL_WRITE --> DATA_PROBE\n    SSL_READ --> DATA_PROBE\n    SSL_HANDSHAKE --> DATA_PROBE\n    SSL_WBIO --> DATA_PROBE\n    \n    SSL_STATE --> KEY_PROBE\n    BORING_HOOK --> KEY_PROBE\n    \n    DATA_PROBE --> PLAINTEXT\n    KEY_PROBE --> KEYS\n    \n    style DATA_PROBE fill:#e8f5e9\n    style KEY_PROBE fill:#fff3e0\n```\n\n**Data Capture Hooks**: The probes on `SSL_write` and `SSL_read` capture plaintext data before encryption and after decryption. The `SSL_get_wbio` hook extracts the underlying socket file descriptor for connection tracking.\n\n**Master Key Hooks**: The hook point for master secret extraction varies by library:\n- **OpenSSL 1.1.0+**: `SSL_in_before` function\n- **OpenSSL 1.0.x**: `SSL_state` function (since `SSL_in_before` is a macro)\n- **BoringSSL**: `tls13_advance_key_schedule` function\n\nThe list of master key hook functions is configured in `masterHookFuncs` array and adjusted during initialization based on detected version.\n\nSources: [user/module/probe_openssl.go:104](), [user/module/probe_openssl.go:179-196](), [kern/openssl_masterkey.h:80-257](), [kern/boringssl_masterkey.h:169-403]()\n\n---\n\n## Connection Tracking System\n\nThe module maintains bidirectional mappings between processes, file descriptors, and network sockets to associate captured data with connections.\n\n### Connection Tracking Data Structures\n\n```mermaid\ngraph TB\n    subgraph \"Connection Event Flow\"\n        TC_HOOK[\"TC Classifier<br/>Captures packets + tuples\"]\n        SSL_BIO[\"SSL_get_wbio Hook<br/>Extracts fd from SSL*\"]\n        CONN_EVENT[\"ConnDataEvent<br/>pid, fd, tuple, sock\"]\n    end\n    \n    subgraph \"Tracking Maps (Userspace)\"\n        PIDCONNS[\"pidConns<br/>map[uint32]map[uint32]ConnInfo<br/>Key: PID → FD<br/>Value: {tuple, sock}\"]\n        \n        SOCK2PID[\"sock2pidFd<br/>map[uint64][2]uint32<br/>Key: sock<br/>Value: [pid, fd]\"]\n    end\n    \n    subgraph \"Operations\"\n        ADD[\"AddConn(pid, fd, tuple, sock)<br/>Bidirectional insert\"]\n        GET[\"GetConn(pid, fd)<br/>→ *ConnInfo\"]\n        DEL[\"DelConn(sock)<br/>Delayed 3s deletion\"]\n        DESTROY[\"DestroyConn(sock)<br/>Immediate cleanup\"]\n    end\n    \n    subgraph \"Data Correlation\"\n        SSL_DATA[\"SSLDataEvent<br/>pid, fd, data\"]\n        LOOKUP[\"GetConn(pid, fd)\"]\n        ENRICHED[\"Enriched Event<br/>pid, fd, tuple, sock, data\"]\n    end\n    \n    TC_HOOK --> CONN_EVENT\n    SSL_BIO --> CONN_EVENT\n    \n    CONN_EVENT --> ADD\n    ADD --> PIDCONNS\n    ADD --> SOCK2PID\n    \n    SSL_DATA --> LOOKUP\n    LOOKUP --> PIDCONNS\n    PIDCONNS --> GET\n    GET --> ENRICHED\n    \n    SOCK2PID --> DEL\n    DEL --> DESTROY\n    DESTROY --> PIDCONNS\n    \n    style PIDCONNS fill:#e3f2fd\n    style SOCK2PID fill:#f3e5f5\n```\n\n**ConnInfo Structure**: Each connection is represented by a `ConnInfo` struct containing the network 4-tuple (src/dst IP:port) and socket pointer.\n\n**Bidirectional Lookup**: \n- `pidConns`: Maps `(pid, fd)` → `ConnInfo` for enriching SSL data events\n- `sock2pidFd`: Maps `sock` → `(pid, fd)` for connection cleanup when socket closes\n\n**Lifecycle Management**:\n- **AddConn**: Called when TC hook or SSL_get_wbio captures connection metadata\n- **GetConn**: Retrieves tuple for a given `(pid, fd)` pair when processing SSL data\n- **DelConn**: Schedules delayed deletion (3 seconds) to allow event processing to complete\n- **DestroyConn**: Performs actual cleanup, notifies event processor\n\nThe 3-second delay in `DelConn` ensures that any in-flight events can still be correlated before the connection metadata is removed.\n\nSources: [user/module/probe_openssl.go:78-81](), [user/module/probe_openssl.go:91-94](), [user/module/probe_openssl.go:398-481](), [user/module/probe_openssl.go:756-775]()\n\n---\n\n## Master Secret Extraction\n\nMaster secrets enable decryption of captured TLS traffic. The extraction technique differs between TLS 1.2 and TLS 1.3 due to different key derivation mechanisms.\n\n### TLS 1.2 Master Secret Extraction\n\n```mermaid\ngraph TB\n    ENTRY[\"probe_ssl_master_key<br/>Parameter: ssl_st*\"]\n    \n    CHECK_VER{\"version ==<br/>TLS1_3_VERSION?\"}\n    \n    TLS12[\"TLS 1.2 Path\"]\n    \n    GET_S3[\"Get ssl_st->s3<br/>ssl3_state_st*\"]\n    \n    GET_CLIENT_RANDOM[\"Read client_random<br/>32 bytes from s3\"]\n    \n    GET_SESSION[\"Get ssl_st->session or<br/>s3->hs->new_session<br/>ssl_session_st*\"]\n    \n    READ_MASTER_KEY[\"Read master_key<br/>from ssl_session_st<br/>48 bytes\"]\n    \n    OUTPUT_TLS12[\"Output MasterSecretEvent<br/>version, client_random,<br/>master_key\"]\n    \n    ENTRY --> CHECK_VER\n    CHECK_VER -->|No| TLS12\n    TLS12 --> GET_S3\n    GET_S3 --> GET_CLIENT_RANDOM\n    GET_CLIENT_RANDOM --> GET_SESSION\n    GET_SESSION --> READ_MASTER_KEY\n    READ_MASTER_KEY --> OUTPUT_TLS12\n```\n\n**TLS 1.2 Structure Navigation** (OpenSSL):\n1. `ssl_st->s3` → `ssl3_state_st*`\n2. `ssl3_state_st->client_random` (32 bytes)\n3. `ssl_st->session` → `ssl_session_st*`\n4. `ssl_session_st->master_key` (48 bytes)\n\n**TLS 1.2 Structure Navigation** (BoringSSL):\n1. `ssl_st->s3` → `bssl::SSL3_STATE*`\n2. `ssl3_state->client_random` (32 bytes)\n3. `ssl3_state->hs` → `bssl::SSL_HANDSHAKE*`\n4. `ssl_handshake->new_session` or `ssl_st->session` → `ssl_session_st*`\n5. `ssl_session_st->secret` and `ssl_session_st->secret_length`\n\nThe handshake state is checked to ensure the handshake is complete (`state >= CLIENT_STATE12_SEND_CLIENT_FINISHED` for BoringSSL).\n\nSources: [kern/openssl_masterkey.h:82-169](), [kern/boringssl_masterkey.h:170-342](), [kern/openssl_masterkey_3.0.h:82-165]()\n\n### TLS 1.3 Master Secret Extraction\n\nTLS 1.3 uses multiple derived secrets instead of a single master key. The extraction is more complex:\n\n```mermaid\ngraph TB\n    ENTRY[\"probe_ssl_master_key<br/>Parameter: ssl_st*\"]\n    \n    CHECK_VER{\"version ==<br/>TLS1_3_VERSION?\"}\n    \n    TLS13[\"TLS 1.3 Path\"]\n    \n    GET_CIPHER[\"Get cipher_id from<br/>ssl_session_st->cipher or<br/>ssl_session_st->cipher_id\"]\n    \n    DETERMINE_HASH[\"Determine hash algorithm:<br/>TLS_AES_128_GCM_SHA256 → SHA256 (32 bytes)<br/>TLS_AES_256_GCM_SHA384 → SHA384 (48 bytes)<br/>TLS_CHACHA20_POLY1305_SHA256 → SHA256\"]\n    \n    READ_SECRETS[\"Read multiple secrets from ssl_st:<br/>early_secret<br/>handshake_secret<br/>handshake_traffic_hash<br/>client_app_traffic_secret<br/>server_app_traffic_secret<br/>exporter_master_secret\"]\n    \n    DERIVE[\"Derive handshake secrets:<br/>client_handshake = HKDF-Expand(handshake_secret)<br/>server_handshake = HKDF-Expand(handshake_secret)\"]\n    \n    OUTPUT_TLS13[\"Output MasterSecretEvent<br/>version, cipher_id, client_random<br/>+ 6 derived secrets\"]\n    \n    ENTRY --> CHECK_VER\n    CHECK_VER -->|Yes| TLS13\n    TLS13 --> GET_CIPHER\n    GET_CIPHER --> DETERMINE_HASH\n    DETERMINE_HASH --> READ_SECRETS\n    READ_SECRETS --> DERIVE\n    DERIVE --> OUTPUT_TLS13\n```\n\n**TLS 1.3 Structure Navigation** (OpenSSL):\n1. `ssl_st->s3->client_random` (32 bytes) - OpenSSL 3.0+ has client_random directly in ssl_st\n2. `ssl_st->session->cipher->id` → cipher suite ID\n3. From `ssl_st`, read multiple secrets (each up to 64 bytes):\n   - `early_secret` (offset `SSL_ST_EARLY_SECRET`)\n   - `handshake_secret` (offset `SSL_ST_HANDSHAKE_SECRET`)\n   - `handshake_traffic_hash` (offset `SSL_ST_HANDSHAKE_TRAFFIC_HASH`)\n   - `client_app_traffic_secret` (offset `SSL_ST_CLIENT_APP_TRAFFIC_SECRET`)\n   - `server_app_traffic_secret` (offset `SSL_ST_SERVER_APP_TRAFFIC_SECRET`)\n   - `exporter_master_secret` (offset `SSL_ST_EXPORTER_MASTER_SECRET`)\n\n**TLS 1.3 Structure Navigation** (BoringSSL):\n1. `ssl_st->s3->client_random` from `bssl::SSL3_STATE`\n2. `ssl_st->s3->hs->hash_len` for secret length\n3. `ssl_st->s3->hs->client_version` to verify TLS 1.3\n4. Check handshake state: `tls13_state >= CLIENT_STATE13_READ_SERVER_FINISHED`\n5. From `ssl_handshake`, read private member secrets (calculated offsets):\n   - `early_traffic_secret_` (offset `SSL_HANDSHAKE_EARLY_TRAFFIC_SECRET_`)\n   - `client_handshake_secret_` (offset `SSL_HANDSHAKE_CLIENT_HANDSHAKE_SECRET_`)\n   - `server_handshake_secret_` (offset `SSL_HANDSHAKE_SERVER_HANDSHAKE_SECRET_`)\n   - `client_traffic_secret_0_` (offset `SSL_HANDSHAKE_CLIENT_TRAFFIC_SECRET_0_`)\n   - `server_traffic_secret_0_` (offset `SSL_HANDSHAKE_SERVER_TRAFFIC_SECRET_0_`)\n6. From `ssl_st->s3`, read:\n   - `exporter_secret` (offset `BSSL__SSL3_STATE_EXPORTER_SECRET`)\n\n**HKDF Derivation**: For OpenSSL TLS 1.3, the handshake traffic secrets must be derived using HKDF-Expand-Label in userspace since OpenSSL stores only the base `handshake_secret`. The derivation uses labels \"c hs traffic\" and \"s hs traffic\" with the handshake transcript hash.\n\n**BoringSSL Private Members**: BoringSSL stores TLS 1.3 secrets as private members in the `SSL_HANDSHAKE` struct. The offsets are calculated by adding `SSL_MAX_MD_SIZE` (48 bytes) for each secret after the `hash_len_` field. See `SSL_HANDSHAKE_SECRET_` through `SSL_HANDSHAKE_EXPECTED_CLIENT_FINISHED_` constant definitions.\n\nSources: [kern/openssl_masterkey.h:171-257](), [kern/boringssl_masterkey.h:343-403](), [kern/openssl_masterkey_3.0.h:167-253](), [kern/boringssl_const.h:1-63](), [user/module/probe_openssl.go:518-551]()\n\n### Keylog Format Generation\n\nCaptured master secrets are formatted according to the NSS Key Log format (SSLKEYLOGFILE):\n\n**TLS 1.2 Format**:\n```\nCLIENT_RANDOM <client_random_hex> <master_key_hex>\n```\n\n**TLS 1.3 Format**:\n```\nCLIENT_HANDSHAKE_TRAFFIC_SECRET <client_random_hex> <secret_hex>\nSERVER_HANDSHAKE_TRAFFIC_SECRET <client_random_hex> <secret_hex>\nCLIENT_TRAFFIC_SECRET_0 <client_random_hex> <secret_hex>\nSERVER_TRAFFIC_SECRET_0 <client_random_hex> <secret_hex>\nEXPORTER_SECRET <client_random_hex> <secret_hex>\n```\n\nThe `client_random` (32 bytes) serves as the key for deduplication—each unique client random is only written once to the keylog file. The `masterKeys` map tracks which client randoms have been processed.\n\nSources: [user/module/probe_openssl.go:482-642](), [user/module/probe_openssl.go:98]()\n\n---\n\n## Capture Modes\n\nThe module supports three distinct capture modes, configured via the `OpensslConfig.Model` field.\n\n### Capture Mode Comparison\n\n| Mode | Output Format | Use Case | Data Captured |\n|------|--------------|----------|---------------|\n| Text | Human-readable text | Real-time monitoring | Plaintext SSL data + HTTP/HTTP2 parsing |\n| PCAP | PCAP-NG file | Network analysis | Raw packets + DSB with master secrets |\n| Keylog | SSLKEYLOGFILE | Traffic decryption | Master secrets only |\n\n### Text Mode\n\n```mermaid\nflowchart LR\n    SSL_DATA[\"SSLDataEvent<br/>from eBPF\"]\n    \n    GET_CONN[\"GetConn(pid, fd)<br/>→ ConnInfo\"]\n    \n    ENRICH[\"Add tuple + sock<br/>to event\"]\n    \n    PROCESSOR[\"Event Processor<br/>Aggregation + Parsing\"]\n    \n    PARSER[\"HTTP/HTTP2 Parser<br/>Protocol detection\"]\n    \n    OUTPUT[\"Console or File<br/>Formatted text\"]\n    \n    SSL_DATA --> GET_CONN\n    GET_CONN --> ENRICH\n    ENRICH --> PROCESSOR\n    PROCESSOR --> PARSER\n    PARSER --> OUTPUT\n```\n\n**Text Mode Flow**:\n1. `SSLDataEvent` captured by uprobe contains `pid`, `fd`, `data`, `data_len`\n2. `dumpSslData()` calls `GetConn(pid, fd)` to retrieve connection tuple\n3. Event enriched with tuple and socket pointer\n4. Sent to event processor which aggregates fragments and detects HTTP/HTTP2\n5. Parsed events output as formatted text\n\nText mode is the default and provides immediate visibility into decrypted traffic with automatic protocol parsing.\n\nSources: [user/module/probe_openssl.go:756-775](), [user/module/probe_openssl.go:152-153]()\n\n### PCAP Mode\n\n```mermaid\nflowchart TB\n    TC_PROG[\"TC Classifier eBPF<br/>Captures packets\"]\n    \n    TC_EVENT[\"TcSkbEvent<br/>packet data + metadata\"]\n    \n    MASTER_SEC[\"Master Secret Events<br/>TLS keys\"]\n    \n    PCAPNG[\"PCAP-NG Writer<br/>Enhanced Packet Block\"]\n    \n    DSB[\"Decryption Secrets Block<br/>Embed TLS keys\"]\n    \n    FILE[\"Output .pcapng file<br/>Wireshark compatible\"]\n    \n    TC_PROG --> TC_EVENT\n    TC_EVENT --> PCAPNG\n    \n    MASTER_SEC --> DSB\n    DSB --> PCAPNG\n    \n    PCAPNG --> FILE\n```\n\n**PCAP Mode Features**:\n- **Packet Capture**: TC eBPF classifier captures raw network packets (ingress/egress)\n- **Decryption Secrets Block (DSB)**: Master secrets embedded in PCAP-NG file using DSB format\n- **4-Tuple Filtering**: Can filter packets by source/destination IP/port via BPF instructions\n- **Wireshark Integration**: Generated files can be directly opened in Wireshark for decryption\n\nThe `setupManagersPcap()` function configures TC hooks on network interfaces, while `savePcapngSslKeyLog()` writes master secrets as DSB records.\n\nPCAP mode is ideal for offline analysis and sharing captures with standard network analysis tools.\n\nSources: [user/module/probe_openssl.go:138-148](), [user/module/probe_openssl.go:288-289]()\n\n### Keylog Mode\n\n```mermaid\nflowchart LR\n    MASTER_EVENT[\"MasterSecretEvent or<br/>MasterSecretBSSLEvent\"]\n    \n    DEDUP[\"Check masterKeys map<br/>Skip if client_random exists\"]\n    \n    FORMAT[\"Format as NSS keylog:<br/>CLIENT_RANDOM + secrets<br/>or TLS 1.3 labels\"]\n    \n    WRITE[\"Write to keylog file<br/>Append mode\"]\n    \n    MASTER_EVENT --> DEDUP\n    DEDUP --> FORMAT\n    FORMAT --> WRITE\n```\n\n**Keylog Mode Characteristics**:\n- **Output**: Standard SSLKEYLOGFILE format compatible with browsers and tools\n- **Deduplication**: Uses `client_random` as key to prevent duplicate entries\n- **TLS Version Support**: Handles both TLS 1.2 (single master key) and TLS 1.3 (multiple derived secrets)\n- **File Management**: Opens keylog file in append mode with 0600 permissions\n\nThe keylog file can be used with:\n- Wireshark (Edit → Preferences → Protocols → TLS → Pre-Master-Secret log filename)\n- Browsers for debugging encrypted traffic\n- Other tools that support NSS Key Log format\n\nKeylog mode is the most lightweight option when only master secrets are needed for decryption.\n\nSources: [user/module/probe_openssl.go:129-136](), [user/module/probe_openssl.go:482-642](), [user/module/probe_openssl.go:288]()\n\n---\n\n## Initialization and Lifecycle\n\nThe module follows the standard IModule lifecycle with specialized setup for SSL/TLS interception.\n\n### Module Lifecycle\n\n```mermaid\nstateDiagram-v2\n    [*] --> Init\n    \n    Init --> Start\n    note right of Init\n        - Parse configuration\n        - Detect SSL version\n        - Select bytecode\n        - Initialize tracking maps\n        - Setup event processor\n    end note\n    \n    Start --> SetupManagers\n    note right of Start\n        - setupManagersText()\n        - setupManagersPcap()  \n        - setupManagersKeylog()\n    end note\n    \n    SetupManagers --> LoadBytecode\n    note right of LoadBytecode\n        - Fetch from assets\n        - Apply CO-RE/non-CO-RE\n        - Initialize with options\n    end note\n    \n    LoadBytecode --> AttachProbes\n    note right of AttachProbes\n        - Attach uprobes to SSL functions\n        - Setup TC classifiers (pcap mode)\n        - Configure constant editors\n    end note\n    \n    AttachProbes --> Run\n    note right of Run\n        - Start event readers\n        - Process eBPF map events\n        - Dispatch to handlers\n    end note\n    \n    Run --> Processing\n    note right of Processing\n        - AddConn/GetConn\n        - saveMasterSecret\n        - dumpSslData/dumpTcSkb\n    end note\n    \n    Processing --> Close\n    note right of Close\n        - Stop bpfManager\n        - Close event processor\n        - Close output files\n    end note\n    \n    Close --> [*]\n```\n\n**Initialization Steps** (`Init`):\n1. Call base `Module.Init()` for common setup\n2. Initialize connection tracking maps (`pidConns`, `sock2pidFd`, `masterKeys`)\n3. Determine capture mode from configuration\n4. Open output files (keylog or PCAP)\n5. Call `initOpensslOffset()` to populate version-to-bytecode map\n6. Call `getSslBpfFile()` to detect version and select bytecode\n7. Set `masterHookFuncs` based on detected library (OpenSSL vs BoringSSL)\n\n**Start Phase**:\n- Calls appropriate setup function based on `eBPFProgramType`\n- Configures `ebpfmanager` with probes and maps\n- Applies constant editors for PID/UID filtering\n- Loads bytecode from embedded assets\n- Initializes decode functions for eBPF maps\n\n**Runtime Processing**:\n- Event readers continuously poll eBPF maps (perf arrays or ring buffers)\n- Events dispatched via `Dispatcher()` to appropriate handlers\n- Connection lifecycle managed through `AddConn`, `GetConn`, `DelConn` operations\n\n**Cleanup** (`Close`):\n- Stop `bpfManager` with `CleanAll` flag\n- Close event processor\n- Close keylog file (if open)\n- Call base `Module.Close()`\n\nSources: [user/module/probe_openssl.go:109-176](), [user/module/probe_openssl.go:280-350](), [user/module/probe_openssl.go:352-358](), [user/module/probe_openssl.go:733-754]()\n\n---\n\n## Configuration\n\nThe OpenSSL module is configured via the `OpensslConfig` struct.\n\n### Configuration Parameters\n\n| Parameter | Type | Purpose | Default |\n|-----------|------|---------|---------|\n| `Pid` | uint64 | Target process ID (0 = all) | 0 |\n| `Uid` | uint64 | Target user ID (0 = all) | 0 |\n| `Model` | string | Capture mode: text/pcap/keylog | text |\n| `KeylogFile` | string | Path to keylog output file | - |\n| `PcapFile` | string | Path to PCAP output file | - |\n| `PcapFilter` | string | BPF filter for packet capture | \"\" |\n| `SslVersion` | string | Manual version override | \"\" |\n| `IsAndroid` | bool | Android environment flag | false |\n| `AndroidVer` | string | Android API level (13-16) | \"\" |\n| `CGroupPath` | string | cgroup path for filtering | \"\" |\n| `BtfMode` | uint8 | BTF mode: 0=auto, 1=core, 2=non-core | 0 |\n\n**Manual Version Override**: Setting `SslVersion` bypasses automatic detection. Useful for Android where version detection may be unreliable. Examples:\n- `--ssl_version='boringssl_a_13'` for Android 12\n- `--ssl_version='openssl 3.0.0'` for specific OpenSSL version\n\n**PCAP Filter**: When using PCAP mode, `PcapFilter` applies BPF filtering to captured packets. The filter is compiled into eBPF instruction patches applied to TC classifiers.\n\nSources: [user/config/iconfig.go:73-79](), [cli/cmd/root.go:157-175]()\n\n---\n\n## Integration with Event Processing\n\nThe OpenSSL module dispatches events to the central event processing system for aggregation, parsing, and output.\n\n### Event Types and Handlers\n\n```mermaid\ngraph TB\n    subgraph \"Event Sources\"\n        SSL_DATA[\"SSLDataEvent<br/>TypeEventProcessor\"]\n        MASTER_SEC[\"MasterSecretEvent<br/>MasterSecretBSSLEvent<br/>TypeModuleData\"]\n        CONN[\"ConnDataEvent<br/>TypeModuleData\"]\n        TC[\"TcSkbEvent<br/>TypeModuleData\"]\n    end\n    \n    subgraph \"Dispatcher Logic\"\n        CHECK_TYPE{\"Event<br/>Type?\"}\n        CHECK_HEX{\"Hex mode<br/>enabled?\"}\n    end\n    \n    subgraph \"Handlers\"\n        HEX_OUTPUT[\"Direct hex output\"]\n        PROCESSOR[\"Event Processor<br/>Aggregation + parsing\"]\n        MODULE_HANDLER[\"Module-specific handler<br/>AddConn/saveMasterSecret/dumpTcSkb\"]\n    end\n    \n    subgraph \"Output\"\n        CONSOLE[\"Console/File output\"]\n        PCAPNG[\"PCAP-NG file\"]\n        KEYLOG[\"Keylog file\"]\n    end\n    \n    SSL_DATA --> CHECK_TYPE\n    MASTER_SEC --> CHECK_TYPE\n    CONN --> CHECK_TYPE\n    TC --> CHECK_TYPE\n    \n    CHECK_TYPE -->|TypeOutput| CHECK_HEX\n    CHECK_TYPE -->|TypeEventProcessor| CHECK_HEX\n    CHECK_TYPE -->|TypeModuleData| MODULE_HANDLER\n    \n    CHECK_HEX -->|Yes| HEX_OUTPUT\n    CHECK_HEX -->|No TypeOutput| CONSOLE\n    CHECK_HEX -->|No TypeEventProcessor| PROCESSOR\n    \n    HEX_OUTPUT --> CONSOLE\n    PROCESSOR --> CONSOLE\n    \n    MODULE_HANDLER -->|ConnDataEvent| AddConn\n    MODULE_HANDLER -->|MasterSecret*| saveMasterSecret\n    MODULE_HANDLER -->|TcSkbEvent| dumpTcSkb\n    \n    AddConn[AddConn]\n    saveMasterSecret[saveMasterSecret]\n    dumpTcSkb[dumpTcSkb]\n    \n    saveMasterSecret --> KEYLOG\n    saveMasterSecret --> PCAPNG\n    dumpTcSkb --> PCAPNG\n```\n\n**Event Type Routing**:\n- `TypeEventProcessor`: SSL data events sent to event processor for aggregation and HTTP parsing\n- `TypeModuleData`: Module-internal events (connections, master secrets, packets) handled by module\n- `TypeOutput`: Pre-formatted output events sent directly to output writer\n\n**Module-Specific Handlers**:\n- `ConnDataEvent`: Calls `AddConn()` or `DelConn()` based on `IsDestroy` flag\n- `MasterSecretEvent`/`MasterSecretBSSLEvent`: Calls `saveMasterSecret()` or `saveMasterSecretBSSL()`\n- `TcSkbEvent`: Calls `dumpTcSkb()` to write packet to PCAP-NG\n- `SSLDataEvent`: Calls `dumpSslData()` to enrich and forward to processor\n\nThe `Dispatcher()` method implements this routing logic, checking the `isClosed` flag to prevent processing events after shutdown.\n\nSources: [user/module/probe_openssl.go:733-754](), [user/module/imodule.go:408-448]()\n\n---\n\n## Structure Offset Calculation\n\nCapturing master secrets requires reading from internal SSL/TLS library structures. Since these structures vary by version, precise offset calculation is critical.\n\n### Offset Calculation Approaches\n\n**1. Automated Offset Generation** (BoringSSL):\n\nThe `boringssl-offset.c` utility uses C's `offsetof()` macro to calculate structure member offsets at compile time:\n\n```c\n#define X(struct_name, field_name) \\\n    format(#struct_name, #field_name, offsetof(struct struct_name, field_name));\n\nSSL_STRUCT_OFFSETS\n```\n\nThis generates header file constants like:\n```c\n#define SSL_ST_S3 0x18\n#define BSSL__SSL3_STATE_HS 0x30\n#define SSL_SESSION_ST_SECRET 0x48\n```\n\n**2. Manual Offset Mapping** (OpenSSL):\n\nFor OpenSSL, offsets are manually determined for each major version by:\n- Analyzing OpenSSL source code structure definitions\n- Verifying offsets across minor version updates\n- Creating version-specific header files (e.g., `openssl_1_1_1j_offset.h`)\n\n**3. Private Member Handling** (BoringSSL TLS 1.3):\n\nBoringSSL stores TLS 1.3 secrets as private members in `SSL_HANDSHAKE`. Since `offsetof()` cannot access private members, offsets are calculated by:\n- Finding the last public member (`max_version`)\n- Adding size with memory alignment\n- Computing cumulative offsets for each secret field\n\nExample calculation in `boringssl_const.h`:\n```c\n// max_version is at offset 30, sizeof(uint16_t) = 2\n// Memory aligned to 8-byte boundary\n#define SSL_HANDSHAKE_HASH_LEN_ roundup(30+2, 8)  // = 32\n#define SSL_HANDSHAKE_SECRET_ (32 + 8)  // hash_len_ is size_t (8 bytes)\n#define SSL_HANDSHAKE_EARLY_TRAFFIC_SECRET_ (40 + 48*1)\n#define SSL_HANDSHAKE_CLIENT_HANDSHAKE_SECRET_ (40 + 48*2)\n// ... each secret is SSL_MAX_MD_SIZE (48 bytes) apart\n```\n\n**Version-Specific Challenges**:\n- OpenSSL 3.0+ moved `client_random` directly into `ssl_st` structure\n- OpenSSL 3.0.12 has unique offsets different from other 3.0.x versions\n- Android BoringSSL changes offsets between API levels\n\nSources: [utils/boringssl-offset.c:1-79](), [kern/boringssl_const.h:1-63](), [user/module/probe_openssl_lib.go:73-187]()\n\n---\n\n## Performance Considerations\n\n**Connection Tracking Overhead**: The bidirectional maps (`pidConns`, `sock2pidFd`) use mutexes for thread safety. Connections are only added/removed on socket events, not per-packet, minimizing lock contention.\n\n**Event Buffer Sizing**: The per-CPU map size (default 1024 * PAGE_SIZE) affects how many events can be buffered before dropping. Increase via `--mapsize` flag for high-throughput scenarios.\n\n**Delayed Connection Cleanup**: The 3-second delay in `DelConn()` prevents premature removal of connection metadata while events are still being processed by the event processor. This trades memory for correctness.\n\n**Master Key Deduplication**: The `masterKeys` map prevents writing duplicate entries to the keylog file. Each entry is indexed by `client_random` hex string, ensuring O(1) lookup.\n\n**PCAP Mode Overhead**: TC-based packet capture has lower overhead than traditional libpcap since it operates entirely in kernel space. However, it captures all packets on the interface, which may include non-SSL traffic unless filtered.\n\nSources: [user/module/probe_openssl.go:94](), [user/module/probe_openssl.go:98](), [user/module/probe_openssl.go:454-462](), [cli/cmd/root.go:143]()\n\n---\n\n## Error Handling and Fallbacks\n\n**Version Detection Failures**: When `detectOpenssl()` fails to find a version string:\n1. Try reading from `libcrypto.so.3` instead of `libssl.so.3`\n2. Apply `downgradeOpensslVersion()` to find closest matching version\n3. Fall back to default bytecode based on library path pattern\n4. Log warnings with suggestions for manual version specification\n\n**Bytecode Selection Failures**: If no bytecode matches the detected version, the module uses conservative defaults:\n- `openssl_1_1_1j_kern.o` for general Linux OpenSSL\n- `openssl_3_0_0_kern.o` for `libssl.so.3`\n- `boringssl_a_13_kern.o` for Android\n\n**Master Secret Extraction Errors**: The eBPF probes include extensive error checking with debug logging. If reading a field fails, the probe typically returns early rather than sending partial/corrupted data. Common failure scenarios:\n- Handshake not yet complete (state checks prevent premature capture)\n- Null pointers for session structures (fallback session retrieval logic)\n- Invalid memory addresses (bpf_probe_read_user returns error)\n\n**Connection Tracking Errors**: When `GetConn()` fails to find a connection (e.g., SSL data event arrives before TC event):\n- Event is still processed with default tuple `\"0.0.0.0:0-0.0.0.0:0\"`\n- Logged for debugging purposes\n- Does not block SSL data capture\n\nSources: [user/module/probe_openssl_lib.go:206-278](), [user/module/probe_openssl_lib.go:284-317](), [user/module/probe_openssl.go:756-775]()"
          },
          {
            "page_plan": {
              "id": "3.1.2",
              "title": "Go TLS Module"
            },
            "content": "# Go TLS Module\n\n<details>\n<summary>Relevant source files</summary>\n\nThe following files were used as context for generating this wiki page:\n\n- [cli/cmd/bash.go](cli/cmd/bash.go)\n- [cli/cmd/gnutls.go](cli/cmd/gnutls.go)\n- [cli/cmd/gotls.go](cli/cmd/gotls.go)\n- [cli/cmd/mysqld.go](cli/cmd/mysqld.go)\n- [cli/cmd/nspr.go](cli/cmd/nspr.go)\n- [cli/cmd/postgres.go](cli/cmd/postgres.go)\n- [cli/cmd/tls.go](cli/cmd/tls.go)\n- [cli/cmd/zsh.go](cli/cmd/zsh.go)\n- [kern/go_argument.h](kern/go_argument.h)\n- [kern/gotls_kern.c](kern/gotls_kern.c)\n- [pkg/util/ws/client.go](pkg/util/ws/client.go)\n- [pkg/util/ws/client_test.go](pkg/util/ws/client_test.go)\n- [user/config/config_gotls.go](user/config/config_gotls.go)\n- [user/module/probe_gotls.go](user/module/probe_gotls.go)\n- [user/module/probe_gotls_keylog.go](user/module/probe_gotls_keylog.go)\n- [user/module/probe_gotls_text.go](user/module/probe_gotls_text.go)\n\n</details>\n\n\n\n## Purpose and Scope\n\nThe Go TLS Module captures plaintext TLS/SSL traffic and cryptographic secrets from applications compiled with the Go programming language. Unlike the OpenSSL Module (see [3.1.1](#3.1.1)), which hooks dynamic library functions, this module directly instruments the Go binary's crypto/tls package functions by parsing the Go application's ELF structure and symbol tables.\n\nThis module addresses unique challenges of Go binaries: statically-linked TLS implementation, evolving Application Binary Interface (ABI) conventions (register-based vs stack-based), Position Independent Executable (PIE) build modes, and version-specific symbol table formats. For general TLS capture concepts and master secret extraction techniques, see [3.1.4](#3.1.4).\n\n**Key Capabilities:**\n- Capture plaintext TLS data from Go applications without library injection\n- Extract TLS master secrets for traffic decryption\n- Support both register-based ABI (Go 1.17+) and stack-based ABI (Go <1.17)\n- Handle PIE and non-PIE Go binaries\n- Three output modes: text, keylog, and pcap (see [4](#4))\n\n---\n\n## Architecture Overview\n\nThe Go TLS Module follows a three-phase initialization and execution pattern distinct from library-based modules:\n\n```mermaid\ngraph TB\n    subgraph \"Phase 1: Binary Analysis\"\n        ELF[\"ELF File Reader<br/>(config_gotls.go)\"]\n        BUILDINFO[\"buildinfo.ReadFile()<br/>Extract Go version<br/>Build settings\"]\n        SYMTAB[\"Symbol Table Parser<br/>ReadTable()<br/>.gopclntab section\"]\n        PIE_DETECT[\"PIE Detection<br/>-buildmode=pie\"]\n    end\n    \n    subgraph \"Phase 2: Function Location\"\n        ABI_SELECT[\"ABI Selection<br/>Go >= 1.17: Register<br/>Go < 1.17: Stack\"]\n        OFFSET_CALC[\"Offset Calculator<br/>findRetOffsets()<br/>findPieSymbolAddr()\"]\n        HOOK_ADDRS[\"Hook Addresses<br/>writeRecordLocked<br/>Read (multiple RET)<br/>writeKeyLog\"]\n    end\n    \n    subgraph \"Phase 3: eBPF Attachment\"\n        UPROBE_MGR[\"Uprobe Manager<br/>ebpfmanager\"]\n        REG_PROG[\"Register ABI Programs<br/>gotls_write_register<br/>gotls_read_register<br/>gotls_mastersecret_register\"]\n        STACK_PROG[\"Stack ABI Programs<br/>gotls_write_stack<br/>gotls_read_stack<br/>gotls_mastersecret_stack\"]\n        ARG_EXTRACT[\"Argument Extraction<br/>go_argument.h<br/>go_get_argument()\"]\n    end\n    \n    subgraph \"Runtime Capture\"\n        DATA_EVENT[\"go_tls_event<br/>Plaintext data<br/>Read/Write type\"]\n        SECRET_EVENT[\"mastersecret_gotls_t<br/>Label + ClientRandom<br/>+ Secret\"]\n        TC_EVENT[\"TcSkbEvent<br/>(pcap mode only)\"]\n    end\n    \n    ELF --> BUILDINFO\n    ELF --> SYMTAB\n    BUILDINFO --> PIE_DETECT\n    BUILDINFO --> ABI_SELECT\n    SYMTAB --> OFFSET_CALC\n    PIE_DETECT --> OFFSET_CALC\n    ABI_SELECT --> OFFSET_CALC\n    OFFSET_CALC --> HOOK_ADDRS\n    HOOK_ADDRS --> UPROBE_MGR\n    ABI_SELECT --> REG_PROG\n    ABI_SELECT --> STACK_PROG\n    REG_PROG --> ARG_EXTRACT\n    STACK_PROG --> ARG_EXTRACT\n    UPROBE_MGR --> DATA_EVENT\n    UPROBE_MGR --> SECRET_EVENT\n    UPROBE_MGR --> TC_EVENT\n    \n    style BUILDINFO fill:#f9f9f9\n    style ABI_SELECT fill:#f9f9f9\n    style ARG_EXTRACT fill:#f9f9f9\n```\n\n**Sources:** [user/module/probe_gotls.go:58-122](), [user/config/config_gotls.go:95-190]()\n\n---\n\n## Go Binary Analysis and ABI Detection\n\n### ELF Structure Parsing\n\nThe module begins by extracting metadata from the target Go binary using Go's `debug/buildinfo` and `debug/elf` packages:\n\n```mermaid\nflowchart TD\n    START[\"GoTLSConfig.Check()\"]\n    READ_BUILD[\"buildinfo.ReadFile()<br/>Extract BuildInfo\"]\n    OPEN_ELF[\"elf.Open()<br/>Parse ELF headers\"]\n    ARCH_CHECK[\"Architecture Check<br/>EM_X86_64 → amd64<br/>EM_AARCH64 → arm64\"]\n    PIE_CHECK{\"Check BuildSettings<br/>-buildmode=pie?\"}\n    READ_SYMTAB[\"ReadTable()<br/>Parse .gopclntab\"]\n    FIND_FUNCS[\"Find Function Addresses<br/>findPieSymbolAddr()\"]\n    FIND_OFFSETS_PIE[\"findRetOffsetsPie()<br/>Decode instructions\"]\n    FIND_OFFSETS_NOPIE[\"findRetOffsets()<br/>Search symbol table\"]\n    VALIDATE[\"Validate hook points<br/>Set addresses\"]\n    \n    START --> READ_BUILD\n    READ_BUILD --> OPEN_ELF\n    OPEN_ELF --> ARCH_CHECK\n    ARCH_CHECK --> PIE_CHECK\n    PIE_CHECK -->|Yes| READ_SYMTAB\n    PIE_CHECK -->|No| FIND_OFFSETS_NOPIE\n    READ_SYMTAB --> FIND_FUNCS\n    FIND_FUNCS --> FIND_OFFSETS_PIE\n    FIND_OFFSETS_NOPIE --> VALIDATE\n    FIND_OFFSETS_PIE --> VALIDATE\n```\n\n**Key Data Structures:**\n\n| Field | Type | Purpose |\n|-------|------|---------|\n| `Buildinfo` | `*buildinfo.BuildInfo` | Go version, build settings, module info |\n| `goElf` | `*elf.File` | ELF file handle for section/symbol access |\n| `goSymTab` | `*gosym.Table` | Symbol table for PIE binaries |\n| `IsPieBuildMode` | `bool` | Indicates PIE compilation |\n| `ReadTlsAddrs` | `[]int` | Multiple RET instruction offsets for Read uretprobes |\n| `GoTlsWriteAddr` | `uint64` | Address of writeRecordLocked function |\n| `GoTlsMasterSecretAddr` | `uint64` | Address of Config.writeKeyLog function |\n\n**Sources:** [user/config/config_gotls.go:102-190]()\n\n### Symbol Table Parsing for PIE Binaries\n\nPIE binaries require special handling because symbols are unlabeled and relocated. The module locates the `.gopclntab` section (or `.data.rel.ro.gopclntab` for PIE) using magic number matching:\n\n```mermaid\ngraph LR\n    SECTIONS[\"ELF Sections\"]\n    PCLNTAB[\".gopclntab<br/>.data.rel.ro.gopclntab<br/>.data.rel.ro\"]\n    MAGIC[\"Magic Number<br/>0xFFFFFFFA (Go 1.16)<br/>0xFFFFFFF0 (Go 1.18)<br/>0xFFFFFFF1 (Go 1.20)\"]\n    INDEX[\"bytes.Index()<br/>Find magic in data\"]\n    LINETAB[\"gosym.NewLineTable()<br/>PC-to-line mapping\"]\n    SYMTAB[\"gosym.NewTable()<br/>Function symbols\"]\n    LOOKUP[\"LookupFunc()<br/>Resolve addresses\"]\n    \n    SECTIONS --> PCLNTAB\n    PCLNTAB --> MAGIC\n    MAGIC --> INDEX\n    INDEX --> LINETAB\n    LINETAB --> SYMTAB\n    SYMTAB --> LOOKUP\n```\n\nThe magic number varies by Go version to accommodate changes in the program counter line table format:\n\n| Go Version | Magic Number | Hex Value |\n|------------|--------------|-----------|\n| < 1.16 | `go12magic` | `0xFFFFFFFB` |\n| 1.16-1.17 | `go116magic` | `0xFFFFFFFA` |\n| 1.18-1.19 | `go118magic` | `0xFFFFFFF0` |\n| ≥ 1.20 | `go120magic` | `0xFFFFFFF1` |\n\n**Sources:** [user/config/config_gotls.go:46-69](), [user/config/config_gotls.go:281-325]()\n\n### ABI Version Detection\n\nGo 1.17 introduced a register-based calling convention, fundamentally changing how function arguments are passed. The module detects this by comparing the Go version:\n\n```mermaid\ngraph TD\n    VERSION[\"Extract Go Version<br/>proc.ExtraceGoVersion()\"]\n    COMPARE{\"Version >= 1.17?\"}\n    REG_ABI[\"isRegisterABI = true<br/>Use register-based argument extraction\"]\n    STACK_ABI[\"isRegisterABI = false<br/>Use stack-based argument extraction\"]\n    SELECT_PROG{\"Select eBPF Programs\"}\n    REG_PROGS[\"gotls_write_register<br/>gotls_read_register<br/>gotls_mastersecret_register\"]\n    STACK_PROGS[\"gotls_write_stack<br/>gotls_read_stack<br/>gotls_mastersecret_stack\"]\n    \n    VERSION --> COMPARE\n    COMPARE -->|Yes| REG_ABI\n    COMPARE -->|No| STACK_ABI\n    REG_ABI --> SELECT_PROG\n    STACK_ABI --> SELECT_PROG\n    SELECT_PROG --> REG_PROGS\n    SELECT_PROG --> STACK_PROGS\n```\n\n**Sources:** [user/module/probe_gotls.go:71-79](), [user/module/probe_gotls_text.go:37-47]()\n\n---\n\n## Hook Points and Function Offsets\n\n### Target Functions\n\nThe module hooks three critical functions in the `crypto/tls` package:\n\n| Function | Constant | Purpose | Hook Type |\n|----------|----------|---------|-----------|\n| `(*Conn).writeRecordLocked` | `GoTlsWriteFunc` | Writes TLS records (plaintext data) | Uprobe (entry) |\n| `(*Conn).Read` | `GoTlsReadFunc` | Reads TLS records (plaintext data) | Uretprobe (return) |\n| `(*Config).writeKeyLog` | `GoTlsMasterSecretFunc` | Logs TLS secrets for keylog files | Uprobe (entry) |\n\n**Sources:** [user/config/config_gotls.go:31-35]()\n\n### RET Instruction Offset Calculation\n\nFor `Read` function uretprobes, the module must find all RET instruction offsets because uretprobes in userspace are implemented as uprobes on RET instructions. The process differs for PIE vs non-PIE binaries:\n\n```mermaid\ngraph TB\n    subgraph \"Non-PIE: findRetOffsets()\"\n        SYMBOL1[\"Search .symtab<br/>Find symbol by name\"]\n        SECTION1[\"Get symbol.Section<br/>Extract code bytes\"]\n        DECODE1[\"decodeInstruction()<br/>Find RET offsets\"]\n        ADJUST1[\"Adjust for PT_LOAD<br/>segment offset\"]\n    end\n    \n    subgraph \"PIE: findRetOffsetsPie()\"\n        SYMTAB[\"goSymTab.LookupFunc()<br/>Get function entry/end\"]\n        ADDR[\"Get function address<br/>from symbol table\"]\n        PROG[\"Find PT_LOAD segment<br/>Read function bytes\"]\n        DECODE2[\"decodeInstruction()<br/>Find RET offsets\"]\n        ADJUST2[\"Calculate absolute<br/>addresses\"]\n    end\n    \n    START{\"IsPieBuildMode?\"}\n    RESULT[\"ReadTlsAddrs []int<br/>List of RET addresses\"]\n    \n    START -->|No| SYMBOL1\n    START -->|Yes| SYMTAB\n    SYMBOL1 --> SECTION1\n    SECTION1 --> DECODE1\n    DECODE1 --> ADJUST1\n    ADJUST1 --> RESULT\n    SYMTAB --> ADDR\n    ADDR --> PROG\n    PROG --> DECODE2\n    DECODE2 --> ADJUST2\n    ADJUST2 --> RESULT\n```\n\nThe `decodeInstruction()` function is architecture-specific and searches for RET opcodes (0xC3 on x86-64, specific patterns on ARM64).\n\n**Sources:** [user/config/config_gotls.go:196-262](), [user/config/config_gotls.go:327-357]()\n\n---\n\n## eBPF Programs and Argument Extraction\n\n### Register vs Stack ABI Argument Access\n\nThe core challenge is extracting function arguments, which differ fundamentally between ABIs:\n\n```mermaid\ngraph TB\n    subgraph \"Register-Based ABI (Go >= 1.17)\"\n        REG_PARAMS[\"x86-64 Registers:<br/>AX, BX, CX, DI, SI, R8, R9, R10<br/><br/>ARM64 Registers:<br/>X0-X7\"]\n        REG_MACRO[\"GO_PARAMx() Macros<br/>go_argument.h\"]\n        REG_READ[\"Direct register read<br/>BPF_CORE_READ(ctx, reg)\"]\n    end\n    \n    subgraph \"Stack-Based ABI (Go < 1.17)\"\n        STACK_PTR[\"Stack Pointer (SP)<br/>PT_REGS_SP(ctx)\"]\n        STACK_OFFSET[\"Calculate offset<br/>SP + (index * 8)\"]\n        STACK_READ[\"bpf_probe_read()<br/>Read from stack\"]\n    end\n    \n    FUNC_CALL[\"go_get_argument(ctx, is_register_abi, index)\"]\n    SWITCH{\"is_register_abi?\"}\n    \n    FUNC_CALL --> SWITCH\n    SWITCH -->|true| REG_PARAMS\n    SWITCH -->|false| STACK_PTR\n    REG_PARAMS --> REG_MACRO\n    REG_MACRO --> REG_READ\n    STACK_PTR --> STACK_OFFSET\n    STACK_OFFSET --> STACK_READ\n```\n\n**x86-64 Register Mapping:**\n\n| Argument Index | Register (Register ABI) | Stack Offset (Stack ABI) |\n|----------------|------------------------|-------------------------|\n| 1 | RAX | SP + 8 |\n| 2 | RBX | SP + 16 |\n| 3 | RCX | SP + 24 |\n| 4 | RDI | SP + 32 |\n| 5 | RSI | SP + 40 |\n| 6 | R8 | SP + 48 |\n| 7 | R9 | SP + 56 |\n| 8 | R10 | SP + 64 |\n\n**Sources:** [kern/go_argument.h:74-108]()\n\n### Write Capture (gotls_write)\n\nThe `writeRecordLocked` function signature is:\n```go\nfunc (c *Conn) writeRecordLocked(typ recordType, data []byte) (int, error)\n```\n\nThe eBPF program extracts:\n- Argument 2: `recordType` (uint8) - must be `recordTypeApplicationData` (23)\n- Argument 3: `data` pointer (byte slice array pointer)\n- Argument 4: `len` (int) - length of data\n\n```mermaid\nsequenceDiagram\n    participant App as \"Go Application\"\n    participant Uprobe as \"gotls_write_*\"\n    participant Helper as \"go_get_argument()\"\n    participant Map as \"events map\"\n    \n    App->>Uprobe: writeRecordLocked(conn, 23, []byte, len)\n    Uprobe->>Helper: get_argument(ctx, is_register_abi, 2)\n    Helper-->>Uprobe: record_type = 23\n    Uprobe->>Uprobe: Check if ApplicationData\n    Uprobe->>Helper: get_argument(ctx, is_register_abi, 3)\n    Helper-->>Uprobe: data pointer\n    Uprobe->>Helper: get_argument(ctx, is_register_abi, 4)\n    Helper-->>Uprobe: length\n    Uprobe->>Uprobe: bpf_probe_read_user(&event.data, len, ptr)\n    Uprobe->>Map: bpf_perf_event_output(event)\n```\n\n**Event Structure:**\n\n```c\nstruct go_tls_event {\n    u64 ts_ns;              // Timestamp\n    u32 pid;                // Process ID\n    u32 tid;                // Thread ID\n    s32 data_len;           // Data length\n    u8 event_type;          // 0=Write, 1=Read\n    char comm[TASK_COMM_LEN]; // Process name\n    char data[MAX_DATA_SIZE_OPENSSL]; // Plaintext data\n};\n```\n\n**Sources:** [kern/gotls_kern.c:89-123](), [kern/gotls_kern.c:31-39]()\n\n### Read Capture (gotls_read)\n\nThe `Read` function signature is:\n```go\nfunc (c *Conn) Read(b []byte) (int, error)\n```\n\nThis uses **uretprobe** to capture data after the read completes. The challenge is that at return time, arguments are on the stack even for register ABI:\n\n```mermaid\ngraph TB\n    URETPROBE[\"Uretprobe on RET instruction\"]\n    STACK_READ[\"Always use stack reads<br/>Arguments pushed during call\"]\n    ARG1[\"Arg 2: byte slice pointer<br/>go_get_argument(ctx, false, 2)\"]\n    RET_VAL{\"Return value location\"}\n    REG_RET[\"Register ABI:<br/>Return in register<br/>go_get_argument(ctx, true, 1)\"]\n    STACK_RET[\"Stack ABI:<br/>Return at SP+40<br/>go_get_argument(ctx, false, 5)\"]\n    READ_DATA[\"bpf_probe_read_user()<br/>Copy data to event\"]\n    OUTPUT[\"Send event\"]\n    \n    URETPROBE --> STACK_READ\n    STACK_READ --> ARG1\n    ARG1 --> RET_VAL\n    RET_VAL -->|is_register_abi=true| REG_RET\n    RET_VAL -->|is_register_abi=false| STACK_RET\n    REG_RET --> READ_DATA\n    STACK_RET --> READ_DATA\n    READ_DATA --> OUTPUT\n```\n\n**Sources:** [kern/gotls_kern.c:137-179]()\n\n### Master Secret Capture (gotls_mastersecret)\n\nThe `writeKeyLog` function signature is:\n```go\nfunc (c *Config) writeKeyLog(label string, clientRandom, secret []byte) error\n```\n\nGo slices are represented as three-word structures: `{pointer, len, cap}`. The eBPF program extracts:\n\n| Argument | Index | Content |\n|----------|-------|---------|\n| label (string) | 2 | Label pointer |\n| label.len | 3 | Label length |\n| clientRandom ([]byte) | 4 | Client random pointer |\n| clientRandom.len | 5 | Client random length |\n| clientRandom.cap | 6 | (skipped) |\n| secret ([]byte) | 7 | Secret pointer |\n| secret.len | 8 | Secret length |\n\n```c\nstruct mastersecret_gotls_t {\n    u8 label[MASTER_SECRET_KEY_LEN];           // \"CLIENT_RANDOM\" etc\n    u8 labellen;\n    u8 client_random[EVP_MAX_MD_SIZE];         // 32 bytes\n    u8 client_random_len;\n    u8 secret_[EVP_MAX_MD_SIZE];               // TLS secret\n    u8 secret_len;\n};\n```\n\n**Sources:** [kern/gotls_kern.c:194-267](), [kern/gotls_kern.c:41-48]()\n\n---\n\n## Capture Modes\n\nThe module supports three capture modes, each with different eBPF program configurations:\n\n### Text Mode\n\nCaptures plaintext data for immediate console output or logging.\n\n**Setup:**\n- Hooks: `writeRecordLocked` (uprobe), `Read` (multiple uretprobes)\n- Maps: `events` (perf array for `go_tls_event`)\n- No TC programs\n\n```mermaid\ngraph LR\n    WRITE[\"writeRecordLocked<br/>uprobe\"]\n    READ[\"Read<br/>uretprobes (multiple RET)\"]\n    EVENTS[\"events map<br/>PERF_EVENT_ARRAY\"]\n    USERSPACE[\"Event Processor<br/>GoTLSEvent\"]\n    OUTPUT[\"Text output<br/>HTTP/HTTP2 parsing\"]\n    \n    WRITE --> EVENTS\n    READ --> EVENTS\n    EVENTS --> USERSPACE\n    USERSPACE --> OUTPUT\n```\n\n**Sources:** [user/module/probe_gotls_text.go:31-118](), [user/module/probe_gotls_text.go:120-135]()\n\n### Keylog Mode\n\nCaptures TLS master secrets for decryption with external tools (Wireshark, etc).\n\n**Setup:**\n- Hooks: `writeKeyLog` (uprobe) only\n- Maps: `mastersecret_go_events` (perf array for `mastersecret_gotls_t`)\n- Output: SSLKEYLOGFILE format\n\n```mermaid\ngraph LR\n    KEYLOG[\"writeKeyLog<br/>uprobe\"]\n    SECRETS[\"mastersecret_go_events<br/>PERF_EVENT_ARRAY\"]\n    USERSPACE[\"Event Processor<br/>MasterSecretGotlsEvent\"]\n    DEDUP[\"Deduplication<br/>masterSecrets map\"]\n    FILE[\"Write to keylog file<br/>Label ClientRandom Secret\"]\n    \n    KEYLOG --> SECRETS\n    SECRETS --> USERSPACE\n    USERSPACE --> DEDUP\n    DEDUP --> FILE\n```\n\nMaster secrets are deduplicated using a key: `{label}-{clientRandom}` to prevent duplicate entries for the same TLS session.\n\n**Sources:** [user/module/probe_gotls_keylog.go:31-122](), [user/module/probe_gotls.go:236-275]()\n\n### PCAP Mode\n\nCaptures both plaintext data and network packets for complete traffic reconstruction.\n\n**Setup:**\n- Hooks: `writeKeyLog` (uprobe), TC ingress/egress classifiers\n- Maps: `mastersecret_go_events`, `packet_events`, connection tracking maps\n- Output: PCAP-NG with DSB (Decryption Secrets Block)\n\n```mermaid\ngraph TB\n    KEYLOG[\"writeKeyLog<br/>uprobe\"]\n    TC_IN[\"TC Ingress<br/>capture_packets\"]\n    TC_OUT[\"TC Egress<br/>capture_packets\"]\n    SECRET_MAP[\"mastersecret_go_events\"]\n    PACKET_MAP[\"packet_events\"]\n    \n    PROCESSOR[\"Event Processor\"]\n    DSB[\"DSB Block<br/>Embed secrets\"]\n    PACKETS[\"Packet Blocks<br/>Network data\"]\n    PCAPNG[\"PCAP-NG Writer<br/>save.pcapng\"]\n    \n    KEYLOG --> SECRET_MAP\n    TC_IN --> PACKET_MAP\n    TC_OUT --> PACKET_MAP\n    SECRET_MAP --> PROCESSOR\n    PACKET_MAP --> PROCESSOR\n    PROCESSOR --> DSB\n    PROCESSOR --> PACKETS\n    DSB --> PCAPNG\n    PACKETS --> PCAPNG\n```\n\nThe TC classifiers use connection tracking (see [2.6](#2.6)) to associate packets with processes.\n\n**Sources:** [user/module/probe_gotls_pcap.go]()\n\n---\n\n## Configuration and CLI\n\n### Configuration Structure\n\nThe `GoTLSConfig` struct centralizes all module settings:\n\n```mermaid\nclassDiagram\n    class GoTLSConfig {\n        +BaseConfig\n        +string Path\n        +string PcapFile\n        +string KeylogFile\n        +string Model\n        +string Ifname\n        +string PcapFilter\n        +bool IsPieBuildMode\n        +bool isRegisterABI\n        +buildinfo.BuildInfo Buildinfo\n        +[]int ReadTlsAddrs\n        +uint64 GoTlsWriteAddr\n        +uint64 GoTlsMasterSecretAddr\n        +Check() error\n        +ReadTable() gosym.Table\n        +findRetOffsets() []int\n        +findPieSymbolAddr() uint64\n    }\n    \n    class BaseConfig {\n        +uint64 Pid\n        +uint64 Uid\n        +uint64 PerCpuMapSize\n        +string LogFile\n        +bool IsHex\n        +int BTFMode\n    }\n    \n    GoTLSConfig --|> BaseConfig\n```\n\n**Sources:** [user/config/config_gotls.go:76-93]()\n\n### CLI Commands\n\nThe `gotls` subcommand provides the user interface:\n\n```bash\n# Basic text capture\necapture gotls --elfpath=/path/to/go_binary\n\n# Keylog mode with filtering\necapture gotls -m keylog -k /tmp/keys.log --elfpath=/path/to/go_binary --pid=1234\n\n# PCAP mode with network interface\necapture gotls -m pcap -w capture.pcapng -i eth0 --elfpath=/path/to/go_binary tcp port 443\n```\n\n**Flag Mapping:**\n\n| Flag | Config Field | Default | Purpose |\n|------|--------------|---------|---------|\n| `-e, --elfpath` | `Path` | (required) | Path to Go binary |\n| `-m, --model` | `Model` | `text` | Capture mode: text/pcap/keylog |\n| `-w, --pcapfile` | `PcapFile` | `ecapture_gotls.pcapng` | PCAP output file |\n| `-k, --keylogfile` | `KeylogFile` | `ecapture_gotls_key.log` | Keylog output file |\n| `-i, --ifname` | `Ifname` | (required for pcap) | Network interface |\n| `--pid` | `Pid` | 0 (all) | Target process ID |\n\n**Sources:** [cli/cmd/gotls.go:26-58]()\n\n---\n\n## Event Processing and Output\n\n### Event Dispatcher\n\nThe `Dispatcher` method routes events based on type:\n\n```mermaid\nflowchart TD\n    EVENT[\"eventStruct received\"]\n    TYPE_CHECK{\"Event Type?\"}\n    MASTER[\"MasterSecretGotlsEvent\"]\n    TCSKB[\"TcSkbEvent\"]\n    GOTLS[\"GoTLSEvent\"]\n    \n    SAVE_MASTER[\"saveMasterSecret()<br/>Write to keylog/DSB\"]\n    DUMP_TC[\"dumpTcSkb()<br/>Write to PCAP\"]\n    PARSE_HTTP[\"HTTP/HTTP2 Parser<br/>Format output\"]\n    \n    EVENT --> TYPE_CHECK\n    TYPE_CHECK --> MASTER\n    TYPE_CHECK --> TCSKB\n    TYPE_CHECK --> GOTLS\n    MASTER --> SAVE_MASTER\n    TCSKB --> DUMP_TC\n    GOTLS --> PARSE_HTTP\n```\n\n**Sources:** [user/module/probe_gotls.go:277-288]()\n\n### Deduplication of Master Secrets\n\nMaster secrets are deduplicated to prevent multiple writes of the same key:\n\n```go\n// Key format: \"LABEL-CLIENTRANDOM\"\n// e.g., \"CLIENT_RANDOM-6a7b8c9d...\"\nk := fmt.Sprintf(\"%s-%02x\", label, clientRandom)\n\n_, exists := g.masterSecrets[k]\nif exists {\n    return // Skip duplicate\n}\ng.masterSecrets[k] = true\n```\n\nThis ensures that repeated TLS handshakes (e.g., HTTP/2 with session resumption) don't produce redundant keylog entries.\n\n**Sources:** [user/module/probe_gotls.go:242-248]()\n\n---\n\n## Build System Integration\n\nThe module integrates with eCapture's dual-path eBPF compilation:\n\n```mermaid\ngraph TB\n    SOURCE[\"kern/gotls_kern.c\"]\n    HEADER[\"kern/go_argument.h<br/>kern/ecapture.h\"]\n    \n    CORE[\"CO-RE Path<br/>clang -target bpf<br/>-D__TARGET_ARCH_xxx\"]\n    NONCORE[\"Non-CO-RE Path<br/>clang + kernel headers\"]\n    \n    CORE_OBJ[\"gotls_kern_core.o\"]\n    NONCORE_OBJ[\"gotls_kern_noncore.o\"]\n    \n    BINDATA[\"go-bindata<br/>Embed bytecode\"]\n    ASSETS[\"assets/ebpf_probe.go\"]\n    \n    SOURCE --> CORE\n    SOURCE --> NONCORE\n    HEADER --> CORE\n    HEADER --> NONCORE\n    CORE --> CORE_OBJ\n    NONCORE --> NONCORE_OBJ\n    CORE_OBJ --> BINDATA\n    NONCORE_OBJ --> BINDATA\n    BINDATA --> ASSETS\n```\n\nThe module selects bytecode at runtime via `geteBPFName()` based on kernel BTF support.\n\n**Sources:** See [5.1](#5.1) for comprehensive build system documentation.\n\n---\n\n## Error Handling and Edge Cases\n\n### Common Failure Scenarios\n\n| Issue | Detection | Mitigation |\n|-------|-----------|-----------|\n| Not a Go binary | `buildinfo.ReadFile()` fails | Return `ErrNotGoCompiledBin` |\n| Architecture mismatch | `runtime.GOARCH != goElfArch` | Return architecture error |\n| Stripped PIE binary | Symbol table not found | Return `ErrorSymbolNotFoundFromTable` |\n| No RET instructions found | `decodeInstruction()` returns empty | Return `ErrorNoRetFound` |\n| Function not found | `LookupFunc()` returns nil | Return `ErrorNoFuncFoundFromSymTabFun` |\n\n**Sources:** [user/config/config_gotls.go:37-44](), [user/module/probe_gotls.go:40]()\n\n### PIE Binary Challenges\n\nPIE binaries present unique challenges:\n1. **Relocated Symbols**: Addresses are relative, requiring runtime calculation\n2. **Hidden Sections**: `.gopclntab` may be unlabeled in `.data.rel.ro`\n3. **Magic Number Search**: Must scan section data for pclntab signature\n4. **Address Translation**: Must account for `PT_LOAD` segment virtual addresses\n\nThe module handles these by parsing the symbol table directly and using `gosym.Table.LookupFunc()` for address resolution.\n\n**Sources:** [user/config/config_gotls.go:281-325](), [user/config/config_gotls.go:327-357]()\n\n---\n\n## Summary\n\nThe Go TLS Module demonstrates sophisticated binary instrumentation techniques tailored to Go's unique runtime characteristics. By parsing ELF structures, detecting ABI conventions, and hooking crypto/tls functions, it captures TLS traffic without requiring source modifications or dynamic library injection. The module's support for both legacy stack-based and modern register-based ABIs ensures compatibility across Go versions 1.0 through current releases.\n\nFor related TLS capture techniques using dynamic libraries, see the OpenSSL Module ([3.1.1](#3.1.1)). For master secret extraction details applicable to both modules, see [3.1.4](#3.1.4)."
          },
          {
            "page_plan": {
              "id": "3.1.3",
              "title": "GnuTLS and NSS Modules"
            },
            "content": "# GnuTLS and NSS Modules\n\n<details>\n<summary>Relevant source files</summary>\n\nThe following files were used as context for generating this wiki page:\n\n- [cli/cmd/bash.go](cli/cmd/bash.go)\n- [cli/cmd/gnutls.go](cli/cmd/gnutls.go)\n- [cli/cmd/gotls.go](cli/cmd/gotls.go)\n- [cli/cmd/mysqld.go](cli/cmd/mysqld.go)\n- [cli/cmd/nspr.go](cli/cmd/nspr.go)\n- [cli/cmd/postgres.go](cli/cmd/postgres.go)\n- [cli/cmd/tls.go](cli/cmd/tls.go)\n- [cli/cmd/zsh.go](cli/cmd/zsh.go)\n- [kern/bash_kern.c](kern/bash_kern.c)\n- [kern/mysqld_kern.c](kern/mysqld_kern.c)\n- [kern/nspr_kern.c](kern/nspr_kern.c)\n- [kern/postgres_kern.c](kern/postgres_kern.c)\n- [pkg/util/ws/client.go](pkg/util/ws/client.go)\n- [pkg/util/ws/client_test.go](pkg/util/ws/client_test.go)\n\n</details>\n\n\n\n## Purpose and Scope\n\nThis document describes the GnuTLS and NSS/NSPR capture modules in eCapture. These modules provide TLS/SSL plaintext capture capabilities for applications using GnuTLS and NSS/NSPR cryptographic libraries, complementing the OpenSSL module (see [OpenSSL Module](#3.1.1)) and GoTLS module (see [Go TLS Module](#3.1.2)). Both modules use eBPF uprobes to intercept read/write functions in their respective libraries, extracting plaintext data before encryption and after decryption.\n\nThe GnuTLS module targets applications built with the GnuTLS library (commonly used by wget, curl variants, and other GNU utilities), while the NSS/NSPR module targets applications using Mozilla's Network Security Services (NSS) and Netscape Portable Runtime (NSPR) libraries, most notably Firefox and Thunderbird.\n\nFor information about TLS master secret extraction across all modules, see [Master Secret Extraction](#3.1.4). For output format details, see [Output Formats](#4).\n\n---\n\n## Module Architecture\n\nBoth modules follow eCapture's standard module pattern, implementing the `IModule` interface (see [Module System and Lifecycle](#2.4)). They share similar architectural patterns with the OpenSSL module but target different library function signatures.\n\n```mermaid\ngraph TB\n    subgraph \"CLI Layer\"\n        GNUTLS_CMD[\"gnutlsCmd<br/>cobra.Command<br/>Alias: 'gnu'\"]\n        NSPR_CMD[\"nssCmd<br/>cobra.Command<br/>Aliases: 'nspr','nss'\"]\n    end\n    \n    subgraph \"Configuration Layer\"\n        GNUTLS_CONFIG[\"GnutlsConfig<br/>--gnutls: library path<br/>--ssl_version<br/>--model: text/pcap/keylog\"]\n        NSPR_CONFIG[\"NsprConfig<br/>--nspr: library path\"]\n    end\n    \n    subgraph \"Module Implementation\"\n        GNUTLS_MOD[\"MGnuTLSProbe<br/>ModuleNameGnutls<br/>IModule implementation\"]\n        NSPR_MOD[\"MNSPRProbe<br/>ModuleNameNspr<br/>IModule implementation\"]\n    end\n    \n    subgraph \"eBPF Programs\"\n        GNUTLS_KERN[\"gnutls_kern.c<br/>gnutls_record_send<br/>gnutls_record_recv\"]\n        NSPR_KERN[\"nspr_kern.c<br/>PR_Write/PR_Read<br/>uprobe/uretprobe\"]\n    end\n    \n    subgraph \"eBPF Maps\"\n        NSPR_EVENTS[\"nspr_events<br/>BPF_MAP_TYPE_PERF_EVENT_ARRAY\"]\n        NSPR_READ_MAP[\"active_ssl_read_args_map<br/>BPF_MAP_TYPE_HASH\"]\n        NSPR_WRITE_MAP[\"active_ssl_write_args_map<br/>BPF_MAP_TYPE_HASH\"]\n        DATA_HEAP[\"data_buffer_heap<br/>BPF_MAP_TYPE_PERCPU_ARRAY\"]\n    end\n    \n    subgraph \"Event Structures\"\n        SSL_EVENT[\"ssl_data_event_t<br/>type: kSSLRead/kSSLWrite<br/>timestamp_ns<br/>pid/tid<br/>data[MAX_DATA_SIZE_OPENSSL]<br/>data_len<br/>comm\"]\n    end\n    \n    GNUTLS_CMD --> GNUTLS_CONFIG\n    NSPR_CMD --> NSPR_CONFIG\n    GNUTLS_CONFIG --> GNUTLS_MOD\n    NSPR_CONFIG --> NSPR_MOD\n    \n    GNUTLS_MOD --> GNUTLS_KERN\n    NSPR_MOD --> NSPR_KERN\n    \n    NSPR_KERN --> NSPR_EVENTS\n    NSPR_KERN --> NSPR_READ_MAP\n    NSPR_KERN --> NSPR_WRITE_MAP\n    NSPR_KERN --> DATA_HEAP\n    \n    NSPR_EVENTS --> SSL_EVENT\n    \n    style GNUTLS_CMD fill:#f9f9f9\n    style NSPR_CMD fill:#f9f9f9\n    style GNUTLS_KERN fill:#e8e8e8\n    style NSPR_KERN fill:#e8e8e8\n    style SSL_EVENT fill:#f0f0f0\n```\n\n**Module Architecture Overview**: Both modules integrate into eCapture's CLI and module system. The GnuTLS module provides more comprehensive configuration options including capture modes (text/pcap/keylog), while NSPR module focuses on text capture. Both use eBPF uprobes to intercept library I/O functions and perf event arrays to stream data to user space.\n\n**Sources**: [cli/cmd/gnutls.go:1-65](), [cli/cmd/nspr.go:1-52](), [kern/nspr_kern.c:1-218]()\n\n---\n\n## Target Libraries\n\n### GnuTLS\n\nGnuTLS is a free software implementation of the TLS, SSL, and DTLS protocols. It provides a high-level API for secure communication and is commonly used in:\n\n- **GNU wget**: Network downloader\n- **curl (GnuTLS variant)**: Command-line HTTP client\n- **Various GNU utilities**: Applications requiring secure networking\n\nThe module targets the core I/O functions:\n- `gnutls_record_send()`: Sends encrypted data\n- `gnutls_record_recv()`: Receives and decrypts data\n\n### NSS/NSPR\n\nNetwork Security Services (NSS) and Netscape Portable Runtime (NSPR) are cryptographic libraries developed by Mozilla:\n\n- **NSS**: Provides cryptographic operations, certificate handling, and SSL/TLS\n- **NSPR**: Provides platform abstraction for I/O, threading, and other system operations\n\nPrimary applications:\n- **Mozilla Firefox**: Web browser\n- **Mozilla Thunderbird**: Email client\n- **Chrome/Chromium (older versions)**: Web browsers\n- **Various Mozilla-based applications**\n\nThe module targets NSPR I/O functions:\n- `PR_Write()`: Writes data to a file descriptor\n- `PR_Read()`: Reads data from a file descriptor\n\n**Sources**: [cli/cmd/gnutls.go:35-36](), [cli/cmd/nspr.go:33-34](), [kern/nspr_kern.c:110-113]()\n\n---\n\n## NSPR/NSS Module Implementation\n\nThe NSPR module demonstrates eCapture's approach to library-specific TLS capture. The implementation uses uprobe entry/exit pairs to capture buffer pointers on entry and extract data on return.\n\n### Hook Points and Data Flow\n\n```mermaid\ngraph TB\n    subgraph \"Application Space\"\n        APP[\"Firefox/Thunderbird<br/>Application\"]\n        NSPR_LIB[\"libnspr44.so<br/>NSPR Library\"]\n    end\n    \n    subgraph \"Kernel eBPF - Entry Probes\"\n        PR_WRITE_ENTRY[\"probe_entry_SSL_write<br/>SEC('uprobe/PR_Write')<br/>PT_REGS_PARM2: buf pointer\"]\n        PR_READ_ENTRY[\"probe_entry_SSL_read<br/>SEC('uprobe/PR_Read')<br/>PT_REGS_PARM2: buf pointer\"]\n    end\n    \n    subgraph \"Kernel eBPF - State Storage\"\n        WRITE_MAP[\"active_ssl_write_args_map<br/>key: pid_tgid<br/>value: buf*\"]\n        READ_MAP[\"active_ssl_read_args_map<br/>key: pid_tgid<br/>value: buf*\"]\n    end\n    \n    subgraph \"Kernel eBPF - Return Probes\"\n        PR_WRITE_RET[\"probe_ret_SSL_write<br/>SEC('uretprobe/PR_Write')<br/>PT_REGS_RC: return value\"]\n        PR_READ_RET[\"probe_ret_SSL_read<br/>SEC('uretprobe/PR_Read')<br/>PT_REGS_RC: return value\"]\n    end\n    \n    subgraph \"Kernel eBPF - Processing\"\n        PROCESS_DATA[\"process_SSL_data()<br/>create_ssl_data_event()<br/>bpf_probe_read_user()<br/>bpf_perf_event_output()\"]\n    end\n    \n    subgraph \"eBPF Maps Output\"\n        PERF_ARRAY[\"nspr_events<br/>BPF_MAP_TYPE_PERF_EVENT_ARRAY\"]\n    end\n    \n    subgraph \"User Space\"\n        EVENT_READER[\"Event Reader<br/>perfEventReader\"]\n        MODULE[\"MNSPRProbe<br/>Module Processing\"]\n    end\n    \n    APP -->|\"PR_Write(fd, buf, len)\"| NSPR_LIB\n    APP -->|\"PR_Read(fd, buf, len)\"| NSPR_LIB\n    \n    NSPR_LIB -->|\"entry hook\"| PR_WRITE_ENTRY\n    NSPR_LIB -->|\"entry hook\"| PR_READ_ENTRY\n    \n    PR_WRITE_ENTRY -->|\"store buf*\"| WRITE_MAP\n    PR_READ_ENTRY -->|\"store buf*\"| READ_MAP\n    \n    NSPR_LIB -->|\"return hook\"| PR_WRITE_RET\n    NSPR_LIB -->|\"return hook\"| PR_READ_RET\n    \n    PR_WRITE_RET -->|\"lookup buf*\"| WRITE_MAP\n    PR_READ_RET -->|\"lookup buf*\"| READ_MAP\n    \n    PR_WRITE_RET --> PROCESS_DATA\n    PR_READ_RET --> PROCESS_DATA\n    \n    PROCESS_DATA -->|\"ssl_data_event_t\"| PERF_ARRAY\n    \n    PERF_ARRAY --> EVENT_READER\n    EVENT_READER --> MODULE\n```\n\n**NSPR Hook Implementation**: The module uses a two-phase approach. Entry probes (`probe_entry_SSL_write`, `probe_entry_SSL_read`) capture buffer pointers and store them in hash maps keyed by thread ID. Return probes (`probe_ret_SSL_write`, `probe_ret_SSL_read`) retrieve the stored pointers, check return values for success, and use `process_SSL_data()` to extract plaintext and emit events. This pattern ensures buffer contents are captured only after successful I/O operations.\n\n**Sources**: [kern/nspr_kern.c:114-217]()\n\n### Event Structure\n\nThe NSPR module uses a unified event structure for both read and write operations:\n\n| Field | Type | Description |\n|-------|------|-------------|\n| `type` | `enum ssl_data_event_type` | `kSSLRead` (0) or `kSSLWrite` (1) |\n| `timestamp_ns` | `u64` | Event timestamp from `bpf_ktime_get_ns()` |\n| `pid` | `u32` | Process ID (upper 32 bits of `pid_tgid`) |\n| `tid` | `u32` | Thread ID (lower 32 bits of `pid_tgid`) |\n| `data` | `char[MAX_DATA_SIZE_OPENSSL]` | Captured plaintext data |\n| `data_len` | `s32` | Actual data length (capped at `MAX_DATA_SIZE_OPENSSL`) |\n| `comm` | `char[TASK_COMM_LEN]` | Process command name from `bpf_get_current_comm()` |\n\n**Sources**: [kern/nspr_kern.c:19-27]()\n\n### eBPF Maps Configuration\n\nThe NSPR module uses four eBPF maps:\n\n```mermaid\ngraph LR\n    subgraph \"Output Maps\"\n        EVENTS[\"nspr_events<br/>BPF_MAP_TYPE_PERF_EVENT_ARRAY<br/>max_entries: 1024\"]\n    end\n    \n    subgraph \"State Management Maps\"\n        READ_ARGS[\"active_ssl_read_args_map<br/>BPF_MAP_TYPE_HASH<br/>key: u64 (tid)<br/>value: const char*<br/>max_entries: 1024\"]\n        \n        WRITE_ARGS[\"active_ssl_write_args_map<br/>BPF_MAP_TYPE_HASH<br/>key: u64 (tid)<br/>value: const char*<br/>max_entries: 1024\"]\n    end\n    \n    subgraph \"Per-CPU Scratch Space\"\n        HEAP[\"data_buffer_heap<br/>BPF_MAP_TYPE_PERCPU_ARRAY<br/>key: u32 (always 0)<br/>value: ssl_data_event_t<br/>max_entries: 1\"]\n    end\n    \n    WRITE_ARGS -.->|\"uprobe stores\"| WRITE_ARGS\n    READ_ARGS -.->|\"uprobe stores\"| READ_ARGS\n    WRITE_ARGS -.->|\"uretprobe reads\"| EVENTS\n    READ_ARGS -.->|\"uretprobe reads\"| EVENTS\n    HEAP -.->|\"avoids stack limit\"| EVENTS\n```\n\n**eBPF Map Design**: The `data_buffer_heap` uses `BPF_MAP_TYPE_PERCPU_ARRAY` to work around eBPF's 512-byte stack limit. Each CPU gets its own `ssl_data_event_t` instance for event construction. The `active_ssl_*_args_map` hash maps provide temporary storage between uprobe entry and return, using thread ID as key to handle concurrent operations.\n\n**Sources**: [kern/nspr_kern.c:29-62]()\n\n---\n\n## GnuTLS Module Implementation\n\nThe GnuTLS module follows a similar architectural pattern to NSPR but targets different library functions and provides more comprehensive capture modes.\n\n### Library Detection and Version Handling\n\nThe GnuTLS CLI command supports version-specific behavior through the `--ssl_version` flag:\n\n```bash\necapture gnutls --ssl_version=3.7.9\n```\n\nThis allows the module to adapt to different GnuTLS API versions and structure layouts. The module automatically searches for `libgnutls.so` if no path is specified.\n\n**Sources**: [cli/cmd/gnutls.go:54]()\n\n### Capture Modes\n\nThe GnuTLS module supports three capture modes via the `--model` flag:\n\n| Mode | Description | Output |\n|------|-------------|--------|\n| `text` | Direct plaintext capture | Console/log file with HTTP/HTTP2 parsing |\n| `pcap`/`pcapng` | Network packet capture with plaintext | PCAP-NG file compatible with Wireshark |\n| `key`/`keylog` | TLS master secrets | SSLKEYLOGFILE format for decryption |\n\n**Sources**: [cli/cmd/gnutls.go:50-53]()\n\n### CLI Usage Examples\n\n```mermaid\ngraph TB\n    subgraph \"Basic Text Capture\"\n        CMD1[\"ecapture gnutls<br/>--hex --pid=3423\"]\n        OUT1[\"Hex-formatted<br/>plaintext output\"]\n        CMD1 --> OUT1\n    end\n    \n    subgraph \"Keylog Mode\"\n        CMD2[\"ecapture gnutls<br/>-m keylog<br/>-k ecapture_gnutls_key.log<br/>--ssl_version=3.7.9\"]\n        OUT2[\"TLS master secrets<br/>SSLKEYLOGFILE format\"]\n        CMD2 --> OUT2\n    end\n    \n    subgraph \"PCAP Mode with TC\"\n        CMD3[\"ecapture gnutls<br/>-m pcap<br/>--pcapfile save.pcapng<br/>-i eth0<br/>--gnutls=/lib/x86_64-linux-gnu/libgnutls.so<br/>tcp port 443\"]\n        OUT3[\"PCAP-NG file<br/>Network packets + plaintext<br/>BPF filter applied\"]\n        CMD3 --> OUT3\n    end\n    \n    subgraph \"Targeted Capture\"\n        CMD4[\"ecapture gnutls<br/>-l save.log<br/>--pid=3423\"]\n        OUT4[\"Process-specific<br/>log file\"]\n        CMD4 --> OUT4\n    end\n```\n\n**GnuTLS CLI Patterns**: The command supports flexible targeting (by PID/UID), custom library paths, network interface attachment for TC-based packet capture, and BPF filter expressions for PCAP mode. The keylog mode enables offline decryption of captured traffic using standard tools like Wireshark.\n\n**Sources**: [cli/cmd/gnutls.go:36-43]()\n\n---\n\n## Filtering and Targeting\n\nBoth modules implement PID and UID filtering at the eBPF level for efficient event processing:\n\n```c\n#ifndef KERNEL_LESS_5_2\n    // if target_ppid is 0 then we target all pids\n    if (target_pid != 0 && target_pid != pid) {\n        return 0;\n    }\n    if (target_uid != 0 && target_uid != uid) {\n        return 0;\n    }\n#endif\n```\n\nThis filtering pattern appears in all hook functions and operates in kernel space before any data is captured, minimizing performance overhead. The conditional compilation (`#ifndef KERNEL_LESS_5_2`) indicates that global variables for filtering are only available in kernels 5.2+.\n\n**Sources**: [kern/nspr_kern.c:122-130](), [kern/nspr_kern.c:147-153](), [kern/nspr_kern.c:177-185](), [kern/nspr_kern.c:200-208]()\n\n---\n\n## Data Capture Implementation\n\n### Buffer Size Management\n\nBoth modules use size-limited buffers with bitwise masking for safety:\n\n```c\n// NSPR module data capture\nevent->data_len = (len < MAX_DATA_SIZE_OPENSSL ? \n                   (len & (MAX_DATA_SIZE_OPENSSL - 1)) : \n                   MAX_DATA_SIZE_OPENSSL);\nbpf_probe_read_user(event->data, event->data_len, buf);\n```\n\nThe bitwise AND operation `(len & (MAX_DATA_SIZE_OPENSSL - 1))` ensures the size doesn't exceed the buffer even if the comparison fails due to verifier limitations. This pattern is common across eCapture's eBPF programs for eBPF verifier compliance.\n\n**Sources**: [kern/nspr_kern.c:100-101]()\n\n### Event Creation and Output\n\nThe NSPR module uses a helper function to create events from per-CPU scratch space:\n\n```c\nstatic __inline struct ssl_data_event_t* create_ssl_data_event(u64 current_pid_tgid) {\n    u32 kZero = 0;\n    struct ssl_data_event_t* event = bpf_map_lookup_elem(&data_buffer_heap, &kZero);\n    if (event == NULL) {\n        return NULL;\n    }\n    \n    const u32 kMask32b = 0xffffffff;\n    event->timestamp_ns = bpf_ktime_get_ns();\n    event->pid = current_pid_tgid >> 32;\n    event->tid = current_pid_tgid & kMask32b;\n    return event;\n}\n```\n\nThis function avoids stack allocation by using a per-CPU array map, working around the 512-byte eBPF stack limit. Events are then output via `bpf_perf_event_output()` to the `nspr_events` perf array.\n\n**Sources**: [kern/nspr_kern.c:68-80](), [kern/nspr_kern.c:103]()\n\n---\n\n## Integration with Event Processing Pipeline\n\nBoth modules integrate with eCapture's event processing system (see [Event Processing Pipeline](#2.2)):\n\n```mermaid\ngraph LR\n    subgraph \"eBPF Space\"\n        KERN[\"nspr_kern.c or<br/>gnutls_kern.c<br/>bpf_perf_event_output()\"]\n        MAP[\"nspr_events or<br/>gnutls_events<br/>Perf Event Array\"]\n        KERN --> MAP\n    end\n    \n    subgraph \"User Space - Module\"\n        READER[\"perfEventReader<br/>Read from perf array\"]\n        WORKER[\"Event Worker<br/>IWorker interface<br/>Connection tracking\"]\n        PARSER[\"Protocol Parser<br/>IParser interface<br/>HTTP/HTTP2\"]\n        MAP --> READER\n        READER --> WORKER\n        WORKER --> PARSER\n    end\n    \n    subgraph \"Output Layer\"\n        TEXT[\"Text Output<br/>Console/File<br/>Hex formatting\"]\n        PCAP[\"PCAP Writer<br/>gopacket serialization<br/>DSB for keys\"]\n        KEYLOG[\"Keylog Writer<br/>SSLKEYLOGFILE format\"]\n        PARSER --> TEXT\n        PARSER --> PCAP\n        PARSER --> KEYLOG\n    end\n```\n\n**Event Processing Integration**: Events flow from eBPF programs through perf arrays to the module's event reader. The worker layer manages connection state and lifecycle, while parsers decode protocol data (HTTP/HTTP2). Output handlers format data according to the selected mode (text/pcap/keylog).\n\n**Sources**: [cli/cmd/gnutls.go:50-53](), [cli/cmd/nspr.go:34-39]()\n\n---\n\n## Comparison with Other TLS Modules\n\nThe following table compares GnuTLS and NSS modules with other TLS capture modules:\n\n| Feature | OpenSSL | GoTLS | GnuTLS | NSS/NSPR |\n|---------|---------|-------|--------|----------|\n| **Primary Target** | OpenSSL/BoringSSL apps | Go TLS apps | GNU utilities | Mozilla apps |\n| **Hook Functions** | SSL_read/SSL_write | crypto/tls.Conn.Read/Write | gnutls_record_recv/send | PR_Read/PR_Write |\n| **Version Detection** | Extensive (1.0.x-3.5.x) | Go version + ABI | Optional | Optional |\n| **Master Secret Extraction** | Yes (TLS 1.2/1.3) | Yes | Yes | Limited |\n| **PCAP Mode** | Yes with TC | Yes with TC | Yes with TC | Limited |\n| **Keylog Format** | Yes | Yes | Yes | No |\n| **Android Support** | Yes (BoringSSL) | No | No | No |\n| **CLI Complexity** | High | Medium | Medium | Low |\n\n**Module Comparison**: GnuTLS and NSS modules provide simpler implementations compared to OpenSSL due to less version fragmentation. NSS module is the most minimal, focusing on basic text capture. GnuTLS offers a middle ground with keylog and PCAP support but without the extensive version-specific bytecode variants required by OpenSSL.\n\n**Sources**: [cli/cmd/tls.go:1-68](), [cli/cmd/gotls.go:1-59](), [cli/cmd/gnutls.go:1-65](), [cli/cmd/nspr.go:1-52]()\n\n---\n\n## Build System Integration\n\nBoth modules are conditionally compiled based on platform:\n\n```go\n//go:build !androidgki\n// +build !androidgki\n```\n\nThis build tag excludes GnuTLS and NSS modules from Android builds, as these libraries are not typically available on Android platforms. The OpenSSL/BoringSSL module handles Android's TLS requirements.\n\nThe modules integrate with eCapture's build system:\n- **eBPF compilation**: `kern/gnutls_kern.c` and `kern/nspr_kern.c` compiled via Makefile\n- **CO-RE support**: Both support BTF-enabled kernels for portability\n- **Non-CO-RE fallback**: Kernel header-based compilation for older systems\n- **Asset embedding**: Bytecode embedded via go-bindata into the final binary\n\n**Sources**: [cli/cmd/gnutls.go:1-2](), [cli/cmd/nspr.go:1-2]()\n\n---\n\n## Usage Examples\n\n### Capturing Firefox Traffic (NSS)\n\n```bash\n# Basic capture with hex output\necapture nspr --hex --pid=$(pgrep firefox)\n\n# Save to log file\necapture nspr -l firefox_capture.log --pid=$(pgrep firefox)\n\n# Specify NSPR library path manually\necapture nspr --nspr=/usr/lib/x86_64-linux-gnu/libnspr4.so\n```\n\n### Capturing wget Traffic (GnuTLS)\n\n```bash\n# Text mode with automatic library detection\necapture gnutls\n\n# PCAP mode with network interface and BPF filter\necapture gnutls -m pcap --pcapfile wget_traffic.pcapng -i eth0 \\\n  --gnutls=/lib/x86_64-linux-gnu/libgnutls.so.30 \\\n  tcp port 443\n\n# Keylog mode for offline decryption\necapture gnutls -m keylog -k gnutls_keys.log --ssl_version=3.7.9\n\n# Targeted capture by PID\necapture gnutls --pid=$(pgrep wget) -l wget_output.log\n```\n\n### Advanced Filtering\n\n```bash\n# Capture only specific user's traffic\necapture gnutls --uid=1000\n\n# PCAP with complex BPF filter\necapture gnutls -m pcap -w capture.pcapng -i wlan0 \\\n  \"host 192.168.1.100 and tcp port 443\"\n```\n\n**Sources**: [cli/cmd/nspr.go:35-39](), [cli/cmd/gnutls.go:36-43]()\n\n---\n\n## Limitations and Considerations\n\n### NSS/NSPR Module Limitations\n\n1. **No PCAP mode**: Unlike GnuTLS, the NSPR module doesn't support PCAP output mode\n2. **No keylog support**: Master secret extraction is not implemented\n3. **Limited configuration**: Fewer CLI options compared to other TLS modules\n4. **NSPR-specific**: Only captures data through PR_Read/PR_Write, not NSS's higher-level functions\n\n### GnuTLS Module Limitations\n\n1. **Version sensitivity**: Some GnuTLS versions may have different structure layouts\n2. **Limited adoption**: Fewer applications use GnuTLS compared to OpenSSL\n3. **Master secret extraction complexity**: TLS 1.3 secrets require version-specific offsets\n\n### General Considerations\n\n- **Library detection**: Automatic detection may fail if libraries are in non-standard paths\n- **Performance overhead**: Capturing all traffic from busy applications (e.g., Firefox) can generate significant data\n- **Kernel version**: Some features require kernel 5.2+ for global variable support\n- **BTF requirement**: CO-RE mode requires kernel with BTF support\n\n**Sources**: [cli/cmd/nspr.go:43-45](), [cli/cmd/gnutls.go:47-55](), [kern/nspr_kern.c:122-130]()\n\n---\n\n## Related Modules\n\nFor comprehensive TLS capture coverage across different applications and libraries:\n\n- **[OpenSSL Module](#3.1.1)**: Primary module for OpenSSL/BoringSSL applications\n- **[Go TLS Module](#3.1.2)**: Specialized module for Go applications using crypto/tls\n- **[Master Secret Extraction](#3.1.4)**: Deep dive into TLS key material extraction\n- **[TC-based Packet Capture](#3.3)**: Network-level packet capture with process attribution\n\nThe GnuTLS and NSS modules extend eCapture's coverage to applications outside the OpenSSL ecosystem, enabling comprehensive TLS observability across diverse application stacks."
          },
          {
            "page_plan": {
              "id": "3.1.4",
              "title": "Master Secret Extraction"
            },
            "content": "# Master Secret Extraction\n\n<details>\n<summary>Relevant source files</summary>\n\nThe following files were used as context for generating this wiki page:\n\n- [cli/cmd/root.go](cli/cmd/root.go)\n- [kern/boringssl_const.h](kern/boringssl_const.h)\n- [kern/boringssl_masterkey.h](kern/boringssl_masterkey.h)\n- [kern/openssl_masterkey.h](kern/openssl_masterkey.h)\n- [kern/openssl_masterkey_3.0.h](kern/openssl_masterkey_3.0.h)\n- [user/config/iconfig.go](user/config/iconfig.go)\n- [user/module/imodule.go](user/module/imodule.go)\n- [user/module/probe_openssl.go](user/module/probe_openssl.go)\n- [utils/boringssl-offset.c](utils/boringssl-offset.c)\n\n</details>\n\n\n\nThis document describes the mechanisms eCapture uses to extract TLS master secrets and traffic keys from OpenSSL and BoringSSL libraries. These secrets enable decryption of captured TLS traffic without requiring certificate private keys.\n\nFor information about general TLS capture architecture, see [OpenSSL Module](#3.1.1). For keylog file generation and PCAP integration, see [TLS Key Logging](#4.3) and [PCAP Integration](#4.2).\n\n## Overview\n\nMaster secret extraction operates through eBPF uprobes attached to SSL/TLS library functions. eCapture intercepts cryptographic handshakes to capture:\n\n- **TLS 1.2**: Single master secret derived during handshake\n- **TLS 1.3**: Multiple traffic secrets (handshake, client/server traffic, exporter secrets)\n\nThe extracted secrets are exported in SSLKEYLOGFILE format for use with Wireshark and other decryption tools.\n\nSources: [user/module/probe_openssl.go:482-575](), [kern/openssl_masterkey.h:25-39](), [kern/boringssl_masterkey.h:37-56]()\n\n## TLS Version Differences\n\n### TLS 1.2 Secret Extraction\n\nTLS 1.2 uses a single 48-byte `master_key` derived from the pre-master secret and client/server random values. This master key remains constant for the session.\n\n```mermaid\ngraph LR\n    subgraph \"TLS 1.2 Structure Navigation\"\n        SSL_ST[\"ssl_st\"]\n        SESSION[\"ssl_session_st\"]\n        MASTER[\"master_key[48]\"]\n        CLIENT_RND[\"client_random[32]\"]\n        \n        SSL_ST -->|\"SSL_ST_SESSION\"| SESSION\n        SSL_ST -->|\"SSL_ST_S3\"| S3[\"ssl3_state_st\"]\n        S3 -->|\"SSL3_STATE_ST_CLIENT_RANDOM\"| CLIENT_RND\n        SESSION -->|\"SSL_SESSION_ST_MASTER_KEY\"| MASTER\n    end\n```\n\n**TLS 1.2 Extraction Process:**\n1. Read `ssl_st->version` to verify TLS version\n2. Navigate to `ssl_st->s3->client_random` for the 32-byte random value\n3. Navigate to `ssl_st->session->master_key` for the 48-byte master secret\n4. Format as: `CLIENT_RANDOM <client_random> <master_key>`\n\nSources: [kern/openssl_masterkey.h:151-168](), [kern/boringssl_masterkey.h:288-342]()\n\n### TLS 1.3 Secret Extraction\n\nTLS 1.3 replaced the single master secret with multiple derived secrets for different phases:\n\n| Secret Type | Purpose | Size |\n|------------|---------|------|\n| `early_secret` | Early data (0-RTT) | 32 or 48 bytes |\n| `handshake_secret` | Handshake encryption | 32 or 48 bytes |\n| `client_handshake_secret` | Derived from handshake_secret | 32 or 48 bytes |\n| `server_handshake_secret` | Derived from handshake_secret | 32 or 48 bytes |\n| `client_app_traffic_secret` | Client application data | 32 or 48 bytes |\n| `server_app_traffic_secret` | Server application data | 32 or 48 bytes |\n| `exporter_master_secret` | Key exporters | 32 or 48 bytes |\n\nThe secret length depends on cipher suite (32 bytes for SHA256-based, 48 bytes for SHA384-based).\n\nSources: [kern/openssl_masterkey.h:171-256](), [kern/boringssl_masterkey.h:344-402](), [user/module/probe_openssl.go:502-551]()\n\n## OpenSSL vs BoringSSL Extraction\n\n### OpenSSL Structure Layout\n\nOpenSSL stores TLS 1.3 secrets directly in the `ssl_st` structure at fixed offsets:\n\n```mermaid\ngraph TB\n    subgraph \"OpenSSL ssl_st Structure\"\n        SSL_ST[\"ssl_st\"]\n        VERSION[\"version\"]\n        SESSION[\"session*\"]\n        S3[\"s3*\"]\n        EARLY[\"early_secret[64]\"]\n        HS[\"handshake_secret[64]\"]\n        HTH[\"handshake_traffic_hash[64]\"]\n        CATS[\"client_app_traffic_secret[64]\"]\n        SATS[\"server_app_traffic_secret[64]\"]\n        EMS[\"exporter_master_secret[64]\"]\n        \n        SSL_ST --> VERSION\n        SSL_ST --> SESSION\n        SSL_ST --> S3\n        SSL_ST --> EARLY\n        SSL_ST --> HS\n        SSL_ST --> HTH\n        SSL_ST --> CATS\n        SSL_ST --> SATS\n        SSL_ST --> EMS\n    end\n```\n\n**OpenSSL Offset Macros** (version-specific):\n- `SSL_ST_VERSION`: Version field offset\n- `SSL_ST_SESSION`: Session pointer offset\n- `SSL_ST_EARLY_SECRET`: Early secret offset (TLS 1.3)\n- `SSL_ST_HANDSHAKE_SECRET`: Handshake secret offset\n- `SSL_ST_CLIENT_APP_TRAFFIC_SECRET`: Client traffic secret offset\n- `SSL_ST_SERVER_APP_TRAFFIC_SECRET`: Server traffic secret offset\n- `SSL_ST_EXPORTER_MASTER_SECRET`: Exporter secret offset\n\nSources: [kern/openssl_masterkey.h:80-257](), [kern/openssl_masterkey_3.0.h:80-253]()\n\n### BoringSSL Structure Layout\n\nBoringSSL stores TLS 1.3 secrets in the `SSL_HANDSHAKE` structure (accessible via `ssl_st->s3->hs`), and some secrets are marked `private`, requiring manual offset calculation:\n\n```mermaid\ngraph TB\n    subgraph \"BoringSSL Structure Hierarchy\"\n        SSL_ST[\"ssl_st\"]\n        S3[\"ssl3_state_st (s3)\"]\n        HS[\"SSL_HANDSHAKE (hs)\"]\n        NEW_SESSION[\"new_session*\"]\n        \n        SSL_ST -->|\"SSL_ST_S3\"| S3\n        S3 -->|\"BSSL__SSL3_STATE_HS\"| HS\n        S3 -->|\"BSSL__SSL3_STATE_EXPORTER_SECRET\"| EXPORT_SEC[\"exporter_secret[64]\"]\n        HS -->|\"BSSL__SSL_HANDSHAKE_NEW_SESSION\"| NEW_SESSION\n        HS -->|\"SSL_HANDSHAKE_HASH_LEN_\"| HASH_LEN[\"hash_len_\"]\n        HS -->|\"private fields\"| SECRETS[\"secret_, early_traffic_secret_,<br/>client_handshake_secret_,<br/>server_handshake_secret_,<br/>client_traffic_secret_0_,<br/>server_traffic_secret_0_\"]\n    end\n```\n\n**Private Field Offset Calculation:**\n\nBoringSSL's `SSL_HANDSHAKE` structure contains private fields that cannot be accessed via standard `offsetof()`. The offsets are computed manually:\n\n```c\n// max_version is the last public field (uint16_t, offset 30)\n// After memory alignment to 8 bytes: offset 32\n// hash_len_ (size_t): offset 32\n// secret_ starts at: 32 + sizeof(size_t) = 40\n#define SSL_HANDSHAKE_HASH_LEN_ roundup(BSSL__SSL_HANDSHAKE_MAX_VERSION+2,8)\n#define SSL_HANDSHAKE_SECRET_ SSL_HANDSHAKE_HASH_LEN_+8\n#define SSL_HANDSHAKE_EARLY_TRAFFIC_SECRET_ SSL_HANDSHAKE_SECRET_+SSL_MAX_MD_SIZE*1\n#define SSL_HANDSHAKE_CLIENT_HANDSHAKE_SECRET_ SSL_HANDSHAKE_SECRET_+SSL_MAX_MD_SIZE*2\n// ... and so on\n```\n\nSources: [kern/boringssl_const.h:28-60](), [kern/boringssl_masterkey.h:90-98](), [utils/boringssl-offset.c:23-78]()\n\n## eBPF Hook Point\n\nBoth OpenSSL and BoringSSL extraction use the same hook point strategy:\n\n**Uprobe Function:** `SSL_write_key` (symbolic name, actual function varies)\n\nThe eBPF program `probe_ssl_master_key` is attached as a uprobe to SSL/TLS library functions. The actual hook functions are determined by version detection (see [Version Detection and Bytecode Selection](#2.5)):\n\n| Hook Function | Library | Purpose |\n|--------------|---------|---------|\n| `SSL_write` | OpenSSL/BoringSSL | Main hook point for capturing secrets during writes |\n| `SSL_do_handshake` | OpenSSL/BoringSSL | Handshake completion hook |\n| `SSL_get_wbio` | BoringSSL | BIO retrieval for connection tracking |\n| `SSL_in_before` | OpenSSL 1.1.0+ | Handshake state check |\n| `SSL_state` | OpenSSL 1.0.x | Alternative handshake state (older versions) |\n\nThe master hook functions are configured in [user/module/probe_openssl_masterkey.go:13-21]():\n\n```go\nvar masterKeyHookFuncs = []string{\n    \"SSL_write\",\n    \"SSL_read\",\n    \"SSL_do_handshake\",\n}\n```\n\nSources: [kern/openssl_masterkey.h:81-82](), [kern/boringssl_masterkey.h:169-170](), [user/module/probe_openssl.go:104](), [user/module/probe_openssl.go:179-195]()\n\n## Extraction Flow\n\n### Complete Extraction Pipeline\n\n```mermaid\nflowchart TD\n    subgraph \"Kernel Space - eBPF\"\n        UPROBE[\"uprobe: probe_ssl_master_key\"]\n        SSL_PTR[\"Read ssl_st* from PT_REGS_PARM1\"]\n        VER_CHECK[\"Check TLS Version<br/>(ssl_st->version)\"]\n        \n        TLS12[\"TLS 1.2 Extraction\"]\n        TLS13[\"TLS 1.3 Extraction\"]\n        \n        CLIENT_RND[\"Read client_random[32]<br/>(ssl_st->s3->client_random)\"]\n        \n        MASTER12[\"Read master_key[48]<br/>(ssl_session_st->master_key)\"]\n        \n        SECRETS13[\"Read multiple secrets:<br/>handshake_secret,<br/>client/server traffic secrets,<br/>exporter_secret\"]\n        \n        EVENT_OUT[\"bpf_perf_event_output<br/>(mastersecret_events)\"]\n    end\n    \n    subgraph \"User Space - Go\"\n        READ_EVENT[\"perfEventReader reads<br/>MasterSecretEvent\"]\n        DISPATCH[\"Dispatcher routes event\"]\n        SAVE[\"saveMasterSecret/<br/>saveMasterSecretBSSL\"]\n        \n        NULL_CHECK[\"Null Secret Validation\"]\n        DEDUP[\"Deduplication Check<br/>(masterKeys map)\"]\n        \n        FORMAT12[\"Format TLS 1.2:<br/>CLIENT_RANDOM <cr> <mk>\"]\n        FORMAT13[\"Format TLS 1.3:<br/>Multiple lines with<br/>HKDF expansion\"]\n        \n        OUTPUT[\"Write to keylogger file<br/>or PCAP DSB block\"]\n    end\n    \n    UPROBE --> SSL_PTR\n    SSL_PTR --> VER_CHECK\n    VER_CHECK -->|\"!= TLS1_3_VERSION\"| TLS12\n    VER_CHECK -->|\"== TLS1_3_VERSION\"| TLS13\n    \n    TLS12 --> CLIENT_RND\n    TLS13 --> CLIENT_RND\n    \n    CLIENT_RND --> MASTER12\n    TLS12 --> MASTER12\n    \n    CLIENT_RND --> SECRETS13\n    TLS13 --> SECRETS13\n    \n    MASTER12 --> EVENT_OUT\n    SECRETS13 --> EVENT_OUT\n    \n    EVENT_OUT --> READ_EVENT\n    READ_EVENT --> DISPATCH\n    DISPATCH --> SAVE\n    \n    SAVE --> NULL_CHECK\n    NULL_CHECK -->|\"Not null\"| DEDUP\n    NULL_CHECK -->|\"All null\"| DISCARD[\"Discard Event\"]\n    \n    DEDUP -->|\"New\"| FORMAT12\n    DEDUP -->|\"New\"| FORMAT13\n    DEDUP -->|\"Duplicate\"| DISCARD\n    \n    FORMAT12 --> OUTPUT\n    FORMAT13 --> OUTPUT\n```\n\nSources: [kern/openssl_masterkey.h:82-257](), [kern/boringssl_masterkey.h:170-403](), [user/module/probe_openssl.go:482-642]()\n\n### State Validation\n\nThe eBPF programs check handshake state to ensure secrets are only captured after negotiation completes:\n\n**OpenSSL:** No explicit state check (relies on secret availability)\n\n**BoringSSL TLS 1.2:**\n```c\nif (ssl3_hs_state.state < CLIENT_STATE12_SEND_CLIENT_FINISHED) {\n    return 0; // not finished yet\n}\n```\n\n**BoringSSL TLS 1.3:**\n```c\nif (ssl3_hs_state.tls13_state < CLIENT_STATE13_READ_SERVER_FINISHED) {\n    return 0; // not finished yet\n}\n```\n\nSources: [kern/boringssl_masterkey.h:263-292](), [kern/boringssl_masterkey.h:345-348]()\n\n## Data Structures\n\n### Kernel-Side Event Structures\n\n**OpenSSL Event Structure:**\n\n```c\nstruct mastersecret_t {\n    s32 version;                                   // TLS version\n    u8 client_random[SSL3_RANDOM_SIZE];            // 32 bytes\n    u8 master_key[MASTER_SECRET_MAX_LEN];          // 48 bytes (TLS 1.2)\n    \n    // TLS 1.3 fields\n    u32 cipher_id;                                 // Cipher suite ID\n    u8 early_secret[EVP_MAX_MD_SIZE];              // 64 bytes\n    u8 handshake_secret[EVP_MAX_MD_SIZE];          // 64 bytes\n    u8 handshake_traffic_hash[EVP_MAX_MD_SIZE];    // 64 bytes\n    u8 client_app_traffic_secret[EVP_MAX_MD_SIZE]; // 64 bytes\n    u8 server_app_traffic_secret[EVP_MAX_MD_SIZE]; // 64 bytes\n    u8 exporter_master_secret[EVP_MAX_MD_SIZE];    // 64 bytes\n};\n```\n\n**BoringSSL Event Structure:**\n\n```c\nstruct mastersecret_bssl_t {\n    s32 version;                                   // TLS version\n    u8 client_random[SSL3_RANDOM_SIZE];            // 32 bytes\n    u8 secret_[MASTER_SECRET_MAX_LEN];             // 48 bytes (TLS 1.2)\n    \n    // TLS 1.3 fields\n    u32 hash_len;                                  // Hash length (32 or 48)\n    u8 early_traffic_secret_[EVP_MAX_MD_SIZE];    // 64 bytes\n    u8 client_handshake_secret_[EVP_MAX_MD_SIZE]; // 64 bytes\n    u8 server_handshake_secret_[EVP_MAX_MD_SIZE]; // 64 bytes\n    u8 client_traffic_secret_0_[EVP_MAX_MD_SIZE]; // 64 bytes\n    u8 server_traffic_secret_0_[EVP_MAX_MD_SIZE]; // 64 bytes\n    u8 exporter_secret[EVP_MAX_MD_SIZE];          // 64 bytes\n};\n```\n\nSources: [kern/openssl_masterkey.h:25-39](), [kern/boringssl_masterkey.h:37-56]()\n\n### User-Space Event Structures\n\nThe Go-side mirrors these structures in [user/event/event_openssl.go]():\n\n- `MasterSecretEvent`: OpenSSL master secret event\n- `MasterSecretBSSLEvent`: BoringSSL master secret event\n\nBoth implement the `IEventStruct` interface for unified event processing.\n\nSources: [user/module/probe_openssl.go:50-56]()\n\n## Master Secret Processing\n\n### User-Space Handler: saveMasterSecret\n\nThe `saveMasterSecret` function processes OpenSSL master secret events:\n\n```mermaid\nflowchart TD\n    START[\"saveMasterSecret(secretEvent)\"]\n    \n    KEY[\"Generate key:<br/>fmt.Sprintf('%02x', client_random)\"]\n    \n    DEDUP{\"Key exists in<br/>masterKeys map?\"}\n    \n    VER_CHECK{\"TLS Version\"}\n    \n    TLS12_PROC[\"TLS 1.2 Processing\"]\n    NULL12[\"Check master_key != all zeros\"]\n    FMT12[\"Format: CLIENT_RANDOM <cr> <mk>\"]\n    \n    TLS13_PROC[\"TLS 1.3 Processing\"]\n    CIPHER[\"Determine hash length<br/>based on cipher_id\"]\n    EXPAND[\"HKDF Expand:<br/>client_handshake_secret,<br/>server_handshake_secret\"]\n    NULL13[\"Validate secrets != all zeros\"]\n    FMT13[\"Format multiple lines:<br/>CLIENT_HANDSHAKE_TRAFFIC_SECRET,<br/>SERVER_HANDSHAKE_TRAFFIC_SECRET,<br/>CLIENT_TRAFFIC_SECRET_0,<br/>SERVER_TRAFFIC_SECRET_0,<br/>EXPORTER_SECRET\"]\n    \n    WRITE[\"Write to output\"]\n    KEYLOG[\"Write to keylogger file\"]\n    PCAP[\"Save to PCAP DSB block\"]\n    MARK[\"Mark key as saved:<br/>masterKeys[k] = true\"]\n    \n    START --> KEY\n    KEY --> DEDUP\n    DEDUP -->|\"Yes\"| RETURN[\"Return (skip duplicate)\"]\n    DEDUP -->|\"No\"| VER_CHECK\n    \n    VER_CHECK -->|\"TLS 1.2\"| TLS12_PROC\n    VER_CHECK -->|\"TLS 1.3\"| TLS13_PROC\n    \n    TLS12_PROC --> NULL12\n    NULL12 -->|\"Valid\"| FMT12\n    NULL12 -->|\"All zeros\"| RETURN\n    FMT12 --> MARK\n    \n    TLS13_PROC --> CIPHER\n    CIPHER --> EXPAND\n    EXPAND --> NULL13\n    NULL13 -->|\"Valid\"| FMT13\n    NULL13 -->|\"Has nulls\"| RETURN\n    FMT13 --> MARK\n    \n    MARK --> WRITE\n    WRITE -->|\"TlsCaptureModelTypeKeylog\"| KEYLOG\n    WRITE -->|\"TlsCaptureModelTypePcap\"| PCAP\n    KEYLOG --> DONE[\"Done\"]\n    PCAP --> DONE\n```\n\nSources: [user/module/probe_openssl.go:482-575]()\n\n### TLS 1.3 HKDF Expansion\n\nFor TLS 1.3, the handshake secrets must be expanded using HKDF-Expand-Label:\n\n**Cipher Suite Hash Determination:**\n\n| Cipher Suite | Hash | Length |\n|-------------|------|--------|\n| `TLS_AES_128_GCM_SHA256` | SHA256 | 32 bytes |\n| `TLS_CHACHA20_POLY1305_SHA256` | SHA256 | 32 bytes |\n| `TLS_AES_256_GCM_SHA384` | SHA384 | 48 bytes |\n\n**HKDF-Expand-Label Invocations:**\n\n```go\n// Expand handshake secret into client/server handshake secrets\nclientHandshakeSecret := hkdf.ExpandLabel(\n    secretEvent.HandshakeSecret[:length],\n    hkdf.ClientHandshakeTrafficLabel,\n    secretEvent.HandshakeTrafficHash[:length],\n    length,\n    transcript\n)\n\nserverHandshakeSecret := hkdf.ExpandLabel(\n    secretEvent.HandshakeSecret[:length],\n    hkdf.ServerHandshakeTrafficLabel,\n    secretEvent.HandshakeTrafficHash[:length],\n    length,\n    transcript\n)\n```\n\nLabels used:\n- `ClientHandshakeTrafficLabel`: \"c hs traffic\"\n- `ServerHandshakeTrafficLabel`: \"s hs traffic\"\n\nSources: [user/module/probe_openssl.go:502-551](), [pkg/util/hkdf/hkdf.go]()\n\n### Null Secret Validation\n\nBoth TLS 1.2 and TLS 1.3 secrets are validated to ensure they are not all zeros (which would indicate an error or incomplete handshake):\n\n**TLS 1.2 Validation:**\n```go\nfunc (m *MOpenSSLProbe) mk12NullSecrets(hashLen int, secret []byte) bool {\n    isNull := true\n    for i := 0; i < hashLen; i++ {\n        if secret[i] != 0 {\n            isNull = false\n            break\n        }\n    }\n    return isNull\n}\n```\n\n**TLS 1.3 Validation:**\nThe function checks all five secrets (client handshake, client traffic, server handshake, server traffic, exporter) and returns `true` if any remain all-zero:\n\n```go\nfunc (m *MOpenSSLProbe) mk13NullSecrets(hashLen int,\n    ClientHandshakeSecret [64]byte,\n    ClientTrafficSecret0 [64]byte,\n    ServerHandshakeSecret [64]byte,\n    ServerTrafficSecret0 [64]byte,\n    ExporterSecret [64]byte) bool {\n    // Returns true if any secret is still null\n    // ...\n}\n```\n\nSources: [user/module/probe_openssl.go:652-731]()\n\n## Output Formats\n\n### SSLKEYLOGFILE Format\n\nThe standard format for TLS key logging:\n\n**TLS 1.2:**\n```\nCLIENT_RANDOM <64 hex digits client_random> <96 hex digits master_key>\n```\n\n**TLS 1.3:**\n```\nCLIENT_HANDSHAKE_TRAFFIC_SECRET <64 hex digits client_random> <64-96 hex digits>\nSERVER_HANDSHAKE_TRAFFIC_SECRET <64 hex digits client_random> <64-96 hex digits>\nCLIENT_TRAFFIC_SECRET_0 <64 hex digits client_random> <64-96 hex digits>\nSERVER_TRAFFIC_SECRET_0 <64 hex digits client_random> <64-96 hex digits>\nEXPORTER_SECRET <64 hex digits client_random> <64-96 hex digits>\n```\n\n### Output Modes\n\nBased on `TlsCaptureModelType` configuration:\n\n| Mode | Implementation | Output Location |\n|------|---------------|-----------------|\n| `TlsCaptureModelTypeKeylog` | Write to file via `m.keylogger.WriteString()` | Keylog file specified by `--keylog` flag |\n| `TlsCaptureModelTypePcap` | Embed in PCAP-NG DSB block via `m.savePcapngSslKeyLog()` | Inside PCAP-NG file |\n| `TlsCaptureModelTypeText` | No output (secrets not needed) | N/A |\n\nSources: [user/module/probe_openssl.go:58-76](), [user/module/probe_openssl.go:558-574]()\n\n## Offset Calculation Utilities\n\n### BoringSSL Offset Generator\n\nThe `boringssl-offset.c` utility generates offset macros for BoringSSL structures by compiling against BoringSSL headers:\n\n```bash\ng++ -I include/ -I src/ ./utils/boringssl-offset.c -o off\n./off > generated_offsets.h\n```\n\nIt uses the `offsetof()` macro for public fields:\n\n```c\n#define X(struct_name, field_name) \\\n    format(#struct_name, #field_name, offsetof(struct struct_name, field_name));\nSSL_STRUCT_OFFSETS\n#undef X\n```\n\nOutput example:\n```c\n// ssl_st->version\n#define SSL_ST_VERSION 0x10\n\n// ssl_st->session\n#define SSL_ST_SESSION 0x18\n```\n\nFor private fields in BoringSSL, manual calculation is required (see [BoringSSL Structure Layout](#boringssl-structure-layout)).\n\nSources: [utils/boringssl-offset.c:1-78](), [kern/boringssl_const.h:28-60]()\n\n## Deduplication Strategy\n\nThe `masterKeys` map prevents duplicate master secret output:\n\n```go\ntype MOpenSSLProbe struct {\n    // ...\n    masterKeys map[string]bool\n}\n```\n\n**Key:** Hexadecimal representation of `client_random` (32 bytes → 64 hex characters)\n\n**Value:** Boolean flag indicating whether the secret has been saved\n\nWhen a new master secret event arrives:\n1. Generate key: `k := fmt.Sprintf(\"%02x\", secretEvent.ClientRandom)`\n2. Check existence: `_, f := m.masterKeys[k]`\n3. If exists, return early (duplicate)\n4. If new, process and mark: `m.masterKeys[k] = true`\n\nThis prevents duplicate entries when multiple SSL/TLS functions are hooked on the same connection.\n\nSources: [user/module/probe_openssl.go:98](), [user/module/probe_openssl.go:482-489](), [user/module/probe_openssl.go:500](), [user/module/probe_openssl.go:533]()"
          },
          {
            "page_plan": {
              "id": "3.2",
              "title": "System Audit Modules"
            },
            "content": "# System Audit Modules\n\n<details>\n<summary>Relevant source files</summary>\n\nThe following files were used as context for generating this wiki page:\n\n- [cli/cmd/bash.go](cli/cmd/bash.go)\n- [cli/cmd/gnutls.go](cli/cmd/gnutls.go)\n- [cli/cmd/gotls.go](cli/cmd/gotls.go)\n- [cli/cmd/mysqld.go](cli/cmd/mysqld.go)\n- [cli/cmd/nspr.go](cli/cmd/nspr.go)\n- [cli/cmd/postgres.go](cli/cmd/postgres.go)\n- [cli/cmd/tls.go](cli/cmd/tls.go)\n- [cli/cmd/zsh.go](cli/cmd/zsh.go)\n- [kern/bash_kern.c](kern/bash_kern.c)\n- [kern/mysqld_kern.c](kern/mysqld_kern.c)\n- [kern/nspr_kern.c](kern/nspr_kern.c)\n- [kern/postgres_kern.c](kern/postgres_kern.c)\n- [pkg/util/ws/client.go](pkg/util/ws/client.go)\n- [pkg/util/ws/client_test.go](pkg/util/ws/client_test.go)\n\n</details>\n\n\n\n## Purpose and Scope\n\nThis document covers eCapture's system auditing capabilities for capturing shell commands and database queries without code modification. System audit modules use eBPF uprobes to hook into critical functions in shell interpreters (Bash, Zsh) and database servers (MySQL, PostgreSQL), enabling security auditing and forensics analysis.\n\nFor TLS/SSL capture modules including OpenSSL and Go TLS, see [TLS/SSL Modules](#3.1). For network packet capture using TC classifiers, see [Network Packet Capture with TC](#3.3).\n\n## Overview\n\nSystem audit modules provide real-time visibility into:\n- **Shell Commands**: Bash and Zsh command execution, including command text and exit status\n- **Database Queries**: MySQL and PostgreSQL SQL queries executed by server processes\n\nUnlike TLS modules that focus on encrypted network traffic, system audit modules capture application-level activity directly from process memory, providing:\n- Command-line activity monitoring for security compliance\n- Database query auditing for debugging and performance analysis\n- Process and user attribution via PID/UID filtering\n- Zero configuration on target applications\n\nThe system audit subsystem consists of four specialized modules:\n\n| Module | Target | Hook Functions | Supported Versions |\n|--------|--------|----------------|-------------------|\n| Bash | `/bin/bash` | `readline()`, `execute_command()` | All versions |\n| Zsh | `/bin/zsh` | `zleread()`, `execcmd_exec()` | All versions |\n| MySQL | `mysqld`/`mariadbd` | `dispatch_command()` | 5.6, 5.7, 8.0, MariaDB 10.5+ |\n| PostgreSQL | `postgres` | `exec_simple_query()` | 10+ |\n\n**Sources:** [cli/cmd/bash.go:1-56](), [cli/cmd/zsh.go:1-58](), [cli/cmd/mysqld.go:1-50](), [cli/cmd/postgres.go:1-46]()\n\n## System Audit Architecture\n\n```mermaid\ngraph TB\n    subgraph \"CLI Commands\"\n        BashCLI[\"bash command<br/>cli/cmd/bash.go\"]\n        ZshCLI[\"zsh command<br/>cli/cmd/zsh.go\"]\n        MysqlCLI[\"mysqld command<br/>cli/cmd/mysqld.go\"]\n        PgCLI[\"postgres command<br/>cli/cmd/postgres.go\"]\n    end\n    \n    subgraph \"Configuration\"\n        BashConfig[\"BashConfig<br/>--bash, --readlineso<br/>--errnumber\"]\n        ZshConfig[\"ZshConfig<br/>--zsh, --errnumber\"]\n        MysqlConfig[\"MysqldConfig<br/>--mysqld, --offset<br/>--funcname\"]\n        PgConfig[\"PostgresConfig<br/>--postgres, --funcname\"]\n    end\n    \n    subgraph \"Module Layer\"\n        BashModule[\"MBashProbe<br/>user/module/probe_bash.go\"]\n        ZshModule[\"MZshProbe<br/>user/module/probe_zsh.go\"]\n        MysqlModule[\"MMysqldProbe<br/>user/module/probe_mysqld.go\"]\n        PgModule[\"MPostgresProbe<br/>user/module/probe_postgres.go\"]\n    end\n    \n    subgraph \"eBPF Programs\"\n        BashKern[\"bash_kern.c<br/>uretprobe/bash_readline<br/>uretprobe/bash_retval<br/>uprobe/exec_builtin<br/>uprobe/exit_builtin\"]\n        MysqlKern[\"mysqld_kern.c<br/>uprobe/dispatch_command<br/>uretprobe/dispatch_command<br/>uprobe/dispatch_command_57<br/>uretprobe/dispatch_command_57\"]\n        PgKern[\"postgres_kern.c<br/>uprobe/exec_simple_query\"]\n    end\n    \n    subgraph \"eBPF Maps\"\n        BashMaps[\"events_t<br/>PID → event<br/>events<br/>perf array\"]\n        MysqlMaps[\"sql_hash<br/>PID → data_t<br/>events<br/>perf array\"]\n        PgMaps[\"events<br/>perf array\"]\n    end\n    \n    subgraph \"Event Structures\"\n        BashEvent[\"struct event<br/>type, pid, uid<br/>line, retval, comm\"]\n        MysqlEvent[\"struct data_t<br/>pid, timestamp<br/>query, len, comm<br/>retval\"]\n        PgEvent[\"struct data_t<br/>pid, timestamp<br/>query, comm\"]\n    end\n    \n    subgraph \"Output\"\n        TextOutput[\"Text Output<br/>Console/File\"]\n    end\n    \n    BashCLI --> BashConfig\n    ZshCLI --> ZshConfig\n    MysqlCLI --> MysqlConfig\n    PgCLI --> PgConfig\n    \n    BashConfig --> BashModule\n    ZshConfig --> ZshModule\n    MysqlConfig --> MysqlModule\n    PgConfig --> PgModule\n    \n    BashModule --> BashKern\n    ZshModule --> BashKern\n    MysqlModule --> MysqlKern\n    PgModule --> PgKern\n    \n    BashKern --> BashMaps\n    MysqlKern --> MysqlMaps\n    PgKern --> PgMaps\n    \n    BashMaps --> BashEvent\n    MysqlMaps --> MysqlEvent\n    PgMaps --> PgEvent\n    \n    BashEvent --> TextOutput\n    MysqlEvent --> TextOutput\n    PgEvent --> TextOutput\n    \n    style BashKern fill:#e3f2fd\n    style MysqlKern fill:#fff3e0\n    style PgKern fill:#f3e5f5\n```\n\n**Diagram: System Audit Module Architecture**\n\nThe architecture follows a layered design where CLI commands parse user arguments into configuration objects, which are passed to module implementations that load and manage eBPF programs. The eBPF programs use uprobes to intercept function calls, store intermediate state in eBPF maps, and emit events via perf arrays to userspace.\n\n**Sources:** [cli/cmd/bash.go:24-55](), [cli/cmd/mysqld.go:27-49](), [cli/cmd/postgres.go:27-45](), [kern/bash_kern.c:17-133](), [kern/mysqld_kern.c:19-266](), [kern/postgres_kern.c:17-61]()\n\n## Shell Command Auditing\n\n### Bash Command Capture\n\nBash command auditing works by hooking the `readline()` function and related execution functions to capture both the command text and its exit status.\n\n```mermaid\nsequenceDiagram\n    participant User\n    participant Bash[\"bash process\"]\n    participant Readline[\"readline()\"]\n    participant Execute[\"execute_command()\"]\n    participant eBPF[\"bash_kern.c\"]\n    participant Maps[\"eBPF Maps\"]\n    participant UserSpace[\"User Space\"]\n    \n    User->>Bash: Type command\n    Bash->>Readline: Call readline()\n    \n    Note over eBPF: uretprobe/bash_readline\n    Readline-->>eBPF: Return command string\n    eBPF->>eBPF: Create event<br/>type=READLINE<br/>line=command text\n    eBPF->>Maps: Store in events_t[pid]\n    eBPF->>UserSpace: Send via perf array\n    \n    Bash->>Execute: Execute command\n    Execute->>Execute: Run command\n    \n    Note over eBPF: uretprobe/bash_retval\n    Execute-->>eBPF: Return exit code\n    eBPF->>Maps: Lookup events_t[pid]\n    eBPF->>eBPF: Update event<br/>type=RETVAL<br/>retval=exit_code\n    eBPF->>UserSpace: Send completed event\n    eBPF->>Maps: Delete events_t[pid]\n    \n    UserSpace->>User: Display command + exit status\n```\n\n**Diagram: Bash Command Capture Flow**\n\nThe capture process uses two uretprobes:\n1. **uretprobe/bash_readline** [kern/bash_kern.c:42-70]() captures the command text when `readline()` returns\n2. **uretprobe/bash_retval** [kern/bash_kern.c:71-112]() captures the exit status from command execution\n\nThe two-phase capture correlates commands with their results using PID-indexed map storage.\n\n**Sources:** [kern/bash_kern.c:42-112]()\n\n### Bash eBPF Implementation\n\nThe Bash eBPF program defines event structures and uses hash maps for state tracking:\n\n```c\nstruct event {\n    u32 type;              // Event type: READLINE or RETVAL\n    u32 pid;               // Process ID\n    u32 uid;               // User ID\n    u8 line[MAX_DATA_SIZE_BASH];  // Command text\n    u32 retval;            // Exit status\n    char comm[TASK_COMM_LEN];      // Process name\n};\n```\n\nThe program uses two eBPF maps:\n- **events** (BPF_MAP_TYPE_PERF_EVENT_ARRAY): Output events to userspace [kern/bash_kern.c:26-31]()\n- **events_t** (BPF_MAP_TYPE_HASH): Store partial events indexed by PID [kern/bash_kern.c:33-38]()\n\n**PID/UID Filtering**: When compiled for kernels ≥5.2 (non-KERNEL_LESS_5_2), the program performs filtering:\n```c\nif (target_pid != 0 && target_pid != pid) {\n    return 0;\n}\nif (target_uid != 0 && target_uid != uid) {\n    return 0;\n}\n```\n\nThis allows users to target specific processes or users via CLI flags.\n\n**Sources:** [kern/bash_kern.c:17-112]()\n\n### Bash/Zsh Exit and Exec Events\n\nBoth Bash and Zsh modules capture special events when the shell exits or executes external commands:\n\n```c\nstatic __always_inline int send_bash_exit_event(struct pt_regs *ctx) {\n    struct event event = {\n        .type = BASH_EVENT_TYPE_EXIT_OR_EXEC,\n        .pid = pid,\n        .uid = uid,\n    };\n    bpf_perf_event_output(ctx, &events, BPF_F_CURRENT_CPU, &event, sizeof(struct event));\n    return 0;\n}\n\nSEC(\"uprobe/exec_builtin\")\nint uprobe_exec_builtin(struct pt_regs *ctx) { return send_bash_exit_event(ctx); }\n\nSEC(\"uprobe/exit_builtin\")\nint uprobe_exit_builtin(struct pt_regs *ctx) { return send_bash_exit_event(ctx); }\n```\n\nThese probes track shell lifecycle events, useful for session monitoring and forensics.\n\n**Sources:** [kern/bash_kern.c:114-133]()\n\n### Zsh Command Capture\n\nZsh auditing follows the same architecture as Bash but hooks different functions:\n- `zleread()` for command input\n- `execcmd_exec()` for return values\n\nThe Zsh module reuses the same eBPF bytecode structure [kern/bash_kern.c]() with different hook points configured via the CLI command [cli/cmd/zsh.go:30-57]().\n\n**Sources:** [cli/cmd/zsh.go:30-57]()\n\n## Database Query Auditing\n\n### MySQL Query Capture\n\nMySQL query auditing intercepts the `dispatch_command()` function, which processes all client commands including SQL queries.\n\n```mermaid\ngraph TB\n    subgraph \"MySQL Server Process\"\n        Client[\"MySQL Client<br/>Connection\"]\n        Protocol[\"Protocol Handler\"]\n        Dispatch[\"dispatch_command()<br/>Entry Point\"]\n        Execute[\"Query Execution<br/>Engine\"]\n    end\n    \n    subgraph \"eBPF Hooks\"\n        Entry[\"uprobe/dispatch_command<br/>OR<br/>uprobe/dispatch_command_57\"]\n        Return[\"uretprobe/dispatch_command<br/>OR<br/>uretprobe/dispatch_command_57\"]\n    end\n    \n    subgraph \"eBPF State\"\n        HashCheck[\"Check command<br/>== COM_QUERY?\"]\n        ReadQuery[\"bpf_probe_read_user<br/>Extract query string\"]\n        Store[\"sql_hash[PID]<br/>Store query + metadata\"]\n        Lookup[\"sql_hash[PID]<br/>Retrieve query\"]\n        AddRetval[\"Add return value<br/>retval field\"]\n        Output[\"bpf_perf_event_output<br/>Send to userspace\"]\n    end\n    \n    subgraph \"Userspace\"\n        Parser[\"Event Parser\"]\n        Logger[\"Text Logger\"]\n    end\n    \n    Client --> Protocol\n    Protocol --> Dispatch\n    \n    Dispatch -.->|\"entry probe\"| Entry\n    Entry --> HashCheck\n    HashCheck -->|\"Yes\"| ReadQuery\n    HashCheck -->|\"No\"| Skip[\"Skip\"]\n    ReadQuery --> Store\n    \n    Dispatch --> Execute\n    Execute --> ExecReturn[\"Return\"]\n    \n    ExecReturn -.->|\"return probe\"| Return\n    Return --> Lookup\n    Lookup --> AddRetval\n    AddRetval --> Output\n    \n    Output --> Parser\n    Parser --> Logger\n    \n    style Entry fill:#fff3e0\n    style Return fill:#fff3e0\n    style Store fill:#e3f2fd\n```\n\n**Diagram: MySQL Query Capture Flow**\n\nThe capture uses version-specific probe functions:\n- **MySQL 5.6**: `dispatch_command(enum command, THD *thd, char *packet, uint length)` [kern/mysqld_kern.c:43-99]()\n- **MySQL 5.7+/8.0**: `dispatch_command(THD *thd, const COM_DATA *com_data, enum command)` [kern/mysqld_kern.c:186-226]()\n\n**Sources:** [kern/mysqld_kern.c:43-266]()\n\n### MySQL Version-Specific Handling\n\nThe MySQL module handles two different function signatures:\n\n**MySQL 5.6 Signature:**\n```c\nSEC(\"uprobe/dispatch_command\")\nint mysql56_query(struct pt_regs *ctx) {\n    u64 command = (u64)PT_REGS_PARM1(ctx);  // enum_server_command\n    if (command != COM_QUERY) {\n        return 0;  // Only capture SQL queries (COM_QUERY = 0x03)\n    }\n    \n    u64 len = (u64)PT_REGS_PARM4(ctx);\n    bpf_probe_read_user(&data.query, len, (void *)PT_REGS_PARM3(ctx));\n}\n```\n\n**MySQL 5.7+/8.0 Signature:**\n```c\nSEC(\"uprobe/dispatch_command_57\")\nint mysql57_query(struct pt_regs *ctx) {\n    u64 command = (u64)PT_REGS_PARM3(ctx);  // enum_server_command moved\n    if (command != COM_QUERY) {\n        return 0;\n    }\n    \n    void *st = (void *)PT_REGS_PARM2(ctx);  // COM_DATA struct pointer\n    struct COM_QUERY_DATA query;\n    bpf_probe_read_user(&query, sizeof(query), st);\n    bpf_probe_read_user(&data.query, sizeof(data.query), query.query);\n}\n```\n\nThe COM_DATA structure layout changed between versions [kern/mysqld_kern.c:173-178]().\n\n**Sources:** [kern/mysqld_kern.c:43-266]()\n\n### MySQL Event Structure\n\nThe MySQL event structure captures comprehensive query information:\n\n```c\nstruct data_t {\n    u64 pid;        // Process ID\n    u64 timestamp;  // Capture timestamp\n    char query[MAX_DATA_SIZE_MYSQL];  // SQL query text\n    u64 alllen;     // Original query length\n    u64 len;        // Captured length (truncated if > MAX)\n    char comm[TASK_COMM_LEN];  // Process name\n    s8 retval;      // dispatch_command return value\n};\n```\n\nThe `retval` field indicates query execution status:\n- **MySQL 5.6**: `DISPATCH_COMMAND_SUCCESS=0`, `DISPATCH_COMMAND_CLOSE_CONNECTION=1`, `DISPATCH_COMMAND_WOULDBLOCK=2`\n- **MySQL 5.7**: `0` for success, `1` for connection close, with `DISPATCH_COMMAND_V57_FAILED=-2` used internally\n\n**Sources:** [kern/mysqld_kern.c:19-27](), [kern/mysqld_kern.c:101-141](), [kern/mysqld_kern.c:233-266]()\n\n### PostgreSQL Query Capture\n\nPostgreSQL auditing is simpler, hooking a single function that processes text queries:\n\n```mermaid\nsequenceDiagram\n    participant Client[\"psql/Application\"]\n    participant Server[\"postgres process\"]\n    participant ExecFunc[\"exec_simple_query()\"]\n    participant eBPF[\"postgres_kern.c\"]\n    participant UserSpace[\"User Space\"]\n    \n    Client->>Server: Send SQL query\n    Server->>ExecFunc: exec_simple_query(query_string)\n    \n    Note over eBPF: uprobe/exec_simple_query\n    ExecFunc->>eBPF: Function entry\n    eBPF->>eBPF: PT_REGS_PARM1(ctx)<br/>= query_string pointer\n    eBPF->>eBPF: bpf_probe_read_user<br/>Read query text\n    eBPF->>eBPF: Create data_t event<br/>pid, timestamp, query, comm\n    eBPF->>UserSpace: bpf_perf_event_output\n    \n    ExecFunc->>Server: Execute query\n    Server->>Client: Return results\n    \n    UserSpace->>UserSpace: Parse event\n    UserSpace->>UserSpace: Display query\n```\n\n**Diagram: PostgreSQL Query Capture Flow**\n\nThe PostgreSQL implementation is straightforward because `exec_simple_query()` handles text-based queries uniformly across versions 10+.\n\n**Sources:** [kern/postgres_kern.c:35-60]()\n\n### PostgreSQL eBPF Implementation\n\nThe PostgreSQL eBPF program is the simplest of the database modules:\n\n```c\nstruct data_t {\n    u64 pid;\n    u64 timestamp;\n    char query[MAX_DATA_SIZE_POSTGRES];\n    char comm[TASK_COMM_LEN];\n};\n\nSEC(\"uprobe/exec_simple_query\")\nint postgres_query(struct pt_regs *ctx) {\n    // PID/UID filtering\n    \n    struct data_t data = {};\n    data.pid = pid;\n    data.timestamp = bpf_ktime_get_ns();\n    \n    char *sql_string = (char *)PT_REGS_PARM1(ctx);\n    bpf_get_current_comm(&data.comm, sizeof(data.comm));\n    bpf_probe_read_user(&data.query, sizeof(data.query), sql_string);\n    bpf_perf_event_output(ctx, &events, BPF_F_CURRENT_CPU, &data, sizeof(data));\n    return 0;\n}\n```\n\nUnlike MySQL, PostgreSQL doesn't require return value tracking or multiple version-specific hooks.\n\n**Sources:** [kern/postgres_kern.c:17-60]()\n\n## CLI Usage and Configuration\n\n### Shell Command Auditing CLI\n\n**Bash Command:**\n```bash\n# Basic usage\necapture bash\n\n# Specify bash binary path\necapture bash --bash=/bin/bash\n\n# Specify readline library path\necapture bash --readlineso=/lib/x86_64-linux-gnu/libreadline.so.8\n\n# Filter by exit code (e.g., only failed commands)\necapture bash -e 1\n\n# PID/UID filtering (common flags)\necapture bash --pid=1234 --uid=1000\n```\n\n**Zsh Command:**\n```bash\necapture zsh\necapture zsh --zsh=/bin/zsh -e 0  # Only successful commands\n```\n\nThe `--errnumber` flag filters events by exit status:\n- `-e 0`: Only show successful commands\n- `-e 1`: Only show failed commands\n- `-e 128` (default): Show all commands\n\n**Sources:** [cli/cmd/bash.go:27-55](), [cli/cmd/zsh.go:30-57]()\n\n### Database Auditing CLI\n\n**MySQL Command:**\n```bash\n# Basic usage\necapture mysqld\n\n# Specify mysqld binary\necapture mysqld --mysqld=/usr/sbin/mysqld\n\n# MariaDB\necapture mysqld --mysqld=/usr/sbin/mariadbd\n\n# Manual function specification (for symbol resolution issues)\necapture mysqld --funcname=_Z16dispatch_commandP3THDPK8COM_DATA19enum_server_command\n\n# Manual offset specification\necapture mysqld --offset=0x710410\n```\n\n**PostgreSQL Command:**\n```bash\n# Basic usage\necapture postgres\n\n# Specify postgres binary\necapture postgres --postgres=/usr/lib/postgresql/14/bin/postgres\n\n# Manual function specification\necapture postgres --funcname=exec_simple_query\n```\n\nThe `--funcname` and `--offset` flags provide fallback mechanisms when automatic symbol resolution fails.\n\n**Sources:** [cli/cmd/mysqld.go:30-49](), [cli/cmd/postgres.go:30-45]()\n\n## System Audit Module Comparison\n\n| Feature | Bash/Zsh | MySQL | PostgreSQL |\n|---------|----------|-------|------------|\n| **Hook Strategy** | Two-phase (command + retval) | Two-phase (entry + return) | Single-phase (entry only) |\n| **State Storage** | events_t[PID] hash map | sql_hash[PID] hash map | None (direct output) |\n| **Version Variants** | Single eBPF program | Two variants (5.6 vs 5.7+) | Single program |\n| **Output Timing** | After command completes | After query completes | At query start |\n| **Truncation** | MAX_DATA_SIZE_BASH | MAX_DATA_SIZE_MYSQL | MAX_DATA_SIZE_POSTGRES |\n| **Return Value** | Exit code (0-255) | dispatch_command result | N/A |\n| **Lifecycle Events** | Exit/exec tracking | None | None |\n| **CLI Filtering** | Error number, PID, UID | PID, UID | PID, UID |\n\n## Implementation Considerations\n\n### Memory Constraints\n\neBPF programs have a 512-byte stack limit, requiring careful buffer management:\n- Bash: `MAX_DATA_SIZE_BASH` for command text [kern/bash_kern.c:21]()\n- MySQL: `MAX_DATA_SIZE_MYSQL` for queries [kern/mysqld_kern.c:22]()\n- PostgreSQL: `MAX_DATA_SIZE_POSTGRES` for queries [kern/postgres_kern.c:20]()\n\nLarge commands/queries are truncated with length tracking via `alllen` vs `len` fields.\n\n### PID-Based Correlation\n\nBoth shell and database modules use PID-indexed hash maps to correlate entry and return probes:\n1. Entry probe stores event in map [kern/bash_kern.c:66](), [kern/mysqld_kern.c:95]()\n2. Return probe retrieves event [kern/bash_kern.c:89](), [kern/mysqld_kern.c:132]()\n3. Return probe updates with return value\n4. Return probe outputs completed event\n5. Return probe deletes map entry\n\nThis pattern prevents memory leaks while enabling two-phase capture.\n\n### Cross-Version Compatibility\n\nMySQL requires version detection to select the correct eBPF program:\n- Module code detects MySQL version via binary analysis\n- Loads either `mysql56_query`/`mysql56_query_return` or `mysql57_query`/`mysql57_query_return`\n- COM_DATA structure layout differs between versions\n\nPostgreSQL's stable ABI across versions 10+ simplifies implementation.\n\n**Sources:** [kern/mysqld_kern.c:43-266]()"
          },
          {
            "page_plan": {
              "id": "3.2.1",
              "title": "Shell Command Auditing"
            },
            "content": "# Shell Command Auditing\n\n<details>\n<summary>Relevant source files</summary>\n\nThe following files were used as context for generating this wiki page:\n\n- [kern/bash_kern.c](kern/bash_kern.c)\n- [kern/mysqld_kern.c](kern/mysqld_kern.c)\n- [kern/nspr_kern.c](kern/nspr_kern.c)\n- [kern/postgres_kern.c](kern/postgres_kern.c)\n- [pkg/event_processor/base_event.go](pkg/event_processor/base_event.go)\n- [user/event/event_bash.go](user/event/event_bash.go)\n- [user/event/event_gnutls.go](user/event/event_gnutls.go)\n- [user/event/event_masterkey.go](user/event/event_masterkey.go)\n- [user/event/event_mysqld.go](user/event/event_mysqld.go)\n- [user/event/event_nspr.go](user/event/event_nspr.go)\n- [user/event/event_openssl.go](user/event/event_openssl.go)\n- [user/event/event_openssl_tc.go](user/event/event_openssl_tc.go)\n- [user/event/event_postgres.go](user/event/event_postgres.go)\n\n</details>\n\n\n\n## Purpose and Scope\n\nThis document describes eCapture's shell command auditing capabilities, which intercept and log commands executed in Bash and Zsh shells for security auditing purposes. The module uses eBPF uprobes to hook into the GNU readline library, capturing command-line input and execution results without requiring shell history files or configuration changes.\n\nThis page covers the Bash and Zsh capture modules. For database query auditing, see [Database Query Auditing](#3.2.2). For general module architecture, see [Module System and Lifecycle](#2.4).\n\n---\n\n## Module Architecture\n\nThe shell command auditing system consists of two parallel modules sharing the same underlying architecture: one for Bash and one for Zsh. Both modules hook into the readline library to intercept user input before command execution.\n\n### System Components\n\n```mermaid\ngraph TB\n    subgraph \"User Space - Shell Processes\"\n        BashProc[\"bash process<br/>executable\"]\n        ZshProc[\"zsh process<br/>executable\"]\n        Readline[\"libreadline.so<br/>or built-in readline\"]\n    end\n    \n    subgraph \"eCapture CLI Layer\"\n        BashCmd[\"bashCmd<br/>cobra.Command<br/>cli/cmd/bash.go\"]\n        ZshCmd[\"zshCmd<br/>cobra.Command<br/>cli/cmd/zsh.go\"]\n        BashConfig[\"BashConfig<br/>config.NewBashConfig()\"]\n        ZshConfig[\"ZshConfig<br/>config.NewZshConfig()\"]\n    end\n    \n    subgraph \"Module Layer\"\n        BashModule[\"MBashProbe<br/>ModuleNameBash\"]\n        ZshModule[\"MZshProbe<br/>ModuleNameZsh\"]\n        ModuleFactory[\"GetModuleFunc<br/>module factory\"]\n    end\n    \n    subgraph \"eBPF Probes\"\n        ReadlineHook[\"Uprobe: readline()<br/>captures input\"]\n        ReadlineRetHook[\"Uretprobe: readline()<br/>captures return value\"]\n    end\n    \n    subgraph \"Event Pipeline\"\n        BashEvent[\"BashEvent struct<br/>event_bash.go<br/>MaxDataSizeBash=256\"]\n        EventWorker[\"eventWorker<br/>UUID-based grouping\"]\n        Output[\"Console Output<br/>Filtered by ErrNo\"]\n    end\n    \n    BashProc --> Readline\n    ZshProc --> Readline\n    \n    BashCmd --> BashConfig\n    ZshCmd --> ZshConfig\n    \n    BashConfig --> ModuleFactory\n    ZshConfig --> ModuleFactory\n    \n    ModuleFactory --> BashModule\n    ModuleFactory --> ZshModule\n    \n    BashModule --> ReadlineHook\n    ZshModule --> ReadlineHook\n    \n    ReadlineHook -.intercept.-> Readline\n    ReadlineRetHook -.intercept.-> Readline\n    \n    ReadlineHook --> BashEvent\n    ReadlineRetHook --> BashEvent\n    \n    BashEvent --> EventWorker\n    EventWorker --> Output\n```\n\n**Sources:** [cli/cmd/bash.go:1-56](), [cli/cmd/zsh.go:1-58](), [user/event/event_bash.go:1-134]()\n\n---\n\n## Configuration\n\n### Bash Module Configuration\n\nThe Bash module accepts the following configuration parameters:\n\n| Parameter | Flag | Type | Default | Description |\n|-----------|------|------|---------|-------------|\n| Bashpath | `--bash` | string | Auto-detect from `$SHELL` | Path to bash executable |\n| Readline | `--readlineso` | string | Auto-detect from bash path | Path to readline.so library |\n| ErrNo | `-e, --errnumber` | int | `BashErrnoDefault` | Filter commands by exit code |\n\n**Configuration Structure:**\n\n```go\n// Created via config.NewBashConfig()\ntype BashConfig struct {\n    Bashpath string  // Target bash binary\n    Readline string  // libreadline.so path\n    ErrNo    int     // Exit code filter\n}\n```\n\n### Zsh Module Configuration\n\n| Parameter | Flag | Type | Default | Description |\n|-----------|------|------|---------|-------------|\n| Zshpath | `--zsh` | string | Auto-detect from `$SHELL` | Path to zsh executable |\n| ErrNo | `-e, --errnumber` | int | `ZshErrnoDefault` | Filter commands by exit code |\n\n**Sources:** [cli/cmd/bash.go:24-39](), [cli/cmd/zsh.go:27-41]()\n\n### Command Line Usage\n\n```bash\n# Basic bash command capture\necapture bash\n\n# Capture bash commands with custom paths\necapture bash --bash=/bin/bash --readlineso=/lib/x86_64-linux-gnu/libreadline.so\n\n# Filter by exit code (only show failed commands)\necapture bash -e 1\n\n# Zsh command capture\necapture zsh --zsh=/bin/zsh -e 0\n```\n\n**Sources:** [cli/cmd/bash.go:26-33](), [cli/cmd/zsh.go:30-36]()\n\n---\n\n## Event Structure\n\n### BashEvent Data Layout\n\nCommands captured from the shell are encoded in the `BashEvent` structure, which mirrors the eBPF kernel-side structure:\n\n```mermaid\ngraph LR\n    subgraph \"Kernel Space - eBPF Event\"\n        BPFStruct[\"struct bash_event<br/>- u8 type<br/>- u32 pid<br/>- u32 uid<br/>- u8 line[256]<br/>- u32 retval<br/>- char comm[16]\"]\n    end\n    \n    subgraph \"User Space - Go Structure\"\n        GoStruct[\"BashEvent<br/>- BashType uint32<br/>- Pid uint32<br/>- Uid uint32<br/>- Line [256]uint8<br/>- ReturnValue uint32<br/>- Comm [16]byte<br/>- AllLines string\"]\n    end\n    \n    subgraph \"Output Format\"\n        StringOut[\"PID:123, UID:1000<br/>Comm:bash<br/>Retvalue:0<br/>Line: ls -la\"]\n    end\n    \n    BPFStruct -->|\"perf buffer\"| GoStruct\n    GoStruct -->|\"String()\"| StringOut\n```\n\n**Sources:** [user/event/event_bash.go:26-47]()\n\n### Field Descriptions\n\n| Field | Type | Size | Description |\n|-------|------|------|-------------|\n| BashType | uint32 | 4 bytes | Event type identifier |\n| Pid | uint32 | 4 bytes | Process ID of shell |\n| Uid | uint32 | 4 bytes | User ID executing command |\n| Line | [256]uint8 | 256 bytes | Command line text (may be partial) |\n| ReturnValue | uint32 | 4 bytes | Exit code of command |\n| Comm | [16]byte | 16 bytes | Process name (typically \"bash\" or \"zsh\") |\n| AllLines | string | Variable | Aggregated full command (for multi-chunk commands) |\n\n**Maximum Data Size:** Commands longer than 256 bytes are captured in multiple events and reassembled using the `AllLines` field.\n\n**Sources:** [user/event/event_bash.go:37-47]()\n\n---\n\n## Event Processing Pipeline\n\n### Data Flow from Shell to Output\n\n```mermaid\nflowchart TD\n    Shell[\"User types command<br/>in bash/zsh\"]\n    Readline[\"readline() function<br/>in libreadline.so\"]\n    UprobeEntry[\"Uprobe attached to<br/>readline() entry\"]\n    UprobeRet[\"Uretprobe attached to<br/>readline() return\"]\n    \n    Shell --> Readline\n    Readline --> UprobeEntry\n    Readline --> UprobeRet\n    \n    subgraph \"eBPF Kernel Space\"\n        Capture[\"Capture function arguments<br/>- Input buffer pointer<br/>- PID/UID from bpf_get_current_*\"]\n        CaptureRet[\"Capture return value<br/>- Exit code from retval\"]\n        PerfMap[\"Perf event array<br/>bash_events\"]\n    end\n    \n    UprobeEntry --> Capture\n    UprobeRet --> CaptureRet\n    Capture --> PerfMap\n    CaptureRet --> PerfMap\n    \n    subgraph \"User Space Processing\"\n        Decode[\"BashEvent.Decode()<br/>Binary deserialization\"]\n        Filter{\"ErrNo filter?<br/>Match ReturnValue\"}\n        Aggregate[\"Multi-chunk<br/>aggregation via UUID\"]\n        Format[\"String() method<br/>Format output\"]\n    end\n    \n    PerfMap -->|\"perfEventReader\"| Decode\n    Decode --> Filter\n    Filter -->|\"Pass\"| Aggregate\n    Filter -->|\"Drop\"| Drop[Discard]\n    Aggregate --> Format\n    Format --> Console[\"Console output\"]\n```\n\n**Sources:** [user/event/event_bash.go:49-80](), [cli/cmd/bash.go:38]()\n\n### UUID-Based Event Correlation\n\nEach command execution generates a unique identifier for event grouping:\n\n**UUID Format:** `{Pid}_{Uid}_{Comm}`\n\nExample: `1234_1000_bash`\n\nThis UUID enables:\n- Correlation of multi-chunk command captures\n- Grouping of related events from the same shell session\n- Proper event ordering in the event worker pipeline\n\n**Sources:** [user/event/event_bash.go:123-125]()\n\n---\n\n## Exit Code Filtering\n\nThe shell auditing modules support filtering by command exit codes, allowing users to focus on specific execution outcomes.\n\n### Filter Configuration\n\n```mermaid\ngraph LR\n    AllCommands[\"All commands<br/>executed\"]\n    Filter{\"ReturnValue ==<br/>ErrNo?\"}\n    Success[\"ErrNo = 0<br/>Show successful<br/>commands only\"]\n    Failure[\"ErrNo = 1<br/>Show failed<br/>commands only\"]\n    AllCodes[\"ErrNo = BashErrnoDefault<br/>Show all commands\"]\n    \n    AllCommands --> Filter\n    Filter -->|\"Match\"| Output[\"Display to user\"]\n    Filter -->|\"No match\"| Drop[\"Discard\"]\n    \n    Success -.example.-> Filter\n    Failure -.example.-> Filter\n    AllCodes -.example.-> Filter\n```\n\n**Sources:** [cli/cmd/bash.go:38](), [cli/cmd/zsh.go:40]()\n\n### Common Use Cases\n\n| ErrNo Value | Use Case | Description |\n|-------------|----------|-------------|\n| 0 | Successful commands | Audit commands that completed successfully |\n| 1 | Failed commands | Detect failed execution attempts |\n| 127 | Command not found | Identify typos or missing binaries |\n| 126 | Permission denied | Track permission issues |\n| Default | All commands | Comprehensive audit trail |\n\n---\n\n## Output Format\n\n### Text Output Structure\n\nThe `BashEvent.String()` method formats captured commands for console display:\n\n```\nPID:1234, UID:1000, \tComm:bash, \tRetvalue:0, \tLine:\nls -la /etc/passwd\n```\n\n**Format Template:** `PID:%d, UID:%d, \\tComm:%s, \\tRetvalue:%d, \\tLine:\\n%s`\n\n**Color Coding:** Output uses the standard color scheme from [user/event/event_bash.go:72-75](), though the specific colors depend on terminal support.\n\n**Sources:** [user/event/event_bash.go:72-75]()\n\n### Hex Output Mode\n\nWhen running with `--hex` flag, commands are displayed in hexadecimal format via `StringHex()`:\n\n```\nPID:1234, UID:1000, \tComm:bash, \tRetvalue:0, \tLine:\n0000    6C 73 20 2D 6C 61    ls -la\n```\n\n**Sources:** [user/event/event_bash.go:77-80]()\n\n---\n\n## Library Detection and Hooking\n\n### Readline Library Resolution\n\nThe module employs a multi-step process to locate the readline library:\n\n```mermaid\nflowchart TD\n    Start[\"Module initialization\"]\n    \n    CheckFlag{\"--readlineso<br/>flag provided?\"}\n    UseFlag[\"Use specified path\"]\n    \n    CheckBash{\"--bash flag<br/>provided?\"}\n    UseBashPath[\"Use bash path<br/>to find readline\"]\n    \n    CheckEnv{\"$SHELL env<br/>variable set?\"}\n    UseEnv[\"Use $SHELL path\"]\n    \n    Default[\"Use system defaults<br/>/bin/bash<br/>/lib/x86_64-linux-gnu/libreadline.so\"]\n    \n    Verify[\"Verify library exists<br/>and contains readline()\"]\n    \n    AttachProbe[\"Attach eBPF probes<br/>to readline() function\"]\n    \n    Start --> CheckFlag\n    CheckFlag -->|\"Yes\"| UseFlag\n    CheckFlag -->|\"No\"| CheckBash\n    \n    CheckBash -->|\"Yes\"| UseBashPath\n    CheckBash -->|\"No\"| CheckEnv\n    \n    CheckEnv -->|\"Yes\"| UseEnv\n    CheckEnv -->|\"No\"| Default\n    \n    UseFlag --> Verify\n    UseBashPath --> Verify\n    UseEnv --> Verify\n    Default --> Verify\n    \n    Verify -->|\"Success\"| AttachProbe\n    Verify -->|\"Failure\"| Error[\"Error: readline<br/>not found\"]\n```\n\n**Sources:** [cli/cmd/bash.go:36-37]()\n\n### Uprobe Attachment Points\n\nThe module attaches to two critical points in the readline library:\n\n| Probe Type | Function | Purpose |\n|------------|----------|---------|\n| Uprobe | `readline()` entry | Capture PID, UID, command text buffer |\n| Uretprobe | `readline()` return | Capture exit code after command execution |\n\n**Note:** The actual eBPF program implementation is not shown in the provided files, but the event structure in [user/event/event_bash.go:26-47]() reflects the data captured at these hook points.\n\n---\n\n## Protobuf Event Serialization\n\nShell events can be exported via the Protobuf/WebSocket interface for external integrations:\n\n### Protobuf Mapping\n\n```mermaid\ngraph LR\n    BashEvent[\"BashEvent struct\"]\n    ProtoEvent[\"pb.Event protobuf\"]\n    \n    subgraph \"Field Mappings\"\n        Timestamp[\"Timestamp<br/>time.Now().Unix()\"]\n        UUID[\"UUID<br/>{Pid}_{Uid}_{Comm}\"]\n        IPs[\"SrcIp/DstIp<br/>127.0.0.1<br/>(local events)\"]\n        Ports[\"SrcPort/DstPort<br/>0 (N/A)\"]\n        Process[\"Pid, Pname<br/>from event\"]\n        Type[\"Type<br/>BashType\"]\n        Payload[\"Length, Payload<br/>AllLines command text\"]\n    end\n    \n    BashEvent --> ProtoEvent\n    Timestamp --> ProtoEvent\n    UUID --> ProtoEvent\n    IPs --> ProtoEvent\n    Ports --> ProtoEvent\n    Process --> ProtoEvent\n    Type --> ProtoEvent\n    Payload --> ProtoEvent\n```\n\n**Special Handling:**\n- Bash events do not have network context (SrcIP/DstIP set to `127.0.0.1`, ports set to `0`)\n- Timestamp uses `time.Now().Unix()` rather than kernel timestamp\n- Payload contains the full command line text from `AllLines`\n\n**Sources:** [user/event/event_bash.go:103-117]()\n\n---\n\n## Event Lifecycle\n\n### Event Type Classification\n\nShell events are classified as `TypeModuleData`, which routes them through module-specific handling rather than the generic event processor:\n\n```go\nfunc (be *BashEvent) Clone() IEventStruct {\n    event := new(BashEvent)\n    event.eventType = TypeModuleData  // Not TypeEventProcessor\n    return event\n}\n```\n\nThis classification means:\n- Events bypass HTTP protocol parsing\n- No PCAP output generation\n- Direct output to console or log file\n- Module maintains control over formatting\n\n**Sources:** [user/event/event_bash.go:82-86]()\n\n### Multi-Chunk Command Handling\n\nCommands exceeding 256 bytes are captured in multiple events:\n\n1. First chunk captured when user presses Enter\n2. eBPF program reads up to 256 bytes from readline buffer\n3. Subsequent chunks captured if command continues\n4. User-space code aggregates chunks into `AllLines` field using UUID correlation\n\n**Maximum Command Length:** Limited by eBPF program design and event aggregation logic (not visible in provided files, but structure supports unlimited length via `AllLines` string).\n\n**Sources:** [user/event/event_bash.go:37-47]()\n\n---\n\n## Integration with Other Modules\n\n### Module Factory Registration\n\nBoth Bash and Zsh modules are registered with the module factory:\n\n```\nModuleNameBash  -> MBashProbe  -> BashConfig\nModuleNameZsh   -> MZshProbe   -> ZshConfig\n```\n\nThe `runModule()` function in CLI commands delegates to the factory:\n\n```go\nfunc bashCommandFunc(command *cobra.Command, args []string) error {\n    return runModule(module.ModuleNameBash, bc)\n}\n```\n\n**Sources:** [cli/cmd/bash.go:53-55](), [cli/cmd/zsh.go:55-57]()\n\n### Shared Infrastructure\n\nShell modules leverage common eCapture infrastructure:\n\n- **Event Pipeline:** [Event Processing Pipeline](#2.2)\n- **Module Lifecycle:** [Module System and Lifecycle](#2.4)\n- **Configuration System:** [Configuration System](#2.3)\n- **Output Formats:** [Text Output Mode](#4.1) and [Protobuf Integration](#4.4)\n\n---\n\n## Security Considerations\n\n### Audit Trail Integrity\n\nShell command auditing provides:\n\n- **Non-bypassable capture:** Hooks at library level before history file writes\n- **UID tracking:** Associates commands with user identities\n- **Exit code tracking:** Distinguishes successful vs. failed attempts\n- **Process correlation:** Links commands to specific shell sessions\n\n### Privacy Implications\n\nThe module captures:\n- All interactive command input (including passwords if typed)\n- Arguments to commands (may contain sensitive data)\n- Working directory context (via process inspection)\n\n**Recommendation:** Use exit code filtering and secure log storage when deploying in production environments.\n\n---\n\n## Use Cases\n\n### Security Auditing\n\n```bash\n# Monitor all commands executed by specific user\necapture bash --pid=$(pgrep -u suspicious_user bash)\n\n# Track failed command attempts (potential reconnaissance)\necapture bash -e 1\n```\n\n### Compliance Monitoring\n\n```bash\n# Capture all successful administrative commands\necapture bash -e 0 -l /var/log/audit/bash_commands.log\n```\n\n### Debugging and Support\n\n```bash\n# Record all commands during troubleshooting session\necapture bash > debug_session.log\n```\n\n### Intrusion Detection\n\n```bash\n# Monitor for command-not-found errors (unusual activity)\necapture bash -e 127\n```\n\n**Sources:** [cli/cmd/bash.go:28-33](), [user/event/event_bash.go:72-75]()"
          },
          {
            "page_plan": {
              "id": "3.2.2",
              "title": "Database Query Auditing"
            },
            "content": "# Database Query Auditing\n\n<details>\n<summary>Relevant source files</summary>\n\nThe following files were used as context for generating this wiki page:\n\n- [kern/bash_kern.c](kern/bash_kern.c)\n- [kern/mysqld_kern.c](kern/mysqld_kern.c)\n- [kern/nspr_kern.c](kern/nspr_kern.c)\n- [kern/postgres_kern.c](kern/postgres_kern.c)\n- [pkg/event_processor/base_event.go](pkg/event_processor/base_event.go)\n- [user/event/event_bash.go](user/event/event_bash.go)\n- [user/event/event_gnutls.go](user/event/event_gnutls.go)\n- [user/event/event_masterkey.go](user/event/event_masterkey.go)\n- [user/event/event_mysqld.go](user/event/event_mysqld.go)\n- [user/event/event_nspr.go](user/event/event_nspr.go)\n- [user/event/event_openssl.go](user/event/event_openssl.go)\n- [user/event/event_openssl_tc.go](user/event/event_openssl_tc.go)\n- [user/event/event_postgres.go](user/event/event_postgres.go)\n\n</details>\n\n\n\n## Purpose and Scope\n\nThis document describes eCapture's database query auditing capabilities, which enable real-time capture of SQL queries executed by MySQL and PostgreSQL database servers without requiring database-level logging configuration or permissions. The system uses eBPF uprobes to intercept query dispatch functions within database server binaries, capturing query text, process information, and execution metadata.\n\nThis page covers the MySQL (`mysqld`) and PostgreSQL (`postgres`) capture modules. For shell command auditing (bash/zsh), see [Shell Command Auditing](#3.2.1). For TLS/SSL traffic capture, see [TLS/SSL Modules](#3.1).\n\n---\n\n## Architecture Overview\n\nDatabase query auditing operates differently from TLS modules, as it targets database server processes rather than SSL/TLS libraries. The system attaches uprobes to specific query processing functions within the database binary, capturing SQL query strings as they are dispatched for execution.\n\n### Database Query Capture Architecture\n\n```mermaid\ngraph TB\n    subgraph \"Database Server Process\"\n        Client[\"Database Client<br/>mysql, psql, application\"]\n        Protocol[\"Protocol Handler<br/>MySQL Protocol<br/>PostgreSQL Wire Protocol\"]\n        Dispatcher[\"Query Dispatcher<br/>dispatch_command (MySQL)<br/>exec_* functions (PostgreSQL)\"]\n        Executor[\"Query Executor<br/>SQL Parser & Optimizer\"]\n    end\n    \n    subgraph \"eCapture eBPF Hooks\"\n        UprobeEntry[\"Uprobe Entry<br/>Function Entry Hook\"]\n        ExtractQuery[\"Query Extraction<br/>Read query string<br/>from function parameters\"]\n        BuildEvent[\"Build Event Structure<br/>MysqldEvent<br/>PostgresEvent\"]\n    end\n    \n    subgraph \"Event Pipeline\"\n        PerfBuffer[\"Perf Event Buffer<br/>events map\"]\n        EventReader[\"perfEventReader<br/>Module.Decode\"]\n        Display[\"Text Output<br/>PID, Query, Comm, Retval\"]\n    end\n    \n    Client --> Protocol\n    Protocol --> Dispatcher\n    Dispatcher --> Executor\n    \n    Dispatcher -.hook.-> UprobeEntry\n    UprobeEntry --> ExtractQuery\n    ExtractQuery --> BuildEvent\n    BuildEvent --> PerfBuffer\n    \n    PerfBuffer --> EventReader\n    EventReader --> Display\n    \n    style Dispatcher fill:#fff4e1\n    style UprobeEntry fill:#ffe1e1\n    style BuildEvent fill:#e1ffe1\n```\n\n**Key Differences from TLS Capture:**\n- **Single Hook Point**: Database modules use one uprobe per database type, not multiple hooks for read/write/handshake\n- **No Network Correlation**: Events contain query text but not network 5-tuple information\n- **No Master Secrets**: Database audit does not require cryptographic key extraction\n- **Direct Text Capture**: SQL queries are captured as plaintext strings from memory\n\nSources: [user/event/event_mysqld.go:1-169](), [user/event/event_postgres.go:1-119]()\n\n---\n\n## MySQL Query Auditing\n\n### Supported Versions\n\nThe MySQL module supports:\n- **MySQL 5.6, 5.7, 8.0**\n- **MariaDB 10.5+**\n\nThe module targets the `dispatch_command` function, which is the central query processing entry point in MySQL/MariaDB server binaries.\n\nSources: [cli/cmd/mysqld.go:32-35]()\n\n### Hook Function: dispatch_command\n\nThe MySQL module attaches a uprobe to the `dispatch_command` function, which processes incoming client commands. This function signature varies slightly across MySQL versions, but generally receives:\n- **THD pointer**: MySQL thread descriptor containing session state\n- **COM_DATA union**: Command data including query string\n- **enum_server_command**: Command type (COM_QUERY for SQL queries)\n\nThe eBPF program extracts the query string from the `COM_DATA` parameter and captures it along with process metadata.\n\n### Event Structure\n\n```mermaid\ngraph LR\n    subgraph \"MysqldEvent Structure\"\n        PID[\"Pid: uint64<br/>Process ID\"]\n        TS[\"Timestamp: uint64<br/>Kernel timestamp\"]\n        Query[\"Query: [256]uint8<br/>SQL query text\"]\n        Alllen[\"Alllen: uint64<br/>Total query length\"]\n        Len[\"Len: uint64<br/>Captured length\"]\n        Comm[\"Comm: [16]uint8<br/>Process name\"]\n        Retval[\"Retval: int8<br/>dispatch_command return\"]\n    end\n    \n    PID --> Output[\"Text Output Format\"]\n    TS --> Output\n    Query --> Output\n    Len --> Output\n    Comm --> Output\n    Retval --> Output\n```\n\nThe `MysqldEvent` structure captures:\n\n| Field | Type | Description |\n|-------|------|-------------|\n| `Pid` | `uint64` | Process ID of mysqld server |\n| `Timestamp` | `uint64` | Kernel timestamp (converted to Unix nanoseconds) |\n| `Query` | `[256]uint8` | SQL query text (up to 256 bytes) |\n| `Alllen` | `uint64` | Total length of original query |\n| `Len` | `uint64` | Length of captured query text |\n| `Comm` | `[16]uint8` | Process command name |\n| `Retval` | `dispatchCommandReturn` | Return value from dispatch_command |\n\n**Return Values:**\n\nThe `Retval` field indicates the query execution result:\n\n| Constant | Value | Description |\n|----------|-------|-------------|\n| `DispatchCommandSuccess` | 0 | Query executed successfully |\n| `DispatchCommandCloseConnection` | 1 | Connection closed after query |\n| `DispatchCommandWouldblock` | 2 | Query would block (async) |\n| `DispatchCommandNotCaptured` | -1 | Query not captured by probe |\n| `DispatchCommandV57Failed` | -2 | MySQL 5.7 specific failure |\n\nSources: [user/event/event_mysqld.go:38-78](), [user/event/event_mysqld.go:40-66]()\n\n### CLI Usage\n\n```bash\n# Basic MySQL query capture\necapture mysqld\n\n# Specify custom mysqld binary path\necapture mysqld --mysqld /usr/sbin/mysqld\n\n# Capture from MariaDB\necapture mysqld --mysqld /usr/sbin/mariadbd\n\n# Manual offset specification (advanced)\necapture mysqld --offset 0x710410\n\n# Custom function name (if dispatch_command is not found)\necapture mysqld --funcname my_dispatch_command\n```\n\n**Configuration Flags:**\n\n| Flag | Short | Default | Description |\n|------|-------|---------|-------------|\n| `--mysqld` | `-m` | `/usr/sbin/mariadbd` | Path to mysqld binary |\n| `--offset` | | `0` | Manual function offset (hex) |\n| `--funcname` | `-f` | | Custom function name to hook |\n\nThe module automatically locates the `dispatch_command` function symbol in the specified binary. If symbol resolution fails, `--offset` or `--funcname` can be used to manually specify the hook point.\n\nSources: [cli/cmd/mysqld.go:39-43]()\n\n### Output Format\n\nMySQL query events are displayed in text format:\n\n```\nPID:12345, Comm:mysqld, Time:1640000000000, length:(85/85), return:DISPATCH_COMMAND_SUCCESS, Line:SELECT * FROM users WHERE id = 42\n```\n\nThe output includes:\n- **PID**: Database server process ID\n- **Comm**: Process name (mysqld/mariadbd)\n- **Time**: Unix timestamp in nanoseconds\n- **length**: Captured length / Total query length\n- **return**: Dispatch command return status\n- **Line**: SQL query text\n\nSources: [user/event/event_mysqld.go:112-115]()\n\n---\n\n## PostgreSQL Query Auditing\n\n### Supported Versions\n\nThe PostgreSQL module supports:\n- **PostgreSQL 10+**\n\nThe module hooks query execution functions within the PostgreSQL server to capture SQL statements.\n\nSources: [cli/cmd/postgres.go:32-33]()\n\n### Hook Function\n\nPostgreSQL uses a different internal architecture than MySQL. The exact hook function is configurable via the `--funcname` flag, allowing targeting of different query processing entry points such as:\n- `exec_simple_query` - Simple query protocol\n- `exec_parse_message` - Extended query protocol (parse phase)\n- `exec_bind_message` - Extended query protocol (bind phase)\n\nThe specific function choice depends on the PostgreSQL version and desired capture granularity.\n\n### Event Structure\n\n```mermaid\ngraph LR\n    subgraph \"PostgresEvent Structure\"\n        PID[\"Pid: uint64<br/>Process ID\"]\n        TS[\"Timestamp: uint64<br/>Kernel timestamp\"]\n        Query[\"Query: [256]uint8<br/>SQL query text\"]\n        Comm[\"Comm: [16]uint8<br/>Process name\"]\n    end\n    \n    PID --> Output[\"Text Output Format\"]\n    TS --> Output\n    Query --> Output\n    Comm --> Output\n```\n\nThe `PostgresEvent` structure is simpler than MySQL's:\n\n| Field | Type | Description |\n|-------|------|-------------|\n| `Pid` | `uint64` | Process ID of postgres backend |\n| `Timestamp` | `uint64` | Kernel timestamp (converted to Unix nanoseconds) |\n| `Query` | `[256]uint8` | SQL query text (up to 256 bytes) |\n| `Comm` | `[16]uint8` | Process command name |\n\n**Note:** PostgreSQL events do not capture return values or length information, as the hook point occurs at a different stage of query processing compared to MySQL.\n\nSources: [user/event/event_postgres.go:30-44]()\n\n### CLI Usage\n\n```bash\n# Basic PostgreSQL query capture\necapture postgres\n\n# Specify custom postgres binary path\necapture postgres --postgres /usr/lib/postgresql/14/bin/postgres\n\n# Specify custom function to hook\necapture postgres --funcname exec_simple_query\n```\n\n**Configuration Flags:**\n\n| Flag | Short | Default | Description |\n|------|-------|---------|-------------|\n| `--postgres` | `-m` | `/usr/bin/postgres` | Path to postgres binary |\n| `--funcname` | `-f` | | Function name to hook (required for some versions) |\n\nThe `--funcname` flag is particularly important for PostgreSQL, as the optimal hook function varies by version and use case. Common targets include `exec_simple_query` for basic query capture or `exec_parse_message` for capturing prepared statements.\n\nSources: [cli/cmd/postgres.go:37-38]()\n\n### Output Format\n\nPostgreSQL query events are displayed in text format:\n\n```\nPID: 23456, Comm: postgres, Time: 1640000000000, Query: SELECT version();\n```\n\nThe output includes:\n- **PID**: PostgreSQL backend process ID\n- **Comm**: Process name (postgres)\n- **Time**: Unix timestamp in nanoseconds\n- **Query**: SQL query text\n\nSources: [user/event/event_postgres.go:67-69]()\n\n---\n\n## Data Flow and Event Processing\n\n### Module Initialization and Hook Attachment\n\n```mermaid\nflowchart TD\n    CLI[\"CLI Command<br/>mysqldCommandFunc<br/>postgresCommandFunc\"]\n    RunModule[\"runModule<br/>ModuleNameMysqld<br/>ModuleNamePostgres\"]\n    ModuleFactory[\"Module Factory<br/>GetModuleFunc\"]\n    \n    subgraph \"MySQL Module\"\n        MySQLInit[\"MMysqldProbe.Init<br/>Parse binary<br/>Find dispatch_command\"]\n        MySQLOffset[\"Symbol Resolution<br/>ELF parsing<br/>Offset calculation\"]\n        MySQLAttach[\"Attach Uprobe<br/>dispatch_command entry\"]\n    end\n    \n    subgraph \"PostgreSQL Module\"\n        PGInit[\"MPostgresProbe.Init<br/>Parse binary<br/>Find exec_* function\"]\n        PGOffset[\"Symbol Resolution<br/>ELF parsing<br/>Function lookup\"]\n        PGAttach[\"Attach Uprobe<br/>exec_* entry\"]\n    end\n    \n    CLI --> RunModule\n    RunModule --> ModuleFactory\n    \n    ModuleFactory -->|mysqld| MySQLInit\n    ModuleFactory -->|postgres| PGInit\n    \n    MySQLInit --> MySQLOffset\n    MySQLOffset --> MySQLAttach\n    \n    PGInit --> PGOffset\n    PGOffset --> PGAttach\n    \n    MySQLAttach --> eBPF[\"eBPF Programs Loaded\"]\n    PGAttach --> eBPF\n```\n\n**Initialization Steps:**\n1. **CLI Parsing**: `mysqldCommandFunc` or `postgresCommandFunc` processes command-line arguments\n2. **Module Creation**: `runModule` invokes the module factory with `ModuleNameMysqld` or `ModuleNamePostgres`\n3. **Binary Analysis**: Module `Init` function parses the target binary (mysqld/postgres) using ELF parsing\n4. **Symbol Resolution**: Locate target function symbol (`dispatch_command` or custom function)\n5. **Uprobe Attachment**: Attach eBPF uprobe to function entry point\n\nSources: [cli/cmd/mysqld.go:46-48](), [cli/cmd/postgres.go:43-44]()\n\n### Event Capture and Decoding\n\n```mermaid\nsequenceDiagram\n    participant DB as Database Server\n    participant Uprobe as eBPF Uprobe\n    participant Perf as Perf Buffer\n    participant Reader as perfEventReader\n    participant Module as Module.Decode\n    participant Output as Text Output\n    \n    DB->>Uprobe: dispatch_command() / exec_*() called\n    Uprobe->>Uprobe: Extract query string from parameters\n    Uprobe->>Uprobe: Build event struct (Pid, Timestamp, Query)\n    Uprobe->>Perf: bpf_perf_event_output(events)\n    \n    Perf->>Reader: Poll perf buffer\n    Reader->>Module: Decode(payload)\n    Module->>Module: binary.Read(MysqldEvent/PostgresEvent)\n    Module->>Module: DecodeKtime(timestamp)\n    Module->>Output: String() formatting\n    Output->>Output: Display: PID, Comm, Query\n```\n\n**Event Flow:**\n1. **Function Entry**: Database server calls hooked function (`dispatch_command` or `exec_*`)\n2. **Parameter Extraction**: eBPF probe reads function parameters to extract query string pointer\n3. **Query Capture**: Probe reads up to 256 bytes from query string address\n4. **Event Construction**: Probe builds `MysqldEvent` or `PostgresEvent` structure\n5. **Perf Buffer**: Event is written to perf buffer via `bpf_perf_event_output`\n6. **Userspace Read**: `perfEventReader` polls perf buffer and retrieves raw event data\n7. **Decoding**: `Module.Decode` deserializes binary payload into Go struct\n8. **Timestamp Conversion**: `DecodeKtime` converts kernel timestamp to Unix nanoseconds\n9. **Display**: `String()` method formats event for console output\n\nSources: [user/event/event_mysqld.go:80-109](), [user/event/event_postgres.go:46-64]()\n\n---\n\n## Event Structure Comparison\n\n| Feature | MySQL (MysqldEvent) | PostgreSQL (PostgresEvent) |\n|---------|---------------------|----------------------------|\n| **Max Query Length** | 256 bytes | 256 bytes |\n| **PID Field** | ✓ (uint64) | ✓ (uint64) |\n| **Timestamp** | ✓ (kernel time → Unix nano) | ✓ (kernel time → Unix nano) |\n| **Process Name** | ✓ (16 bytes) | ✓ (16 bytes) |\n| **Query Text** | ✓ (256 bytes) | ✓ (256 bytes) |\n| **Total Length** | ✓ (Alllen field) | ✗ |\n| **Captured Length** | ✓ (Len field) | ✗ |\n| **Return Value** | ✓ (dispatchCommandReturn) | ✗ |\n| **Event Type** | `TypeOutput` | `TypeOutput` |\n| **UUID Format** | `{PID}_{Comm}` | `{PID}_{Comm}` |\n\nBoth modules:\n- Capture up to 256 bytes of query text (defined by `MysqldMaxDataSize` and `PostgresMaxDataSize`)\n- Convert kernel timestamps to Unix nanoseconds via `DecodeKtime`\n- Use `TypeOutput` event type for direct console display\n- Support Protobuf event conversion via `ToProtobufEvent()`\n\nMySQL provides additional metadata (query length tracking, return value) due to richer information available at the `dispatch_command` hook point.\n\nSources: [user/event/event_mysqld.go:38-78](), [user/event/event_postgres.go:36-44]()\n\n---\n\n## Protobuf Integration\n\nBoth database modules implement the `ToProtobufEvent()` method for external integration via WebSocket streaming (see [Protobuf and External Integration](#4.4)).\n\n### MySQL Protobuf Event\n\n```go\n// ToProtobufEvent converts MysqldEvent to protobuf Event\n// Source: user/event/event_mysqld.go:138-151\nEvent {\n    Timestamp: int64(me.Timestamp),\n    Uuid:      \"{PID}_{Comm}\",\n    SrcIp:     \"127.0.0.1\",  // Database events have no network info\n    SrcPort:   0,\n    DstIp:     \"127.0.0.1\",\n    DstPort:   0,\n    Pid:       int64(me.Pid),\n    Pname:     Comm string,\n    Type:      uint32(me.Retval),  // Dispatch command return value\n    Length:    uint32(me.Len),     // Query length\n    Payload:   me.Query[:me.Len]   // SQL query bytes\n}\n```\n\n### PostgreSQL Protobuf Event\n\n```go\n// ToProtobufEvent converts PostgresEvent to protobuf Event\n// Source: user/event/event_postgres.go:87-101\nEvent {\n    Timestamp: int64(pe.Timestamp),\n    Uuid:      \"{PID}_{Comm}\",\n    SrcIp:     \"127.0.0.1\",  // Database events have no network info\n    SrcPort:   0,\n    DstIp:     \"127.0.0.1\",\n    DstPort:   0,\n    Pid:       int64(pe.Pid),\n    Pname:     Comm string,\n    Type:      0,             // No return value for PostgreSQL\n    Length:    uint32(len(queryStr)),\n    Payload:   queryStr bytes  // SQL query bytes\n}\n```\n\n**Key Differences:**\n- MySQL events use `Type` field to encode `dispatchCommandReturn` status\n- PostgreSQL events have `Type` fixed at 0\n- Both use placeholder IPs (`127.0.0.1`) as database events have no network correlation\n- Payload contains raw SQL query bytes\n\nSources: [user/event/event_mysqld.go:138-151](), [user/event/event_postgres.go:87-101]()\n\n---\n\n## Limitations and Considerations\n\n### Query Length Truncation\n\nBoth modules capture a maximum of 256 bytes of query text:\n- **MySQL**: `MysqldMaxDataSize = 256` ([user/event/event_mysqld.go:38]())\n- **PostgreSQL**: `PostgresMaxDataSize = 256` ([user/event/event_postgres.go:36]())\n\nFor MySQL, the `Alllen` field indicates the total query length, allowing detection of truncation. PostgreSQL events do not track total length.\n\n**Long Query Handling:**\n```\n# MySQL output shows truncation\nPID:12345, Comm:mysqld, length:(256/1024), return:DISPATCH_COMMAND_SUCCESS, Line:SELECT * FROM very_long_table_name WHERE column1 = 'val...\n\n# PostgreSQL output shows only captured portion\nPID: 23456, Comm: postgres, Query: SELECT * FROM very_long_table_name WHERE column1 = 'val...\n```\n\n### Version-Specific Symbol Requirements\n\n**MySQL/MariaDB:**\n- Function name `dispatch_command` is consistent across MySQL 5.6-8.0 and MariaDB 10.5+\n- Older MySQL 5.5 versions may use different internal function names\n- `--funcname` flag allows override if symbol not found\n\n**PostgreSQL:**\n- No default function name is hardcoded\n- `--funcname` flag is often required to specify target function\n- Common targets: `exec_simple_query`, `exec_parse_message`, `exec_bind_message`\n- Function availability varies by PostgreSQL version\n\n### No Network Context\n\nUnlike TLS modules, database audit events do not capture:\n- Client IP address and port\n- Server IP address and port\n- Socket file descriptors\n- Network connection state\n\nThis is because the hook points occur at the query processing layer, after network protocol handling. Process ID (`Pid`) and command name (`Comm`) are the primary identifiers for correlating queries to database server instances.\n\n### Process vs Connection Tracking\n\nDatabase events are associated with backend process PIDs, not client connections:\n- **MySQL**: Single `mysqld` process with multiple threads (one PID)\n- **PostgreSQL**: Separate backend process per connection (different PIDs)\n\nThis affects event correlation:\n- MySQL events from all connections share the same PID\n- PostgreSQL events can be grouped by backend PID to track per-connection activity\n\nSources: [user/event/event_mysqld.go:158-159](), [user/event/event_postgres.go:108-109]()\n\n---\n\n## Use Cases\n\n### Security Auditing\n\nDatabase query auditing enables:\n- **SQL Injection Detection**: Capture suspicious query patterns with unusual syntax\n- **Privilege Escalation Monitoring**: Track queries accessing sensitive tables or performing administrative operations\n- **Compliance Logging**: Record all database access for audit trails without database-level logging overhead\n\n### Performance Analysis\n\nQuery capture supports:\n- **Slow Query Identification**: Correlate captured queries with performance metrics (requires external tooling)\n- **Query Pattern Analysis**: Understand application database access patterns\n- **Connection Tracking** (PostgreSQL): Monitor per-connection query sequences via backend PID\n\n### Development and Debugging\n\nReal-time query capture assists:\n- **ORM Debugging**: Observe actual SQL generated by ORMs (Hibernate, SQLAlchemy, etc.)\n- **Application Tracing**: Correlate application code execution with database queries via PID\n- **Query Optimization**: Capture queries before they reach database logs for immediate analysis\n\n---\n\n## Module Registration and CLI Integration\n\n### Module Name Constants\n\nDatabase modules are registered with the module system using predefined constants:\n\n```go\n// MySQL module registration\n// Source: cli/cmd/mysqld.go:48\nrunModule(module.ModuleNameMysqld, myc)\n\n// PostgreSQL module registration  \n// Source: cli/cmd/postgres.go:44\nrunModule(module.ModuleNamePostgres, pgc)\n```\n\nThese constants (`ModuleNameMysqld`, `ModuleNamePostgres`) map to module factory functions that instantiate `MMysqldProbe` and `MPostgresProbe` respectively.\n\n### Configuration Structures\n\n**MySQL Configuration:**\n- `MysqldConfig` structure ([cli/cmd/mysqld.go:27]())\n- Fields: `Mysqldpath`, `Offset`, `FuncName`\n- Created via `config.NewMysqldConfig()`\n\n**PostgreSQL Configuration:**\n- `PostgresConfig` structure ([cli/cmd/postgres.go:27]())\n- Fields: `PostgresPath`, `FuncName`\n- Created via `config.NewPostgresConfig()`\n\nBoth inherit common configuration fields from the base config (PID filtering, UID filtering, output logging, hex display, etc.).\n\nSources: [cli/cmd/mysqld.go:27-49](), [cli/cmd/postgres.go:27-44]()"
          },
          {
            "page_plan": {
              "id": "3.3",
              "title": "Network Packet Capture with TC"
            },
            "content": "# Network Packet Capture with TC\n\n<details>\n<summary>Relevant source files</summary>\n\nThe following files were used as context for generating this wiki page:\n\n- [cli/cmd/root.go](cli/cmd/root.go)\n- [kern/common.h](kern/common.h)\n- [kern/ecapture.h](kern/ecapture.h)\n- [kern/tc.h](kern/tc.h)\n- [user/config/iconfig.go](user/config/iconfig.go)\n- [user/module/imodule.go](user/module/imodule.go)\n- [user/module/probe_openssl.go](user/module/probe_openssl.go)\n\n</details>\n\n\n\n## Purpose and Scope\n\nThis document explains eCapture's Traffic Control (TC) based network packet capture subsystem. TC eBPF programs attach to network interfaces to intercept packets at the kernel level, enabling the capture of encrypted network traffic alongside plaintext data extracted from TLS libraries. The TC subsystem provides process attribution by mapping network connections to processes using kprobe-based connection tracking.\n\nFor information about TLS/SSL plaintext capture, see [TLS/SSL Modules](#3.1). For PCAP file generation and output formats, see [PCAP Integration](#4.2).\n\n## Architecture Overview\n\nThe TC packet capture system consists of three main components:\n\n1. **TC Classifier Programs**: eBPF programs attached to network interfaces that intercept packets at ingress and egress points\n2. **Connection Tracking Kprobes**: eBPF kprobes on `tcp_sendmsg` and `udp_sendmsg` that map network connections to processes\n3. **Network Mapping System**: An LRU hash map that maintains the association between network 4-tuples and process metadata\n\n```mermaid\ngraph TB\n    subgraph \"Network Interface Layer\"\n        NIC[\"Network Interface<br/>(eth0, wlan0, etc.)\"]\n    end\n    \n    subgraph \"TC eBPF Programs - kern/tc.h\"\n        INGRESS[\"ingress_cls_func()<br/>SEC classifier<br/>Lines 285-288\"]\n        EGRESS[\"egress_cls_func()<br/>SEC classifier<br/>Lines 279-282\"]\n        CAPTURE[\"capture_packets()<br/>Main capture logic<br/>Lines 135-276\"]\n    end\n    \n    subgraph \"Connection Tracking Kprobes - kern/tc.h\"\n        TCP_PROBE[\"tcp_sendmsg<br/>SEC kprobe<br/>Lines 290-347\"]\n        UDP_PROBE[\"udp_sendmsg<br/>SEC kprobe<br/>Lines 349-397\"]\n    end\n    \n    subgraph \"eBPF Maps - kern/tc.h\"\n        NET_MAP[\"network_map<br/>BPF_MAP_TYPE_LRU_HASH<br/>Lines 73-77\"]\n        SKB_EVENTS[\"skb_events<br/>BPF_MAP_TYPE_PERF_EVENT_ARRAY<br/>Lines 57-62\"]\n        SKB_BUFFER[\"skb_data_buffer_heap<br/>BPF_MAP_TYPE_PERCPU_ARRAY<br/>Lines 64-69\"]\n    end\n    \n    subgraph \"User Space - user/module/\"\n        MODULE[\"MOpenSSLProbe<br/>MTCProbe embedded<br/>probe_openssl.go:83-106\"]\n        PROCESSOR[\"Event Processor<br/>Packet handling\"]\n    end\n    \n    NIC -->|\"ingress packets\"| INGRESS\n    NIC <--\"|egress packets\"| EGRESS\n    \n    INGRESS --> CAPTURE\n    EGRESS --> CAPTURE\n    \n    TCP_PROBE -->|\"store tuple->ctx\"| NET_MAP\n    UDP_PROBE -->|\"store tuple->ctx\"| NET_MAP\n    \n    CAPTURE -->|\"lookup ctx\"| NET_MAP\n    CAPTURE -->|\"send event\"| SKB_EVENTS\n    CAPTURE -->|\"use buffer\"| SKB_BUFFER\n    \n    SKB_EVENTS -->|\"perf events\"| MODULE\n    MODULE --> PROCESSOR\n    \n    style CAPTURE fill:#f9f9f9\n    style NET_MAP fill:#f9f9f9\n    style TCP_PROBE fill:#f9f9f9\n    style UDP_PROBE fill:#f9f9f9\n```\n\n**Sources**: [kern/tc.h:1-398](), [user/module/probe_openssl.go:83-106]()\n\n## TC Classifier Programs\n\nTC classifiers are eBPF programs that attach to network devices and process every packet passing through them. eCapture deploys two classifier programs: one for ingress traffic and one for egress traffic.\n\n### Attachment Points\n\n```mermaid\ngraph LR\n    subgraph \"Kernel Network Stack\"\n        RX[\"Packet Reception<br/>from NIC\"]\n        TX[\"Packet Transmission<br/>to NIC\"]\n    end\n    \n    subgraph \"TC Hooks\"\n        ING[\"ingress_cls_func()<br/>tc.h:285-288\"]\n        EGR[\"egress_cls_func()<br/>tc.h:279-282\"]\n    end\n    \n    subgraph \"Capture Logic\"\n        CAP[\"capture_packets(skb, is_ingress)<br/>tc.h:135-276\"]\n    end\n    \n    RX --> ING\n    ING --> CAP\n    \n    CAP --> EGR\n    EGR --> TX\n    \n    CAP -->|\"TC_ACT_OK<br/>pass through\"| TX\n```\n\nBoth classifier functions delegate to the same `capture_packets()` function with a direction flag:\n\n- **ingress_cls_func**: Processes incoming packets [kern/tc.h:285-288]()\n- **egress_cls_func**: Processes outgoing packets [kern/tc.h:279-282]()\n\nThe classifiers return `TC_ACT_OK` to allow packets to continue through the network stack without modification [kern/common.h:58]().\n\n**Sources**: [kern/tc.h:135-288](), [kern/common.h:58]()\n\n## Packet Capture Logic\n\nThe `capture_packets()` function implements the core packet capture logic. It operates on socket buffer structures (`struct __sk_buff`) provided by the kernel.\n\n### Processing Pipeline\n\n```mermaid\nflowchart TD\n    START[\"capture_packets(skb, is_ingress)\"]\n    \n    VALIDATE[\"Validate packet length<br/>eth + ip headers<br/>tc.h:141-144\"]\n    \n    FILTER[\"PCAP filter check<br/>filter_pcap_l2()<br/>tc.h:148-150\"]\n    \n    PROTO_CHECK{\"Protocol?\"}\n    \n    IPV4[\"Parse IPv4 packet<br/>Extract 4-tuple<br/>tc.h:199-236\"]\n    \n    IPV6[\"Parse IPv6 packet<br/>Extract 4-tuple<br/>tc.h:156-198\"]\n    \n    LOOKUP[\"Lookup network_map<br/>by conn_id<br/>tc.h:225 or 188\"]\n    \n    FOUND{\"Context<br/>found?\"}\n    \n    REVERSE[\"Try reverse lookup<br/>swap src/dst<br/>tc.h:227-234 or 189-197\"]\n    \n    FILTER_PID[\"Filter by PID/UID<br/>target_pid, target_uid<br/>tc.h:244-249\"]\n    \n    BUILD[\"Build skb_data_event_t<br/>timestamp, len, ifindex<br/>tc.h:239-258\"]\n    \n    SEND[\"Send to skb_events<br/>bpf_perf_event_output<br/>tc.h:271\"]\n    \n    RETURN[\"Return TC_ACT_OK<br/>tc.h:275\"]\n    \n    START --> VALIDATE\n    VALIDATE -->|\"fail\"| RETURN\n    VALIDATE -->|\"pass\"| FILTER\n    \n    FILTER -->|\"reject\"| RETURN\n    FILTER -->|\"accept\"| PROTO_CHECK\n    \n    PROTO_CHECK -->|\"IPv4\"| IPV4\n    PROTO_CHECK -->|\"IPv6\"| IPV6\n    PROTO_CHECK -->|\"other\"| RETURN\n    \n    IPV4 --> LOOKUP\n    IPV6 --> LOOKUP\n    \n    LOOKUP --> FOUND\n    FOUND -->|\"not found\"| REVERSE\n    FOUND -->|\"found\"| FILTER_PID\n    \n    REVERSE --> FOUND\n    \n    FILTER_PID -->|\"pass\"| BUILD\n    FILTER_PID -->|\"reject\"| RETURN\n    \n    BUILD --> SEND\n    SEND --> RETURN\n```\n\n**Sources**: [kern/tc.h:135-276]()\n\n### Protocol Support\n\nThe TC capture supports multiple protocols with both IPv4 and IPv6:\n\n| Protocol | Constant | Filter Location |\n|----------|----------|-----------------|\n| TCP | `IPPROTO_TCP` | [kern/tc.h:208,320,332]() |\n| UDP | `IPPROTO_UDP` | [kern/tc.h:208,370,382]() |\n| ICMP | `IPPROTO_ICMP` | [kern/tc.h:208]() |\n| ICMPv6 | `IPPROTO_ICMPV6` | [kern/tc.h:164]() |\n\nThe capture extracts the following network tuple information:\n\n```c\nstruct net_id_t {\n    u32 protocol;      // IPPROTO_TCP or IPPROTO_UDP\n    u32 src_port;      // Source port\n    u32 src_ip4;       // Source IPv4 address\n    u32 dst_port;      // Destination port\n    u32 dst_ip4;       // Destination IPv4 address\n    u32 src_ip6[4];    // Source IPv6 address\n    u32 dst_ip6[4];    // Destination IPv6 address\n};\n```\n\n**Sources**: [kern/tc.h:39-47,156-236]()\n\n## Connection Tracking with Kprobes\n\nTo attribute captured packets to specific processes, eCapture uses kprobes on kernel functions that establish network connections. These kprobes capture the process context before packets are transmitted.\n\n### Kprobe Attachment Points\n\n```mermaid\ngraph TB\n    subgraph \"Application Space\"\n        APP[\"Application Process<br/>send()/sendto()\"]\n    end\n    \n    subgraph \"System Call Layer\"\n        SYSCALL[\"sys_sendto/sys_write\"]\n    end\n    \n    subgraph \"Kernel Functions\"\n        TCP[\"tcp_sendmsg(sock *sk, ...)<br/>tc.h:291-347\"]\n        UDP[\"udp_sendmsg(sock *sk, ...)<br/>tc.h:350-397\"]\n    end\n    \n    subgraph \"eBPF Kprobes\"\n        TCP_PROBE[\"SEC kprobe/tcp_sendmsg<br/>Extract sock info<br/>Store to network_map\"]\n        UDP_PROBE[\"SEC kprobe/udp_sendmsg<br/>Extract sock info<br/>Store to network_map\"]\n    end\n    \n    subgraph \"Data Extraction\"\n        SOCK[\"struct sock<br/>__sk_common\"]\n        EXTRACT[\"Extract:<br/>- family (AF_INET/AF_INET6)<br/>- src/dst IP<br/>- src/dst port\"]\n    end\n    \n    subgraph \"Context Collection\"\n        CTX[\"Collect:<br/>- PID (bpf_get_current_pid_tgid)<br/>- UID (bpf_get_current_uid_gid)<br/>- comm (bpf_get_current_comm)\"]\n    end\n    \n    subgraph \"Storage\"\n        MAP[\"network_map<br/>key: net_id_t<br/>value: net_ctx_t\"]\n    end\n    \n    APP --> SYSCALL\n    SYSCALL --> TCP\n    SYSCALL --> UDP\n    \n    TCP --> TCP_PROBE\n    UDP --> UDP_PROBE\n    \n    TCP_PROBE --> SOCK\n    UDP_PROBE --> SOCK\n    \n    SOCK --> EXTRACT\n    EXTRACT --> CTX\n    \n    CTX --> MAP\n    \n    style TCP_PROBE fill:#f9f9f9\n    style UDP_PROBE fill:#f9f9f9\n    style MAP fill:#f9f9f9\n```\n\n**Sources**: [kern/tc.h:290-397]()\n\n### Process Context Extraction\n\nBoth kprobes extract the same information and store it in the `network_map`:\n\n```c\nstruct net_ctx_t {\n    u32 pid;              // Process ID\n    u32 uid;              // User ID\n    char comm[16];        // Command name (TASK_COMM_LEN)\n};\n```\n\nThe kprobes perform the following steps:\n\n1. **Get Process Context** [kern/tc.h:292-294,351-353]()\n   - `bpf_get_current_pid_tgid() >> 32` - Extract PID\n   - `bpf_get_current_uid_gid()` - Extract UID\n   - `bpf_get_current_comm()` - Get process name\n\n2. **Extract Socket Information** [kern/tc.h:304-337,354-387]()\n   - Read `sock->__sk_common.skc_family` - Address family\n   - Read `sock->__sk_common.skc_num` - Local port\n   - Read `sock->__sk_common.skc_dport` - Remote port\n   - Read source/destination IP addresses\n\n3. **Store Mapping** [kern/tc.h:345,395]()\n   - Create `net_id_t` key from network tuple\n   - Create `net_ctx_t` value from process context\n   - `bpf_map_update_elem(&network_map, &conn_id, &net_ctx, BPF_ANY)`\n\n**Sources**: [kern/tc.h:290-397]()\n\n## Network Mapping System\n\nThe `network_map` is the central data structure that associates network connections with process information. It uses an LRU (Least Recently Used) eviction policy to maintain a bounded cache of active connections.\n\n### Map Configuration\n\n```mermaid\ngraph LR\n    subgraph \"Map Definition - tc.h:73-77\"\n        TYPE[\"Type: BPF_MAP_TYPE_LRU_HASH\"]\n        KEY[\"Key: struct net_id_t<br/>4-tuple + protocol\"]\n        VALUE[\"Value: struct net_ctx_t<br/>pid + uid + comm\"]\n        SIZE[\"Max Entries: 10240\"]\n    end\n    \n    subgraph \"Key Structure - net_id_t\"\n        K_PROTO[\"protocol: u32\"]\n        K_SPORT[\"src_port: u32\"]\n        K_SIP4[\"src_ip4: u32\"]\n        K_DPORT[\"dst_port: u32\"]\n        K_DIP4[\"dst_ip4: u32\"]\n        K_SIP6[\"src_ip6: u32[4]\"]\n        K_DIP6[\"dst_ip6: u32[4]\"]\n    end\n    \n    subgraph \"Value Structure - net_ctx_t\"\n        V_PID[\"pid: u32\"]\n        V_UID[\"uid: u32\"]\n        V_COMM[\"comm: char[16]\"]\n    end\n    \n    TYPE --> KEY\n    KEY --> VALUE\n    VALUE --> SIZE\n    \n    KEY --> K_PROTO\n    KEY --> K_SPORT\n    KEY --> K_DIP4\n    \n    VALUE --> V_PID\n    VALUE --> V_UID\n    VALUE --> V_COMM\n```\n\n**Sources**: [kern/tc.h:39-77]()\n\n### Bidirectional Lookup\n\nSince packets can arrive in either direction (client→server or server→client), the `capture_packets()` function implements bidirectional lookup:\n\n1. **Initial Lookup**: Try to find the connection using the packet's source as the connection source [kern/tc.h:225,188]()\n2. **Reverse Lookup**: If not found, swap source and destination and try again [kern/tc.h:227-234,189-197]()\n\nThis ensures that both incoming and outgoing packets are correctly attributed to the originating process.\n\n**Sources**: [kern/tc.h:188-234]()\n\n## Packet Filtering\n\neCapture supports multiple levels of filtering to reduce overhead and capture only relevant traffic.\n\n### Filter Hierarchy\n\n```mermaid\nflowchart TD\n    PKT[\"Incoming Packet\"]\n    \n    L1[\"Length Filter<br/>Minimum header size<br/>tc.h:141-144\"]\n    \n    L2[\"PCAP Filter (Optional)<br/>filter_pcap_l2()<br/>tc.h:121-132,148-150\"]\n    \n    L3[\"Protocol Filter<br/>TCP/UDP/ICMP only<br/>tc.h:164,208\"]\n    \n    L4[\"Process Filter<br/>target_pid, target_uid<br/>tc.h:244-249\"]\n    \n    CAPTURE[\"Capture Packet\"]\n    DROP[\"Drop Packet\"]\n    \n    PKT --> L1\n    L1 -->|\"< min size\"| DROP\n    L1 -->|\"≥ min size\"| L2\n    \n    L2 -->|\"rejected\"| DROP\n    L2 -->|\"accepted\"| L3\n    \n    L3 -->|\"unsupported\"| DROP\n    L3 -->|\"supported\"| L4\n    \n    L4 -->|\"no match\"| DROP\n    L4 -->|\"match\"| CAPTURE\n```\n\n### PCAP Filter Integration\n\nThe `filter_pcap_l2()` function [kern/tc.h:121-132]() serves as an injection point for BPF bytecode generated from PCAP filter expressions. The function is marked `__noinline` to prevent compiler optimization, allowing userspace to patch its instructions.\n\nThe filter patching is initiated in userspace [user/module/probe_openssl.go:303-307]():\n\n```go\nif m.eBPFProgramType == TlsCaptureModelTypePcap && pcapFilter != \"\" {\n    ebpfFuncs := []string{tcFuncNameIngress, tcFuncNameEgress}\n    m.bpfManager.InstructionPatchers = prepareInsnPatchers(m.bpfManager,\n        ebpfFuncs, pcapFilter)\n}\n```\n\n**Sources**: [kern/tc.h:121-150](), [user/module/probe_openssl.go:303-307]()\n\n### Process Filtering\n\nWhen `target_pid` or `target_uid` are set (kernel ≥ 5.2), packets are filtered to match specific processes [kern/tc.h:244-249]():\n\n```c\nif (target_pid != 0 && target_pid != net_ctx->pid) {\n    return TC_ACT_OK;\n}\nif (target_uid != 0 && target_uid != net_ctx->uid) {\n    return TC_ACT_OK;\n}\n```\n\nThis filtering happens after successful connection lookup, ensuring that only packets belonging to the target process are captured.\n\n**Note**: The kprobes themselves do NOT filter by PID/UID [kern/tc.h:296-302]() because the `network_map` must contain all connections for the TC classifiers to perform attribution. Process filtering only occurs during packet capture.\n\n**Sources**: [kern/tc.h:244-249,296-302](), [kern/common.h:64-71]()\n\n## Data Structures\n\n### Event Structure\n\nCaptured packet metadata is transmitted to userspace using the `skb_data_event_t` structure:\n\n```c\nstruct skb_data_event_t {\n    uint64_t ts;                // Timestamp (bpf_ktime_get_ns)\n    u32 pid;                    // Process ID\n    char comm[TASK_COMM_LEN];   // Process name\n    u32 len;                    // Packet length (skb->len)\n    u32 ifindex;                // Network interface index\n};\n```\n\nThe event contains minimal metadata (36 bytes) [kern/tc.h:20]() with the packet payload appended via the `bpf_perf_event_output()` flags parameter [kern/tc.h:260-271]():\n\n```c\nu64 flags = BPF_F_CURRENT_CPU;\nflags |= (u64)skb->len << 32;  // Encode packet length in upper 32 bits\nbpf_perf_event_output(skb, &skb_events, flags, &event, TC_PACKET_MIN_SIZE);\n```\n\n**Sources**: [kern/tc.h:30-37,239-271]()\n\n### Buffer Management\n\nTo avoid stack overflow with large structures, eCapture uses a per-CPU array map for temporary event storage:\n\n```c\nstruct {\n    __uint(type, BPF_MAP_TYPE_PERCPU_ARRAY);\n    __type(key, u32);\n    __type(value, struct skb_data_event_t);\n    __uint(max_entries, 1);\n} skb_data_buffer_heap SEC(\".maps\");\n```\n\nThe `make_skb_data_event()` function [kern/tc.h:92-100]() retrieves a buffer from this map, which is automatically managed per-CPU by the kernel.\n\n**Sources**: [kern/tc.h:64-100]()\n\n## Integration with Capture Modules\n\nThe TC packet capture integrates primarily with TLS capture modules to provide complete network traffic visibility.\n\n### MTCProbe Base Structure\n\nThe TC functionality is encapsulated in the `MTCProbe` struct, which is embedded by capture modules that need network packet capture [user/module/probe_openssl.go:84]():\n\n```mermaid\ngraph TB\n    subgraph \"Module Hierarchy\"\n        MOD[\"Module<br/>base module struct\"]\n        MTCP[\"MTCProbe<br/>TC probe base<br/>probe_tc.go\"]\n        MOSSL[\"MOpenSSLProbe<br/>OpenSSL/BoringSSL capture<br/>probe_openssl.go:83-106\"]\n    end\n    \n    subgraph \"TC Components in MTCProbe\"\n        PKT_CHAN[\"tcPacketsChan<br/>chan *TcPacket<br/>Buffered: 2048\"]\n        PKT_BUF[\"tcPackets<br/>[]*TcPacket<br/>Batch buffer: 256\"]\n        PCAP_FILE[\"pcapngFilename<br/>Output file path\"]\n        TIME[\"startTime, bootTime<br/>Timestamp conversion\"]\n    end\n    \n    subgraph \"PCAP Generation - probe_tc.go\"\n        WRITER[\"PCAP-NG Writer<br/>savePcapngSslKeyLog()\"]\n        DSB[\"DSB Block<br/>TLS key log\"]\n    end\n    \n    MOD -.->|\"embedded\"| MTCP\n    MTCP -.->|\"embedded\"| MOSSL\n    \n    MTCP --> PKT_CHAN\n    MTCP --> PKT_BUF\n    MTCP --> PCAP_FILE\n    MTCP --> TIME\n    \n    MOSSL -->|\"TcSkbEvent\"| PKT_CHAN\n    PKT_CHAN --> WRITER\n    WRITER --> PCAP_FILE\n    WRITER --> DSB\n```\n\n**Sources**: [user/module/probe_openssl.go:83-106](), [user/module/probe_tc.go]()\n\n### Event Flow\n\nWhen the OpenSSL module operates in PCAP mode, it receives both TC packet events and TLS master secret events:\n\n1. **Initialization** [user/module/probe_openssl.go:137-148]():\n   - Set `eBPFProgramType = TlsCaptureModelTypePcap`\n   - Create `tcPacketsChan` buffered channel (2048 entries)\n   - Initialize `tcPackets` batch buffer (256 entries)\n   - Store PCAP output filename\n\n2. **Event Dispatch** [user/module/probe_openssl.go:733-753]():\n   ```go\n   switch ev := eventStruct.(type) {\n   case *event.TcSkbEvent:\n       err := m.dumpTcSkb(ev)  // Process TC packet\n   case *event.MasterSecretEvent:\n       m.saveMasterSecret(ev)   // Process TLS key\n   }\n   ```\n\n3. **PCAP Output** [user/module/probe_openssl.go:558-565]():\n   - TC packets written to PCAP-NG file\n   - TLS master secrets written as DSB (Decryption Secrets Block)\n   - Enables Wireshark to decrypt captured TLS traffic\n\n**Sources**: [user/module/probe_openssl.go:137-148,558-565,733-753]()\n\n## Userspace Event Reading\n\nThe userspace module reads TC events from the `skb_events` perf event array using the standard event reading infrastructure.\n\n### Event Reader Setup\n\n```mermaid\nflowchart LR\n    subgraph \"eBPF Maps\"\n        SKB_MAP[\"skb_events<br/>PERF_EVENT_ARRAY\"]\n    end\n    \n    subgraph \"Module Event System - imodule.go\"\n        EVENTS[\"Events() []*ebpf.Map<br/>Returns list of maps\"]\n        DECODE[\"DecodeFun(*ebpf.Map)<br/>Returns decoder\"]\n        READER[\"perfEventReader()<br/>imodule.go:308-350\"]\n    end\n    \n    subgraph \"Event Processing\"\n        PERF[\"perf.NewReader()<br/>cilium/ebpf/perf\"]\n        LOOP[\"Read Loop<br/>record, err := rd.Read()\"]\n        DEC[\"Decode event<br/>child.Decode(em, record.RawSample)\"]\n        DISP[\"Dispatcher()<br/>child.Dispatcher(evt)\"]\n    end\n    \n    SKB_MAP --> EVENTS\n    EVENTS --> READER\n    READER --> PERF\n    PERF --> LOOP\n    LOOP --> DEC\n    DEC --> DISP\n```\n\nThe reading process [user/module/imodule.go:285-350]():\n\n1. **Map Discovery**: `Events()` returns all event maps including `skb_events`\n2. **Reader Creation**: `perfEventReader()` creates a perf event reader with configurable buffer size\n3. **Event Loop**: Continuously reads from the perf ring buffer\n4. **Decoding**: `Decode()` parses the raw event bytes into `TcSkbEvent` struct\n5. **Dispatch**: Passes the event to the module's `Dispatcher()` for handling\n\n**Sources**: [user/module/imodule.go:285-350]()\n\n## Kernel Version Compatibility\n\nTC capture has specific kernel version requirements:\n\n| Feature | Minimum Kernel | Note |\n|---------|----------------|------|\n| TC Classifier | 4.1+ | Basic TC BPF support |\n| PCAP Filter Injection | 5.2+ | Required for `filter_pcap_l2()` patching |\n| PID/UID Filtering | 5.2+ | Uses global const variables [kern/common.h:64-71]() |\n\nFor kernels < 5.2, the following limitations apply:\n- No runtime PCAP filter injection\n- No PID/UID filtering in TC programs\n- Connection tracking still works via kprobes\n\nThe `KERNEL_LESS_5_2` preprocessor directive [kern/common.h:64-71]() controls conditional compilation of features requiring newer kernels.\n\n**Sources**: [kern/common.h:64-71](), [kern/tc.h:147-150,243-250]()\n\n## Summary\n\nThe TC-based packet capture system provides comprehensive network visibility by:\n\n1. **Intercepting All Traffic**: TC classifiers capture packets at the network interface level before encryption/after decryption\n2. **Process Attribution**: Kprobes on `tcp_sendmsg`/`udp_sendmsg` map connections to processes via the `network_map` LRU hash\n3. **Bidirectional Capture**: Handles both ingress and egress traffic with automatic source/destination reversal\n4. **Flexible Filtering**: Supports PCAP filter expressions, protocol filtering, and PID/UID filtering\n5. **TLS Integration**: Combines network packets with TLS master secrets for complete traffic decryption in PCAP-NG format\n\nThis approach enables eCapture to capture complete network traffic with process context, even for encrypted connections, without requiring application instrumentation or certificate installation.\n\n**Sources**: [kern/tc.h:1-398](), [user/module/probe_openssl.go:83-106,303-307,558-565,733-753](), [user/module/imodule.go:285-350]()"
          },
          {
            "page_plan": {
              "id": "4",
              "title": "Output Formats"
            },
            "content": "# Output Formats\n\n<details>\n<summary>Relevant source files</summary>\n\nThe following files were used as context for generating this wiki page:\n\n- [CHANGELOG.md](CHANGELOG.md)\n- [README.md](README.md)\n- [README_CN.md](README_CN.md)\n- [images/ecapture-help-v0.8.9.svg](images/ecapture-help-v0.8.9.svg)\n- [main.go](main.go)\n- [pkg/event_processor/base_event.go](pkg/event_processor/base_event.go)\n- [user/event/event_bash.go](user/event/event_bash.go)\n- [user/event/event_gnutls.go](user/event/event_gnutls.go)\n- [user/event/event_masterkey.go](user/event/event_masterkey.go)\n- [user/event/event_mysqld.go](user/event/event_mysqld.go)\n- [user/event/event_nspr.go](user/event/event_nspr.go)\n- [user/event/event_openssl.go](user/event/event_openssl.go)\n- [user/event/event_openssl_tc.go](user/event/event_openssl_tc.go)\n- [user/event/event_postgres.go](user/event/event_postgres.go)\n\n</details>\n\n\n\neCapture provides four distinct output formats for captured network traffic, master secrets, and audit data. Each format serves specific use cases and integrates with different analysis tools. The output format determines both the data encoding (text, binary PCAP, keylog, protobuf) and the destination (console, file, TCP socket, WebSocket).\n\n## Output Format Overview\n\n| Format | Primary Use Case | Output Destination | Wireshark Compatible | Real-time |\n|--------|------------------|-------------------|---------------------|-----------|\n| **Text** | Interactive debugging, log analysis | Console, file, WebSocket | No | Yes |\n| **PCAP** | Network analysis, traffic replay | PCAP-NG file | Yes | No |\n| **Keylog** | TLS decryption with external tools | NSS keylog file | Yes (with tcpdump) | No |\n| **Protobuf** | Tool integration, eCaptureQ GUI | TCP, WebSocket | No | Yes |\n\nFor detailed information about specific output modes, see:\n- [Text Output Mode](#4.1) - Plain text formatting, HTTP parsing, color coding\n- [PCAP Integration](#4.2) - PCAP-NG file generation, DSB blocks, Wireshark workflow\n- [TLS Key Logging](#4.3) - Master secret extraction, SSLKEYLOGFILE format\n- [Protobuf and External Integration](#4.4) - Binary protocol, WebSocket streaming, eCaptureQ\n\n**Sources:** [README.md:172-253](), [user/module/probe_openssl.go:58-76](), [user/config/iconfig.go:73-79]()\n\n## Output Format Architecture\n\n### Format Selection and Encoding Pipeline\n\nThe following diagram shows how CLI flags are translated into output encoders and destination writers:\n\n```mermaid\ngraph TB\n    CLI[\"cobra.Command<br/>--model/-m flag<br/>--pcapfile/-w<br/>--keylogfile<br/>--logaddr<br/>--eventaddr\"]\n    \n    Config[\"OpensslConfig.Model<br/>OpensslConfig.PcapFile<br/>OpensslConfig.KeylogFile\"]\n    \n    ModuleInit[\"MOpenSSLProbe.Init()\"]\n    \n    FormatSwitch{Model value}\n    \n    TextBranch[\"eBPFProgramType =<br/>TlsCaptureModelTypeText<br/>Call setupManagersText()\"]\n    PcapBranch[\"eBPFProgramType =<br/>TlsCaptureModelTypePcap<br/>Open pcapFile<br/>Call setupManagersPcap()\"]\n    KeylogBranch[\"eBPFProgramType =<br/>TlsCaptureModelTypeKeylog<br/>Open keylogFile<br/>Call setupManagersKeylog()\"]\n    \n    TextEncode[\"IEventStruct.String()<br/>IEventStruct.StringHex()\"]\n    PcapEncode[\"savePcapngSslKeyLog()<br/>saveMasterSecret()<br/>dumpTcSkb()\"]\n    KeylogEncode[\"keylogger.WriteString()<br/>NSS format\"]\n    ProtobufEncode[\"IEventStruct.ToProtobufEvent()<br/>proto.Marshal()\"]\n    \n    ConsoleOut[\"os.Stdout<br/>zerolog.ConsoleWriter\"]\n    FileOut[\"os.File<br/>rotateLog wrapper\"]\n    TcpOut[\"net.Conn<br/>TCP socket\"]\n    WsOut[\"ws.Client<br/>WebSocket\"]\n    \n    CLI --> Config\n    Config --> ModuleInit\n    ModuleInit --> FormatSwitch\n    \n    FormatSwitch -->|text| TextBranch\n    FormatSwitch -->|pcap/pcapng| PcapBranch\n    FormatSwitch -->|keylog/key| KeylogBranch\n    \n    TextBranch --> TextEncode\n    TextBranch -.->|if codecTypeProtobuf| ProtobufEncode\n    PcapBranch --> PcapEncode\n    KeylogBranch --> KeylogEncode\n    \n    TextEncode --> ConsoleOut\n    TextEncode --> FileOut\n    PcapEncode --> FileOut\n    KeylogEncode --> FileOut\n    ProtobufEncode --> TcpOut\n    ProtobufEncode --> WsOut\n```\n\n**Sources:** [user/module/probe_openssl.go:109-176](), [user/config/iconfig.go:95-112](), [cli/cmd/root.go:178-247]()\n\n### Format Type Constants\n\nOutput formats are defined using the `TlsCaptureModelType` enumeration in the codebase:\n\n| Enum Value | Constant Name | CLI Flag | Description |\n|------------|--------------|----------|-------------|\n| `0` | `TlsCaptureModelTypePcap` | `pcap`, `pcapng` | PCAP-NG binary format |\n| `1` | `TlsCaptureModelTypeText` | `text` (default) | Human-readable text |\n| `2` | `TlsCaptureModelTypeKeylog` | `keylog`, `key` | NSS Key Log format |\n\nThe CLI accepts string values via the `--model/-m` flag:\n- `text` → `TlsCaptureModelTypeText` → Uses `setupManagersText()`\n- `pcap` or `pcapng` → `TlsCaptureModelTypePcap` → Uses `setupManagersPcap()`\n- `keylog` or `key` → `TlsCaptureModelTypeKeylog` → Uses `setupManagersKeylog()`\n\nProtobuf format is automatically enabled when using remote destinations (`tcp://` or `ws://` in `--eventaddr`).\n\n**Sources:** [user/module/probe_openssl.go:58-76](), [user/config/iconfig.go:73-79]()\n\n## Event Structure and Serialization\n\nAll captured events implement the `IEventStruct` interface, which defines methods for multiple output formats:\n\n### IEventStruct Interface Methods\n\n```go\ntype IEventStruct interface {\n    Decode(payload []byte) error\n    String() string                    // Text format\n    StringHex() string                 // Text format with hex dump\n    Clone() IEventStruct\n    EventType() Type\n    GetUUID() string\n    Payload() []byte\n    PayloadLen() int\n    Base() Base                        // Common metadata\n    ToProtobufEvent() *pb.Event       // Protobuf format\n}\n```\n\n### Event Types by Module\n\n| Module | Event Structure | Contains | Output Modes |\n|--------|----------------|----------|--------------|\n| TLS/SSL | `SSLDataEvent` | Encrypted payload, tuple, TLS version | Text, PCAP, Protobuf |\n| TLS/SSL | `ConnDataEvent` | Connection 4-tuple (IP:port pairs) | PCAP, Protobuf |\n| TLS/SSL | `MasterSecretEvent` | Client random, master key | Keylog, PCAP (DSB) |\n| TLS/SSL | `TcSkbEvent` | Raw packet data from TC hook | PCAP |\n| GoTLS | `TlsDataEvent` | Go TLS plaintext, connection info | Text, PCAP, Protobuf |\n| GnuTLS | `GnutlsDataEvent` | GnuTLS plaintext | Text, Protobuf |\n| NSS | `NsprDataEvent` | NSS/NSPR plaintext | Text, Protobuf |\n| Bash | `BashEvent` | Shell command line | Text, Protobuf |\n| MySQL | `MysqldEvent` | SQL query, return value | Text, Protobuf |\n| PostgreSQL | `PostgresEvent` | SQL query | Text, Protobuf |\n\nEach event structure implements serialization for its supported output formats:\n- `String()` / `StringHex()` for text output with optional color coding\n- `ToProtobufEvent()` for binary protobuf serialization\n- Module-specific methods (`saveMasterSecret()`, `dumpTcSkb()`) for PCAP/keylog\n\n**Sources:** [user/event/event_openssl.go:77-391](), [user/event/event_masterkey.go:37-273](), [user/event/event_bash.go:37-133](), [user/event/event_mysqld.go:68-168]()\n\n## Output Destination Configuration\n\neCapture separates logging (diagnostic messages) from event output (captured data). Both support multiple destination types.\n\n### Destination Type Detection\n\n```mermaid\ngraph TB\n    Flags[\"CLI Flags:<br/>--logaddr<br/>--eventaddr<br/>--ecaptureq\"]\n    \n    ParseFunc[\"initLogger() function\"]\n    \n    CheckFormat{Address format?}\n    \n    StdoutType[\"loggerTypeStdout = 0<br/>Empty string\"]\n    FileType[\"loggerTypeFile = 1<br/>File path<br/>/path/to/file.log\"]\n    TcpType[\"loggerTypeTcp = 2<br/>tcp://host:port\"]\n    WsType[\"loggerTypeWebsocket = 3<br/>ws://host:port/path\"]\n    \n    CreateStdout[\"zerolog.ConsoleWriter<br/>os.Stdout\"]\n    CreateFile[\"os.Create(path)<br/>Optional: roratelog.Logger\"]\n    CreateTcp[\"net.Dial(tcp, addr)<br/>Set codecTypeProtobuf\"]\n    CreateWs[\"ws.Client.Dial(url)<br/>Set codecTypeProtobuf\"]\n    \n    MultiWriter[\"zerolog.MultiLevelWriter<br/>Combines logger + eventCollector\"]\n    \n    Flags --> ParseFunc\n    ParseFunc --> CheckFormat\n    \n    CheckFormat -->|Empty| StdoutType\n    CheckFormat -->|Path| FileType\n    CheckFormat -->|tcp://| TcpType\n    CheckFormat -->|ws://| WsType\n    \n    StdoutType --> CreateStdout\n    FileType --> CreateFile\n    TcpType --> CreateTcp\n    WsType --> CreateWs\n    \n    CreateStdout --> MultiWriter\n    CreateFile --> MultiWriter\n    CreateTcp --> MultiWriter\n    CreateWs --> MultiWriter\n```\n\n**Sources:** [cli/cmd/root.go:68-73](), [cli/cmd/root.go:178-247]()\n\n### Destination Type Constants and Behavior\n\n| Constant | Value | Trigger Pattern | Writer Implementation | Codec Type |\n|----------|-------|----------------|----------------------|------------|\n| `loggerTypeStdout` | `0` | Empty string | `zerolog.ConsoleWriter` → `os.Stdout` | Text |\n| `loggerTypeFile` | `1` | `/path/to/file` | `os.Create()` + optional `roratelog.Logger` | Text |\n| `loggerTypeTcp` | `2` | `tcp://host:port` | `net.Dial(\"tcp\", addr)` | Protobuf |\n| `loggerTypeWebsocket` | `3` | `ws://` or `wss://` | `ws.Client.Dial(url)` | Protobuf |\n\n### Codec Selection Logic\n\nThe destination type determines which codec is used for event serialization:\n\n```go\n// In initLogger() function\nif strings.Contains(addr, \"tcp://\") || strings.Contains(addr, \"ws://\") {\n    // Remote destinations use protobuf\n    module.eventOutputType = codecTypeProtobuf\n} else {\n    // Local destinations use text\n    module.eventOutputType = codecTypeText\n}\n```\n\nRemote destinations (`tcp://`, `ws://`) automatically enable protobuf encoding via `IEventStruct.ToProtobufEvent()`, while local destinations use `IEventStruct.String()`.\n\n### Log Rotation\n\nFile destinations support automatic rotation when configured:\n- `--eventroratesize <MB>` - Rotate when file reaches size limit\n- `--eventroratetime <seconds>` - Rotate at time intervals\n\nRotation is handled by the `roratelog.Logger` wrapper around the file handle.\n\n**Sources:** [cli/cmd/root.go:68-73](), [cli/cmd/root.go:178-247](), [cli/cmd/root.go:151-152]()\n\n---\n\n## Event Output Pipeline\n\nCaptured events flow through a multi-stage pipeline before reaching their final destination.\n\n### Event Flow Architecture\n\n```mermaid\nflowchart TB\n    subgraph \"eBPF Event Sources\"\n        PerfBuffer[\"Perf Event Array<br/>events map\"]\n        MasterSecretBuffer[\"Perf Event Array<br/>mastersecret_events map\"]\n        TcSkbBuffer[\"Perf Event Array<br/>skb_events map\"]\n    end\n    \n    subgraph \"Event Readers\"\n        PerfReader[\"perfEventReader()<br/>perf.NewReader()\"]\n        Decode[\"Module.Decode()<br/>IEventStruct\"]\n    end\n    \n    subgraph \"Module Dispatcher\"\n        Dispatcher[\"Module.Dispatcher()\"]\n        TypeCheck{\"`EventType`\"}\n        \n        OutputType[\"TypeOutput<br/>Direct output\"]\n        ProcessorType[\"TypeEventProcessor<br/>Protocol parsing\"]\n        ModuleType[\"TypeModuleData<br/>Internal cache\"]\n    end\n    \n    subgraph \"Event Processing\"\n        EventProcessor[\"EventProcessor.Write()<br/>Protocol detection<br/>Aggregation\"]\n        ChildDispatcher[\"child.Dispatcher()<br/>Format-specific\"]\n    end\n    \n    subgraph \"Output Encoding\"\n        OutputMethod[\"Module.output()\"]\n        CodecCheck{\"`codecType`\"}\n        StringEncode[\"e.String()<br/>Text format\"]\n        ProtobufEncode[\"proto.Marshal()<br/>protobuf format\"]\n    end\n    \n    subgraph \"Final Writers\"\n        EventCollector[\"eventCollector<br/>io.Writer\"]\n    end\n    \n    PerfBuffer --> PerfReader\n    MasterSecretBuffer --> PerfReader\n    TcSkbBuffer --> PerfReader\n    \n    PerfReader --> Decode\n    Decode --> Dispatcher\n    \n    Dispatcher --> TypeCheck\n    \n    TypeCheck --> OutputType\n    TypeCheck --> ProcessorType\n    TypeCheck --> ModuleType\n    \n    OutputType --> OutputMethod\n    ProcessorType --> EventProcessor\n    ModuleType --> ChildDispatcher\n    \n    EventProcessor --> OutputMethod\n    ChildDispatcher -.->|\"saveMasterSecret\"| EventCollector\n    ChildDispatcher -.->|\"dumpTcSkb\"| EventCollector\n    \n    OutputMethod --> CodecCheck\n    CodecCheck -->|\"codecTypeText\"| StringEncode\n    CodecCheck -->|\"codecTypeProtobuf\"| ProtobufEncode\n    \n    StringEncode --> EventCollector\n    ProtobufEncode --> EventCollector\n```\n\n**Sources:** [user/module/imodule.go:285-448](), [user/module/probe_openssl.go:733-775]()\n\n### Event Routing by Type\n\nThe event pipeline uses three classification types to route events through different processing stages:\n\n| Event Type | Constant Value | Handler | Purpose |\n|------------|---------------|---------|---------|\n| `TypeOutput` | `event.TypeOutput` | `module.output()` | Pre-formatted events, direct output |\n| `TypeEventProcessor` | `event.TypeEventProcessor` | `EventProcessor.Write()` | HTTP/HTTP2 parsing, protocol detection |\n| `TypeModuleData` | `event.TypeModuleData` | `module.Dispatcher()` | Internal caching, PCAP writes, keylog |\n\nEvents are assigned types during `Clone()`:\n\n```go\n// Example from SSLDataEvent\nfunc (se *SSLDataEvent) Clone() IEventStruct {\n    event := new(SSLDataEvent)\n    event.eventType = TypeModuleData  // Routes to module dispatcher\n    return event\n}\n```\n\n**Sources:** [user/event/event_openssl.go:200-204](), [user/module/imodule.go:430-447]()\n\n---\n\n## Format-Specific Processing\n\nEach output format implements specialized processing logic within the module's dispatcher.\n\n## Format-Specific Use Cases\n\n### Text Mode\n\n**When to use:**\n- Interactive debugging and real-time monitoring\n- Console-based traffic inspection\n- Log file analysis with grep/awk\n- HTTP/HTTP2 protocol analysis\n\n**Output examples:**\n- Plain text request/response bodies with color coding\n- HTTP/1.1 headers and content\n- HTTP/2 frame-by-frame decoding with stream IDs\n- Connection metadata (PID, process name, IP:port tuples)\n\nSee [Text Output Mode](#4.1) for formatting details, color schemes, and HTTP parsing.\n\n**Sources:** [user/module/probe_openssl.go:756-775](), [user/event/event_openssl.go:167-198]()\n\n### PCAP Mode\n\n**When to use:**\n- Network analysis with Wireshark\n- Traffic archival for later analysis\n- Integration with existing PCAP-based tools\n- Combining plaintext capture with packet inspection\n\n**Output structure:**\n- PCAP-NG file format with Interface Description Block (IDB)\n- Enhanced Packet Blocks (EPB) for captured packets\n- Decryption Secrets Blocks (DSB) containing master keys\n- Automatic key-to-connection association\n\nSee [PCAP Integration](#4.2) for file format details and Wireshark workflow.\n\n**Sources:** [user/module/probe_openssl.go:733-754]()\n\n### Keylog Mode\n\n**When to use:**\n- Decrypting existing pcap files with Wireshark\n- Real-time decryption with tshark\n- Compliance with SSLKEYLOGFILE-based tools\n- Separating key capture from packet capture\n\n**Output format:**\n```\nCLIENT_RANDOM <32-byte-hex> <48-byte-hex-master-key>\nCLIENT_HANDSHAKE_TRAFFIC_SECRET <32-byte-hex> <secret>\nSERVER_HANDSHAKE_TRAFFIC_SECRET <32-byte-hex> <secret>\n```\n\nSee [TLS Key Logging](#4.3) for TLS 1.2/1.3 key extraction and integration examples.\n\n**Sources:** [user/module/probe_openssl.go:482-642]()\n\n### Protobuf Mode\n\n**When to use:**\n- eCaptureQ GUI integration\n- Custom tool development with structured data\n- Remote monitoring over TCP/WebSocket\n- Event forwarding to SIEM systems\n\n**Protocol:**\n- Binary protobuf encoding via `pb.Event` message type\n- Fields: `timestamp`, `uuid`, `pid`, `pname`, `src_ip`, `dst_ip`, `payload`\n- WebSocket framing with heartbeat mechanism\n\nSee [Protobuf and External Integration](#4.4) for protocol schema and client examples.\n\n**Sources:** [user/event/event_openssl.go:237-266](), [protobuf/PROTOCOLS.md]()\n\n## CLI Configuration Reference\n\n### Global Output Flags\n\n| Flag | Short | Type | Default | Description |\n|------|-------|------|---------|-------------|\n| `--logaddr` | `-l` | string | `\"\"` | Logger destination: file path, `tcp://host:port`, `ws://host:port` |\n| `--eventaddr` | | string | `\"\"` | Event collector destination (if unset, uses `--logaddr`) |\n| `--ecaptureq` | | string | `\"\"` | Local WebSocket server for eCaptureQ integration |\n| `--listen` | | string | `localhost:28256` | HTTP API server for runtime configuration updates |\n| `--eventroratesize` | | uint16 | `0` | Rotate event file when size exceeds N MB (0=disabled) |\n| `--eventroratetime` | | uint16 | `0` | Rotate event file every N seconds (0=disabled) |\n\n### Module-Specific Format Flags\n\nAvailable for `tls`, `gotls`, `gnutls`, `nss` modules:\n\n| Flag | Short | Type | Default | Description |\n|------|-------|------|---------|-------------|\n| `--model` | `-m` | string | `text` | Format: `text`, `pcap`, `pcapng`, `keylog`, `key` |\n| `--pcapfile` | `-w` | string | `ecapture_openssl.pcapng` | Output file for PCAP mode |\n| `--keylogfile` | | string | `ecapture_masterkey.log` | Output file for keylog mode |\n| `--hex` | | bool | `false` | Hex dump payload in text mode |\n\n### Example Commands\n\n```bash\n# Text mode to console\nsudo ecapture tls\n\n# Text mode to file with rotation\nsudo ecapture tls --eventaddr=/var/log/ecapture.log --eventroratesize=100\n\n# PCAP mode with custom file\nsudo ecapture tls -m pcap -w /tmp/capture.pcapng -i eth0\n\n# Keylog mode for Wireshark decryption\nsudo ecapture tls -m keylog --keylogfile=/tmp/keys.log\n\n# Protobuf streaming to eCaptureQ\nsudo ecapture tls --ecaptureq=:9090\n\n# Remote TCP streaming\nsudo ecapture tls --eventaddr=tcp://192.168.1.100:8080\n```\n\n**Sources:** [cli/cmd/root.go:136-153](), [README.md:172-253]()\n\n### Configuration Structure\n\nThe output configuration is stored in multiple places:\n\n1. **BaseConfig**: Common settings for all modules\n   - `LoggerAddr`: Logger destination\n   - `EventCollectorAddr`: Event collector destination\n   - `LoggerType`: Destination type (stdout/file/tcp/ws)\n\n2. **OpensslConfig**: SSL module-specific settings\n   - `Model`: Output format mode\n   - `PcapFile`: PCAP file path\n   - `KeylogFile`: Keylog file path\n\n3. **Module Runtime State**: Derived from configuration\n   - `eBPFProgramType`: Internal format type enum\n   - `keylogger`: Open file handle for keylog\n   - `pcapngFilename`: Resolved PCAP file path\n\n**Sources:** [user/config/iconfig.go:95-112](), [user/module/probe_openssl.go:83-106]()\n\n---\n\n## Output Format Selection Matrix\n\nThe following table summarizes format capabilities and requirements:\n\n| Format | CLI Flag | File Output | Real-time | Wireshark Compatible | Master Secrets | Protocol Parsing |\n|--------|----------|-------------|-----------|---------------------|----------------|------------------|\n| **Text** | `-m text` | Optional (--eventaddr) | Yes (stdout) | No | No (v0.7.0+) | Yes (HTTP/1.1, HTTP/2) |\n| **PCAP** | `-m pcap` | Required (--pcapfile) | No | Yes | Yes (DSB blocks) | No |\n| **Keylog** | `-m keylog` | Required (--keylogfile) | No | Yes (with tcpdump) | Yes (NSS format) | No |\n| **Protobuf** | Auto (--ecaptureq) | Optional (--eventaddr) | Yes (WebSocket) | No | Embedded | Varies |\n\n**Compatibility Notes:**\n- Text mode with HTTP/2 support added in v0.8.5\n- PCAP DSB block support for embedded master secrets\n- Keylog format compatible with Wireshark's \"Pre-Master-Secret log filename\" setting\n- Protobuf mode automatically enabled when using eCaptureQ integration\n\n**Sources:** [README.md:172-253](), [CHANGELOG.md:487-493]()"
          },
          {
            "page_plan": {
              "id": "4.1",
              "title": "Text Output Mode"
            },
            "content": "# Text Output Mode\n\n<details>\n<summary>Relevant source files</summary>\n\nThe following files were used as context for generating this wiki page:\n\n- [pkg/event_processor/base_event.go](pkg/event_processor/base_event.go)\n- [pkg/event_processor/http_request.go](pkg/event_processor/http_request.go)\n- [pkg/event_processor/http_response.go](pkg/event_processor/http_response.go)\n- [pkg/event_processor/iparser.go](pkg/event_processor/iparser.go)\n- [pkg/event_processor/iworker.go](pkg/event_processor/iworker.go)\n- [pkg/event_processor/processor.go](pkg/event_processor/processor.go)\n- [user/event/event_bash.go](user/event/event_bash.go)\n- [user/event/event_gnutls.go](user/event/event_gnutls.go)\n- [user/event/event_masterkey.go](user/event/event_masterkey.go)\n- [user/event/event_mysqld.go](user/event/event_mysqld.go)\n- [user/event/event_nspr.go](user/event/event_nspr.go)\n- [user/event/event_openssl.go](user/event/event_openssl.go)\n- [user/event/event_openssl_tc.go](user/event/event_openssl_tc.go)\n- [user/event/event_postgres.go](user/event/event_postgres.go)\n- [user/event/ievent.go](user/event/ievent.go)\n\n</details>\n\n\n\n## Purpose and Scope\n\nText Output Mode provides human-readable console and file output for captured network traffic and system events. This mode formats captured SSL/TLS plaintext, database queries, and shell commands into structured text with protocol parsing, color coding, and connection metadata. Unlike PCAP mode (see [PCAP Integration](#4.2)) which generates binary packet captures, or keylog mode (see [TLS Key Logging](#4.3)) which exports decryption keys, Text Output Mode is designed for immediate viewing and log file analysis.\n\nThis page covers:\n- Event string formatting mechanisms (`String()` and `StringHex()` methods)\n- Protocol-aware parsing (HTTP/1.x, HTTP/2, gzip decompression)\n- Color-coded output for traffic direction\n- The event processing pipeline from capture to console\n- Configuration options for hex dumps and truncation\n\n---\n\n## Event Formatting Architecture\n\nText Output Mode relies on a polymorphic formatting system where each event type implements the `IEventStruct` interface, providing two output methods:\n\n```mermaid\nclassDiagram\n    class IEventStruct {\n        <<interface>>\n        +String() string\n        +StringHex() string\n        +Payload() []byte\n        +GetUUID() string\n        +Base() Base\n    }\n    \n    class SSLDataEvent {\n        +DataType int64\n        +Pid uint32\n        +Comm [16]byte\n        +Fd uint32\n        +Version int32\n        +Tuple string\n        +Data [MaxDataSize]byte\n        +DataLen int32\n        +String() string\n        +StringHex() string\n        +BaseInfo() string\n    }\n    \n    class BashEvent {\n        +Pid uint32\n        +Uid uint32\n        +Line [256]byte\n        +ReturnValue uint32\n        +Comm [16]byte\n        +AllLines string\n        +String() string\n        +StringHex() string\n    }\n    \n    class MysqldEvent {\n        +Pid uint64\n        +Query [256]byte\n        +Alllen uint64\n        +Len uint64\n        +Comm [16]byte\n        +Retval int8\n        +String() string\n        +StringHex() string\n    }\n    \n    class NsprDataEvent {\n        +DataType int64\n        +Pid uint32\n        +Data [MaxDataSize]byte\n        +DataLen int32\n        +String() string\n        +StringHex() string\n    }\n    \n    IEventStruct <|.. SSLDataEvent\n    IEventStruct <|.. BashEvent\n    IEventStruct <|.. MysqldEvent\n    IEventStruct <|.. NsprDataEvent\n```\n\n**Sources:** [user/event/ievent.go:41-52](), [user/event/event_openssl.go:77-92](), [user/event/event_bash.go:37-47](), [user/event/event_mysqld.go:68-78](), [user/event/event_nspr.go:26-36]()\n\n### String vs StringHex Methods\n\nEach event type provides two formatting variants:\n\n| Method | Purpose | Output Format |\n|--------|---------|---------------|\n| `String()` | Default text output | Plain text payload with metadata header |\n| `StringHex()` | Hexadecimal dump | Multi-line hex dump with ASCII sidebar |\n\nThe `EventProcessor` selects between these based on the `isHex` flag:\n\n[pkg/event_processor/processor.go:48]()\n```\nisHex        bool\n```\n\nWhen `eventWorker.Display()` is called, it checks this flag and applies hex encoding if enabled:\n\n[pkg/event_processor/iworker.go:192-194]()\n```\nif ew.processor.isHex {\n    b = []byte(hex.Dump(b))\n}\n```\n\n**Sources:** [pkg/event_processor/processor.go:48](), [pkg/event_processor/iworker.go:192-194]()\n\n---\n\n## Connection Metadata Display\n\nText output includes rich connection metadata extracted from eBPF events. For SSL/TLS connections, the `SSLDataEvent.BaseInfo()` method formats this information:\n\n**Example Output Format:**\n```\nPID:1234, Comm:curl, TID:1234, Version:TLS1_3_VERSION, Received 512 bytes from 93.184.216.34:443\n```\n\n**Formatted Fields:**\n\n| Field | Source | Description |\n|-------|--------|-------------|\n| PID | `SSLDataEvent.Pid` | Process identifier |\n| Comm | `SSLDataEvent.Comm` | Process command name (16 bytes max) |\n| TID | `SSLDataEvent.Tid` | Thread identifier |\n| Version | `SSLDataEvent.Version` | TLS version (converted via `TlsVersion.String()`) |\n| Direction | `SSLDataEvent.DataType` | ProbeEntry (Received) or ProbeRet (Send) |\n| Tuple | `SSLDataEvent.Tuple` | IP:Port-IP:Port connection tuple |\n\n[user/event/event_openssl.go:181-198]()\n\nThe `Tuple` field is populated by `ConnDataEvent` from TC (Traffic Control) hook events and provides the network 4-tuple for connection attribution.\n\n**Sources:** [user/event/event_openssl.go:181-198](), [user/event/event_openssl.go:55-75]()\n\n---\n\n## Color-Coded Output System\n\nText Output Mode uses ANSI color codes to visually distinguish traffic direction and event types:\n\n```mermaid\ngraph LR\n    ProbeEntry[\"ProbeEntry<br/>(SSL_read)\"]\n    ProbeRet[\"ProbeRet<br/>(SSL_write)\"]\n    GreenOutput[\"Green Text<br/>COLORGREEN\"]\n    PurpleOutput[\"Purple Text<br/>COLORPURPLE\"]\n    Console[\"Console/File Output\"]\n    \n    ProbeEntry --> GreenOutput\n    ProbeRet --> PurpleOutput\n    GreenOutput --> Console\n    PurpleOutput --> Console\n```\n\n**Color Code Definitions:**\n\n[user/event/event.go:8-13]()\n```\nCOLORPURPLE = \"\\033[35m\"  // Send (outbound traffic)\nCOLORGREEN  = \"\\033[32m\"  // Received (inbound traffic)\nCOLORYELLOW = \"\\033[33m\"  // Address/Tuple highlighting\nCOLORRED    = \"\\033[31m\"  // Errors/Unknown types\nCOLORRESET  = \"\\033[0m\"   // Reset to default\nCOLORBLUE   = \"\\033[34m\"  // Filtering indicators\n```\n\n### Application in SSLDataEvent\n\n[user/event/event_openssl.go:168-179]()\n\nThe `String()` method applies colors based on `AttachType`:\n```\nswitch AttachType(se.DataType) {\ncase ProbeEntry:\n    prefix = COLORGREEN\ncase ProbeRet:\n    prefix = COLORPURPLE\n}\n```\n\nFor received data (green):\n```\nReceived 256 bytes from 93.184.216.34:443\n<green text>GET / HTTP/1.1\nHost: example.com\n...</green text>\n```\n\nFor sent data (purple):\n```\nSend 512 bytes to 93.184.216.34:443\n<purple text>HTTP/1.1 200 OK\nContent-Type: text/html\n...</purple text>\n```\n\n**Sources:** [user/event/event.go:8-13](), [user/event/event_openssl.go:168-179](), [user/event/event_openssl.go:151-166]()\n\n---\n\n## Protocol-Aware Parsing\n\nText Output Mode includes automatic protocol detection and parsing for HTTP traffic, providing structured formatting instead of raw byte dumps.\n\n### Parser Detection Flow\n\n```mermaid\nflowchart TD\n    PayloadArrival[\"Payload Arrives<br/>in eventWorker\"]\n    NewParser[\"NewParser(payload)<br/>Detect protocol\"]\n    HTTPReqDetect[\"HTTPRequest.detect()<br/>http.ReadRequest()\"]\n    HTTPRespDetect[\"HTTPResponse.detect()<br/>http.ReadResponse()\"]\n    HTTP2ReqDetect[\"HTTP2Request.detect()<br/>H2C magic check\"]\n    HTTP2RespDetect[\"HTTP2Response.detect()<br/>Frame detection\"]\n    \n    DefaultParser[\"DefaultParser<br/>Raw output\"]\n    HTTPRequestParser[\"HTTPRequest parser<br/>DumpRequest()\"]\n    HTTPResponseParser[\"HTTPResponse parser<br/>DumpResponse()\"]\n    HTTP2Parser[\"HTTP2 parsers<br/>Frame formatting\"]\n    \n    Display[\"Display()<br/>Format output\"]\n    \n    PayloadArrival --> NewParser\n    NewParser --> HTTPReqDetect\n    NewParser --> HTTPRespDetect\n    NewParser --> HTTP2ReqDetect\n    NewParser --> HTTP2RespDetect\n    \n    HTTPReqDetect -->|Success| HTTPRequestParser\n    HTTPRespDetect -->|Success| HTTPResponseParser\n    HTTP2ReqDetect -->|Success| HTTP2Parser\n    HTTP2RespDetect -->|Success| HTTP2Parser\n    \n    HTTPReqDetect -->|Fail| DefaultParser\n    HTTPRespDetect -->|Fail| DefaultParser\n    HTTP2ReqDetect -->|Fail| DefaultParser\n    HTTP2RespDetect -->|Fail| DefaultParser\n    \n    HTTPRequestParser --> Display\n    HTTPResponseParser --> Display\n    HTTP2Parser --> Display\n    DefaultParser --> Display\n```\n\n**Sources:** [pkg/event_processor/iparser.go:85-115]()\n\n### HTTP/1.x Request Parsing\n\n[pkg/event_processor/http_request.go:28-35]()\n\nThe `HTTPRequest` parser uses Go's `net/http` package to parse requests:\n\n```mermaid\nsequenceDiagram\n    participant Worker as eventWorker\n    participant Parser as HTTPRequest\n    participant NetHTTP as http.ReadRequest\n    participant Gzip as gzip.NewReader\n    participant Output as httputil.DumpRequest\n    \n    Worker->>Parser: Write(payload)\n    Parser->>NetHTTP: Parse HTTP headers\n    NetHTTP-->>Parser: http.Request object\n    \n    Parser->>Parser: Check Content-Encoding\n    alt Is gzip\n        Parser->>Gzip: Decompress body\n        Gzip-->>Parser: Decompressed data\n    end\n    \n    Parser->>Output: DumpRequest(request, false)\n    Output-->>Parser: Formatted bytes\n    Parser->>Worker: Append decompressed body\n    Worker->>Worker: Apply color codes\n```\n\n[pkg/event_processor/http_request.go:105-157]()\n\n**Key Features:**\n- Automatic gzip decompression when `Content-Encoding: gzip` header is present\n- Uses `httputil.DumpRequest()` for consistent formatting\n- HTTP/2.0 detection (returns raw bytes for HTTP/2)\n- Handles truncated bodies with `io.ErrUnexpectedEOF`\n\n**Sources:** [pkg/event_processor/http_request.go:54-81](), [pkg/event_processor/http_request.go:105-157]()\n\n### HTTP/1.x Response Parsing\n\n[pkg/event_processor/http_response.go:28-37]()\n\nResponse parsing follows a similar pattern with additional considerations:\n\n[pkg/event_processor/http_response.go:115-175]()\n\n**Chunked Transfer Handling:**\n- Detects `ContentLength < 0` indicating chunked encoding\n- Logs truncation warnings when `ContentLength > rawLength`\n- Supports HEAD method responses (zero-length body with Content-Length header)\n\n**Gzip Support:**\n```\nswitch hr.response.Header.Get(\"Content-Encoding\") {\ncase \"gzip\":\n    reader, err = gzip.NewReader(bytes.NewReader(rawData))\n    rawData, err = io.ReadAll(reader)\n    hr.packerType = PacketTypeGzip\n```\n\n**Sources:** [pkg/event_processor/http_response.go:115-175]()\n\n### Default Parser (Non-HTTP)\n\n[pkg/event_processor/iparser.go:117-166]()\n\nWhen no protocol is detected, the `DefaultParser` provides fallback formatting:\n\n**Behavior:**\n1. Check first byte: if `< 32` or `> 126` (non-ASCII), output hex dump\n2. Otherwise, output as trimmed string\n\n```\nif b[0] < 32 || b[0] > 126 {\n    return []byte(hex.Dump(b))\n}\nreturn []byte(CToGoString(dp.reader.Bytes()))\n```\n\n**Sources:** [pkg/event_processor/iparser.go:152-160]()\n\n---\n\n## Event Processing Pipeline\n\nThe text output system processes events through a multi-stage pipeline:\n\n```mermaid\nflowchart TB\n    subgraph \"Module Layer\"\n        Module[\"Capture Module<br/>(TLS/Bash/MySQL)\"]\n    end\n    \n    subgraph \"EventProcessor\"\n        Incoming[\"incoming chan<br/>IEventStruct\"]\n        Dispatch[\"dispatch()<br/>Route by UUID\"]\n        WorkerQueue[\"workerQueue<br/>map[string]IWorker\"]\n    end\n    \n    subgraph \"eventWorker (per connection)\"\n        IncomingChan[\"incoming chan<br/>IEventStruct\"]\n        WriteEvent[\"writeEvent()<br/>Accumulate payload\"]\n        PayloadBuf[\"payload *bytes.Buffer\"]\n        Ticker[\"ticker (100ms)<br/>Idle detection\"]\n        ParserEvents[\"parserEvents()<br/>Protocol detection\"]\n        ParserInst[\"parser IParser<br/>(HTTP/HTTP2/Default)\"]\n        Display[\"Display()<br/>Format output\"]\n    end\n    \n    subgraph \"Output\"\n        OutComing[\"outComing chan []byte\"]\n        Logger[\"logger io.Writer\"]\n    end\n    \n    Module -->|Write()| Incoming\n    Incoming --> Dispatch\n    Dispatch -->|Get/Create| WorkerQueue\n    WorkerQueue -->|Route to| IncomingChan\n    \n    IncomingChan --> WriteEvent\n    WriteEvent --> PayloadBuf\n    \n    Ticker -->|Timeout| ParserEvents\n    PayloadBuf --> ParserEvents\n    ParserEvents --> ParserInst\n    ParserInst --> Display\n    \n    Display -->|isHex check| OutComing\n    OutComing --> Logger\n```\n\n**Sources:** [pkg/event_processor/processor.go:66-89](), [pkg/event_processor/iworker.go:262-306](), [pkg/event_processor/iworker.go:174-228]()\n\n### EventProcessor: Central Dispatcher\n\n[pkg/event_processor/processor.go:30-50]()\n\nThe `EventProcessor` maintains a worker queue indexed by connection UUID:\n\n**Key Fields:**\n- `incoming chan event.IEventStruct` - Receives events from modules\n- `outComing chan []byte` - Sends formatted output to logger\n- `workerQueue map[string]IWorker` - Active workers per connection\n- `isHex bool` - Global hex dump flag\n- `truncateSize uint64` - Payload truncation limit\n\n**Dispatch Logic:**\n\n[pkg/event_processor/processor.go:91-109]()\n\n```\nuuid := e.GetUUID()  // Format: \"PID_TID_Comm_FD_DataType\"\nfound, eWorker := ep.getWorkerByUUID(uuid)\nif !found {\n    eWorker = NewEventWorker(uuid, ep)\n    ep.addWorkerByUUID(eWorker)\n}\nerr := eWorker.Write(e)\n```\n\n**Sources:** [pkg/event_processor/processor.go:30-50](), [pkg/event_processor/processor.go:91-109]()\n\n### eventWorker: Per-Connection State Machine\n\n[pkg/event_processor/iworker.go:70-89]()\n\nEach `eventWorker` manages a single connection's event stream:\n\n**Lifecycle States:**\n\n```mermaid\nstateDiagram-v2\n    [*] --> Init: NewEventWorker()\n    Init --> Accumulating: Write(event)\n    Accumulating --> Accumulating: More events\n    Accumulating --> Parsing: Ticker timeout (1s)\n    Parsing --> Formatting: parserEvents()\n    Formatting --> Output: Display()\n    Output --> Init: Reset()\n    \n    Accumulating --> Destroying: Close signal\n    Destroying --> [*]: drainAndClose()\n    \n    note right of Accumulating\n        LifeCycleStateDefault:\n        10 ticks (1s) max\n        \n        LifeCycleStateSock:\n        Continues until socket\n        closure notification\n    end note\n```\n\n**Two Lifecycle Modes:**\n\n[pkg/event_processor/iworker.go:57-63]()\n\n| State | Trigger | Behavior |\n|-------|---------|----------|\n| `LifeCycleStateDefault` | Standard UUID | Self-destructs after 1 second idle |\n| `LifeCycleStateSock` | UUID starts with \"sock:\" | Persists until socket destroyed |\n\n**Sources:** [pkg/event_processor/iworker.go:57-89](), [pkg/event_processor/iworker.go:262-306]()\n\n### Display Method: Output Formatting\n\n[pkg/event_processor/iworker.go:174-228]()\n\nThe `Display()` method coordinates final output formatting:\n\n```mermaid\nflowchart TD\n    Start[\"Display() called\"]\n    CheckLen{\"payload.Len() > 0?\"}\n    ParserEvents[\"parserEvents()<br/>Detect protocol & format\"]\n    CheckHex{\"processor.isHex?\"}\n    HexDump[\"hex.Dump(b)\"]\n    CheckLogger{\"logger type?\"}\n    \n    CollectorPath[\"CollectorWriter<br/>(Text file/console)\"]\n    ProtobufPath[\"Protobuf serialization<br/>(WebSocket stream)\"]\n    \n    FormatText[\"Format with metadata:<br/>PID, Comm, Src:Port, Dest:Port\"]\n    SerializeProto[\"ToProtobufEvent()<br/>Marshal to bytes\"]\n    \n    WriteChannel[\"writeToChan(b)<br/>Send to outComing\"]\n    Reset[\"Reset parser<br/>Reset payload buffer\"]\n    \n    Start --> CheckLen\n    CheckLen -->|Yes| ParserEvents\n    CheckLen -->|No| Reset\n    \n    ParserEvents --> CheckHex\n    CheckHex -->|true| HexDump\n    CheckHex -->|false| CheckLogger\n    HexDump --> CheckLogger\n    \n    CheckLogger -->|CollectorWriter| CollectorPath\n    CheckLogger -->|Other| ProtobufPath\n    \n    CollectorPath --> FormatText\n    ProtobufPath --> SerializeProto\n    \n    FormatText --> WriteChannel\n    SerializeProto --> WriteChannel\n    WriteChannel --> Reset\n    Reset --> Start\n```\n\n**Output Format Selection:**\n\n[pkg/event_processor/iworker.go:198-227]()\n\n1. **CollectorWriter (Text Mode):**\n   ```\n   PID:1234, Comm:curl, Src:192.168.1.100:54321, Dest:93.184.216.34:443,\n   <formatted payload>\n   ```\n\n2. **Protobuf Mode:**\n   - Serialized `pb.LogEntry` with `pb.Event` payload\n   - Used for WebSocket streaming to eCaptureQ GUI\n   - See [Protobuf and External Integration](#4.4) for details\n\n**Sources:** [pkg/event_processor/iworker.go:174-228]()\n\n---\n\n## Payload Truncation\n\nTo prevent memory exhaustion from large payloads, Text Output Mode supports configurable truncation:\n\n[pkg/event_processor/iworker.go:230-245]()\n\n```\ntsize := int(ew.processor.truncateSize)\nif tsize > 0 && ew.payload.Len() >= tsize {\n    ew.payload.Truncate(tsize)\n    ew.Log(fmt.Sprintf(\"Events truncated, size: %d bytes\\n\", tsize))\n    return\n}\n```\n\n**Configuration:**\n\n[pkg/event_processor/processor.go:206-215]()\n\n```\nfunc NewEventProcessor(logger io.Writer, isHex bool, truncateSize uint64) *EventProcessor\n```\n\n**Truncation Behavior:**\n- Applied when accumulated payload reaches `truncateSize` bytes\n- Stops accepting new events for that worker\n- Logs truncation message\n- Worker continues with truncated payload\n\n**Sources:** [pkg/event_processor/iworker.go:230-245](), [pkg/event_processor/processor.go:206-215]()\n\n---\n\n## Hex Dump Format\n\nWhen `isHex` mode is enabled, the system uses a structured hex dump format:\n\n[pkg/event_processor/base_event.go:211-252]()\n\n**Format Layout:**\n```\n0000    47 45 54 20 2F 20 48 54    54 50 2F 31 2E 31 0D 0A    GET / HTTP/1.1..\n0016    48 6F 73 74 3A 20 65 78    61 6D 70 6C 65 2E 63 6F    Host: example.co\n0032    6D 0D 0A 0D 0A                                       m....\n```\n\n**Column Structure:**\n| Column | Width | Content |\n|--------|-------|---------|\n| Offset | 4 chars | Byte position (hex) |\n| Hex Group 1 | 24 chars | 8 bytes in hex (2 spaces after 4th byte) |\n| Hex Group 2 | 24 chars | 8 bytes in hex (2 spaces after 4th byte) |\n| ASCII | 16 chars | ASCII representation (non-printable → '.') |\n\n**Implementation Details:**\n\n```\nChunkSize = 16       // Bytes per line\nChunkSizeHalf = 8    // Split point for spacing\n\nfor i := 0; i < n; i++ {\n    if i%ChunkSize == 0 {\n        fmt.Fprintf(bb, \"%04d\", i)  // Offset\n    }\n    if i%ChunkSizeHalf == 0 {\n        bb.WriteString(\"    \")      // Group separator\n    }\n    fmt.Fprintf(bb, \" %02X\", b[i])  // Hex byte\n    \n    // Convert non-ASCII to '.'\n    if b[i] < 32 || b[i] > 126 {\n        a[i%ChunkSize] = '.'\n    } else {\n        a[i%ChunkSize] = b[i]\n    }\n}\n```\n\n**Sources:** [pkg/event_processor/base_event.go:35-36](), [pkg/event_processor/base_event.go:211-252]()\n\n---\n\n## Module-Specific Output Examples\n\n### SSL/TLS Data Output\n\n**Standard Format:**\n```\nPID:12345, Comm:curl, TID:12345, Version:TLS1_3_VERSION, Received 1024 bytes from 93.184.216.34:443\nGET /api/v1/users HTTP/1.1\nHost: api.example.com\nUser-Agent: curl/7.68.0\nAccept: */*\n```\n\n**Hex Format:**\n```\nPID:12345, Comm:curl, TID:12345, Received 1024 bytes, Payload:\n0000    47 45 54 20 2F 61 70 69    2F 76 31 2F 75 73 65 72    GET /api/v1/user\n0016    73 20 48 54 54 50 2F 31    2E 31 0D 0A 48 6F 73 74    s HTTP/1.1..Host\n...\n```\n\n**Sources:** [user/event/event_openssl.go:168-179](), [user/event/event_openssl.go:151-166]()\n\n### Bash Command Output\n\n[user/event/event_bash.go:72-74]()\n\n```\nPID:5678, UID:1000, \tComm:bash, \tRetvalue:0, \tLine:\nls -la /etc/passwd && cat /etc/hosts\n```\n\n**Sources:** [user/event/event_bash.go:72-80]()\n\n### MySQL Query Output\n\n[user/event/event_mysqld.go:112-114]()\n\n```\nPID:3306, Comm:mysqld, Time:1634567890000000000,  length:(45/45),  return:DISPATCH_COMMAND_SUCCESS, Line:SELECT * FROM users WHERE id = 1234\n```\n\n**Return Status Values:**\n\n| Code | Constant | Meaning |\n|------|----------|---------|\n| 0 | `DISPATCH_COMMAND_SUCCESS` | Query executed successfully |\n| 1 | `DISPATCH_COMMAND_CLOSE_CONNECTION` | Connection closed |\n| 2 | `DISPATCH_COMMAND_WOULDBLOCK` | Non-blocking operation pending |\n| -1 | `DISPATCH_COMMAND_NOT_CAPTURED` | Failed to capture query |\n| -2 | `DISPATCH_COMMAND_V57_FAILED` | MySQL 5.7 specific failure |\n\n**Sources:** [user/event/event_mysqld.go:40-66](), [user/event/event_mysqld.go:112-114]()\n\n### PostgreSQL Query Output\n\n[user/event/event_postgres.go:68-69]()\n\n```\nPID: 5432, Comm: postgres, Time: 1634567890000000000, Query: SELECT id, name FROM accounts WHERE created_at > '2023-01-01'\n```\n\n**Sources:** [user/event/event_postgres.go:68-69]()\n\n### NSPR/NSS (Firefox) Output\n\n[user/event/event_nspr.go:98-120]()\n\n```\nPID:9876, Comm:Socket Thread, TID:9877, TYPE:Received, DataLen:512 bytes, Payload:\nHTTP/1.1 200 OK\nContent-Type: application/json\n...\n```\n\n**Thread Filtering:**\n- Firefox SSL communication occurs on dedicated \"Socket Thread\"\n- Optional filtering based on thread name (currently disabled by default)\n\n**Sources:** [user/event/event_nspr.go:98-120]()\n\n---\n\n## Configuration and Usage\n\n### Initialization\n\n[pkg/event_processor/processor.go:206-215]()\n\n```\nprocessor := NewEventProcessor(logger, isHex, truncateSize)\n```\n\n**Parameters:**\n- `logger io.Writer` - Output destination (console, file, or custom writer)\n- `isHex bool` - Enable hex dump mode\n- `truncateSize uint64` - Maximum payload size (0 = unlimited)\n\n### Logger Types\n\n**1. CollectorWriter (Text Mode):**\n\n[user/event/ievent.go:54-70]()\n\n```\nlogger := zerolog.New(os.Stdout).With().Timestamp().Logger()\ncollectorWriter := event.NewCollectorWriter(&logger)\nprocessor := NewEventProcessor(collectorWriter, false, 0)\n```\n\n**2. Standard io.Writer:**\n```\nfile, _ := os.OpenFile(\"capture.log\", os.O_CREATE|os.O_WRONLY, 0644)\nprocessor := NewEventProcessor(file, false, 0)\n```\n\n**Sources:** [user/event/ievent.go:54-70](), [pkg/event_processor/processor.go:206-215]()\n\n### Runtime Operation\n\n```mermaid\nsequenceDiagram\n    participant Module as Capture Module\n    participant EP as EventProcessor\n    participant Worker as eventWorker\n    participant Parser as IParser\n    participant Logger as io.Writer\n    \n    Module->>EP: Write(event)\n    EP->>Worker: incoming <- event\n    Worker->>Worker: Accumulate payload\n    \n    Note over Worker: 100ms idle timeout\n    \n    Worker->>Worker: Display()\n    Worker->>Parser: NewParser(payload)\n    Parser-->>Worker: Detected type\n    Worker->>Parser: Write(payload)\n    Parser->>Parser: Format (HTTP/hex/default)\n    Parser-->>Worker: Formatted bytes\n    \n    alt isHex == true\n        Worker->>Worker: hex.Dump(bytes)\n    end\n    \n    Worker->>EP: outComing <- bytes\n    EP->>Logger: Write(formatted)\n```\n\n**Sources:** [pkg/event_processor/processor.go:66-89](), [pkg/event_processor/iworker.go:262-306]()\n\n---\n\n## Performance Considerations\n\n### Buffering and Channels\n\n[pkg/event_processor/processor.go:25-28]()\n\n```\nMaxIncomingChanLen = 1024\nMaxParserQueueLen  = 1024\nMaxChanLen         = 1024  // per eventWorker\n```\n\n**Channel Depths:**\n- `EventProcessor.incoming` - 1024 events\n- `EventProcessor.outComing` - 1024 formatted outputs\n- `eventWorker.incoming` - 1024 events per connection\n\n**Backpressure Handling:**\n- If channels are full, events are dropped silently\n- No blocking to prevent eBPF ringbuffer overflow\n\n**Sources:** [pkg/event_processor/processor.go:25-28](), [pkg/event_processor/iworker.go:51-55]()\n\n### Worker Lifecycle Management\n\n**Idle Timeout:**\n\n[pkg/event_processor/iworker.go:51-52]()\n\n```\nMaxTickerCount = 10   // 10 ticks × 100ms = 1 second\n```\n\n**Default Lifecycle:**\n- Workers self-destruct after 1 second of inactivity\n- Reduces memory usage for short-lived connections\n\n**Socket Lifecycle:**\n- Workers with \"sock:\" UUID prefix persist until socket closure\n- Enables connection-oriented aggregation\n- See [Network Connection Tracking](#2.6) for details\n\n**Sources:** [pkg/event_processor/iworker.go:51-63](), [pkg/event_processor/iworker.go:262-306]()\n\n### Memory Optimization\n\n**Truncation:**\n- Prevents unbounded payload growth\n- Applied per-worker before parsing\n- Configurable via `truncateSize` parameter\n\n**Parser Reset:**\n\n[pkg/event_processor/iworker.go:183-187]()\n\n```\ndefer func() {\n    ew.parser.Reset()\n    ew.payload.Reset()\n    ew.status = ProcessStateInit\n}()\n```\n\nEach display cycle resets buffers to reclaim memory.\n\n**Sources:** [pkg/event_processor/iworker.go:230-245](), [pkg/event_processor/iworker.go:183-187]()"
          },
          {
            "page_plan": {
              "id": "4.2",
              "title": "PCAP Integration"
            },
            "content": "# PCAP Integration\n\n<details>\n<summary>Relevant source files</summary>\n\nThe following files were used as context for generating this wiki page:\n\n- [CHANGELOG.md](CHANGELOG.md)\n- [README.md](README.md)\n- [README_CN.md](README_CN.md)\n- [cli/cmd/root.go](cli/cmd/root.go)\n- [images/ecapture-help-v0.8.9.svg](images/ecapture-help-v0.8.9.svg)\n- [main.go](main.go)\n- [user/config/iconfig.go](user/config/iconfig.go)\n- [user/module/imodule.go](user/module/imodule.go)\n- [user/module/probe_openssl.go](user/module/probe_openssl.go)\n\n</details>\n\n\n\n## Purpose and Scope\n\nThis document describes eCapture's PCAP-NG file generation capabilities, which enable network packet capture and storage in a format compatible with Wireshark and other network analysis tools. The PCAP integration captures both encrypted network traffic and the TLS/SSL decryption keys required to decrypt it, storing them together in a single PCAP-NG file with Decryption Secrets Blocks (DSB).\n\nFor information about other output formats, see [Text Output Mode](#4.1) and [TLS Key Logging](#4.3). For details on the underlying packet capture mechanism, see [Network Connection Tracking](#2.6).\n\n---\n\n## Overview\n\neCapture's PCAP integration operates in `pcap` or `pcapng` mode, which differs fundamentally from text mode by capturing complete network packets rather than just plaintext content. This mode combines three data sources into a unified PCAP-NG file:\n\n1. **Network packets** captured via TC (Traffic Control) eBPF classifiers on ingress/egress\n2. **TLS master secrets** extracted via uprobe hooks on SSL/TLS functions  \n3. **Connection metadata** including process information (PID, UID, command name)\n\nThe resulting PCAP-NG file can be opened in Wireshark with automatic decryption of TLS traffic using the embedded master secrets.\n\n**PCAP Integration Architecture**\n\n```mermaid\ngraph TB\n    subgraph \"Capture Sources\"\n        TC[TC eBPF Programs<br/>capture_packets<br/>ingress/egress]\n        UPROBE[Uprobe Hooks<br/>SSL_read/SSL_write<br/>SSL_do_handshake]\n        KPROBE[Kprobe Hooks<br/>tcp_sendmsg<br/>udp_sendmsg]\n    end\n    \n    subgraph \"Event Processing\"\n        TC_EVENT[TcSkbEvent<br/>Network packets<br/>4-tuple + payload]\n        MS_EVENT[MasterSecretEvent<br/>TLS 1.2/1.3 secrets<br/>ClientRandom + keys]\n        CONN_EVENT[ConnDataEvent<br/>PID/FD mapping<br/>Tuple generation]\n    end\n    \n    subgraph \"PCAP Writer - MTCProbe\"\n        PACKET_CHAN[tcPacketsChan<br/>buffered channel<br/>2048 capacity]\n        PACKET_BUF[tcPackets slice<br/>256 capacity<br/>batch buffer]\n        MASTERKEY_BUF[masterKeyBuffer<br/>bytes.Buffer<br/>DSB data]\n    end\n    \n    subgraph \"File Output\"\n        PCAPNG_WRITER[PcapNG Writer<br/>gopacket/pcapgo]\n        DSB_BLOCKS[DSB Blocks<br/>Decryption Secrets<br/>TLS Key Log format]\n        EPB_BLOCKS[EPB Blocks<br/>Enhanced Packet<br/>with metadata]\n    end\n    \n    TC --> TC_EVENT\n    UPROBE --> MS_EVENT\n    KPROBE --> CONN_EVENT\n    \n    TC_EVENT -->|dumpTcSkb| PACKET_CHAN\n    MS_EVENT -->|savePcapngSslKeyLog| MASTERKEY_BUF\n    CONN_EVENT -->|AddConn| PACKET_CHAN\n    \n    PACKET_CHAN --> PACKET_BUF\n    PACKET_BUF -->|savePcapng| PCAPNG_WRITER\n    MASTERKEY_BUF -->|savePcapng| DSB_BLOCKS\n    \n    PCAPNG_WRITER --> EPB_BLOCKS\n    DSB_BLOCKS --> PCAPNG_WRITER\n    \n    style TC fill:#bbdefb\n    style UPROBE fill:#c5e1a5\n    style PCAPNG_WRITER fill:#fff9c4\n    style DSB_BLOCKS fill:#f8bbd0\n```\n\nSources: [user/module/probe_openssl.go:137-148](), [user/module/probe_openssl.go:287-296](), [README.md:173-187]()\n\n---\n\n## Activation and Configuration\n\n### Command Line Usage\n\nPCAP mode is activated using the `-m pcap` or `-m pcapng` flag with the `tls` or `gotls` modules. Required parameters include:\n\n| Parameter | Description | Default Value |\n|-----------|-------------|---------------|\n| `-m pcap` or `-m pcapng` | Activates PCAP mode | N/A (required) |\n| `--pcapfile` | Output file path | `ecapture_openssl.pcapng` |\n| `-i` | Network interface to capture | N/A (required) |\n| PCAP filter expression | Optional BPF filter | None |\n\nExample command:\n```bash\nsudo ecapture tls -m pcap -i eth0 --pcapfile=capture.pcapng tcp port 443\n```\n\n**Mode Selection Implementation**\n\n```mermaid\ngraph LR\n    CLI_PARSE[CLI Parser<br/>cobra command] --> MODEL_CONFIG[OpensslConfig.Model<br/>string value]\n    MODEL_CONFIG --> SWITCH{Model Switch}\n    \n    SWITCH -->|\"pcap/pcapng\"| PCAP_INIT[TlsCaptureModelTypePcap<br/>eBPFProgramType = 1]\n    SWITCH -->|\"keylog/key\"| KEYLOG_INIT[TlsCaptureModelTypeKeylog<br/>eBPFProgramType = 2]\n    SWITCH -->|\"text/default\"| TEXT_INIT[TlsCaptureModelTypeText<br/>eBPFProgramType = 0]\n    \n    PCAP_INIT --> PCAP_SETUP[tcPacketsChan created<br/>pcapngFilename set<br/>setupManagersPcap]\n    KEYLOG_INIT --> KEYLOG_SETUP[keylogger file opened<br/>setupManagersKeylog]\n    TEXT_INIT --> TEXT_SETUP[setupManagersText]\n    \n    PCAP_SETUP --> RUN[Module.Run]\n    KEYLOG_SETUP --> RUN\n    TEXT_SETUP --> RUN\n```\n\nSources: [user/module/probe_openssl.go:127-154](), [user/config/iconfig.go:73-79](), [cli/cmd/root.go:249-296]()\n\n### Configuration Structure\n\nThe PCAP mode is configured through `OpensslConfig`:\n\n```\nOpensslConfig.Model = \"pcap\" or \"pcapng\"\nOpensslConfig.PcapFile = output file path\nOpensslConfig.Ifname = network interface name\nOpensslConfig.PcapFilter = optional BPF filter expression\n```\n\nThis configuration triggers initialization of:\n- `tcPacketsChan`: Buffered channel (capacity 2048) for packet queueing\n- `tcPackets`: Slice buffer (capacity 256) for batch writing\n- `pcapngFilename`: Absolute path to output file\n\nSources: [user/module/probe_openssl.go:137-148]()\n\n---\n\n## PCAP-NG File Format\n\n### File Structure\n\neCapture generates PCAP-NG (Next Generation) files, which extend the classic PCAP format with richer metadata. The file structure consists of:\n\n1. **Section Header Block (SHB)**: File identification and byte order\n2. **Interface Description Block (IDB)**: Network interface metadata\n3. **Decryption Secrets Block (DSB)**: TLS master secrets for decryption\n4. **Enhanced Packet Block (EPB)**: Individual packet data with timestamps\n\n**PCAP-NG Block Structure**\n\n```mermaid\ngraph TB\n    FILE[PCAP-NG File]\n    \n    FILE --> SHB[Section Header Block<br/>Byte Order: 0x1A2B3C4D<br/>Version: 1.0]\n    \n    SHB --> IDB[Interface Description Block<br/>LinkType: Ethernet<br/>SnapLen: 262144<br/>Name/Description]\n    \n    IDB --> DSB1[Decryption Secrets Block<br/>SecretsType: TLS Key Log<br/>CLIENT_RANDOM format<br/>TLS 1.2/1.3 keys]\n    \n    IDB --> EPB1[Enhanced Packet Block<br/>InterfaceID: 0<br/>Timestamp: ns precision<br/>Captured Length<br/>Original Length<br/>Packet Data]\n    \n    EPB1 --> EPB2[Enhanced Packet Block<br/>...]\n    \n    EPB2 --> DSB2[Decryption Secrets Block<br/>Additional secrets]\n    \n    DSB2 --> EPB3[Enhanced Packet Block<br/>...]\n    \n    EPB3 --> EPBN[Enhanced Packet Block<br/>...]\n    \n    style SHB fill:#e1f5fe\n    style IDB fill:#fff3e0\n    style DSB1 fill:#f3e5f5\n    style DSB2 fill:#f3e5f5\n    style EPB1 fill:#e8f5e9\n    style EPB2 fill:#e8f5e9\n    style EPB3 fill:#e8f5e9\n```\n\nSources: [user/module/probe_openssl.go:558-565](), [user/module/probe_openssl.go:625-632]()\n\n### Enhanced Packet Block (EPB) Content\n\nEach captured packet is stored as an EPB with:\n\n- **Interface ID**: Links to the IDB (typically 0)\n- **Timestamp**: Nanosecond precision (boot time + monotonic clock)\n- **Captured packet length**: Actual bytes captured\n- **Original packet length**: Length on wire (may exceed captured if truncated)\n- **Packet data**: Raw Ethernet frame including:\n  - Ethernet header (14 bytes)\n  - IP header (IPv4 or IPv6)\n  - Transport header (TCP/UDP)\n  - Application payload (encrypted or decrypted)\n\nThe packet data comes from TC eBPF programs that capture the complete network frame at ingress/egress points.\n\nSources: [user/module/probe_openssl.go:747-750]()\n\n---\n\n## Decryption Secrets Block (DSB)\n\n### Purpose and Format\n\nThe DSB is a PCAP-NG block type that stores TLS decryption keys, enabling Wireshark to automatically decrypt captured TLS traffic. eCapture embeds DSB blocks containing master secrets in the SSLKEYLOGFILE format used by browsers and other TLS tools.\n\n### DSB Data Format\n\nDSB blocks contain TLS secrets in the standard key log format:\n\n```\nCLIENT_RANDOM <client_random_hex> <master_secret_hex>\nCLIENT_HANDSHAKE_TRAFFIC_SECRET <client_random_hex> <secret_hex>\nSERVER_HANDSHAKE_TRAFFIC_SECRET <client_random_hex> <secret_hex>\nCLIENT_TRAFFIC_SECRET_0 <client_random_hex> <secret_hex>\nSERVER_TRAFFIC_SECRET_0 <client_random_hex> <secret_hex>\nEXPORTER_SECRET <client_random_hex> <secret_hex>\n```\n\nFor TLS 1.2, only `CLIENT_RANDOM` is written. For TLS 1.3, multiple traffic secrets are derived and written.\n\n**Master Secret Extraction and DSB Writing**\n\n```mermaid\ngraph TB\n    subgraph \"Uprobe Capture\"\n        SSL_HANDSHAKE[SSL_do_handshake<br/>uprobe entry/return]\n        SSL_WBIO[SSL_get_wbio<br/>get FD mapping]\n        SSL_STATE[SSL_in_before/SSL_state<br/>handshake state]\n    end\n    \n    subgraph \"eBPF Event\"\n        MS_EVENT_12[MasterSecretEvent<br/>TLS 1.2<br/>ClientRandom 32B<br/>MasterKey 48B]\n        MS_EVENT_13[MasterSecretEvent<br/>TLS 1.3<br/>ClientRandom 32B<br/>HandshakeSecret 64B<br/>AppTrafficSecrets 64B]\n        MS_EVENT_BSSL[MasterSecretBSSLEvent<br/>BoringSSL variant<br/>HashLen dynamic<br/>Various secrets]\n    end\n    \n    subgraph \"User Space Processing\"\n        DISPATCHER[Dispatcher<br/>event type routing]\n        SAVE_MS[saveMasterSecret<br/>OpenSSL format]\n        SAVE_BSSL[saveMasterSecretBSSL<br/>BoringSSL format]\n        NULL_CHECK{Null Secrets<br/>Check}\n        DEDUP[masterKeys map<br/>deduplication by<br/>ClientRandom]\n    end\n    \n    subgraph \"DSB Generation\"\n        HKDF_EXPAND[HKDF ExpandLabel<br/>TLS 1.3 secret<br/>derivation]\n        FORMAT_12[Format TLS 1.2<br/>CLIENT_RANDOM line]\n        FORMAT_13[Format TLS 1.3<br/>6 secret types]\n        BUFFER[masterKeyBuffer<br/>bytes.Buffer]\n    end\n    \n    subgraph \"File Writing\"\n        PCAP_WRITER[savePcapngSslKeyLog<br/>write DSB to file]\n        FLUSH[Periodic flush<br/>every 2 seconds]\n    end\n    \n    SSL_HANDSHAKE --> MS_EVENT_12\n    SSL_HANDSHAKE --> MS_EVENT_13\n    SSL_HANDSHAKE --> MS_EVENT_BSSL\n    \n    MS_EVENT_12 --> DISPATCHER\n    MS_EVENT_13 --> DISPATCHER\n    MS_EVENT_BSSL --> DISPATCHER\n    \n    DISPATCHER --> SAVE_MS\n    DISPATCHER --> SAVE_BSSL\n    \n    SAVE_MS --> NULL_CHECK\n    SAVE_BSSL --> NULL_CHECK\n    \n    NULL_CHECK -->|Not Null| DEDUP\n    NULL_CHECK -->|All Null| DROP[Drop Event]\n    \n    DEDUP -->|New ClientRandom| HKDF_EXPAND\n    DEDUP -->|Duplicate| DROP\n    \n    HKDF_EXPAND --> FORMAT_12\n    HKDF_EXPAND --> FORMAT_13\n    \n    FORMAT_12 --> BUFFER\n    FORMAT_13 --> BUFFER\n    \n    BUFFER --> PCAP_WRITER\n    PCAP_WRITER --> FLUSH\n```\n\nSources: [user/module/probe_openssl.go:482-575](), [user/module/probe_openssl.go:577-642]()\n\n### Implementation Details\n\n#### TLS 1.2 Master Secret\n\nFor TLS 1.2, the master secret is captured directly from the SSL structure:\n\n1. Uprobe on `SSL_do_handshake` captures the SSL context\n2. Navigate to `s3->tmp.new_cipher` to get cipher suite\n3. Read `session->master_key` (48 bytes)\n4. Read `session->client_random` (32 bytes)\n5. Format: `CLIENT_RANDOM <32 hex bytes> <48 hex bytes>`\n\n#### TLS 1.3 Traffic Secrets\n\nFor TLS 1.3, multiple secrets are extracted and derived:\n\n1. Capture `handshake_secret`, `handshake_traffic_hash` from SSL structure\n2. Use HKDF to derive:\n   - `client_handshake_traffic_secret` = HKDF-Expand-Label(handshake_secret, \"c hs traffic\", handshake_traffic_hash, hash_len)\n   - `server_handshake_traffic_secret` = HKDF-Expand-Label(handshake_secret, \"s hs traffic\", handshake_traffic_hash, hash_len)\n3. Capture `client_app_traffic_secret`, `server_app_traffic_secret`, `exporter_master_secret` directly\n4. Write all six secret types to DSB\n\nThe HKDF expansion is performed in user space using the captured hash algorithm (SHA256 or SHA384 based on cipher suite).\n\nSources: [user/module/probe_openssl.go:502-551](), [pkg/util/hkdf/hkdf.go]()\n\n#### Null Secret Detection\n\neCapture validates that captured secrets are not null (all zeros) before writing to DSB. This prevents corruption of the keylog:\n\n- For TLS 1.2: Check if all 48 bytes of `master_key` are zero\n- For TLS 1.3: Check if all traffic secrets are zero (5 different secrets)\n- If all secrets are null, the event is dropped\n\nSources: [user/module/probe_openssl.go:644-731]()\n\n#### Deduplication\n\nMaster secrets are deduplicated using a `map[string]bool` keyed by the hex-encoded `ClientRandom`:\n\n```\nClientRandom (32 bytes) -> hex string (64 characters) -> map key\n```\n\nIf a `ClientRandom` already exists in the map, the duplicate secret is not written. This prevents the same TLS session from writing multiple identical DSB blocks.\n\nSources: [user/module/probe_openssl.go:483-489](), [user/module/probe_openssl.go:578-584]()\n\n---\n\n## TC Packet Capture Integration\n\n### Traffic Control (TC) eBPF Programs\n\nPCAP mode relies on TC eBPF classifiers attached to network interfaces for packet capture. Unlike uprobes that capture plaintext at the application layer, TC programs capture complete network packets including encrypted payloads.\n\n**TC Classifier Attachment Points**\n\n```mermaid\ngraph LR\n    subgraph \"Network Interface\"\n        NIC[Network Interface<br/>e.g., eth0]\n    end\n    \n    subgraph \"TC Ingress Path\"\n        ING_QDISC[Ingress Qdisc<br/>clsact]\n        ING_FILTER[TC Classifier<br/>capture_packets_ingress<br/>BPF program]\n    end\n    \n    subgraph \"TC Egress Path\"\n        EG_QDISC[Egress Qdisc<br/>clsact]\n        EG_FILTER[TC Classifier<br/>capture_packets_egress<br/>BPF program]\n    end\n    \n    subgraph \"Kernel Network Stack\"\n        IP_LAYER[IP Layer<br/>routing/filtering]\n        SOCKET[Socket Layer<br/>application I/O]\n    end\n    \n    subgraph \"eBPF Maps\"\n        SKB_EVENTS[skb_events<br/>perf/ring buffer<br/>TcSkbEvent data]\n    end\n    \n    NIC -->|Ingress| ING_QDISC\n    ING_QDISC --> ING_FILTER\n    ING_FILTER -->|TC_ACT_OK| IP_LAYER\n    \n    IP_LAYER --> SOCKET\n    \n    SOCKET -->|Egress| EG_QDISC\n    EG_QDISC --> EG_FILTER\n    EG_FILTER -->|TC_ACT_OK| NIC\n    \n    ING_FILTER -->|Capture| SKB_EVENTS\n    EG_FILTER -->|Capture| SKB_EVENTS\n```\n\nSources: [user/module/probe_openssl.go:303-307]()\n\n### TcSkbEvent Structure\n\nEach captured packet generates a `TcSkbEvent` containing:\n\n| Field | Type | Description |\n|-------|------|-------------|\n| `Pid` | uint32 | Process ID that sent/received packet |\n| `Tid` | uint32 | Thread ID |\n| `Uid` | uint32 | User ID |\n| `Gid` | uint32 | Group ID |\n| `Comm` | [16]byte | Command name (process) |\n| `SAddr` | [16]byte | Source IP address (IPv4/IPv6) |\n| `DAddr` | [16]byte | Destination IP address |\n| `Sport` | uint16 | Source port |\n| `Dport` | uint16 | Destination port |\n| `PacketLen` | uint32 | Total packet length |\n| `Payload` | []byte | Packet data (Ethernet frame) |\n| `Direction` | uint8 | 0=egress, 1=ingress |\n\nThe complete Ethernet frame is captured, including headers and encrypted payload.\n\nSources: [user/event/event_tc.go]()\n\n### BPF Filter Integration\n\nWhen a PCAP filter expression is provided (e.g., `tcp port 443`), it is compiled into eBPF instructions and patched into the TC classifier programs at load time:\n\n1. Parse filter expression using libpcap syntax\n2. Compile to classic BPF instructions\n3. Convert to eBPF instructions\n4. Patch into TC programs using `InstructionPatchers`\n\nThis filtering occurs in kernel space, reducing the volume of events sent to user space.\n\nSources: [user/module/probe_openssl.go:303-307]()\n\n---\n\n## Packet Processing Pipeline\n\n### Event Flow from TC to File\n\n**Packet Capture Pipeline**\n\n```mermaid\ngraph TB\n    subgraph \"Kernel Space\"\n        TC_ING[TC Ingress Classifier]\n        TC_EG[TC Egress Classifier]\n        PERF_MAP[Perf Event Array<br/>or Ring Buffer]\n    end\n    \n    subgraph \"User Space - Event Reader\"\n        PERF_READER[perfEventReader<br/>or ringbufEventReader]\n        DECODE[Decode TcSkbEvent<br/>from raw bytes]\n    end\n    \n    subgraph \"Module Dispatcher\"\n        DISPATCHER[MOpenSSLProbe.Dispatcher]\n        DUMP_TCSKB[dumpTcSkb method]\n    end\n    \n    subgraph \"Packet Buffering\"\n        BUILD_PKT[buildTcPacket<br/>construct TcPacket]\n        CHAN[tcPacketsChan<br/>buffered channel<br/>cap: 2048]\n        CONSUMER[Channel Consumer<br/>goroutine]\n        SLICE[tcPackets slice<br/>batch buffer<br/>cap: 256]\n    end\n    \n    subgraph \"File Writing\"\n        LOCK[tcPacketLocker<br/>mutex]\n        SAVE[savePcapng<br/>write EPB blocks]\n        WRITER[PcapNG Writer<br/>gopacket/pcapgo]\n        FLUSH[Flush to disk<br/>every 2s]\n    end\n    \n    TC_ING --> PERF_MAP\n    TC_EG --> PERF_MAP\n    \n    PERF_MAP --> PERF_READER\n    PERF_READER --> DECODE\n    DECODE --> DISPATCHER\n    \n    DISPATCHER --> DUMP_TCSKB\n    DUMP_TCSKB --> BUILD_PKT\n    BUILD_PKT --> CHAN\n    \n    CHAN --> CONSUMER\n    CONSUMER --> SLICE\n    \n    SLICE -->|Batch Write| LOCK\n    LOCK --> SAVE\n    SAVE --> WRITER\n    WRITER --> FLUSH\n```\n\nSources: [user/module/probe_openssl.go:747-750](), [user/module/probe_tc.go]()\n\n### TcPacket Construction\n\nThe `dumpTcSkb` method converts `TcSkbEvent` into `TcPacket` structures:\n\n1. **Timestamp conversion**: Convert kernel monotonic time to wall clock time\n   - `timestamp_ns = boot_time + skb_event.timestamp_ns`\n2. **Packet data extraction**: Copy Ethernet frame from event payload\n3. **Metadata attachment**: Include PID, command, tuple information\n4. **Enqueue**: Send to `tcPacketsChan` for buffered processing\n\nThe `TcPacket` structure holds:\n- Timestamp (nanosecond precision)\n- Packet data (Ethernet frame bytes)\n- Connection information (for correlation with uprobes)\n\nSources: [user/module/probe_tc.go]()\n\n### Batch Writing\n\nPackets are written to the PCAP-NG file in batches for performance:\n\n1. Consumer goroutine reads from `tcPacketsChan`\n2. Accumulates packets in `tcPackets` slice (up to 256)\n3. When slice is full or timeout occurs, calls `savePcapng`\n4. `savePcapng` acquires lock and writes all packets as EPB blocks\n5. Flushes writer to disk every 2 seconds\n\nThis batching reduces system call overhead and improves throughput.\n\nSources: [user/module/probe_tc.go]()\n\n---\n\n## File Writer Implementation\n\n### PcapNG Writer Initialization\n\neCapture uses the `gopacket/pcapgo` library for PCAP-NG file generation:\n\n```\nWriter: *pcapgo.NgWriter\nFile: *os.File opened with O_CREATE | O_WRONLY | O_TRUNC\nInterface: pcapgo.NgInterface with LinkType, SnapLen, Name, Description\n```\n\nInitialization sequence:\n1. Create/truncate output file\n2. Create `NgWriter` with file handle\n3. Write Section Header Block (SHB)\n4. Write Interface Description Block (IDB)\n5. Set up periodic flush timer (2 seconds)\n\nSources: [user/module/probe_tc.go]()\n\n### DSB Writing\n\nDecryption secrets are written via `savePcapngSslKeyLog`:\n\n1. Format master secrets as TLS Key Log lines in `masterKeyBuffer`\n2. Call `NgWriter.WriteDecryptionSecretsBlock`:\n   - SecretsType: `pcapgo.DSB_SECRETS_TYPE_TLS` (0x544c534b)\n   - SecretsData: Key log formatted bytes\n3. Clear `masterKeyBuffer` for next batch\n\nDSB blocks can appear anywhere in the file, interleaved with EPB blocks. Wireshark processes all DSB blocks to build its decryption key table.\n\nSources: [user/module/probe_openssl.go:558-565]()\n\n### EPB Writing\n\nEach packet is written as an Enhanced Packet Block:\n\n```\nCaptureInfo: gopacket.CaptureInfo {\n    Timestamp: time.Unix(0, timestamp_ns)\n    CaptureLength: len(packet_data)\n    Length: len(packet_data)\n    InterfaceIndex: 0\n}\n```\n\nThe `NgWriter.WritePacket` method handles EPB block formatting, including:\n- Block type and length fields\n- Interface ID\n- Timestamp (high/low 32-bit split)\n- Captured and original lengths\n- Packet data\n- Padding to 32-bit boundary\n- Block total length trailer\n\nSources: [user/module/probe_tc.go]()\n\n### Periodic Flushing\n\nTo ensure data is written to disk even with infrequent packets:\n\n1. Start ticker goroutine with 2-second interval\n2. On each tick, acquire lock and flush writer\n3. Log packet count statistics\n4. Continue until context cancellation\n\nThis prevents data loss if the program is terminated.\n\nSources: [user/module/probe_tc.go]()\n\n---\n\n## Process and Connection Correlation\n\n### PID/FD to Socket Mapping\n\nTo correlate network packets (captured at TC layer) with TLS plaintext (captured at SSL layer), eCapture maintains bidirectional mappings:\n\n**Connection Tracking Architecture**\n\n```mermaid\ngraph TB\n    subgraph \"Kprobe Capture\"\n        CONNECT[tcp_connect<br/>udp_connect<br/>or sys_connect]\n        SENDMSG[tcp_sendmsg<br/>udp_sendmsg]\n        DESTROY[tcp_destroy_sock<br/>or inet_sock_destruct]\n    end\n    \n    subgraph \"Connection Events\"\n        CONN_CREATE[ConnDataEvent<br/>IsDestroy=0<br/>Pid, Fd, Sock, Tuple]\n        CONN_DESTROY[ConnDataEvent<br/>IsDestroy=1<br/>Sock]\n    end\n    \n    subgraph \"User Space Maps\"\n        PID_CONNS[\"pidConns<br/>map[pid]map[fd]ConnInfo<br/>ConnInfo={tuple, sock}\"]\n        SOCK_MAP[\"sock2pidFd<br/>map[sock][2]uint32<br/>[2]uint32={pid, fd}\"]\n    end\n    \n    subgraph \"TLS Data Capture\"\n        SSL_READ[SSL_read uprobe<br/>returns Fd]\n        SSL_WRITE[SSL_write uprobe<br/>returns Fd]\n        LOOKUP[GetConn by PID+FD<br/>returns tuple+sock]\n    end\n    \n    subgraph \"TC Packet Matching\"\n        TC_PKT[TC Packet<br/>has tuple<br/>SAddr:Sport-DAddr:Dport]\n        MATCH[Match tuple<br/>to PID/Comm]\n    end\n    \n    CONNECT --> CONN_CREATE\n    DESTROY --> CONN_DESTROY\n    \n    CONN_CREATE --> PID_CONNS\n    CONN_CREATE --> SOCK_MAP\n    \n    CONN_DESTROY --> PID_CONNS\n    CONN_DESTROY --> SOCK_MAP\n    \n    SSL_READ --> LOOKUP\n    SSL_WRITE --> LOOKUP\n    LOOKUP --> PID_CONNS\n    \n    PID_CONNS --> TC_PKT\n    TC_PKT --> MATCH\n```\n\nSources: [user/module/probe_openssl.go:398-480]()\n\n### Connection Lifecycle\n\n1. **Creation**: When a connection is established (detected via kprobe on `tcp_connect` or `sys_connect`):\n   - Generate 4-tuple: `SrcIP:SrcPort-DstIP:DstPort`\n   - Map PID+FD -> {tuple, sock}\n   - Map sock -> {PID, FD}\n\n2. **Usage**: When SSL data is captured (via uprobe on `SSL_read`/`SSL_write`):\n   - Lookup tuple and sock by PID+FD\n   - Attach tuple to `SSLDataEvent`\n   - Event processor uses tuple to correlate with TC packets\n\n3. **Destruction**: When socket is closed (detected via kprobe on `tcp_destroy_sock`):\n   - Remove PID+FD -> ConnInfo mapping\n   - Remove sock -> PID+FD mapping\n   - Delayed deletion (3 seconds) to allow in-flight events to complete\n\nThis correlation enables Wireshark to display:\n- Which process generated each packet\n- Which user owns the process\n- Command name for the process\n\nSources: [user/module/probe_openssl.go:398-462]()\n\n---\n\n## Wireshark Integration\n\n### Opening PCAP-NG Files\n\nTo view captured traffic in Wireshark:\n\n1. **Direct open**: `wireshark ecapture.pcapng`\n   - TLS traffic is automatically decrypted using embedded DSB blocks\n   - No additional configuration needed\n\n2. **Manual keylog**: If DSB is not embedded, use `Edit -> Preferences -> Protocols -> TLS -> (Pre)-Master-Secret log filename`\n\n3. **Live capture**: While eCapture is running, Wireshark can open the file for live viewing (file is flushed every 2 seconds)\n\n### Display Filters\n\nUseful Wireshark filters for eCapture PCAP-NG files:\n\n| Filter | Purpose |\n|--------|---------|\n| `http` | HTTP/1.x decrypted requests/responses |\n| `http2` | HTTP/2 decrypted frames |\n| `http3` | HTTP/3 QUIC decrypted streams |\n| `tls.handshake.type == 1` | TLS ClientHello messages |\n| `frame.comment` | Packets with comments (PID/Comm) |\n\nSources: [README.md:189-230]()\n\n### Protocol Hierarchy\n\nThe PCAP-NG file contains complete protocol stacks:\n\n```\nEthernet II\n  └─ IPv4 or IPv6\n      └─ TCP or UDP\n          └─ TLS 1.2/1.3\n              └─ HTTP/1.1, HTTP/2, or HTTP/3 (QUIC)\n```\n\nWireshark automatically dissects all layers and displays decrypted application data when DSB blocks are present.\n\n---\n\n## Performance Considerations\n\n### Buffer Sizing\n\n| Buffer | Size | Purpose |\n|--------|------|---------|\n| `tcPacketsChan` | 2048 packets | Asynchronous producer/consumer buffering |\n| `tcPackets` slice | 256 packets | Batch writing to reduce system calls |\n| Per-CPU map | Configurable (default 1024 * PAGE_SIZE) | eBPF event buffer size |\n\nLarger buffers reduce packet loss under high traffic but increase memory usage.\n\nSources: [user/module/probe_openssl.go:137-148](), [cli/cmd/root.go:143]()\n\n### Packet Loss Scenarios\n\n1. **eBPF map overflow**: If per-CPU map fills, events are dropped in kernel\n2. **Channel overflow**: If `tcPacketsChan` fills (2048 packets), blocking may occur\n3. **Processing latency**: If user space cannot keep up with kernel event rate\n\nThe system logs warnings when packets are lost, including lost sample counts from perf buffers.\n\nSources: [user/module/imodule.go:336-338]()\n\n### Optimization Strategies\n\n1. **Increase map size**: Use `--mapsize` flag to allocate more memory for eBPF maps\n2. **Filter aggressively**: Use PCAP filter expressions to reduce captured packet volume\n3. **Target specific processes**: Use `-p` flag to capture only specific PIDs\n4. **SSD storage**: Write PCAP-NG files to fast storage (SSD) to reduce I/O bottlenecks\n\n---\n\n## Implementation Class Diagram\n\n**Key Classes and Their Relationships**\n\n```mermaid\nclassDiagram\n    class MOpenSSLProbe {\n        -tcPacketsChan chan TcPacket\n        -tcPackets []TcPacket\n        -tcPacketLocker sync.Mutex\n        -pcapngFilename string\n        -masterKeyBuffer bytes.Buffer\n        -pidConns map[uint32]map[uint32]ConnInfo\n        -sock2pidFd map[uint64][2]uint32\n        +setupManagersPcap() error\n        +dumpTcSkb(TcSkbEvent) error\n        +savePcapng() error\n        +savePcapngSslKeyLog([]byte) error\n        +saveMasterSecret(MasterSecretEvent)\n        +AddConn(pid, fd, tuple, sock)\n        +GetConn(pid, fd) ConnInfo\n        +DestroyConn(sock)\n    }\n    \n    class TcSkbEvent {\n        +Pid uint32\n        +Comm [16]byte\n        +SAddr [16]byte\n        +DAddr [16]byte\n        +Sport uint16\n        +Dport uint16\n        +PacketLen uint32\n        +Payload []byte\n        +Direction uint8\n    }\n    \n    class TcPacket {\n        +Timestamp time.Time\n        +Data []byte\n        +Info gopacket.CaptureInfo\n    }\n    \n    class MasterSecretEvent {\n        +Version uint32\n        +ClientRandom [32]byte\n        +MasterKey [48]byte\n        +HandshakeSecret [64]byte\n        +ClientAppTrafficSecret [64]byte\n        +ServerAppTrafficSecret [64]byte\n        +ExporterMasterSecret [64]byte\n        +CipherId uint32\n    }\n    \n    class ConnInfo {\n        +tuple string\n        +sock uint64\n    }\n    \n    class NgWriter {\n        +WriteDecryptionSecretsBlock() error\n        +WritePacket() error\n        +Flush() error\n    }\n    \n    MOpenSSLProbe --> TcSkbEvent : receives\n    MOpenSSLProbe --> TcPacket : creates\n    MOpenSSLProbe --> MasterSecretEvent : receives\n    MOpenSSLProbe --> ConnInfo : manages\n    MOpenSSLProbe --> NgWriter : uses\n    TcSkbEvent --> TcPacket : converted to\n```\n\nSources: [user/module/probe_openssl.go:83-106](), [user/event/event_tc.go](), [user/event/event_ssl.go]()\n\n---\n\n## Error Handling\n\n### Common Issues\n\n| Issue | Cause | Solution |\n|-------|-------|----------|\n| Empty PCAP file | No packets matched filter | Check interface and filter expression |\n| Missing DSB blocks | TLS handshake not captured | Ensure capture starts before connections |\n| Wireshark cannot decrypt | Wrong cipher suite / version | Check TLS version compatibility |\n| File not flushed | Program killed without cleanup | Wait for graceful shutdown or use longer captures |\n\n### Logging\n\nPCAP mode logs include:\n\n- Packet save counts (every 2 seconds): `INF packets saved into pcapng file. count=123`\n- Master secret saves: `INF CLIENT_RANDOM save success CLientRandom=... TlsVersion=...`\n- DSB write failures: `WRN save sslKeylog failed`\n- File path on initialization: `INF packets saved into pcapng file. pcapng path=...`\n\nSources: [README.md:189-230]()\n\n---\n\n## Comparison with Other Modes\n\n| Feature | PCAP Mode | Text Mode | Keylog Mode |\n|---------|-----------|-----------|-------------|\n| Output format | PCAP-NG file | Text logs | SSLKEYLOGFILE |\n| Network packets | Full capture | Not captured | Not captured |\n| Plaintext content | Via DSB decryption | Direct output | Not included |\n| Wireshark compatible | Yes (native) | No | Yes (manual import) |\n| Performance impact | Highest (full packets) | Lowest | Low |\n| Use case | Network analysis | Quick inspection | tcpdump integration |\n\nFor details on other modes, see [Text Output Mode](#4.1) and [TLS Key Logging](#4.3).\n\n---\n\n## Related Components\n\nThis PCAP integration relies on several other eCapture subsystems:\n\n- **TC Programs**: See [Network Connection Tracking](#2.6) for TC eBPF classifier details\n- **Master Secret Extraction**: See [Master Secret Extraction](#3.1.4) for TLS key capture\n- **Event Processing**: See [Event Processing Pipeline](#2.2) for event routing\n- **Module System**: See [Module System and Lifecycle](#2.4) for `IModule` interface\n\nThe PCAP mode is one of three output formats supported by TLS modules, each optimized for different use cases and workflows."
          },
          {
            "page_plan": {
              "id": "4.3",
              "title": "TLS Key Logging"
            },
            "content": "# TLS Key Logging\n\n<details>\n<summary>Relevant source files</summary>\n\nThe following files were used as context for generating this wiki page:\n\n- [cli/cmd/root.go](cli/cmd/root.go)\n- [kern/boringssl_const.h](kern/boringssl_const.h)\n- [kern/boringssl_masterkey.h](kern/boringssl_masterkey.h)\n- [kern/openssl_masterkey.h](kern/openssl_masterkey.h)\n- [kern/openssl_masterkey_3.0.h](kern/openssl_masterkey_3.0.h)\n- [user/config/iconfig.go](user/config/iconfig.go)\n- [user/module/imodule.go](user/module/imodule.go)\n- [user/module/probe_openssl.go](user/module/probe_openssl.go)\n- [utils/boringssl-offset.c](utils/boringssl-offset.c)\n\n</details>\n\n\n\n## Purpose and Scope\n\nThis document describes eCapture's TLS key logging capability, which extracts TLS/SSL master secrets from OpenSSL and BoringSSL applications and writes them to a file in SSLKEYLOGFILE format. This format is compatible with network protocol analyzers like Wireshark, enabling decryption of captured TLS traffic without requiring the server's private key.\n\nFor information about capturing the actual network packets to decrypt, see [PCAP Integration](#4.2). For text-based plaintext capture without network packet correlation, see [Text Output Mode](#4.1).\n\n## Overview\n\nTLS key logging operates by:\n1. **Extracting master secrets** from SSL/TLS library structures using eBPF uprobes\n2. **Formatting secrets** according to the SSLKEYLOGFILE specification\n3. **Writing to a file** that can be loaded by Wireshark or other decryption tools\n4. **Deduplicating entries** to avoid writing the same client_random multiple times\n\nThe output file follows the NSS Key Log Format, where each line contains a label, client random, and the corresponding secret in hexadecimal format.\n\nSources: [user/module/probe_openssl.go:58-76](), [user/config/iconfig.go:72-79]()\n\n## Key Logging Architecture\n\n```mermaid\ngraph TB\n    subgraph \"Application Space\"\n        APP[\"OpenSSL/BoringSSL<br/>Application\"]\n    end\n    \n    subgraph \"eBPF Hooks\"\n        UPROBE[\"uprobe/SSL_write_key<br/>probe_ssl_master_key\"]\n    end\n    \n    subgraph \"Kernel eBPF Maps\"\n        MS_EVENTS[\"mastersecret_events<br/>PERF_EVENT_ARRAY\"]\n        BPF_CTX[\"bpf_context<br/>LRU_HASH\"]\n    end\n    \n    subgraph \"User Space - MOpenSSLProbe\"\n        DISPATCH[\"Dispatcher()<br/>Event routing\"]\n        SAVE_OSSL[\"saveMasterSecret()<br/>OpenSSL handler\"]\n        SAVE_BSSL[\"saveMasterSecretBSSL()<br/>BoringSSL handler\"]\n        DEDUP[\"masterKeys map<br/>Deduplication\"]\n        FORMAT[\"SSLKEYLOGFILE<br/>Formatting\"]\n    end\n    \n    subgraph \"Output\"\n        KEYLOG_FILE[\"keylog.log<br/>SSLKEYLOGFILE format\"]\n    end\n    \n    APP -->|\"SSL_write()<br/>SSL_do_handshake()\"| UPROBE\n    UPROBE -->|\"Extract ssl_st<br/>ssl_session_st<br/>ssl3_state_st\"| BPF_CTX\n    UPROBE -->|\"Send event\"| MS_EVENTS\n    MS_EVENTS -->|\"MasterSecretEvent<br/>MasterSecretBSSLEvent\"| DISPATCH\n    DISPATCH -->|\"OpenSSL\"| SAVE_OSSL\n    DISPATCH -->|\"BoringSSL\"| SAVE_BSSL\n    SAVE_OSSL --> DEDUP\n    SAVE_BSSL --> DEDUP\n    DEDUP -->|\"New client_random\"| FORMAT\n    FORMAT --> KEYLOG_FILE\n    \n    style UPROBE fill:#e3f2fd\n    style DEDUP fill:#fff3e0\n    style FORMAT fill:#e8f5e9\n    style KEYLOG_FILE fill:#f3e5f5\n```\n\n**Diagram: TLS Key Logging Data Flow**\n\nThe system hooks SSL/TLS handshake functions to extract master secrets at the point where they become available in memory. The eBPF program reads secret material from SSL library structures and sends events to user space, where they are formatted and written to the keylog file.\n\nSources: [user/module/probe_openssl.go:482-575](), [kern/openssl_masterkey.h:80-257](), [kern/boringssl_masterkey.h:169-403]()\n\n## Configuration\n\nKey logging mode is configured through the `OpensslConfig.Model` field:\n\n| Configuration Value | Constant | Description |\n|---------------------|----------|-------------|\n| `\"keylog\"` | `TlsCaptureModelKeylog` | Write master secrets only |\n| `\"key\"` | `TlsCaptureModelKey` | Alias for keylog mode |\n\nThe keylog file path is specified via `OpensslConfig.KeylogFile` (default: `./ecapture.keylog`).\n\n```go\n// Example initialization from probe_openssl.go:128-136\nswitch model {\ncase config.TlsCaptureModelKeylog, config.TlsCaptureModelKey:\n    m.keyloggerFilename = m.conf.(*config.OpensslConfig).KeylogFile\n    m.keylogger, err = os.OpenFile(m.keyloggerFilename, \n        os.O_APPEND|os.O_WRONLY|os.O_CREATE, 0o600)\n    m.eBPFProgramType = TlsCaptureModelTypeKeylog\n}\n```\n\nSources: [user/module/probe_openssl.go:128-136](), [user/config/iconfig.go:72-79]()\n\n## SSLKEYLOGFILE Format\n\nThe SSLKEYLOGFILE format consists of space-separated records, one per line:\n\n```\n<Label> <ClientRandom> <Secret>\n```\n\nWhere:\n- **Label**: Identifies the type of secret (e.g., `CLIENT_RANDOM`, `CLIENT_HANDSHAKE_TRAFFIC_SECRET`)\n- **ClientRandom**: 32-byte random value from TLS handshake, hex-encoded\n- **Secret**: The secret material, hex-encoded (48 bytes for TLS 1.2, 32 or 48 bytes for TLS 1.3 depending on cipher)\n\n### Supported Labels\n\n| Label | TLS Version | Description |\n|-------|-------------|-------------|\n| `CLIENT_RANDOM` | TLS 1.2 | Master secret for TLS 1.2 and earlier |\n| `CLIENT_EARLY_TRAFFIC_SECRET` | TLS 1.3 | 0-RTT secret (if early data enabled) |\n| `CLIENT_HANDSHAKE_TRAFFIC_SECRET` | TLS 1.3 | Client handshake traffic key |\n| `SERVER_HANDSHAKE_TRAFFIC_SECRET` | TLS 1.3 | Server handshake traffic key |\n| `CLIENT_TRAFFIC_SECRET_0` | TLS 1.3 | Client application traffic key |\n| `SERVER_TRAFFIC_SECRET_0` | TLS 1.3 | Server application traffic key |\n| `EXPORTER_SECRET` | TLS 1.3 | Exporter master secret |\n\nSources: [user/module/probe_openssl.go:499-553](), [pkg/util/hkdf/hkdf.go]()\n\n## TLS 1.2 Master Secret Extraction\n\n### OpenSSL TLS 1.2\n\n```mermaid\ngraph LR\n    SSL_ST[\"ssl_st\"] -->|\"+SSL_ST_VERSION\"| VERSION[\"version<br/>int\"]\n    SSL_ST -->|\"+SSL_ST_SESSION\"| SESSION_PTR[\"*ssl_session_st\"]\n    SESSION_PTR -->|\"+SSL_SESSION_ST_MASTER_KEY\"| MASTER_KEY[\"master_key[48]<br/>byte array\"]\n    SSL_ST -->|\"+SSL_ST_S3\"| S3_PTR[\"*ssl3_state_st\"]\n    S3_PTR -->|\"+SSL3_STATE_ST_CLIENT_RANDOM\"| CLIENT_RANDOM[\"client_random[32]<br/>byte array\"]\n    \n    VERSION --> OUTPUT[\"MasterSecretEvent\"]\n    CLIENT_RANDOM --> OUTPUT\n    MASTER_KEY --> OUTPUT\n    \n    style OUTPUT fill:#e8f5e9\n```\n\n**Diagram: OpenSSL TLS 1.2 Structure Navigation**\n\nFor TLS 1.2, the eBPF program extracts:\n1. **Client Random**: From `ssl_st->s3->client_random` \n2. **Master Key**: From `ssl_st->session->master_key` (48 bytes)\n3. **Version**: From `ssl_st->version`\n\nThe user-space handler formats this as:\n```\nCLIENT_RANDOM <32-byte-hex> <48-byte-hex>\n```\n\nSources: [kern/openssl_masterkey.h:82-168](), [user/module/probe_openssl.go:493-500]()\n\n### BoringSSL TLS 1.2\n\nBoringSSL uses a different structure layout:\n\n```mermaid\ngraph LR\n    SSL_ST[\"ssl_st\"] -->|\"+SSL_ST_S3\"| S3_PTR[\"*ssl3_state_st\"]\n    S3_PTR -->|\"+BSSL__SSL3_STATE_HS\"| HS_PTR[\"*SSL_HANDSHAKE\"]\n    HS_PTR -->|\"+BSSL__SSL_HANDSHAKE_NEW_SESSION<br/>or fallback to ssl_st->session\"| SESSION_PTR[\"*ssl_session_st\"]\n    SESSION_PTR -->|\"+SSL_SESSION_ST_SECRET\"| SECRET[\"secret_[48]<br/>byte array\"]\n    SESSION_PTR -->|\"+SSL_SESSION_ST_SECRET_LENGTH\"| SECRET_LEN[\"secret_length\"]\n    S3_PTR -->|\"offset 16\"| CLIENT_RANDOM[\"client_random[32]\"]\n    HS_PTR -->|\"+SSL_HANDSHAKE_HASH_LEN_\"| HASH_LEN[\"hash_len\"]\n    \n    SECRET --> OUTPUT[\"MasterSecretBSSLEvent\"]\n    SECRET_LEN --> OUTPUT\n    CLIENT_RANDOM --> OUTPUT\n    HASH_LEN --> OUTPUT\n    \n    style OUTPUT fill:#e8f5e9\n```\n\n**Diagram: BoringSSL TLS 1.2 Structure Navigation**\n\nBoringSSL stores secrets in `ssl_session_st->secret_` with a variable length stored in `secret_length`. The eBPF program checks multiple locations to find the session:\n1. First: `ssl_st->s3->hs->new_session`\n2. Fallback: `ssl_st->session`\n\nSources: [kern/boringssl_masterkey.h:139-342](), [user/module/probe_openssl.go:577-642]()\n\n## TLS 1.3 Master Secret Extraction\n\nTLS 1.3 uses multiple secrets derived through HKDF (HMAC-based Key Derivation Function). eCapture extracts the base secrets and performs HKDF expansion in user space.\n\n### OpenSSL TLS 1.3 Structure Layout\n\n```mermaid\ngraph TB\n    SSL_ST[\"ssl_st<br/>pointer\"] -->|\"+SSL_ST_VERSION\"| VERSION[\"version<br/>TLS1_3_VERSION\"]\n    SSL_ST -->|\"+SSL_ST_SESSION\"| SESSION[\"*ssl_session_st\"]\n    SESSION -->|\"+SSL_SESSION_ST_CIPHER\"| CIPHER[\"*ssl_cipher_st\"]\n    CIPHER -->|\"+SSL_CIPHER_ST_ID\"| CIPHER_ID[\"cipher_id<br/>uint32\"]\n    \n    SSL_ST -->|\"+SSL_ST_S3\"| S3[\"*ssl3_state_st\"]\n    S3 -->|\"+SSL3_STATE_ST_CLIENT_RANDOM\"| CLIENT_RANDOM[\"client_random[32]\"]\n    \n    SSL_ST -->|\"+SSL_ST_EARLY_SECRET\"| EARLY[\"early_secret[64]\"]\n    SSL_ST -->|\"+SSL_ST_HANDSHAKE_SECRET\"| HS[\"handshake_secret[64]\"]\n    SSL_ST -->|\"+SSL_ST_HANDSHAKE_TRAFFIC_HASH\"| HTH[\"handshake_traffic_hash[64]\"]\n    SSL_ST -->|\"+SSL_ST_CLIENT_APP_TRAFFIC_SECRET\"| CATS[\"client_app_traffic_secret[64]\"]\n    SSL_ST -->|\"+SSL_ST_SERVER_APP_TRAFFIC_SECRET\"| SATS[\"server_app_traffic_secret[64]\"]\n    SSL_ST -->|\"+SSL_ST_EXPORTER_MASTER_SECRET\"| EMS[\"exporter_master_secret[64]\"]\n    \n    style VERSION fill:#fff3e0\n    style CLIENT_RANDOM fill:#e8f5e9\n    style HS fill:#e3f2fd\n```\n\n**Diagram: OpenSSL TLS 1.3 Secret Locations in ssl_st**\n\nThe secrets are stored directly in the `ssl_st` structure for OpenSSL 1.1.1+. The cipher ID determines the hash function (SHA-256 for 32-byte secrets, SHA-384 for 48-byte secrets).\n\nSources: [kern/openssl_masterkey.h:171-256](), [user/module/probe_openssl.go:501-551]()\n\n### BoringSSL TLS 1.3 Structure Layout\n\n```mermaid\ngraph TB\n    SSL_ST[\"ssl_st\"] -->|\"+SSL_ST_S3\"| S3[\"*ssl3_state_st\"]\n    S3 -->|\"offset 16\"| CLIENT_RANDOM[\"client_random[32]\"]\n    S3 -->|\"+BSSL__SSL3_STATE_HS\"| HS_PTR[\"*SSL_HANDSHAKE\"]\n    S3 -->|\"+BSSL__SSL3_STATE_EXPORTER_SECRET\"| EXPORTER[\"exporter_secret[64]\"]\n    \n    HS_PTR -->|\"+SSL_HANDSHAKE_HASH_LEN_\"| HASH_LEN[\"hash_len<br/>uint8\"]\n    HS_PTR -->|\"+SSL_HANDSHAKE_EARLY_TRAFFIC_SECRET_\"| EARLY[\"early_traffic_secret_[48]\"]\n    HS_PTR -->|\"+SSL_HANDSHAKE_CLIENT_HANDSHAKE_SECRET_\"| CHS[\"client_handshake_secret_[48]\"]\n    HS_PTR -->|\"+SSL_HANDSHAKE_SERVER_HANDSHAKE_SECRET_\"| SHS[\"server_handshake_secret_[48]\"]\n    HS_PTR -->|\"+SSL_HANDSHAKE_CLIENT_TRAFFIC_SECRET_0_\"| CTS[\"client_traffic_secret_0_[48]\"]\n    HS_PTR -->|\"+SSL_HANDSHAKE_SERVER_TRAFFIC_SECRET_0_\"| STS[\"server_traffic_secret_0_[48]\"]\n    \n    HS_PTR -->|\"+BSSL__SSL_HANDSHAKE_STATE\"| STATE[\"state<br/>int32\"]\n    HS_PTR -->|\"+BSSL__SSL_HANDSHAKE_STATE+4\"| TLS13_STATE[\"tls13_state<br/>int32\"]\n    \n    style HASH_LEN fill:#fff3e0\n    style STATE fill:#e8f5e9\n    style TLS13_STATE fill:#e8f5e9\n```\n\n**Diagram: BoringSSL TLS 1.3 Secret Locations in SSL_HANDSHAKE**\n\nBoringSSL stores TLS 1.3 secrets in private fields of the `SSL_HANDSHAKE` structure. The offsets are calculated based on the known layout of the structure, accounting for memory alignment. The secrets are maximum 48 bytes (SSL_MAX_MD_SIZE).\n\nSources: [kern/boringssl_masterkey.h:343-402](), [kern/boringssl_const.h:1-63]()\n\n### HKDF Expansion for TLS 1.3\n\nFor TLS 1.3, eCapture extracts the `handshake_secret` and `handshake_traffic_hash` from the SSL structure, then computes client and server handshake traffic secrets using HKDF-Expand-Label:\n\n```\nCLIENT_HANDSHAKE_TRAFFIC_SECRET = HKDF-Expand-Label(\n    handshake_secret,\n    \"c hs traffic\",\n    handshake_traffic_hash,\n    hash_length\n)\n\nSERVER_HANDSHAKE_TRAFFIC_SECRET = HKDF-Expand-Label(\n    handshake_secret,\n    \"s hs traffic\",\n    handshake_traffic_hash,\n    hash_length\n)\n```\n\nThe hash function (SHA-256 or SHA-384) is determined by the cipher suite:\n- **TLS_AES_128_GCM_SHA256** (0x1301): 32 bytes, SHA-256\n- **TLS_CHACHA20_POLY1305_SHA256** (0x1303): 32 bytes, SHA-256\n- **TLS_AES_256_GCM_SHA384** (0x1302): 48 bytes, SHA-384\n\nSources: [user/module/probe_openssl.go:502-551](), [pkg/util/hkdf/hkdf.go]()\n\n## Key Deduplication\n\neCapture maintains a `masterKeys` map keyed by the client_random (hex-encoded) to prevent duplicate entries:\n\n```go\ntype MOpenSSLProbe struct {\n    masterKeys map[string]bool  // map[client_random_hex]bool\n    // ...\n}\n\nfunc (m *MOpenSSLProbe) saveMasterSecret(secretEvent *event.MasterSecretEvent) {\n    k := fmt.Sprintf(\"%02x\", secretEvent.ClientRandom)\n    \n    _, f := m.masterKeys[k]\n    if f {\n        // Already exists, skip\n        return\n    }\n    \n    // ... format and write ...\n    m.masterKeys[k] = true\n}\n```\n\nThis is necessary because:\n1. SSL/TLS functions may be called multiple times during a connection\n2. Session resumption can reuse the same client_random\n3. Multiple capture points (SSL_write, SSL_read, SSL_do_handshake) may observe the same secret\n\nSources: [user/module/probe_openssl.go:96-99](), [user/module/probe_openssl.go:482-575]()\n\n## Null Secret Detection\n\neCapture validates that secrets are not all zeros before writing to the keylog file. This prevents writing invalid or uninitialized secrets:\n\n```mermaid\ngraph TB\n    EVENT[\"Master Secret Event\"] --> CHECK_VERSION{\"TLS Version?\"}\n    CHECK_VERSION -->|\"TLS 1.2\"| CHECK_12[\"Check master_key<br/>for all zeros\"]\n    CHECK_VERSION -->|\"TLS 1.3\"| CHECK_13[\"Check all 5 secrets:<br/>- client_handshake<br/>- server_handshake<br/>- client_traffic_0<br/>- server_traffic_0<br/>- exporter\"]\n    \n    CHECK_12 -->|\"All zeros\"| DISCARD[\"Discard event\"]\n    CHECK_12 -->|\"Valid\"| WRITE[\"Write to keylog\"]\n    \n    CHECK_13 -->|\"All zeros\"| DISCARD\n    CHECK_13 -->|\"At least one<br/>non-zero\"| WRITE\n    \n    style CHECK_12 fill:#fff3e0\n    style CHECK_13 fill:#fff3e0\n    style DISCARD fill:#ffebee\n    style WRITE fill:#e8f5e9\n```\n\n**Diagram: Null Secret Detection Logic**\n\nThe validation occurs in functions `mk12NullSecrets()` and `mk13NullSecrets()`:\n\n```go\n// TLS 1.2: Check if all bytes in range [0:hashLen] are zero\nfunc (m *MOpenSSLProbe) mk12NullSecrets(hashLen int, secret []byte) bool {\n    isNull := true\n    for i := 0; i < hashLen; i++ {\n        if secret[i] != 0 {\n            isNull = false\n            break\n        }\n    }\n    return isNull\n}\n\n// TLS 1.3: Check if all 5 secrets are zero\nfunc (m *MOpenSSLProbe) mk13NullSecrets(hashLen int,\n    ClientHandshakeSecret [64]byte,\n    ClientTrafficSecret0 [64]byte,\n    ServerHandshakeSecret [64]byte,\n    ServerTrafficSecret0 [64]byte,\n    ExporterSecret [64]byte) bool {\n    // Returns true if all 5 secrets are null (isNullCount == 5)\n    // Returns false if at least one secret has non-zero bytes\n}\n```\n\nSources: [user/module/probe_openssl.go:652-731]()\n\n## Output File Format Example\n\nA typical keylog file contains entries like:\n\n```\nCLIENT_RANDOM 0123456789abcdef... 0a1b2c3d4e5f6789...\nCLIENT_HANDSHAKE_TRAFFIC_SECRET 0123456789abcdef... 1a2b3c4d5e6f7890...\nSERVER_HANDSHAKE_TRAFFIC_SECRET 0123456789abcdef... 2b3c4d5e6f789012...\nCLIENT_TRAFFIC_SECRET_0 0123456789abcdef... 3c4d5e6f78901234...\nSERVER_TRAFFIC_SECRET_0 0123456789abcdef... 4d5e6f7890123456...\nEXPORTER_SECRET 0123456789abcdef... 5e6f789012345678...\n```\n\nThe file is opened with `O_APPEND` mode, allowing multiple eCapture runs to accumulate keys in the same file. The file permissions are set to `0o600` (read/write for owner only) for security.\n\nSources: [user/module/probe_openssl.go:131-136](), [user/module/probe_openssl.go:567-572]()\n\n## Integration with Wireshark\n\nTo decrypt TLS traffic in Wireshark using the keylog file:\n\n1. **Capture packets** using eCapture's PCAP mode or tcpdump\n2. **Generate keylog file** using eCapture's keylog mode:\n   ```bash\n   ecapture tls --keylogfile=/tmp/keys.log\n   ```\n3. **Configure Wireshark**:\n   - Edit → Preferences → Protocols → TLS\n   - Set \"(Pre)-Master-Secret log filename\" to `/tmp/keys.log`\n4. **Reload capture** or restart Wireshark\n\nWireshark will automatically decrypt TLS traffic matching the client_random values in the keylog file.\n\n### Combined PCAP + Keylog Mode\n\nWhen using PCAP mode, eCapture can embed the keylog data directly into the PCAPNG file as Decryption Secrets Blocks (DSB), eliminating the need for a separate keylog file. See [PCAP Integration](#4.2) for details.\n\nSources: [user/module/probe_openssl.go:560-564]()\n\n## State Verification for Secret Extraction\n\nThe eBPF programs verify that the TLS handshake has reached an appropriate state before extracting secrets:\n\n### OpenSSL State Requirements\n\nFor OpenSSL, secret extraction occurs during any SSL_write or SSL_read call after the handshake completes. The version field is checked, but no explicit state verification is performed since the secrets are stored in persistent structures.\n\n### BoringSSL State Requirements\n\nBoringSSL maintains explicit handshake state machines. The eBPF program verifies:\n\n**TLS 1.2 States:**\n- Client: `state >= CLIENT_STATE12_SEND_CLIENT_FINISHED` (16)\n- Server: `state >= SERVER_STATE12_READ_CLIENT_FINISHED` (18)\n\n**TLS 1.3 States:**\n- Client: `tls13_state >= CLIENT_STATE13_READ_SERVER_FINISHED` (8)\n- Server: `tls13_state >= SERVER_STATE13_READ_CLIENT_FINISHED` (14)\n\n```c\n// From boringssl_masterkey.h:289-293\nif (ssl3_hs_state.state < CLIENT_STATE12_SEND_CLIENT_FINISHED) {\n    // not finished yet.\n    return 0;\n}\n\n// From boringssl_masterkey.h:345-348\nif (ssl3_hs_state.tls13_state < CLIENT_STATE13_READ_SERVER_FINISHED) {\n    // not finished yet.\n    return 0;\n}\n```\n\nThis ensures secrets are only extracted after the handshake completes and all secret material is available.\n\nSources: [kern/boringssl_masterkey.h:263-348](), [kern/boringssl_masterkey.h:77-86]()\n\n## Error Handling\n\nThe key logging system handles several error conditions:\n\n| Condition | Behavior |\n|-----------|----------|\n| File open failure | Initialization fails, error returned to user |\n| Write failure | Warning logged, event discarded |\n| Null secrets detected | Event discarded silently |\n| Duplicate client_random | Event skipped, no write |\n| Hash length exceeds buffer | Truncated to maximum size with warning |\n| eBPF probe read failure | Event not sent to user space |\n\nThe logger provides detailed information about each successfully written secret:\n\n```go\nm.logger.Info().\n    Str(\"TlsVersion\", v.String()).\n    Str(\"CLientRandom\", k).\n    Int(\"bytes\", l).\n    Msg(\"CLIENT_RANDOM save success\")\n```\n\nSources: [user/module/probe_openssl.go:567-572](), [user/module/probe_openssl.go:594-607]()\n\n## Implementation Summary\n\nThe key logging implementation spans three layers:\n\n```mermaid\ngraph TB\n    subgraph \"1. eBPF Layer (Kernel Space)\"\n        PROBE[\"probe_ssl_master_key()<br/>uprobe on SSL functions\"]\n        EXTRACT[\"Structure navigation<br/>Memory reads\"]\n        EVENT[\"mastersecret_events<br/>Perf event array\"]\n    end\n    \n    subgraph \"2. Event Processing (User Space)\"\n        DECODE[\"Decode()<br/>event.MasterSecretEvent\"]\n        DISPATCH[\"Dispatcher()<br/>Route by event type\"]\n        VALIDATE[\"Null secret checks<br/>State verification\"]\n    end\n    \n    subgraph \"3. Format & Write\"\n        HKDF[\"HKDF expansion<br/>(TLS 1.3 only)\"]\n        FORMAT_FUNC[\"Format SSLKEYLOGFILE<br/>Label + ClientRandom + Secret\"]\n        DEDUP_CHECK[\"Deduplication<br/>masterKeys map\"]\n        WRITE_FILE[\"Write to file<br/>O_APPEND mode\"]\n    end\n    \n    PROBE --> EXTRACT\n    EXTRACT --> EVENT\n    EVENT --> DECODE\n    DECODE --> DISPATCH\n    DISPATCH --> VALIDATE\n    VALIDATE -->|\"Valid\"| HKDF\n    HKDF --> FORMAT_FUNC\n    FORMAT_FUNC --> DEDUP_CHECK\n    DEDUP_CHECK -->|\"New\"| WRITE_FILE\n    \n    style PROBE fill:#e3f2fd\n    style VALIDATE fill:#fff3e0\n    style DEDUP_CHECK fill:#fff3e0\n    style WRITE_FILE fill:#e8f5e9\n```\n\n**Diagram: Key Logging Implementation Layers**\n\nThe system achieves high reliability through:\n- **Atomic writes**: Each line is written atomically to the file\n- **Deduplication**: Prevents redundant entries\n- **Validation**: Ensures secrets are non-null before writing\n- **State checking**: Extracts secrets only after handshake completion\n- **Error handling**: Graceful degradation on failures\n\nSources: [user/module/probe_openssl.go:733-754](), [kern/openssl_masterkey.h:80-257](), [kern/boringssl_masterkey.h:169-403]()"
          },
          {
            "page_plan": {
              "id": "4.4",
              "title": "Protobuf and External Integration"
            },
            "content": "# Protobuf and External Integration\n\n<details>\n<summary>Relevant source files</summary>\n\nThe following files were used as context for generating this wiki page:\n\n- [CHANGELOG.md](CHANGELOG.md)\n- [README.md](README.md)\n- [README_CN.md](README_CN.md)\n- [images/ecapture-help-v0.8.9.svg](images/ecapture-help-v0.8.9.svg)\n- [main.go](main.go)\n- [pkg/event_processor/base_event.go](pkg/event_processor/base_event.go)\n- [user/event/event_bash.go](user/event/event_bash.go)\n- [user/event/event_gnutls.go](user/event/event_gnutls.go)\n- [user/event/event_masterkey.go](user/event/event_masterkey.go)\n- [user/event/event_mysqld.go](user/event/event_mysqld.go)\n- [user/event/event_nspr.go](user/event/event_nspr.go)\n- [user/event/event_openssl.go](user/event/event_openssl.go)\n- [user/event/event_openssl_tc.go](user/event/event_openssl_tc.go)\n- [user/event/event_postgres.go](user/event/event_postgres.go)\n\n</details>\n\n\n\n## Purpose and Scope\n\nThis document describes eCapture's protobuf-based event serialization and external integration capabilities. It covers how captured events are converted to Protocol Buffer format for transmission to external systems, the WebSocket streaming protocol for real-time event forwarding, and integration with the eCaptureQ graphical user interface.\n\nFor information about text-based output formatting, see [Text Output Mode](#4.1). For PCAP file generation, see [PCAP Integration](#4.2). For configuration management via HTTP API, see [Configuration System](#2.3).\n\n---\n\n## Protobuf Event Schema\n\n### Event Interface and Serialization\n\nAll event types in eCapture implement the `IEventStruct` interface, which includes a `ToProtobufEvent()` method for serialization. This standardized approach enables uniform event transmission to external systems regardless of the originating module.\n\n**Diagram: Event Serialization Interface**\n\n```mermaid\ngraph TB\n    IEventStruct[\"IEventStruct Interface\"]\n    ToProtobuf[\"ToProtobufEvent() *pb.Event\"]\n    \n    SSLDataEvent[\"SSLDataEvent\"]\n    MasterSecretEvent[\"MasterSecretEvent\"]\n    GnutlsDataEvent[\"GnutlsDataEvent\"]\n    NsprDataEvent[\"NsprDataEvent\"]\n    BashEvent[\"BashEvent\"]\n    MysqldEvent[\"MysqldEvent\"]\n    PostgresEvent[\"PostgresEvent\"]\n    ConnDataEvent[\"ConnDataEvent\"]\n    TcSkbEvent[\"TcSkbEvent\"]\n    \n    IEventStruct --> ToProtobuf\n    \n    SSLDataEvent -.implements.-> IEventStruct\n    MasterSecretEvent -.implements.-> IEventStruct\n    GnutlsDataEvent -.implements.-> IEventStruct\n    NsprDataEvent -.implements.-> IEventStruct\n    BashEvent -.implements.-> IEventStruct\n    MysqldEvent -.implements.-> IEventStruct\n    PostgresEvent -.implements.-> IEventStruct\n    ConnDataEvent -.implements.-> IEventStruct\n    TcSkbEvent -.implements.-> IEventStruct\n    \n    ProtoEvent[\"pb.Event Message<br/>timestamp, uuid, src_ip, src_port<br/>dst_ip, dst_port, pid, pname<br/>type, length, payload\"]\n    \n    ToProtobuf --> ProtoEvent\n```\n\nSources: [user/event/event_openssl.go:237-266](), [user/event/event_masterkey.go:123-137](), [user/event/event_gnutls.go:125-138](), [user/event/event_nspr.go:143-157](), [user/event/event_bash.go:103-117](), [user/event/event_mysqld.go:138-152](), [user/event/event_postgres.go:87-102]()\n\n### Protobuf Event Structure\n\nThe unified `pb.Event` protobuf message contains the following fields:\n\n| Field | Type | Description |\n|-------|------|-------------|\n| `timestamp` | int64 | Event timestamp in nanoseconds (Unix epoch) |\n| `uuid` | string | Unique event identifier (varies by event type) |\n| `src_ip` | string | Source IP address (when available) |\n| `src_port` | uint32 | Source port number (when available) |\n| `dst_ip` | string | Destination IP address (when available) |\n| `dst_port` | uint32 | Destination port number (when available) |\n| `pid` | int64 | Process ID that generated the event |\n| `pname` | string | Process name (command) |\n| `type` | uint32 | Event-specific type field (varies by module) |\n| `length` | uint32 | Payload length in bytes |\n| `payload` | bytes | Raw event data (varies by event type) |\n\nSources: [user/event/event_openssl.go:237-266](), [protobuf/PROTOCOLS.md]()\n\n### Event Type Conversions\n\nEach event type implements `ToProtobufEvent()` differently based on its data structure:\n\n**Table: Event Type Protobuf Mappings**\n\n| Event Type | UUID Format | Type Field | Payload Content | IP/Port Available |\n|------------|-------------|------------|-----------------|-------------------|\n| `SSLDataEvent` | `sock:PID_TID_Comm_FD_DataType_Tuple_Sock` | Data direction (0=recv, 1=send) | SSL/TLS plaintext | Yes (from tuple) |\n| `MasterSecretEvent` | `ClientRandom` (hex) | TLS version | Keylog format string | No (127.0.0.1:0) |\n| `MasterSecretBSSLEvent` | `ClientRandom` (hex) | TLS version | Keylog format string | No (127.0.0.1:0) |\n| `GnutlsDataEvent` | `PID_TID_Comm_DataType` | Data direction | GnuTLS plaintext | No (127.0.0.1:0) |\n| `NsprDataEvent` | `PID_TID_Comm_DataType` | Data direction | NSS plaintext | No (127.0.0.1:0) |\n| `BashEvent` | `PID_UID_Comm` | Bash event type | Command line | No (127.0.0.1:0) |\n| `MysqldEvent` | `PID_Comm` | Return value | SQL query | No (127.0.0.1:0) |\n| `PostgresEvent` | `PID_Comm` | 0 | SQL query | No (127.0.0.1:0) |\n| `ConnDataEvent` | `PID_TID_Comm_FD` | 0 | Connection tuple | Yes (from tuple) |\n| `TcSkbEvent` | `PID_Ifindex_Comm` | 0 | Network packet | No (127.0.0.1:0) |\n\nSources: [user/event/event_openssl.go:237-266](), [user/event/event_masterkey.go:123-137,242-256](), [user/event/event_gnutls.go:125-138](), [user/event/event_nspr.go:143-157](), [user/event/event_bash.go:103-117](), [user/event/event_mysqld.go:138-152](), [user/event/event_postgres.go:87-102](), [user/event/event_openssl_tc.go:99-113]()\n\n---\n\n## Event Serialization Architecture\n\n### Serialization Pipeline\n\nEvents flow from eBPF programs through the event processing pipeline and are optionally serialized to protobuf format for external transmission.\n\n**Diagram: Protobuf Serialization Pipeline**\n\n```mermaid\nflowchart LR\n    subgraph eBPF[\"eBPF Kernel Space\"]\n        Maps[\"eBPF Maps<br/>perf_event_array<br/>ring_buffer\"]\n    end\n    \n    subgraph EventProcessing[\"Event Processing Layer\"]\n        Reader[\"Event Reader<br/>perfEventReader<br/>ringbufEventReader\"]\n        Decoder[\"Decode()<br/>Binary deserialization\"]\n        EventStruct[\"IEventStruct<br/>Concrete event types\"]\n    end\n    \n    subgraph Serialization[\"Serialization Layer\"]\n        ToProto[\"ToProtobufEvent()\"]\n        PbEvent[\"pb.Event\"]\n        Marshal[\"proto.Marshal()\"]\n        Binary[\"Protobuf binary\"]\n    end\n    \n    subgraph Output[\"Output Destinations\"]\n        WebSocket[\"WebSocket Stream\"]\n        HTTP[\"HTTP POST\"]\n        File[\"File/Logger\"]\n    end\n    \n    Maps --> Reader\n    Reader --> Decoder\n    Decoder --> EventStruct\n    \n    EventStruct --> ToProto\n    ToProto --> PbEvent\n    PbEvent --> Marshal\n    Marshal --> Binary\n    \n    Binary --> WebSocket\n    Binary --> HTTP\n    Binary --> File\n```\n\nSources: [user/event/event_openssl.go:237-266](), [pkg/event_processor/base_event.go:185-194]()\n\n### Implementation Details\n\nThe `ToProtobufEvent()` method follows a consistent pattern across all event types:\n\n1. **Create protobuf message**: Instantiate `pb.Event` structure\n2. **Populate common fields**: Set timestamp, UUID, PID, process name\n3. **Parse connection information**: Extract IP addresses and ports when available (from tuple strings)\n4. **Set event-specific fields**: Populate `type`, `length`, and `payload` based on event content\n5. **Return pointer**: Return `*pb.Event` for marshaling\n\n**Example: SSLDataEvent Protobuf Conversion**\n\n```\n// SSLDataEvent.ToProtobufEvent() implementation pattern:\n1. Create pb.Event with timestamp and UUID\n2. Parse tuple string format \"IP:Port-IP:Port\"\n3. Split into source and destination parts\n4. Extract IP addresses and port numbers\n5. Set payload from Data[:DataLen]\n6. Return protobuf event pointer\n```\n\nSources: [user/event/event_openssl.go:237-266]()\n\n### IP Address and Port Extraction\n\nEvents with network connection information (primarily from TLS/SSL modules) extract IP addresses and ports from tuple strings:\n\n**Tuple Format Parsing Logic**:\n- **IPv4 Format**: `192.168.1.1:443-10.0.0.1:54321`\n- **IPv6 Format**: `[2001:db8::1]:443-[fe80::1]:54321`\n- **Parsing Steps**:\n  1. Split on `-` delimiter to separate source and destination\n  2. Split each part on `:` to separate IP and port\n  3. Handle IPv6 bracket notation\n  4. Convert port strings to uint32\n\nSources: [user/event/event_openssl.go:245-263](), [user/event/event_openssl.go:361-379]()\n\n---\n\n## WebSocket Streaming Protocol\n\n### Server Architecture\n\neCapture provides a WebSocket server for real-time event streaming to external clients. The server operates on `localhost:28256` by default and implements a bidirectional protocol for event transmission and configuration updates.\n\n**Diagram: WebSocket Communication Architecture**\n\n```mermaid\nsequenceDiagram\n    participant Client as \"External Client<br/>(eCaptureQ/Custom)\"\n    participant WS as \"WebSocket Server<br/>localhost:28256\"\n    participant EventProc as \"Event Processor\"\n    participant Module as \"Capture Module\"\n    \n    Client->>WS: Connect\n    WS-->>Client: Connection accepted\n    \n    Client->>WS: Subscribe request\n    WS-->>Client: Subscription confirmed\n    \n    loop Event Capture\n        Module->>EventProc: Captured event\n        EventProc->>EventProc: ToProtobufEvent()\n        EventProc->>EventProc: proto.Marshal()\n        EventProc->>WS: Binary protobuf data\n        WS->>Client: WebSocket message (binary)\n    end\n    \n    Client->>WS: Configuration update\n    WS->>Module: Apply configuration\n    WS-->>Client: Update confirmed\n    \n    Client->>WS: Disconnect\n```\n\nSources: [CHANGELOG.md:82-87](), [README.md:322-327]()\n\n### WebSocket Message Format\n\nThe WebSocket protocol uses binary frames containing protobuf-serialized events:\n\n| Component | Description |\n|-----------|-------------|\n| **Frame Type** | Binary (0x02) |\n| **Payload** | Protobuf-encoded `pb.Event` message |\n| **Encoding** | Protocol Buffers binary format |\n| **Compression** | Optional (negotiated during handshake) |\n\n**Message Flow Pattern**:\n1. **Heartbeat**: Periodic ping/pong to maintain connection\n2. **Event Stream**: Continuous flow of protobuf-encoded events\n3. **Control Messages**: Configuration updates and subscription management\n\nSources: [CHANGELOG.md:82-87]()\n\n### Event Forwarding Configuration\n\nThe WebSocket server can be configured to forward events selectively:\n\n- **Module Filtering**: Forward events only from specific modules (tls, gotls, etc.)\n- **Process Filtering**: Filter by PID or UID\n- **Event Type Filtering**: Select specific event types (data, masterkey, connection)\n- **Rate Limiting**: Control event transmission rate to prevent client overload\n\nSources: [README.md:322-327](), [docs/event-forward-api.md]()\n\n---\n\n## eCaptureQ Integration\n\n### Remote Mode Architecture\n\neCaptureQ is a cross-platform GUI client that visualizes eCapture events. It operates in two modes:\n\n**Diagram: eCaptureQ Integration Modes**\n\n```mermaid\ngraph TB\n    subgraph Integrated[\"Integrated Mode<br/>(Linux/Android)\"]\n        eCaptureQ_Int[\"eCaptureQ<br/>Rust+Tauri+React\"]\n        eCapture_Int[\"eCapture Binary<br/>Embedded\"]\n        \n        eCaptureQ_Int -->|Direct API calls| eCapture_Int\n        eCapture_Int -->|Events via IPC| eCaptureQ_Int\n    end\n    \n    subgraph Remote[\"Remote Mode<br/>(Windows/macOS/Linux)\"]\n        eCaptureQ_Remote[\"eCaptureQ Client<br/>Rust+Tauri+React\"]\n        \n        subgraph RemoteServer[\"Remote Linux Server\"]\n            eCapture_Server[\"eCapture Service<br/>localhost:28256\"]\n            eBPF[\"eBPF Programs\"]\n            \n            eCapture_Server --> eBPF\n        end\n        \n        eCaptureQ_Remote -->|WebSocket<br/>protobuf events| eCapture_Server\n        eCaptureQ_Remote -->|HTTP<br/>config updates| eCapture_Server\n    end\n    \n    User[\"User\"] --> eCaptureQ_Int\n    User --> eCaptureQ_Remote\n```\n\nSources: [README.md:267-281](), [README_CN.md:267-281]()\n\n### Remote Mode Communication Protocol\n\nIn remote mode, eCaptureQ communicates with eCapture via two channels:\n\n**1. WebSocket Event Stream (Binary)**\n- **Endpoint**: `ws://host:28256/ws`\n- **Protocol**: WebSocket with protobuf binary frames\n- **Purpose**: Real-time event streaming from eCapture to GUI\n- **Flow**: Server → Client (unidirectional for events)\n\n**2. HTTP Configuration API (JSON)**\n- **Endpoint**: `http://host:28256/config`\n- **Protocol**: RESTful HTTP with JSON payloads\n- **Purpose**: Runtime configuration updates\n- **Flow**: Client → Server (request/response)\n\nSources: [README.md:322-327](), [docs/remote-config-update-api.md]()\n\n### Event Visualization Pipeline\n\neCaptureQ processes protobuf events for visualization:\n\n**Diagram: eCaptureQ Event Processing**\n\n```mermaid\nflowchart LR\n    subgraph eCapture[\"eCapture Server\"]\n        Capture[\"Event Capture\"]\n        ToProto[\"ToProtobufEvent()\"]\n        WS_Send[\"WebSocket Send\"]\n        \n        Capture --> ToProto\n        ToProto --> WS_Send\n    end\n    \n    subgraph eCaptureQ[\"eCaptureQ Client\"]\n        WS_Recv[\"WebSocket Receive\"]\n        Unmarshal[\"proto.Unmarshal()\"]\n        Decode[\"Event Decoder\"]\n        \n        subgraph UI[\"User Interface\"]\n            List[\"Event List View\"]\n            Detail[\"Detail Panel\"]\n            Filter[\"Filter Controls\"]\n            Export[\"Export Actions\"]\n        end\n        \n        WS_Recv --> Unmarshal\n        Unmarshal --> Decode\n        Decode --> List\n        List --> Detail\n        Filter -.filters.-> List\n        List --> Export\n    end\n    \n    WS_Send -->|Binary protobuf| WS_Recv\n```\n\nSources: [README.md:287-302]()\n\n### Protocol Documentation\n\nComplete protobuf schema definitions and protocol specifications are documented in:\n\n- **English**: [protobuf/PROTOCOLS.md]()\n- **Chinese**: [protobuf/PROTOCOLS_CN.md]()\n\nThese documents detail:\n- Message field definitions\n- Event type enumerations\n- Serialization examples\n- Version compatibility guidelines\n\nSources: [README.md:304-308](), [README_CN.md:283-287]()\n\n---\n\n## HTTP API for External Systems\n\n### Configuration Update API\n\neCapture exposes an HTTP API on `localhost:28256` for runtime configuration management. This enables external systems to dynamically control capture behavior without restarting the process.\n\n**API Endpoints**:\n\n| Method | Endpoint | Purpose | Request Format |\n|--------|----------|---------|----------------|\n| GET | `/config` | Retrieve current configuration | N/A |\n| POST | `/config` | Update configuration parameters | JSON |\n| GET | `/status` | Query module status | N/A |\n\n**Configuration Update Example**:\n```json\nPOST /config\n{\n  \"pid\": 1234,\n  \"uid\": 1000,\n  \"btf_mode\": 0,\n  \"log_level\": \"info\"\n}\n```\n\nSources: [README.md:322-324](), [docs/remote-config-update-api.md]()\n\n### Event Forwarding API\n\nExternal systems can receive events via HTTP POST callbacks:\n\n**Forwarding Configuration**:\n```json\nPOST /config\n{\n  \"event_forward\": {\n    \"enabled\": true,\n    \"url\": \"http://external-system:8080/events\",\n    \"format\": \"protobuf\",\n    \"modules\": [\"tls\", \"gotls\"],\n    \"batch_size\": 100,\n    \"batch_timeout_ms\": 1000\n  }\n}\n```\n\n**Event POST Format**:\n- **Content-Type**: `application/x-protobuf` or `application/json`\n- **Body**: Protobuf binary or JSON-serialized event\n- **Headers**: Custom headers for authentication/routing\n\nSources: [README.md:325-327](), [docs/event-forward-api.md]()\n\n### Security Considerations\n\nThe HTTP API is bound to `localhost:28256` by default for security:\n\n1. **Local-only Access**: Only localhost connections accepted by default\n2. **No Authentication**: Relies on OS-level process isolation\n3. **Remote Access**: Requires SSH tunneling or reverse proxy configuration\n4. **Rate Limiting**: Configurable request rate limits to prevent abuse\n\nFor remote access, use SSH port forwarding:\n```bash\nssh -L 28256:localhost:28256 user@remote-host\n```\n\nSources: [README.md:82-85](), [README_CN.md:83-88]()\n\n---\n\n## Integration Examples\n\n### Custom Client Implementation\n\nImplementing a custom protobuf client requires:\n\n1. **Protobuf Definitions**: Import or compile `protobuf/gen/v1/event.proto`\n2. **WebSocket Connection**: Establish connection to `ws://host:28256/ws`\n3. **Binary Deserialization**: Use language-specific protobuf library to unmarshal\n4. **Event Handling**: Process events based on `type` and `uuid` fields\n\n**Python Example Pattern**:\n```python\n# 1. Import generated protobuf classes\nfrom ecapture.protobuf.gen.v1 import event_pb2\n\n# 2. Connect to WebSocket\nws = websocket.WebSocketApp(\"ws://localhost:28256/ws\")\n\n# 3. Handle binary messages\ndef on_message(ws, message):\n    event = event_pb2.Event()\n    event.ParseFromString(message)\n    # Process event fields\n    print(f\"PID: {event.pid}, Payload: {event.payload}\")\n```\n\nSources: [CHANGELOG.md:16]()\n\n### Burp Suite Integration\n\neCapture can forward HTTP/HTTPS events to Burp Suite for security analysis:\n\n**Configuration**:\n```json\nPOST /config\n{\n  \"event_forward\": {\n    \"enabled\": true,\n    \"url\": \"http://localhost:8080\",\n    \"format\": \"http_proxy\",\n    \"modules\": [\"tls\", \"gotls\"],\n    \"filter\": {\n      \"protocols\": [\"http\", \"https\"]\n    }\n  }\n}\n```\n\nThe event payload is reconstructed as HTTP requests/responses and forwarded to Burp's proxy port.\n\nSources: [README.md:325-327](), [docs/event-forward-api.md]()\n\n### Monitoring System Integration\n\nIntegrate eCapture with monitoring platforms (Prometheus, Grafana, ELK):\n\n**Metric Export Pattern**:\n1. **WebSocket Subscriber**: Consume protobuf events\n2. **Metric Aggregation**: Count events by type, PID, protocol\n3. **Time-series Export**: Push metrics to Prometheus/InfluxDB\n4. **Alerting**: Trigger alerts on anomalous patterns (e.g., unusual SQL queries)\n\n**Example Metrics**:\n- `ecapture_events_total{module=\"tls\", pid=\"1234\"}` - Event counter\n- `ecapture_payload_bytes{module=\"tls\"}` - Total bytes captured\n- `ecapture_connections_active` - Active connection count\n\nSources: [README.md:325-327]()\n\n---\n\n## Implementation Notes\n\n### Event Batching\n\nFor high-throughput scenarios, events can be batched before protobuf serialization:\n\n- **Batch Size**: Configurable (default: 100 events)\n- **Timeout**: Max wait time before flushing partial batch (default: 1s)\n- **Compression**: Optional gzip compression for batched messages\n- **Ordering**: Events maintain timestamp-based ordering within batches\n\nSources: [docs/event-forward-api.md]()\n\n### Version Compatibility\n\nThe protobuf schema uses field numbering to ensure backward/forward compatibility:\n\n- **New Fields**: Can be added without breaking existing clients\n- **Deprecated Fields**: Marked but not removed to maintain compatibility\n- **Version Header**: WebSocket handshake includes protocol version\n- **Graceful Degradation**: Unknown fields are ignored by older clients\n\nSources: [protobuf/PROTOCOLS.md]()\n\n### Performance Optimization\n\nProtobuf serialization is optimized for performance:\n\n- **Zero-Copy**: Where possible, payload bytes are referenced not copied\n- **Pool Allocation**: Event objects are pooled to reduce GC pressure\n- **Async Marshaling**: Serialization occurs in background goroutines\n- **Buffer Sizing**: Pre-allocated buffers sized based on typical event sizes\n\nSources: [user/event/event_openssl.go:237-266]()"
          },
          {
            "page_plan": {
              "id": "5",
              "title": "Development Guide"
            },
            "content": "# Development Guide\n\n<details>\n<summary>Relevant source files</summary>\n\nThe following files were used as context for generating this wiki page:\n\n- [.github/workflows/codeql-analysis.yml](.github/workflows/codeql-analysis.yml)\n- [.github/workflows/go-c-cpp.yml](.github/workflows/go-c-cpp.yml)\n- [.github/workflows/release.yml](.github/workflows/release.yml)\n- [Makefile](Makefile)\n- [builder/Dockerfile](builder/Dockerfile)\n- [builder/Makefile.release](builder/Makefile.release)\n- [builder/init_env.sh](builder/init_env.sh)\n- [cli/cmd/root.go](cli/cmd/root.go)\n- [functions.mk](functions.mk)\n- [user/config/iconfig.go](user/config/iconfig.go)\n- [user/module/imodule.go](user/module/imodule.go)\n- [user/module/probe_openssl.go](user/module/probe_openssl.go)\n\n</details>\n\n\n\nThis guide is intended for developers who want to contribute to eCapture, add new capture modules, modify existing functionality, or understand the codebase architecture. It covers the development environment setup, key interfaces, build system, and extension points.\n\nFor detailed information about specific development tasks, see:\n- [Build System](#5.1) - Comprehensive build system documentation\n- [eBPF Program Development](#5.2) - Writing eBPF programs\n- [Adding New Modules](#5.3) - Creating new capture modules\n- [Event Processing and Parsers](#5.4) - Event handling and protocol parsing\n\n---\n\n## Development Environment Requirements\n\neCapture requires specific tools and dependencies for development. The project provides an automated setup script for Ubuntu-based systems.\n\n### Required Tools\n\n| Tool | Minimum Version | Purpose |\n|------|----------------|---------|\n| `clang` | 9+ (14 recommended) | eBPF bytecode compilation |\n| `llvm` | 9+ (14 recommended) | eBPF toolchain |\n| `golang` | 1.24+ | Application compilation |\n| `gcc` | Any recent | Cross-compilation support |\n| `linux-headers` | Matching kernel | Non-CO-RE compilation |\n| `libelf-dev` | - | ELF file parsing |\n| `bpftool` | - | eBPF bytecode generation |\n\n### Automated Setup\n\nThe project provides [builder/init_env.sh:1-106]() which automatically installs dependencies on Ubuntu 20.04-24.04 for both x86_64 and aarch64 architectures. It:\n\n1. Detects Ubuntu version and selects appropriate clang version\n2. Installs compilation toolchain and cross-compilation tools\n3. Extracts and prepares Linux kernel headers\n4. Installs Go 1.24.6\n5. Clones the repository with submodules\n\n**Sources:** [builder/init_env.sh:1-106](), [.github/workflows/go-c-cpp.yml:16-33]()\n\n---\n\n## Core Development Interfaces\n\neCapture's architecture is built around three key interfaces that developers must understand to extend functionality.\n\n### IModule Interface\n\nThe `IModule` interface defines the contract for all capture modules. Every module (OpenSSL, GoTLS, Bash, etc.) implements this interface.\n\n```mermaid\ngraph TB\n    subgraph \"IModule Interface Definition\"\n        IMODULE[\"IModule<br/>(user/module/imodule.go)\"]\n        \n        INIT[\"Init()<br/>Context, Logger, Config, Writer\"]\n        START[\"Start()<br/>Attach eBPF probes\"]\n        RUN[\"Run()<br/>Event loop\"]\n        EVENTS[\"Events()<br/>Return eBPF maps\"]\n        DECODE[\"Decode()<br/>[]byte → IEventStruct\"]\n        DECODEFUN[\"DecodeFun()<br/>Map → EventStruct factory\"]\n        DISPATCH[\"Dispatcher()<br/>Handle events\"]\n        CLOSE[\"Close()<br/>Cleanup\"]\n        \n        IMODULE --> INIT\n        IMODULE --> START\n        IMODULE --> RUN\n        IMODULE --> EVENTS\n        IMODULE --> DECODE\n        IMODULE --> DECODEFUN\n        IMODULE --> DISPATCH\n        IMODULE --> CLOSE\n    end\n    \n    subgraph \"Base Implementation\"\n        MODULE[\"Module struct<br/>(embeddable base)\"]\n        \n        READER[\"reader []IClose<br/>perf/ringbuf readers\"]\n        PROCESSOR[\"processor *EventProcessor<br/>Event aggregation\"]\n        LOGGER[\"logger *zerolog.Logger\"]\n        CTX[\"ctx context.Context\"]\n        \n        MODULE --> READER\n        MODULE --> PROCESSOR\n        MODULE --> LOGGER\n        MODULE --> CTX\n    end\n    \n    subgraph \"Concrete Modules\"\n        OPENSSL[\"MOpenSSLProbe<br/>user/module/probe_openssl.go\"]\n        GOTLS[\"MGoTLSProbe\"]\n        BASH[\"MBashProbe\"]\n        \n        OPENSSL -.->|\"embeds\"| MODULE\n        GOTLS -.->|\"embeds\"| MODULE\n        BASH -.->|\"embeds\"| MODULE\n        \n        OPENSSL -.->|\"implements\"| IMODULE\n        GOTLS -.->|\"implements\"| IMODULE\n        BASH -.->|\"implements\"| IMODULE\n    end\n```\n\n#### IModule Method Contract\n\n| Method | Purpose | Typical Implementation |\n|--------|---------|----------------------|\n| `Init()` | Initialize module state, parse config, setup maps | Load eBPF bytecode selection logic, initialize caches |\n| `Start()` | Attach eBPF programs to hooks | Call `bpfManager.Start()`, attach uprobes/kprobes/TC |\n| `Run()` | Begin event processing | Start event readers, run processor |\n| `Events()` | Return eBPF maps for event reading | Return perf/ringbuf maps |\n| `Decode()` | Deserialize raw bytes to event structs | Parse event type, deserialize fields |\n| `DecodeFun()` | Map eBPF map to event decoder | Return appropriate `IEventStruct` factory |\n| `Dispatcher()` | Handle decoded events | Route to output, update state, save keys |\n| `Close()` | Cleanup resources | Stop readers, close files, detach probes |\n\n**Sources:** [user/module/imodule.go:47-75](), [user/module/imodule.go:83-108]()\n\n### IConfig Interface\n\nAll modules receive configuration through the `IConfig` interface, which provides both common settings and module-specific options.\n\n```mermaid\ngraph LR\n    subgraph \"IConfig Interface\"\n        ICONFIG[\"IConfig<br/>(user/config/iconfig.go)\"]\n        \n        METHODS[\"GetPid()/SetPid()<br/>GetUid()/SetUid()<br/>GetBTF()/SetBTF()<br/>GetDebug()/SetDebug()<br/>GetHex()/SetHex()<br/>GetPerCpuMapSize()<br/>Check()\"]\n        \n        ICONFIG --> METHODS\n    end\n    \n    subgraph \"Base Config\"\n        BASE[\"BaseConfig struct\"]\n        FIELDS[\"Pid uint64<br/>Uid uint64<br/>BtfMode uint8<br/>Debug bool<br/>IsHex bool<br/>PerCpuMapSize int\"]\n        \n        BASE --> FIELDS\n        BASE -.->|\"implements\"| ICONFIG\n    end\n    \n    subgraph \"Module-Specific Configs\"\n        OPENSSLCONF[\"OpensslConfig<br/>(user/config/config_openssl.go)\"]\n        GOTLSCONF[\"GoTLSConfig\"]\n        BASHCONF[\"BashConfig\"]\n        \n        OPENSSLCONF -.->|\"embeds\"| BASE\n        GOTLSCONF -.->|\"embeds\"| BASE\n        BASHCONF -.->|\"embeds\"| BASE\n        \n        SSLFIELDS[\"SslVersion string<br/>Model string (text/pcap/keylog)<br/>PcapFile string<br/>KeylogFile string<br/>IsAndroid bool<br/>CGroupPath string\"]\n        \n        OPENSSLCONF --> SSLFIELDS\n    end\n```\n\n#### Common Configuration Fields\n\n| Field | Type | Purpose | Example |\n|-------|------|---------|---------|\n| `Pid` | `uint64` | Target process ID (0 = all) | `1234` |\n| `Uid` | `uint64` | Target user ID (0 = all) | `1000` |\n| `BtfMode` | `uint8` | BTF mode (0=auto, 1=core, 2=non-core) | `0` |\n| `Debug` | `bool` | Enable debug logging | `true` |\n| `IsHex` | `bool` | Hex output mode | `false` |\n| `PerCpuMapSize` | `int` | eBPF map size per CPU (pages) | `1024` |\n\n**Sources:** [user/config/iconfig.go:24-70](), [user/config/iconfig.go:95-112]()\n\n### IEventStruct Interface\n\nEvents flowing from eBPF to userspace implement `IEventStruct`, enabling polymorphic event handling.\n\n| Method | Return Type | Purpose |\n|--------|-------------|---------|\n| `Decode([]byte)` | `error` | Deserialize from raw bytes |\n| `String()` | `string` | Human-readable text format |\n| `StringHex()` | `string` | Hexadecimal text format |\n| `Clone()` | `IEventStruct` | Create new instance for decoding |\n| `EventType()` | `EventType` | Event classification |\n| `ToProtobufEvent()` | `*pb.Event` | Convert to protobuf |\n\n**Sources:** [user/event/event.go]() (referenced in imports)\n\n---\n\n## Module Development Lifecycle\n\nUnderstanding the lifecycle of a module from initialization to shutdown is essential for development.\n\n```mermaid\nstateDiagram-v2\n    [*] --> Registration: init() calls RegisteFunc()\n    \n    Registration --> Initialization: CLI invokes GetModuleFunc()\n    \n    Initialization --> Configuration: mod.Init(ctx, logger, config)\n    Configuration --> BytecodeSelection: Detect versions/offsets\n    BytecodeSelection --> EBPFLoad: Load appropriate .o file\n    \n    EBPFLoad --> ProbeAttach: mod.Start()\n    ProbeAttach --> EventReading: mod.Run()\n    \n    EventReading --> EventLoop: perfEventReader/ringbufEventReader\n    EventLoop --> Decoding: mod.Decode(map, bytes)\n    Decoding --> Dispatching: mod.Dispatcher(event)\n    \n    Dispatching --> Processing: EventProcessor.Write()\n    Processing --> Output: eventCollector.Write()\n    \n    Output --> EventLoop: Continue\n    \n    EventLoop --> Cleanup: ctx.Done() or Signal\n    Cleanup --> Detach: mod.Close()\n    Detach --> [*]\n    \n    note right of Registration\n        user/module/probe_openssl.go:777-786\n        Factory function registration\n    end note\n    \n    note right of Configuration\n        user/module/probe_openssl.go:109-176\n        Parse config, setup state\n    end note\n    \n    note right of BytecodeSelection\n        user/module/probe_openssl.go:179-278\n        getSslBpfFile(), detectOpenssl()\n    end note\n    \n    note right of EventLoop\n        user/module/imodule.go:285-306\n        readEvents() dispatches readers\n    end note\n    \n    note right of Processing\n        pkg/event_processor/\n        Aggregation, filtering, formatting\n    end note\n```\n\n### Lifecycle Phase Details\n\n**1. Registration Phase**\n- Module factory function is registered via `RegisteFunc()` in `init()`\n- Example: [user/module/probe_openssl.go:777-786]()\n- Factory creates module instance implementing `IModule`\n\n**2. Initialization Phase** \n- `Init(ctx, logger, config, eventCollector)` called by CLI\n- Module parses configuration: [user/module/probe_openssl.go:109-176]()\n- Sets up internal state: connection maps, key caches, etc.\n- Determines BTF mode and kernel version\n\n**3. Bytecode Selection Phase**\n- Modules detect target library versions (e.g., OpenSSL 1.0.x-3.5.x)\n- Select appropriate eBPF bytecode: `_core.o` vs `_noncore.o` vs `_less52.o`\n- Example: [user/module/probe_openssl.go:179-278]()\n\n**4. Probe Attachment Phase**\n- `Start()` method attaches eBPF programs to hooks\n- Uses `ebpfmanager` library for lifecycle management\n- Configures constant editors for PID/UID filtering\n\n**5. Event Reading Phase**\n- `Run()` starts event readers for each eBPF map\n- Readers implemented in [user/module/imodule.go:308-350]() (perf) and [user/module/imodule.go:353-391]() (ringbuf)\n- Each event triggers `Decode()` → `Dispatcher()` pipeline\n\n**6. Event Processing Phase**\n- `EventProcessor` aggregates, filters, and formats events\n- Handles connection lifecycle and protocol parsing\n- Outputs to configured destinations (file, websocket, stdout)\n\n**7. Cleanup Phase**\n- `Close()` stops readers, detaches probes, closes files\n- Triggered by context cancellation or OS signal\n\n**Sources:** [user/module/imodule.go:110-171](), [user/module/imodule.go:236-262](), [user/module/probe_openssl.go:109-176](), [user/module/probe_openssl.go:280-350]()\n\n---\n\n## Development Workflow\n\nThe eCapture development workflow integrates local development, testing, and CI/CD automation.\n\n```mermaid\ngraph TB\n    subgraph \"Local Development\"\n        EDIT[\"Edit Code<br/>Go/C/eBPF\"]\n        COMPILE[\"make env && make\"]\n        TEST[\"make test-race<br/>or<br/>make e2e\"]\n        DEBUG[\"Run with -d flag<br/>Check logs\"]\n        \n        EDIT --> COMPILE\n        COMPILE --> TEST\n        TEST --> DEBUG\n        DEBUG -.->|\"iterate\"| EDIT\n    end\n    \n    subgraph \"Build Variants\"\n        CORE[\"make<br/>(CO-RE mode)\"]\n        NONCORE[\"make nocore<br/>(non-CO-RE)\"]\n        CROSS[\"CROSS_ARCH=arm64 make<br/>(cross-compile)\"]\n        ANDROID[\"ANDROID=1 CROSS_ARCH=arm64 make nocore\"]\n        \n        COMPILE --> CORE\n        COMPILE --> NONCORE\n        COMPILE --> CROSS\n        COMPILE --> ANDROID\n    end\n    \n    subgraph \"CI/CD Pipeline\"\n        PR[\"Pull Request\"]\n        CITEST[\"GitHub Actions<br/>go-c-cpp.yml\"]\n        LINT[\"golangci-lint\"]\n        MULTIARCH[\"Build x86_64 & arm64<br/>Build CO-RE & non-CO-RE\"]\n        RELEASE[\"Tag Push<br/>release.yml\"]\n        ARTIFACTS[\"Build Artifacts<br/>*.tar.gz, *.deb<br/>Docker images\"]\n        \n        PR --> CITEST\n        CITEST --> LINT\n        CITEST --> MULTIARCH\n        RELEASE --> ARTIFACTS\n    end\n    \n    subgraph \"Release Process\"\n        TAG[\"Create Tag<br/>v0.x.y\"]\n        BUILDRPM[\"make rpm<br/>(optional)\"]\n        BUILDDEB[\"make deb\"]\n        PUBLISH[\"make publish<br/>GitHub Release\"]\n        DOCKER[\"Docker Hub<br/>Multi-arch push\"]\n        \n        TAG --> BUILDDEB\n        TAG --> BUILDRPM\n        TAG --> DOCKER\n        BUILDDEB --> PUBLISH\n    end\n    \n    EDIT -.->|\"ready\"| PR\n    ARTIFACTS --> DOCKER\n```\n\n### Local Build Commands\n\n| Command | Purpose | Output |\n|---------|---------|--------|\n| `make env` | Display build environment variables | Configuration info |\n| `make` or `make all` | Build CO-RE + non-CO-RE bytecode and binary | `bin/ecapture` |\n| `make nocore` | Build non-CO-RE bytecode only | `bin/ecapture` (non-CO-RE) |\n| `make clean` | Remove build artifacts | Clean workspace |\n| `CROSS_ARCH=arm64 make` | Cross-compile for ARM64 | `bin/ecapture` (arm64) |\n| `DEBUG=1 make` | Build with debug symbols | Debug-enabled binary |\n| `make test-race` | Run tests with race detector | Test results |\n| `make e2e` | Run end-to-end tests | Integration test results |\n| `make format` | Format C code with clang-format | Formatted code |\n\n### CI/CD Automation\n\nThe project uses GitHub Actions for continuous integration:\n\n**Pull Request Checks** [.github/workflows/go-c-cpp.yml:1-128]()\n1. **Build on Ubuntu 22.04 x86_64**\n   - Install toolchain (clang-14, gcc-aarch64-linux-gnu)\n   - Build CO-RE mode\n   - Run golangci-lint\n   - Build non-CO-RE mode\n   - Cross-compile to arm64 (CO-RE and Android non-CO-RE)\n   - Run race detector tests\n\n2. **Build on Ubuntu 22.04 ARM64**\n   - Mirror of x86_64 workflow\n   - Cross-compile to x86_64\n\n**Release Automation** [.github/workflows/release.yml:1-129]()\n1. Trigger on tag push (`v*`)\n2. Build for amd64 and arm64\n3. Generate release notes from previous tag\n4. Create tar.gz archives and checksums\n5. Build multi-arch Docker images\n6. Publish to GitHub Releases and Docker Hub\n\n**Sources:** [.github/workflows/go-c-cpp.yml:1-128](), [.github/workflows/release.yml:1-129](), [Makefile:1-269]()\n\n---\n\n## Build System Architecture\n\nThe eCapture build system is sophisticated, handling multiple architectures, kernel versions, and compilation modes.\n\n```mermaid\ngraph TB\n    subgraph \"Makefile Structure\"\n        MAIN[\"Makefile<br/>(orchestration)\"]\n        VARS[\"variables.mk<br/>(detection & config)\"]\n        FUNCS[\"functions.mk<br/>(helpers)\"]\n        RELEASE[\"builder/Makefile.release<br/>(packaging)\"]\n        \n        MAIN --> VARS\n        MAIN --> FUNCS\n        RELEASE --> VARS\n        RELEASE --> FUNCS\n    end\n    \n    subgraph \"variables.mk - Environment Detection\"\n        HOST_ARCH[\"HOST_ARCH<br/>uname -m\"]\n        CROSS_ARCH[\"CROSS_ARCH<br/>from args\"]\n        TARGET_ARCH[\"TARGET_ARCH<br/>computed\"]\n        GOARCH[\"GOARCH<br/>(amd64/arm64)\"]\n        LINUX_ARCH[\"LINUX_ARCH<br/>(x86/arm64)\"]\n        CLANG_VER[\"CLANG_VERSION<br/>extracted\"]\n        GO_VER[\"GO_VERSION<br/>extracted\"]\n        \n        HOST_ARCH --> TARGET_ARCH\n        CROSS_ARCH --> TARGET_ARCH\n        TARGET_ARCH --> GOARCH\n        TARGET_ARCH --> LINUX_ARCH\n    end\n    \n    subgraph \"Compilation Paths\"\n        KERN_C[\"kern/*.c<br/>eBPF programs\"]\n        \n        CORE_COMPILE[\"clang -target bpfel<br/>-g -O2 -D__TARGET_ARCH_XXX<br/>→ *_core.o\"]\n        \n        NONCORE_COMPILE[\"clang + llc<br/>-I kernel-headers<br/>→ *_noncore.o\"]\n        \n        LESS52[\"KERNEL_LESS_5_2<br/>variant compilation<br/>→ *_less52.o\"]\n        \n        KERN_C --> CORE_COMPILE\n        KERN_C --> NONCORE_COMPILE\n        CORE_COMPILE --> LESS52\n        NONCORE_COMPILE --> LESS52\n    end\n    \n    subgraph \"Asset Embedding\"\n        BYTECODE[\"user/bytecode/*.o<br/>27+ variants\"]\n        GOBINDATA[\"go-bindata<br/>embed bytecode\"]\n        ASSETS[\"assets/ebpf_probe.go<br/>Asset() func\"]\n        \n        BYTECODE --> GOBINDATA\n        GOBINDATA --> ASSETS\n    end\n    \n    subgraph \"Go Compilation\"\n        LIBPCAP[\"lib/libpcap<br/>static build\"]\n        GOSRC[\"Go source<br/>user/*, cli/*, pkg/*\"]\n        GOBUILD[\"CGO_ENABLED=1<br/>static linking<br/>version injection\"]\n        BINARY[\"bin/ecapture<br/>self-contained\"]\n        \n        ASSETS --> GOBUILD\n        LIBPCAP --> GOBUILD\n        GOSRC --> GOBUILD\n        GOBUILD --> BINARY\n    end\n    \n    subgraph \"Release Artifacts\"\n        TARBALL[\"*.tar.gz<br/>platform archives\"]\n        DEB[\"*.deb<br/>Debian packages\"]\n        CHECKSUM[\"checksum-*.txt<br/>SHA256 sums\"]\n        \n        BINARY --> TARBALL\n        BINARY --> DEB\n        TARBALL --> CHECKSUM\n        DEB --> CHECKSUM\n    end\n```\n\n### Key Build Concepts\n\n**1. Dual Compilation Mode**\n- **CO-RE (Compile Once - Run Everywhere)**: Uses BTF, works on any kernel with BTF enabled\n  - Compiled with `clang -target bpfel` to `*_core.o`\n  - Portable across kernel versions\n- **Non-CO-RE**: Requires kernel headers, specific to kernel version\n  - Compiled with kernel headers to `*_noncore.o`\n  - Necessary for kernels without BTF or Android\n\n**2. Kernel Version Variants**\n- Kernel < 5.2 has different eBPF helpers\n- Separate `*_less52.o` files compiled with `-DKERNEL_LESS_5_2`\n- Runtime selection based on `kernel.HostVersion()`\n\n**3. Cross-Compilation Support**\n- `CROSS_ARCH` variable triggers cross-compilation\n- Requires cross-toolchain: `gcc-aarch64-linux-gnu` or `gcc-x86-64-linux-gnu`\n- Kernel headers for target architecture: `/usr/src/linux-source-*/arch/{x86,arm64}`\n\n**4. Asset Embedding**\n- All eBPF bytecode embedded into Go binary via `go-bindata`\n- No runtime dependency on `.o` files\n- Runtime selects appropriate bytecode from `assets.Asset()`\n\n**5. Version Injection**\n- Git version injected via ldflags: [functions.mk:47-54]()\n- Format: `os_arch:vX.Y.Z-date-commit:kernel_version`\n- Bytecode mode injected: `ByteCodeFiles=core|noncore|all`\n\n**Sources:** [Makefile:1-269](), [variables.mk:1-200](), [functions.mk:1-76](), [builder/Makefile.release:1-151]()\n\n---\n\n## Key Code Patterns for Developers\n\n### Pattern 1: Module Registration\n\nAll modules register themselves in `init()` using a factory pattern:\n\n```go\n// user/module/probe_openssl.go:777-786\nfunc init() {\n    RegisteFunc(NewOpenSSLProbe)\n}\n\nfunc NewOpenSSLProbe() IModule {\n    mod := &MOpenSSLProbe{}\n    mod.name = ModuleNameOpenssl\n    mod.mType = ProbeTypeUprobe\n    return mod\n}\n```\n\nThe CLI retrieves modules via `GetModuleFunc(modName)`.\n\n### Pattern 2: eBPF Bytecode Selection\n\nModules implement version detection and bytecode selection:\n\n```go\n// 1. Detect library version\nverString, err := m.detectOpenssl(soPath)\n\n// 2. Map version to bytecode file\nbpfFile, found := m.sslVersionBpfMap[verString]\n\n// 3. Apply CO-RE/non-CO-RE suffix\nfilename := m.geteBPFName(\"user/bytecode/\" + bpfFile)\n// Result: user/bytecode/openssl_3_0_kern_core.o\n\n// 4. Load from embedded assets\nbyteBuf, err := assets.Asset(filename)\n```\n\nReference: [user/module/probe_openssl.go:179-278](), [user/module/imodule.go:191-214]()\n\n### Pattern 3: Event Dispatching\n\nEvents flow through a type-switching dispatcher:\n\n```go\n// user/module/probe_openssl.go:733-754\nfunc (m *MOpenSSLProbe) Dispatcher(eventStruct event.IEventStruct) {\n    switch ev := eventStruct.(type) {\n    case *event.ConnDataEvent:\n        if ev.IsDestroy == 0 {\n            m.AddConn(ev.Pid, ev.Fd, ev.Tuple, ev.Sock)\n        } else {\n            m.DelConn(ev.Sock)\n        }\n    case *event.MasterSecretEvent:\n        m.saveMasterSecret(ev)\n    case *event.TcSkbEvent:\n        m.dumpTcSkb(ev)\n    case *event.SSLDataEvent:\n        m.dumpSslData(ev)\n    }\n}\n```\n\n### Pattern 4: eBPF Manager Setup\n\nModules use `ebpfmanager` for probe lifecycle:\n\n```go\nm.bpfManager = &manager.Manager{\n    Probes: []*manager.Probe{\n        {Section: \"uprobe/SSL_write\", ElfFuncName: \"SSL_write\"},\n        {Section: \"uretprobe/SSL_write\", ElfFuncName: \"SSL_write\"},\n        // ... more probes\n    },\n    Maps: []*manager.Map{\n        {Name: \"events\"},\n        {Name: \"mastersecret_events\"},\n    },\n}\n\nm.bpfManagerOptions = manager.Options{\n    ConstantEditors: m.constantEditor(), // PID/UID filtering\n}\n\n// Load and start\nbyteBuf, _ := assets.Asset(bpfFileName)\nm.bpfManager.InitWithOptions(bytes.NewReader(byteBuf), m.bpfManagerOptions)\nm.bpfManager.Start()\n```\n\n**Sources:** [user/module/probe_openssl.go:733-754](), [user/module/imodule.go:191-214]()\n\n---\n\n## Testing and Debugging\n\n### Unit Tests\n\nRun unit tests with race detection:\n```bash\nmake test-race\n```\n\nThis executes `go test -v -race ./...` with proper CGO flags for libpcap.\n\n### End-to-End Tests\n\nRun module-specific E2E tests:\n```bash\nmake e2e-tls      # TLS module tests\nmake e2e-gnutls   # GnuTLS module tests\nmake e2e-gotls    # GoTLS module tests\nmake e2e          # All E2E tests\n```\n\nReference: [Makefile:240-268]()\n\n### Debug Mode\n\nEnable debug logging:\n```bash\n./ecapture tls -d          # Debug to stdout\n./ecapture tls -d -l /tmp/debug.log  # Debug to file\n```\n\nDebug mode enables:\n- Verbose eBPF verifier output\n- Connection tracking logs\n- Event decode details\n- Processor state information\n\n### Common Development Issues\n\n| Issue | Cause | Solution |\n|-------|-------|----------|\n| eBPF verifier errors | Bytecode incompatible with kernel | Check kernel version, try `-b 2` for non-CO-RE |\n| Module not found | Factory not registered | Add `init()` with `RegisteFunc()` call |\n| Events not captured | Wrong hooks/offsets | Verify library version detection logic |\n| Compilation errors | Missing headers | Run `make env` to check KERN_SRC_PATH |\n| Cross-compile fails | Missing toolchain | Install `gcc-aarch64-linux-gnu` or `gcc-x86-64-linux-gnu` |\n\n**Sources:** [Makefile:240-268](), [user/module/imodule.go:110-171]()\n\n---\n\n## Next Steps for Developers\n\nFor detailed information on specific development tasks:\n\n- **[Build System](#5.1)**: Deep dive into Makefile structure, variables, cross-compilation, and asset embedding\n- **[eBPF Program Development](#5.2)**: Writing eBPF C programs, using helpers, map operations, and debugging\n- **[Adding New Modules](#5.3)**: Step-by-step guide to creating a new capture module with complete lifecycle implementation\n- **[Event Processing and Parsers](#5.4)**: Implementing event structures, protocol parsers, and output formatting\n\nAdditional resources:\n- [Architecture](#2): High-level system architecture and component interaction\n- [Command Line Interface](#1.2): CLI structure and command patterns\n- [Configuration System](#2.3): IConfig implementation and runtime updates\n\n**Sources:** [cli/cmd/root.go:80-403](), [user/module/imodule.go:47-480](), [user/config/iconfig.go:1-212](), [Makefile:1-269]()"
          },
          {
            "page_plan": {
              "id": "5.1",
              "title": "Build System"
            },
            "content": "# Build System\n\n<details>\n<summary>Relevant source files</summary>\n\nThe following files were used as context for generating this wiki page:\n\n- [.github/workflows/codeql-analysis.yml](.github/workflows/codeql-analysis.yml)\n- [.github/workflows/go-c-cpp.yml](.github/workflows/go-c-cpp.yml)\n- [.github/workflows/release.yml](.github/workflows/release.yml)\n- [Makefile](Makefile)\n- [builder/Dockerfile](builder/Dockerfile)\n- [builder/Makefile.release](builder/Makefile.release)\n- [builder/init_env.sh](builder/init_env.sh)\n- [functions.mk](functions.mk)\n- [go.mod](go.mod)\n- [go.sum](go.sum)\n\n</details>\n\n\n\nThe eCapture build system is a sophisticated Makefile-based build orchestration that implements dual eBPF compilation paths (CO-RE and non-CO-RE), cross-architecture compilation, asset embedding, and multi-format release artifact generation. This page documents the build configuration, compilation pipelines, dependency management, and release processes.\n\nFor information about developing new eBPF programs, see [eBPF Program Development](#5.2). For module development, see [Adding New Modules](#5.3).\n\n## Build Configuration Architecture\n\nThe build system is structured across three interconnected Makefiles that manage configuration, orchestration, and release processes.\n\n```mermaid\ngraph TB\n    subgraph \"Build Configuration Files\"\n        VARS[\"variables.mk<br/>Configuration Variables\"]\n        MAIN[\"Makefile<br/>Build Orchestration\"]\n        FUNCS[\"functions.mk<br/>Helper Functions\"]\n        RELEASE[\"builder/Makefile.release<br/>Release Tasks\"]\n    end\n    \n    subgraph \"Configuration Variables - variables.mk\"\n        HOST[\"HOST_ARCH<br/>UNAME_R<br/>KERN_RELEASE\"]\n        CROSS[\"CROSS_ARCH<br/>TARGET_ARCH<br/>GOARCH<br/>LINUX_ARCH\"]\n        PATHS[\"LINUX_SOURCE_PATH<br/>KERN_BUILD_PATH<br/>KERN_SRC_PATH\"]\n        FLAGS[\"EXTRA_CFLAGS<br/>EXTRA_CFLAGS_NOCORE<br/>BPFHEADER\"]\n        TARGETS[\"KERN_OBJECTS<br/>KERN_OBJECTS_NOCORE<br/>TARGET_LIBPCAP\"]\n    end\n    \n    subgraph \"Helper Functions - functions.mk\"\n        CHECK[\".checkver_*<br/>Version Validation\"]\n        ALLOW[\"allow-override<br/>Variable Override\"]\n        GOBUILD[\"gobuild<br/>Go Build Function\"]\n        RELEASE_TAR[\"release_tar<br/>Archive Creation\"]\n    end\n    \n    subgraph \"Build Targets - Makefile\"\n        ALL[\"all<br/>Full Build\"]\n        NOCORE[\"nocore<br/>Non-CO-RE Only\"]\n        EBPF[\"ebpf<br/>CO-RE Bytecode\"]\n        EBPF_NC[\"ebpf_noncore<br/>Non-CO-RE Bytecode\"]\n        ASSETS[\"assets<br/>Embed All\"]\n        ASSETS_NC[\"assets_noncore<br/>Embed Non-CO-RE\"]\n        BUILD[\"build<br/>Go Binary\"]\n    end\n    \n    VARS --> MAIN\n    FUNCS --> MAIN\n    MAIN --> RELEASE\n    \n    HOST --> MAIN\n    CROSS --> MAIN\n    PATHS --> MAIN\n    FLAGS --> MAIN\n    TARGETS --> MAIN\n    \n    CHECK --> MAIN\n    ALLOW --> MAIN\n    GOBUILD --> MAIN\n    RELEASE_TAR --> RELEASE\n    \n    ALL --> EBPF\n    ALL --> EBPF_NC\n    ALL --> ASSETS\n    ALL --> BUILD\n    \n    NOCORE --> EBPF_NC\n    NOCORE --> ASSETS_NC\n    NOCORE --> BUILD\n```\n\n**Sources:** [Makefile:1-2](), [functions.mk:1-76](), [builder/Makefile.release:1-3]()\n\n### Configuration Variables\n\nThe `variables.mk` file (not shown but referenced in [Makefile:1]()) defines critical build configuration:\n\n| Variable Category | Key Variables | Purpose |\n|------------------|---------------|---------|\n| **Architecture Detection** | `HOST_ARCH`, `UNAME_R`, `CLANG_VERSION`, `GO_VERSION` | Detect host environment |\n| **Cross-Compilation** | `CROSS_ARCH`, `TARGET_ARCH`, `GOARCH`, `LINUX_ARCH`, `LIBPCAP_ARCH` | Target architecture configuration |\n| **Kernel Paths** | `LINUX_SOURCE_PATH`, `KERN_BUILD_PATH`, `KERN_SRC_PATH` | Kernel header locations |\n| **Build Flags** | `EXTRA_CFLAGS`, `EXTRA_CFLAGS_NOCORE`, `BPFHEADER` | Compiler flags for eBPF |\n| **Versioning** | `VERSION_NUM`, `LAST_GIT_TAG`, `BPF_NOCORE_TAG`, `PACKAGE_VERSION` | Version information |\n| **Tools** | `CMD_CLANG`, `CMD_LLC`, `CMD_GO`, `CMD_CC_PREFIX` | Command paths |\n\nThe build system prints all configuration with `make env` ([Makefile:19-63]()).\n\n**Sources:** [Makefile:19-63](), [.github/workflows/go-c-cpp.yml:16-33]()\n\n### Helper Functions\n\nThe [functions.mk:1-76]() file provides reusable build functions:\n\n#### Version Checking Functions\n\n```makefile\n.checkver_$(CMD_CLANG)  # Validates clang >= 9\n.checkver_$(CMD_GO)      # Validates go >= 1.24\n.checkver_$(CMD_BPFTOOL) # Validates bpftool availability\n```\n\nThese functions ([functions.mk:13-40]()) create marker files to avoid repeated checks and fail the build if requirements aren't met.\n\n#### Variable Override Function\n\nThe `allow-override` function ([functions.mk:41-45]()) enables conditional variable defaults:\n\n```makefile\n$(call allow-override,VERSION_FLAG,$(UNAME_R))\n```\n\nThis pattern allows command-line or environment variables to override defaults.\n\n#### Go Build Function\n\nThe `gobuild` function ([functions.mk:47-54]()) encapsulates the Go build command with static linking:\n\n- Enables CGO with static libpcap linking\n- Sets build mode to PIE (Position Independent Executable)\n- Injects version information via `-ldflags`\n- Injects bytecode file list via `ByteCodeFiles` variable\n- Performs static linking with `-extldflags -static`\n\n#### Release Archive Function\n\nThe `release_tar` function ([functions.mk:62-76]()) creates release archives:\n\n```makefile\n$(call release_tar,linux,)        # Linux release\n$(call release_tar,android,nocore) # Android release (non-CO-RE only)\n```\n\n**Sources:** [functions.mk:1-76]()\n\n## eBPF Compilation Pipeline\n\nThe build system implements two parallel eBPF compilation paths: CO-RE (Compile Once - Run Everywhere) for modern kernels with BTF, and non-CO-RE for older kernels requiring specific headers.\n\n```mermaid\ngraph TB\n    subgraph \"Source eBPF Programs\"\n        KERN_C[\"kern/*.c<br/>27+ eBPF programs<br/>openssl.c, gotls.c, etc.\"]\n    end\n    \n    subgraph \"CO-RE Compilation Path\"\n        CLANG_CORE[\"clang -target bpfel<br/>-D__TARGET_ARCH_*<br/>BTF-enabled\"]\n        \n        CORE_OUT[\"user/bytecode/*_core.o<br/>Portable bytecode\"]\n        \n        LESS52_CORE[\"user/bytecode/*_core_less52.o<br/>Kernel < 5.2 variant\"]\n    end\n    \n    subgraph \"Non-CO-RE Compilation Path\"\n        PREPARE[\"make prepare<br/>Generate kernel headers<br/>CROSS_COMPILE support\"]\n        \n        CLANG_NC[\"clang + llc<br/>-I KERN_SRC_PATH<br/>-I KERN_BUILD_PATH<br/>Kernel-specific headers\"]\n        \n        NC_OUT[\"user/bytecode/*_noncore.o<br/>Kernel-specific bytecode\"]\n        \n        LESS52_NC[\"user/bytecode/*_noncore_less52.o<br/>Kernel < 5.2 variant\"]\n    end\n    \n    subgraph \"Asset Embedding\"\n        BINDATA[\"go-bindata<br/>Embed all .o files\"]\n        \n        PROBE_GO[\"assets/ebpf_probe.go<br/>Embedded bytecode\"]\n    end\n    \n    subgraph \"Compilation Triggers\"\n        ALL_TARGET[\"make all<br/>Include both paths\"]\n        NOCORE_TARGET[\"make nocore<br/>Non-CO-RE only\"]\n    end\n    \n    KERN_C --> CLANG_CORE\n    KERN_C --> PREPARE\n    \n    CLANG_CORE --> CORE_OUT\n    CLANG_CORE --> LESS52_CORE\n    \n    PREPARE --> CLANG_NC\n    CLANG_NC --> NC_OUT\n    CLANG_NC --> LESS52_NC\n    \n    CORE_OUT --> BINDATA\n    LESS52_CORE --> BINDATA\n    NC_OUT --> BINDATA\n    LESS52_NC --> BINDATA\n    \n    BINDATA --> PROBE_GO\n    \n    ALL_TARGET --> CLANG_CORE\n    ALL_TARGET --> CLANG_NC\n    NOCORE_TARGET --> CLANG_NC\n```\n\n**Sources:** [Makefile:117-183](), [Makefile:186-195]()\n\n### CO-RE Compilation\n\nCO-RE compilation ([Makefile:117-134]()) generates portable eBPF bytecode using BTF (BPF Type Format):\n\n**Compilation Command:**\n```makefile\n$(CMD_CLANG) -D__TARGET_ARCH_$(LINUX_ARCH) \\\n    $(EXTRA_CFLAGS) \\\n    $(BPFHEADER) \\\n    -target bpfel -c $< -o $(OUTPUT) \\\n    -fno-ident -fdebug-compilation-dir . -g \\\n    -D__BPF_TARGET_MISSING=\"...\" \\\n    -MD -MP\n```\n\n**Key aspects:**\n\n1. **Target Architecture:** `-D__TARGET_ARCH_x86` or `-D__TARGET_ARCH_arm64` ([Makefile:122]())\n2. **BTF-enabled:** Uses `-target bpfel` for BPF ELF format with CO-RE relocations\n3. **Debug Info:** Includes `-g` for BTF generation and `-gdwarf-4` (via `EXTRA_CFLAGS`)\n4. **Dependency Tracking:** `-MD -MP` generates `.d` files for incremental builds\n\n**Outputs:**\n- `user/bytecode/*_core.o` - Standard CO-RE bytecode\n- `user/bytecode/*_core_less52.o` - Variant for kernels < 5.2 with `-DKERNEL_LESS_5_2` ([Makefile:131]())\n\nThe kernel < 5.2 variant is necessary because early kernels lack certain eBPF features (e.g., bounded loops, specific helper functions).\n\n**Sources:** [Makefile:117-134](), [.github/workflows/go-c-cpp.yml:38-42]()\n\n### Non-CO-RE Compilation\n\nNon-CO-RE compilation ([Makefile:146-183]()) generates kernel-specific bytecode using explicit header includes:\n\n**Preparation Step:**\n```makefile\nmake prepare  # Generates kernel headers if needed\n```\n\nThis step ([Makefile:98-104]()) invokes kernel header generation for cross-compilation scenarios:\n```bash\ncd $(LINUX_SOURCE_PATH) && $(KERNEL_HEADER_GEN)\n```\n\n**Compilation Command:**\n```makefile\n$(CMD_CLANG) \\\n    $(EXTRA_CFLAGS_NOCORE) \\\n    $(BPFHEADER) \\\n    -I $(KERN_SRC_PATH)/arch/$(LINUX_ARCH)/include \\\n    -I $(KERN_BUILD_PATH)/arch/$(LINUX_ARCH)/include/generated \\\n    -I $(KERN_SRC_PATH)/include \\\n    [... 8 include paths total ...] \\\n    -c $< -o - | $(CMD_LLC) \\\n    -march=bpf -filetype=obj -o $(OUTPUT)\n```\n\n**Key aspects:**\n\n1. **Kernel Headers:** Uses 8 include paths for kernel headers ([Makefile:154-161]())\n2. **Two-Stage Compilation:** \n   - Stage 1: `clang` compiles to LLVM bitcode (`-o -`)\n   - Stage 2: `llc` converts to BPF object file\n3. **Architecture-Specific:** Includes `arch/$(LINUX_ARCH)/include` headers\n4. **Cross-Compilation:** Supports `CROSS_COMPILE` prefix for cross-arch builds\n\n**Outputs:**\n- `user/bytecode/*_noncore.o` - Kernel-specific bytecode\n- `user/bytecode/*_noncore_less52.o` - Kernel < 5.2 variant ([Makefile:178]())\n\n**Sources:** [Makefile:98-104](), [Makefile:146-183]()\n\n### Kernel < 5.2 Support\n\nBoth compilation paths generate variants for kernels < 5.2 using the `-DKERNEL_LESS_5_2` preprocessor flag. This enables conditional compilation in the C code:\n\n```c\n#ifdef KERNEL_LESS_5_2\n    // Use older eBPF features\n#else\n    // Use modern eBPF features\n#endif\n```\n\nThese variants have a `_less52` suffix in their filenames ([Makefile:132](), [Makefile:183]()).\n\n**Sources:** [Makefile:131-134](), [Makefile:178-183]()\n\n## Asset Embedding System\n\nAfter eBPF compilation, all bytecode files are embedded into the Go binary using `go-bindata`.\n\n```mermaid\ngraph LR\n    subgraph \"Bytecode Files\"\n        CORE[\"*_core.o\"]\n        CORE_L52[\"*_core_less52.o\"]\n        NONCORE[\"*_noncore.o\"]\n        NONCORE_L52[\"*_noncore_less52.o\"]\n    end\n    \n    subgraph \"Embedding Process\"\n        BINDATA[\"go-bindata<br/>github.com/shuLhan/go-bindata\"]\n        IGNORE[\"IGNORE_LESS52 flag<br/>Optional filtering\"]\n    end\n    \n    subgraph \"Generated Asset\"\n        PROBE_GO[\"assets/ebpf_probe.go<br/>Asset() function<br/>AssetNames() function<br/>Binary data embedded\"]\n    end\n    \n    subgraph \"Runtime Usage\"\n        MODULE[\"Module.Init()<br/>Load bytecode by name\"]\n        LOADER[\"eBPF Manager<br/>Load into kernel\"]\n    end\n    \n    CORE --> BINDATA\n    CORE_L52 --> BINDATA\n    NONCORE --> BINDATA\n    NONCORE_L52 --> BINDATA\n    \n    IGNORE -.-> BINDATA\n    \n    BINDATA --> PROBE_GO\n    PROBE_GO --> MODULE\n    MODULE --> LOADER\n```\n\n**Sources:** [Makefile:186-195]()\n\n### Asset Generation\n\nThe `assets` target ([Makefile:186-188]()) embeds all bytecode:\n\n```makefile\n.PHONY: assets\nassets: .checkver_$(CMD_GO) ebpf ebpf_noncore\n\t$(CMD_GO) run github.com/shuLhan/go-bindata/cmd/go-bindata \\\n\t    $(IGNORE_LESS52) -pkg assets -o \"assets/ebpf_probe.go\" \\\n\t    $(wildcard ./user/bytecode/*.o)\n```\n\nThe `assets_noncore` target ([Makefile:191-195]()) embeds only non-CO-RE bytecode for specialized builds (e.g., Android).\n\n**Key aspects:**\n\n1. **Package Name:** Generated in `assets` package\n2. **Output File:** `assets/ebpf_probe.go`\n3. **Input Files:** All `.o` files in `user/bytecode/`\n4. **Optional Filtering:** `IGNORE_LESS52` can exclude kernel < 5.2 variants\n\n### Generated Asset Interface\n\nThe `go-bindata` tool generates Go code with functions:\n\n```go\n// Asset loads and returns the asset for the given name\nfunc Asset(name string) ([]byte, error)\n\n// AssetNames returns the names of all embedded assets\nfunc AssetNames() []string\n\n// AssetInfo returns metadata about an asset\nfunc AssetInfo(name string) (os.FileInfo, error)\n```\n\nAt runtime, modules load their bytecode by filename:\n\n```go\nbytecode, err := assets.Asset(\"user/bytecode/openssl_kern_core.o\")\n```\n\nThe build system injects the list of available bytecode files into the binary via the `ByteCodeFiles` build variable ([functions.mk:52]()):\n\n```makefile\n-X 'github.com/gojue/ecapture/cli/cmd.ByteCodeFiles=$(BYTECODE_FILES)'\n```\n\nThis allows runtime selection between CO-RE and non-CO-RE bytecode.\n\n**Sources:** [Makefile:186-195](), [go.mod:12](), [functions.mk:52]()\n\n## Go Binary Compilation\n\nThe Go binary compilation integrates static linking with embedded assets.\n\n```mermaid\ngraph TB\n    subgraph \"Dependencies\"\n        LIBPCAP[\"lib/libpcap/<br/>Static library build<br/>Configure + Make\"]\n        ASSETS_GO[\"assets/ebpf_probe.go<br/>Embedded bytecode\"]\n        GO_SRC[\"Go Source Code<br/>cli/cmd/*.go<br/>user/module/*.go<br/>pkg/**/*.go\"]\n    end\n    \n    subgraph \"Build Configuration\"\n        CGO_FLAGS[\"CGO_ENABLED=1<br/>CGO_CFLAGS=-I libpcap/<br/>CGO_LDFLAGS=-L libpcap/ -lpcap\"]\n        GO_FLAGS[\"GOOS=linux<br/>GOARCH=amd64|arm64<br/>CC=gcc|cross-gcc\"]\n        BUILD_FLAGS[\"-trimpath<br/>-buildmode=pie<br/>-mod=readonly<br/>-tags netgo\"]\n        LD_FLAGS[\"-w -s<br/>-X GitVersion<br/>-X ByteCodeFiles<br/>-linkmode=external<br/>-extldflags -static\"]\n    end\n    \n    subgraph \"Output\"\n        BINARY[\"bin/ecapture<br/>Static binary<br/>Self-contained\"]\n    end\n    \n    LIBPCAP --> CGO_FLAGS\n    ASSETS_GO --> GO_SRC\n    GO_SRC --> BUILD_FLAGS\n    CGO_FLAGS --> BINARY\n    GO_FLAGS --> BINARY\n    BUILD_FLAGS --> BINARY\n    LD_FLAGS --> BINARY\n```\n\n**Sources:** [Makefile:199-208](), [Makefile:211-225](), [functions.mk:47-54]()\n\n### libpcap Static Build\n\nBefore Go compilation, the build system compiles a static `libpcap` library ([Makefile:199-208]()):\n\n```makefile\n$(TARGET_LIBPCAP):\n\ttest -f ./lib/libpcap/configure || git submodule update --init\n\tcd lib/libpcap && \\\n\t    CC=$(CMD_CC_PREFIX)$(CMD_CC) AR=$(CMD_AR_PREFIX)$(CMD_AR) \\\n\t    CFLAGS=\"-O2 -g -gdwarf-4 -static -Wno-unused-result\" \\\n\t    ./configure --disable-rdma --disable-shared --disable-usb \\\n\t        --disable-netmap --disable-bluetooth --disable-dbus \\\n\t        --without-libnl --without-dpdk --without-dag \\\n\t        --without-septel --without-snf --without-gcc \\\n\t        --with-pcap=linux --without-turbocap \\\n\t        --host=$(LIBPCAP_ARCH) && \\\n\t    CC=$(CMD_CC_PREFIX)$(CMD_CC) AR=$(CMD_AR_PREFIX)$(CMD_AR) make\n```\n\n**Configuration highlights:**\n\n- **Static build:** `--disable-shared` and `-static` in CFLAGS\n- **Minimal features:** Disables RDMA, USB, Bluetooth, DBus\n- **Linux-only:** `--with-pcap=linux`\n- **Cross-compilation:** Uses `$(CMD_CC_PREFIX)` and `--host=$(LIBPCAP_ARCH)`\n- **Debug info:** `-g -gdwarf-4` for debugging\n\nThe static `libpcap.a` is linked into the final binary.\n\n**Sources:** [Makefile:199-208]()\n\n### Go Build Command\n\nThe `gobuild` function ([functions.mk:47-54]()) performs the Go compilation:\n\n```makefile\nCGO_ENABLED=1 \\\nCGO_CFLAGS='-O2 -g -gdwarf-4 -I$(CURDIR)/lib/libpcap/' \\\nCGO_LDFLAGS='-O2 -g -L$(CURDIR)/lib/libpcap/ -lpcap -static' \\\nGOOS=linux GOARCH=$(GOARCH) CC=$(CMD_CC_PREFIX)$(CMD_CC) \\\n$(CMD_GO) build -trimpath -buildmode=pie -mod=readonly \\\n    -tags '$(TARGET_TAG),netgo' \\\n    -ldflags \"-w -s \\\n        -X 'github.com/gojue/ecapture/cli/cmd.GitVersion=$(TARGET_TAG)_$(GOARCH):$(VERSION_NUM):$(VERSION_FLAG)' \\\n        -X 'github.com/gojue/ecapture/cli/cmd.ByteCodeFiles=$(BYTECODE_FILES)' \\\n        -linkmode=external -extldflags -static\" \\\n    -o $(OUT_BIN)\n```\n\n**Build flags explained:**\n\n| Flag | Purpose |\n|------|---------|\n| `CGO_ENABLED=1` | Enable CGO for libpcap integration |\n| `CGO_CFLAGS` | Include libpcap headers |\n| `CGO_LDFLAGS` | Link static libpcap |\n| `-trimpath` | Remove build paths for reproducibility |\n| `-buildmode=pie` | Position Independent Executable |\n| `-mod=readonly` | Fail if `go.mod` needs updates |\n| `-tags netgo` | Use pure Go network stack (backup) |\n| `-w -s` | Strip debugging symbols |\n| `-X` | Inject version and bytecode list |\n| `-linkmode=external` | Use external C linker |\n| `-extldflags -static` | Fully static binary |\n\n**Version injection:**\n\nThe build injects two key variables:\n1. `GitVersion` - Format: `{TAG}_{ARCH}:{VERSION_NUM}:{VERSION_FLAG}`\n2. `ByteCodeFiles` - List of bytecode types (e.g., \"core\", \"noncore\")\n\nThese are accessible at runtime via `cli/cmd` package variables.\n\n**Sources:** [functions.mk:47-54]()\n\n### Build Targets\n\n| Target | eBPF Bytecode | Assets | Description |\n|--------|---------------|--------|-------------|\n| `make all` | CO-RE + non-CO-RE | All | Full build with both bytecode types |\n| `make nocore` | non-CO-RE only | Non-CO-RE | Kernel-specific build |\n| `make build` | (uses existing) | All | Go binary only |\n| `make build_noncore` | (uses existing) | Non-CO-RE | Non-CO-RE Go binary |\n\nThe `all` target ([Makefile:6]()) is the default and produces a binary containing both CO-RE and non-CO-RE bytecode, allowing runtime selection.\n\nThe `nocore` target ([Makefile:10]()) produces a smaller binary with only kernel-specific bytecode, useful for resource-constrained environments or Android.\n\n**Sources:** [Makefile:4-14](), [Makefile:211-225]()\n\n## Cross-Compilation Architecture\n\neCapture supports bidirectional cross-compilation between x86_64 and aarch64 architectures.\n\n```mermaid\ngraph TB\n    subgraph \"Host Detection\"\n        UNAME[\"uname -m<br/>x86_64 or aarch64\"]\n        HOST_ARCH[\"HOST_ARCH variable\"]\n    end\n    \n    subgraph \"Cross-Compilation Configuration\"\n        CROSS_VAR[\"CROSS_ARCH=arm64|amd64<br/>Command-line variable\"]\n        \n        MAPPINGS[\"Architecture Mappings:<br/>arm64 -> aarch64, arm, aarch64-linux-gnu<br/>amd64 -> x86_64, x86, x86_64-linux-gnu\"]\n        \n        TARGET_ARCH[\"TARGET_ARCH<br/>GOARCH<br/>LINUX_ARCH<br/>LIBPCAP_ARCH\"]\n    end\n    \n    subgraph \"Cross-Compilation Tools\"\n        GCC_CROSS[\"Cross GCC:<br/>x86_64: gcc-aarch64-linux-gnu<br/>aarch64: gcc-x86-64-linux-gnu\"]\n        \n        KERN_HEADERS[\"Kernel Headers:<br/>KERN_SRC_PATH/arch/$(LINUX_ARCH)<br/>Cross-prepared headers\"]\n        \n        CC_PREFIX[\"CMD_CC_PREFIX<br/>aarch64-linux-gnu-<br/>x86_64-linux-gnu-\"]\n    end\n    \n    subgraph \"Build Process\"\n        EBPF_CROSS[\"eBPF Cross-Compilation:<br/>-D__TARGET_ARCH_arm64|x86<br/>arch-specific headers\"]\n        \n        LIBPCAP_CROSS[\"libpcap Cross-Build:<br/>CC=$(CMD_CC_PREFIX)gcc<br/>--host=$(LIBPCAP_ARCH)\"]\n        \n        GO_CROSS[\"Go Cross-Build:<br/>GOARCH=arm64|amd64<br/>CC=$(CMD_CC_PREFIX)gcc\"]\n    end\n    \n    subgraph \"Outputs\"\n        X86_BIN[\"bin/ecapture<br/>x86_64 binary\"]\n        ARM_BIN[\"bin/ecapture<br/>aarch64 binary\"]\n    end\n    \n    UNAME --> HOST_ARCH\n    CROSS_VAR --> MAPPINGS\n    HOST_ARCH --> MAPPINGS\n    MAPPINGS --> TARGET_ARCH\n    \n    TARGET_ARCH --> GCC_CROSS\n    TARGET_ARCH --> KERN_HEADERS\n    TARGET_ARCH --> CC_PREFIX\n    \n    GCC_CROSS --> EBPF_CROSS\n    KERN_HEADERS --> EBPF_CROSS\n    CC_PREFIX --> LIBPCAP_CROSS\n    CC_PREFIX --> GO_CROSS\n    \n    EBPF_CROSS --> X86_BIN\n    EBPF_CROSS --> ARM_BIN\n    LIBPCAP_CROSS --> X86_BIN\n    LIBPCAP_CROSS --> ARM_BIN\n    GO_CROSS --> X86_BIN\n    GO_CROSS --> ARM_BIN\n```\n\n**Sources:** [.github/workflows/go-c-cpp.yml:56-65](), [.github/workflows/release.yml:93-97](), [builder/init_env.sh:43-61]()\n\n### Cross-Compilation Variables\n\nCross-compilation is triggered by setting `CROSS_ARCH`:\n\n```bash\nCROSS_ARCH=arm64 make    # Build arm64 on x86_64 host\nCROSS_ARCH=amd64 make    # Build amd64 on aarch64 host\n```\n\nThe build system maps `CROSS_ARCH` to multiple architecture-specific variables:\n\n| Variable | arm64 Value | amd64 Value | Purpose |\n|----------|-------------|-------------|---------|\n| `GOARCH` | `arm64` | `amd64` | Go architecture target |\n| `LINUX_ARCH` | `arm64` | `x86` | Linux kernel architecture name |\n| `TARGET_ARCH` | `aarch64` | `x86_64` | GCC target architecture |\n| `LIBPCAP_ARCH` | `aarch64-linux-gnu` | `x86_64-linux-gnu` | libpcap configure host |\n| `CMD_CC_PREFIX` | `aarch64-linux-gnu-` | `x86_64-linux-gnu-` | Cross-compiler prefix |\n\nThese mappings are defined in `variables.mk` (referenced but not shown).\n\n**Sources:** [builder/init_env.sh:43-61]()\n\n### Cross-Compilation Toolchain Setup\n\nThe CI workflows ([.github/workflows/go-c-cpp.yml:16-33]()) and initialization script ([builder/init_env.sh:1-106]()) install cross-compilation toolchains:\n\n**On x86_64 host (targeting arm64):**\n```bash\nsudo apt-get install gcc-aarch64-linux-gnu linux-source\ncd /usr/src/linux-source-*\nsudo make ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- prepare\n```\n\n**On aarch64 host (targeting x86_64):**\n```bash\nsudo apt-get install gcc-x86-64-linux-gnu linux-source\ncd /usr/src/linux-source-*\nsudo make ARCH=x86 CROSS_COMPILE=x86_64-linux-gnu- prepare\n```\n\nThe `make prepare` command generates architecture-specific kernel headers required for non-CO-RE eBPF compilation.\n\n**Sources:** [.github/workflows/go-c-cpp.yml:16-33](), [.github/workflows/go-c-cpp.yml:76-93](), [builder/init_env.sh:72-89]()\n\n### Cross-Compilation in Action\n\n#### eBPF Cross-Compilation\n\nCO-RE eBPF bytecode is architecture-aware via the `-D__TARGET_ARCH_$(LINUX_ARCH)` flag ([Makefile:122]()), which resolves to:\n- `-D__TARGET_ARCH_x86` for x86_64\n- `-D__TARGET_ARCH_arm64` for aarch64\n\nNon-CO-RE compilation uses cross-prepared kernel headers from the target architecture ([Makefile:154-161]()).\n\n#### libpcap Cross-Build\n\nThe libpcap configure step ([Makefile:203-207]()) uses:\n```makefile\nCC=$(CMD_CC_PREFIX)$(CMD_CC) --host=$(LIBPCAP_ARCH)\n```\n\nWhere:\n- `CMD_CC_PREFIX` is `aarch64-linux-gnu-` or `x86_64-linux-gnu-`\n- `LIBPCAP_ARCH` is `aarch64-linux-gnu` or `x86_64-linux-gnu`\n\n#### Go Cross-Build\n\nThe Go build ([functions.mk:51]()) sets:\n```makefile\nGOARCH=$(GOARCH) CC=$(CMD_CC_PREFIX)$(CMD_CC)\n```\n\nThis tells Go to use the cross-compiler for CGO compilation and to target the specified architecture.\n\n**Sources:** [Makefile:122](), [Makefile:154-161](), [Makefile:203-207](), [functions.mk:51]()\n\n### CI/CD Cross-Compilation Workflow\n\nThe GitHub Actions workflow demonstrates the cross-compilation process:\n\n```yaml\n- name: Build CO-RE (Cross-Compilation)\n  run: |\n    make clean\n    CROSS_ARCH=arm64 make env\n    CROSS_ARCH=arm64 make -j8\n\n- name: Build non-CO-RE (Cross-Compilation/Android)\n  run: |\n    make clean\n    CROSS_ARCH=arm64 make env\n    ANDROID=1 CROSS_ARCH=arm64 make nocore -j8\n```\n\nThis workflow ([.github/workflows/go-c-cpp.yml:56-65]()) validates that:\n1. CO-RE cross-compilation works\n2. Non-CO-RE cross-compilation works\n3. Android-specific builds work (non-CO-RE only)\n\nThe workflow runs on both x86_64 ([.github/workflows/go-c-cpp.yml:9-11]()) and aarch64 ([.github/workflows/go-c-cpp.yml:69-71]()) runners.\n\n**Sources:** [.github/workflows/go-c-cpp.yml:56-65](), [.github/workflows/go-c-cpp.yml:116-125]()\n\n## Release Artifact Generation\n\nThe build system produces multiple release artifact formats: tarballs, Debian packages, Docker images, and Android-specific builds.\n\n```mermaid\ngraph TB\n    subgraph \"Release Targets\"\n        RELEASE[\"make release<br/>builder/Makefile.release\"]\n        SNAPSHOT[\"snapshot target<br/>Linux releases\"]\n        SNAPSHOT_AND[\"snapshot_android target<br/>Android releases\"]\n        DEB[\"build_deb target<br/>Debian packages\"]\n        DOCKER[\"docker build<br/>Multi-arch images\"]\n    end\n    \n    subgraph \"Artifact Types\"\n        LINUX_TAR[\"Linux Tarball:<br/>ecapture-{VERSION}-linux-{ARCH}.tar.gz<br/>Contains: binary, LICENSE, README\"]\n        \n        LINUX_NC_TAR[\"Linux Non-CO-RE Tarball:<br/>ecapture-{VERSION}-linux-{ARCH}-nocore.tar.gz\"]\n        \n        ANDROID_TAR[\"Android Tarball:<br/>ecapture-{VERSION}-android-{ARCH}-nocore.tar.gz<br/>Non-CO-RE only\"]\n        \n        DEB_PKG[\"Debian Package:<br/>ecapture-{VERSION}_{ARCH}.deb<br/>Installs to /usr/local/bin\"]\n        \n        DOCKER_IMG[\"Docker Images:<br/>{USERNAME}/ecapture:{VERSION}<br/>{USERNAME}/ecapture:latest<br/>Multi-arch: linux/amd64, linux/arm64\"]\n    end\n    \n    subgraph \"Release Process\"\n        CHECKSUM[\"checksum-{VERSION}.txt<br/>SHA256 checksums\"]\n        \n        GITHUB[\"GitHub Release:<br/>gh release create<br/>Upload artifacts + notes\"]\n    end\n    \n    RELEASE --> SNAPSHOT\n    RELEASE --> SNAPSHOT_AND\n    RELEASE --> DEB\n    \n    SNAPSHOT --> LINUX_TAR\n    SNAPSHOT --> LINUX_NC_TAR\n    SNAPSHOT_AND --> ANDROID_TAR\n    DEB --> DEB_PKG\n    DOCKER --> DOCKER_IMG\n    \n    LINUX_TAR --> CHECKSUM\n    LINUX_NC_TAR --> CHECKSUM\n    ANDROID_TAR --> CHECKSUM\n    DEB_PKG --> CHECKSUM\n    \n    CHECKSUM --> GITHUB\n    DOCKER_IMG --> GITHUB\n```\n\n**Sources:** [builder/Makefile.release:1-151](), [.github/workflows/release.yml:1-129]()\n\n### Release Tarball Generation\n\nThe `release_tar` function ([functions.mk:62-76]()) creates release archives:\n\n```makefile\n$(call release_tar,linux,)          # Full build (CO-RE + non-CO-RE)\n$(call release_tar,linux,nocore)    # Non-CO-RE only\n$(call release_tar,android,nocore)  # Android (non-CO-RE only)\n```\n\n**Tarball contents:**\n1. `ecapture` binary\n2. `LICENSE` file\n3. `CHANGELOG.md`\n4. `README.md` and `README_CN.md`\n\n**Naming convention:**\n```\necapture-{VERSION}-{PLATFORM}-{ARCH}{CORE_SUFFIX}.tar.gz\n```\n\nWhere:\n- `VERSION` is from `SNAPSHOT_VERSION` or git tag\n- `PLATFORM` is `linux` or `android`\n- `ARCH` is `amd64` or `arm64`\n- `CORE_SUFFIX` is empty or `-nocore`\n\nExamples:\n- `ecapture-v0.8.0-linux-amd64.tar.gz` (full build)\n- `ecapture-v0.8.0-linux-arm64-nocore.tar.gz` (non-CO-RE)\n- `ecapture-v0.8.0-android-arm64-nocore.tar.gz` (Android)\n\n**Sources:** [functions.mk:62-76](), [builder/Makefile.release:94-112]()\n\n### Debian Package Generation\n\nThe `build_deb` target ([builder/Makefile.release:135-151]()) creates `.deb` packages:\n\n**Package structure:**\n```\nBUILD_DIR/\n├── DEBIAN/\n│   └── control         # Package metadata\n└── usr/local/bin/\n    └── ecapture        # Binary\n```\n\n**Control file fields:**\n- `Package`: `ecapture`\n- `Version`: From `PACKAGE_VERSION`\n- `Architecture`: `amd64` or `arm64`\n- `Maintainer`: Package maintainer\n- `Description`: Short description\n- `Homepage`: Project URL\n\n**Output filename:**\n```\necapture-{VERSION}_{ARCH}.deb\n```\n\nExample: `ecapture-0.8.0_amd64.deb`\n\nThe package installs the binary to `/usr/local/bin/ecapture`, making it globally accessible after installation with `dpkg -i`.\n\n**Sources:** [builder/Makefile.release:135-151]()\n\n### Docker Multi-Architecture Images\n\nThe Docker build ([builder/Dockerfile:1-39]()) creates multi-architecture images using BuildKit:\n\n**Build process:**\n\n1. **Base image:** `ubuntu:22.04` with build dependencies\n2. **Compiler installation:** clang-14, llvm-14, gcc\n3. **Go installation:** Version-specific Go binary for target architecture\n4. **eCapture build:** Full `make all` with embedded bytecode\n5. **Final image:** Minimal `alpine:latest` with only the binary\n\n**Multi-arch workflow** ([.github/workflows/release.yml:101-129]()):\n\n```yaml\n- name: Build and push\n  uses: docker/build-push-action@v5\n  with:\n    platforms: linux/amd64,linux/arm64\n    push: true\n    tags: |\n      {USERNAME}/ecapture:{VERSION}\n      {USERNAME}/ecapture:latest\n```\n\n**Key features:**\n\n- **Build cache:** Uses registry cache for faster builds\n- **Version injection:** `--build-args VERSION={VERSION}`\n- **Entrypoint:** `/ecapture` for direct execution\n- **Multi-platform:** Builds both amd64 and arm64 simultaneously\n\nUsage:\n```bash\ndocker run --rm -it --privileged {USERNAME}/ecapture:latest tls\n```\n\n**Sources:** [builder/Dockerfile:1-39](), [.github/workflows/release.yml:101-129]()\n\n### Release Publishing Workflow\n\nThe `publish` target ([builder/Makefile.release:114-124]()) publishes artifacts to GitHub:\n\n```makefile\npublish:\n\tcd $(OUTPUT_DIR)\n\t$(CMD_CHECKSUM) ecapture*v* | $(CMD_SED) 's/.\\/bin\\///g' > checksum-{VERSION}.txt\n\tFILES=$$(ls ecapture-*.tar.gz ecapture*.deb checksum-*.txt)\n\t$(CMD_GITHUB) release create $(DEB_VERSION) $$FILES \\\n\t    --title \"eCapture $(DEB_VERSION)\" \\\n\t    --notes-file $(RELEASE_NOTES)\n```\n\n**Process:**\n\n1. Generate SHA256 checksums for all artifacts\n2. Collect tarballs, `.deb` files, and checksum file\n3. Create GitHub release with tag\n4. Upload all files\n5. Include release notes from `bin/release_notes.txt`\n\n**Release notes generation** ([.github/workflows/release.yml:68-80]()) uses GitHub API:\n\n```bash\ngh api /repos/{repo}/releases/generate-notes \\\n    -f tag_name={VERSION} \\\n    -f previous_tag_name={PREVIOUS_TAG}\n```\n\nThis auto-generates release notes from commit messages and PRs.\n\n**Sources:** [builder/Makefile.release:114-124](), [.github/workflows/release.yml:63-87]()\n\n### Android-Specific Builds\n\nAndroid builds use non-CO-RE compilation exclusively ([.github/workflows/go-c-cpp.yml:61-65]()):\n\n```bash\nANDROID=1 CROSS_ARCH=arm64 make nocore\n```\n\n**Rationale:**\n\n1. Android kernels often lack BTF support\n2. Android uses custom kernel versions\n3. Non-CO-RE ensures compatibility with Android's kernel\n4. Smaller binary (no CO-RE bytecode overhead)\n\nThe `ANDROID` flag may trigger Android-specific preprocessor directives or configurations in `variables.mk`.\n\nAndroid releases are tagged with `android` platform name:\n```\necapture-v0.8.0-android-arm64-nocore.tar.gz\n```\n\n**Sources:** [.github/workflows/go-c-cpp.yml:61-65](), [builder/Makefile.release:104-112]()\n\n## CI/CD Integration\n\nThe GitHub Actions workflows automate building, testing, and releasing.\n\n```mermaid\ngraph TB\n    subgraph \"CI Workflow - go-c-cpp.yml\"\n        CI_TRIGGER[\"Trigger: push/PR to master\"]\n        \n        CI_X86[\"Job: build-on-ubuntu2204<br/>x86_64 runner\"]\n        CI_ARM[\"Job: build-on-ubuntu2204-arm64<br/>aarch64 runner\"]\n        \n        CI_STEPS[\"Steps:<br/>1. Install compilers<br/>2. Build CO-RE<br/>3. Run golangci-lint<br/>4. Build non-CO-RE<br/>5. Cross-compile<br/>6. Run tests\"]\n    end\n    \n    subgraph \"Release Workflow - release.yml\"\n        REL_TRIGGER[\"Trigger: Tag push v*\"]\n        \n        REL_BUILD[\"Job: build-on-ubuntu2204<br/>Build releases\"]\n        \n        REL_STEPS[\"Steps:<br/>1. Generate release notes<br/>2. Build amd64 releases<br/>3. Build arm64 releases<br/>4. Publish to GitHub\"]\n        \n        REL_DOCKER[\"Job: build-docker-image<br/>Multi-arch Docker build\"]\n    end\n    \n    subgraph \"CodeQL Workflow - codeql-analysis.yml\"\n        CQL_TRIGGER[\"Trigger: push/PR/schedule\"]\n        \n        CQL_STEPS[\"Steps:<br/>1. Install compilers<br/>2. Build with autobuild<br/>3. Run CodeQL analysis<br/>4. Upload to Codecov\"]\n    end\n    \n    CI_TRIGGER --> CI_X86\n    CI_TRIGGER --> CI_ARM\n    CI_X86 --> CI_STEPS\n    CI_ARM --> CI_STEPS\n    \n    REL_TRIGGER --> REL_BUILD\n    REL_TRIGGER --> REL_DOCKER\n    REL_BUILD --> REL_STEPS\n    \n    CQL_TRIGGER --> CQL_STEPS\n```\n\n**Sources:** [.github/workflows/go-c-cpp.yml:1-128](), [.github/workflows/release.yml:1-129](), [.github/workflows/codeql-analysis.yml:1-92]()\n\n### CI Workflow (go-c-cpp.yml)\n\nThis workflow ([.github/workflows/go-c-cpp.yml:1-128]()) runs on every push and PR:\n\n**Build matrix:**\n- **x86_64 job:** Ubuntu 22.04 on x86_64 runner ([.github/workflows/go-c-cpp.yml:9-67]())\n- **aarch64 job:** Ubuntu 22.04 on ARM64 runner ([.github/workflows/go-c-cpp.yml:69-127]())\n\n**Build sequence:**\n\n1. **Install dependencies** ([.github/workflows/go-c-cpp.yml:16-33]()):\n   - Go 1.24.6\n   - clang-14, llvm-14, gcc\n   - Cross-compilation toolchains\n   - Linux kernel source\n\n2. **Native CO-RE build** ([.github/workflows/go-c-cpp.yml:38-44]()):\n   ```bash\n   make clean\n   make env\n   DEBUG=1 make -j8\n   ```\n\n3. **Linting** ([.github/workflows/go-c-cpp.yml:45-50]()):\n   ```bash\n   golangci-lint run\n   ```\n\n4. **Native non-CO-RE build** ([.github/workflows/go-c-cpp.yml:51-55]()):\n   ```bash\n   make nocore\n   ```\n\n5. **Cross-compilation CO-RE** ([.github/workflows/go-c-cpp.yml:56-60]()):\n   ```bash\n   CROSS_ARCH=arm64 make  # On x86_64\n   CROSS_ARCH=amd64 make  # On ARM64\n   ```\n\n6. **Cross-compilation Android** ([.github/workflows/go-c-cpp.yml:61-65]()):\n   ```bash\n   ANDROID=1 CROSS_ARCH=arm64 make nocore\n   ```\n\n7. **Run tests** ([.github/workflows/go-c-cpp.yml:66-67]()):\n   ```bash\n   go test -v -race ./...\n   ```\n\nThis comprehensive CI ensures all build configurations work correctly.\n\n**Sources:** [.github/workflows/go-c-cpp.yml:1-128]()\n\n### Release Workflow (release.yml)\n\nThis workflow ([.github/workflows/release.yml:1-129]()) triggers on version tags (`v*`):\n\n**Jobs:**\n\n1. **Build and release** ([.github/workflows/release.yml:13-100]()):\n   - Generate release notes from commits\n   - Build amd64 native releases\n   - Build arm64 cross-compiled releases\n   - Create GitHub release\n   - Upload all artifacts\n\n2. **Docker multi-arch build** ([.github/workflows/release.yml:101-129]()):\n   - Build for `linux/amd64` and `linux/arm64`\n   - Push to Docker Hub\n   - Tag with version and `latest`\n\n**Release artifacts generated:**\n\nFor **amd64** (native build on x86_64):\n- `ecapture-{VERSION}-linux-amd64.tar.gz`\n- `ecapture-{VERSION}-linux-amd64.deb`\n\nFor **arm64** (cross-compiled on x86_64):\n- `ecapture-{VERSION}-linux-arm64.tar.gz`\n- `ecapture-{VERSION}-android-arm64-nocore.tar.gz`\n- `ecapture-{VERSION}-linux-arm64.deb`\n\nPlus:\n- `checksum-{VERSION}.txt` with SHA256 hashes\n- `release_notes.txt` with generated release notes\n\n**Sources:** [.github/workflows/release.yml:1-129]()\n\n### CodeQL Analysis Workflow\n\nThe CodeQL workflow ([.github/workflows/codeql-analysis.yml:1-92]()) performs security scanning:\n\n**Triggers:**\n- Push to master\n- Pull requests\n- Weekly schedule (Wednesday 15:42)\n\n**Language matrix:**\n- C/C++ analysis for eBPF code\n- Go analysis for application code\n\n**Process:**\n1. Install build dependencies\n2. Run autobuild (attempts automatic build detection)\n3. If autobuild fails, run `make nocore` explicitly\n4. Perform CodeQL analysis\n5. Upload results to GitHub Security tab\n6. Upload coverage to Codecov\n\nThis ensures continuous security monitoring of the codebase.\n\n**Sources:** [.github/workflows/codeql-analysis.yml:1-92]()\n\n## Development Environment Setup\n\nThe `builder/init_env.sh` script ([builder/init_env.sh:1-106]()) automates development environment setup on Ubuntu:\n\n**Features:**\n\n1. **Distribution detection:** Selects appropriate clang version based on Ubuntu release\n2. **Architecture detection:** Configures cross-compilation toolchain\n3. **Dependency installation:** Installs all required build tools\n4. **Kernel header preparation:** Prepares headers for both native and cross-compilation\n5. **Go installation:** Downloads and installs Go 1.24.6\n6. **Repository cloning:** Clones eCapture source\n\n**Usage:**\n```bash\n/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/gojue/ecapture/master/builder/init_env.sh)\"\n```\n\n**Supported Ubuntu versions:**\n- 20.04 (clang-10)\n- 20.10, 21.04, 21.10, 22.04, 22.10 (clang-11/12)\n- 23.04, 23.10 (clang-15)\n- 24.04 (clang-18)\n\nAfter running, developers can immediately build eCapture with `make`.\n\n**Sources:** [builder/init_env.sh:1-106]()\n\n## Build System Summary\n\nThe eCapture build system implements a production-grade compilation and release pipeline with the following characteristics:\n\n**Architecture:**\n- Three-file Makefile system with separation of concerns\n- Dual eBPF compilation (CO-RE and non-CO-RE)\n- Bidirectional cross-compilation (x86_64 ↔ aarch64)\n- Static linking for self-contained binaries\n- Asset embedding via go-bindata\n\n**Outputs:**\n- Linux native builds (CO-RE + non-CO-RE)\n- Linux non-CO-RE only builds\n- Android ARM64 builds\n- Debian packages\n- Multi-architecture Docker images\n- SHA256 checksums\n\n**Automation:**\n- Continuous integration on x86_64 and aarch64\n- Automated release on version tags\n- Security analysis with CodeQL\n- Environment setup script\n\nThis comprehensive build system ensures eCapture runs reliably across diverse Linux environments, from modern servers with BTF-enabled kernels to older systems and Android devices."
          },
          {
            "page_plan": {
              "id": "5.2",
              "title": "eBPF Program Development"
            },
            "content": "# eBPF Program Development\n\n<details>\n<summary>Relevant source files</summary>\n\nThe following files were used as context for generating this wiki page:\n\n- [kern/boringssl_const.h](kern/boringssl_const.h)\n- [kern/boringssl_masterkey.h](kern/boringssl_masterkey.h)\n- [kern/common.h](kern/common.h)\n- [kern/ecapture.h](kern/ecapture.h)\n- [kern/openssl_masterkey.h](kern/openssl_masterkey.h)\n- [kern/openssl_masterkey_3.0.h](kern/openssl_masterkey_3.0.h)\n- [kern/tc.h](kern/tc.h)\n- [utils/boringssl-offset.c](utils/boringssl-offset.c)\n\n</details>\n\n\n\n## Purpose and Scope\n\nThis page provides a comprehensive guide to developing eBPF programs for eCapture. It covers the development environment setup, common patterns, helper functions, map types, probe attachment mechanisms, memory management strategies, and debugging techniques used throughout the codebase. \n\nFor detailed information about eBPF program structure patterns and organization, see [eBPF Program Structure](#5.2.1). For techniques to calculate offsets in complex structures like SSL/TLS libraries, see [Structure Offset Calculation](#5.2.2). For the overall build process that compiles these eBPF programs, see [Build System](#5.1).\n\n---\n\n## Development Environment\n\n### CO-RE vs Non-CO-RE Compilation Modes\n\neCapture eBPF programs support two compilation modes, controlled by the `NOCORE` preprocessor flag defined in [kern/ecapture.h:18-88]():\n\n**CO-RE Mode (Compile Once - Run Everywhere):**\n- Uses BTF (BPF Type Format) for kernel compatibility\n- Includes `vmlinux.h` with all kernel types\n- Leverages `bpf_core_read()` helpers for portable structure access\n- Requires kernel 5.2+ with BTF support\n- Enables use of `.rodata` section for constant values\n\n**Non-CO-RE Mode:**\n- Uses traditional kernel headers from specific kernel versions\n- Directly includes `<linux/types.h>`, `<linux/bpf.h>`, etc.\n- Requires compilation for each target kernel version\n- Supports older kernels (< 5.2)\n- Cannot use `.rodata` section (see [kern/common.h:63-71]())\n\n```mermaid\ngraph TB\n    subgraph \"Header Selection - kern/ecapture.h\"\n        NOCORE{NOCORE<br/>Defined?}\n        \n        NOCORE -->|No - CO-RE| CORE_HEADERS[\"vmlinux.h<br/>bpf_core_read.h<br/>bpf_helpers.h<br/>bpf_tracing.h<br/>core_fixes.bpf.h\"]\n        \n        NOCORE -->|Yes - Non-CO-RE| NONCORE_HEADERS[\"linux/types.h<br/>linux/bpf.h<br/>linux/socket.h<br/>net/sock.h<br/>uapi/linux/ptrace.h\"]\n    end\n    \n    subgraph \"Common Headers\"\n        CORE_HEADERS --> COMMON[\"common.h<br/>Constants<br/>Macros<br/>License\"]\n        NONCORE_HEADERS --> COMMON\n    end\n    \n    subgraph \"Module-Specific Headers\"\n        COMMON --> SSL_HEADERS[\"openssl_masterkey.h<br/>boringssl_masterkey.h<br/>openssl_masterkey_3.0.h\"]\n        COMMON --> TC_HEADERS[\"tc.h<br/>Network capture\"]\n    end\n    \n    subgraph \"Compilation Targets\"\n        SSL_HEADERS --> VARIANTS[\"openssl_kern.o<br/>boringssl_a_13_kern.o<br/>...27+ variants\"]\n        TC_HEADERS --> TC_PROGS[\"tc_kern.o\"]\n    end\n```\n\n**Sources:** [kern/ecapture.h:18-92](), [kern/common.h:63-71]()\n\n---\n\n## Common Headers and Definitions\n\n### Core Header: ecapture.h\n\nThe [kern/ecapture.h:1-92]() header serves as the foundation for all eBPF programs, providing:\n\n| Feature | Purpose | Location |\n|---------|---------|----------|\n| Mode Selection | Switch between CO-RE and non-CO-RE | Lines 18-28, 27-88 |\n| Helper Macros | `asm_inline` redefinition for Clang compatibility | Lines 43-46 |\n| Kernel Types | `tcphdr`, `ipv6hdr` structures for non-CO-RE | Lines 69-86 |\n| Common Include | Always includes `common.h` | Line 90 |\n\n### Common Definitions: common.h\n\nThe [kern/common.h:1-85]() header defines constants and macros used across all eBPF programs:\n\n**Debug Macro:**\n```c\n#ifdef DEBUG_PRINT\n#define debug_bpf_printk(fmt, ...)                     \\\n    do {                                               \\\n        char s[] = fmt;                                \\\n        bpf_trace_printk(s, sizeof(s), ##__VA_ARGS__); \\\n    } while (0)\n#else\n#define debug_bpf_printk(fmt, ...)\n#endif\n```\n\n**Key Constants:**\n\n| Constant | Value | Purpose |\n|----------|-------|---------|\n| `TASK_COMM_LEN` | 16 | Process command name length |\n| `PATH_MAX_LEN` | 256 | Maximum path length |\n| `MAX_DATA_SIZE_OPENSSL` | 16384 | TLS record max size (RFC 5246) |\n| `MAX_DATA_SIZE_MYSQL` | 256 | MySQL query capture size |\n| `MAX_DATA_SIZE_BASH` | 256 | Bash command capture size |\n| `SKB_MAX_DATA_SIZE` | 2048 | Network packet buffer size |\n| `AF_INET` | 2 | IPv4 address family |\n| `AF_INET6` | 10 | IPv6 address family |\n| `TC_ACT_OK` | 0 | TC program return value |\n\n**Target Filtering (CO-RE Mode Only):**\n```c\n#ifndef KERNEL_LESS_5_2\nconst volatile u64 target_pid = 0;\nconst volatile u64 target_uid = 0;\nconst volatile u64 target_errno = BASH_ERRNO_DEFAULT;\n#endif\n```\n\nThese volatile constants in `.rodata` allow userspace to set filtering parameters before loading the eBPF program.\n\n**Sources:** [kern/common.h:18-85](), [kern/ecapture.h:18-92]()\n\n---\n\n## eBPF Map Types and Usage\n\neCapture uses several BPF map types for different purposes. Here's a comprehensive overview:\n\n```mermaid\ngraph TB\n    subgraph \"Event Output Maps\"\n        PERF[\"BPF_MAP_TYPE_PERF_EVENT_ARRAY<br/>mastersecret_events<br/>skb_events<br/>Max: 1024-10240 entries\"]\n    end\n    \n    subgraph \"Temporary Storage Maps\"\n        LRU[\"BPF_MAP_TYPE_LRU_HASH<br/>bpf_context<br/>network_map<br/>Auto-eviction on size limit\"]\n        \n        ARRAY[\"BPF_MAP_TYPE_ARRAY<br/>bpf_context_gen<br/>Single entry for stack workaround\"]\n        \n        PERCPU[\"BPF_MAP_TYPE_PERCPU_ARRAY<br/>skb_data_buffer_heap<br/>Per-CPU temporary buffers\"]\n    end\n    \n    subgraph \"Usage Patterns\"\n        PERF -->|\"Send events to userspace\"| OUTPUT[\"User Space<br/>Event Readers\"]\n        \n        LRU -->|\"Store PID-to-context<br/>Network tuple mapping\"| CONTEXT[\"Process<br/>Attribution\"]\n        \n        ARRAY -->|\"Workaround 512-byte<br/>stack limit\"| HEAP[\"Heap-like<br/>Allocation\"]\n        \n        PERCPU -->|\"Per-CPU buffers<br/>avoid locks\"| EFFICIENCY[\"Lock-free<br/>Performance\"]\n    end\n```\n\n### Map Type Comparison\n\n| Map Type | Use Cases | Key Features | Example |\n|----------|-----------|--------------|---------|\n| `PERF_EVENT_ARRAY` | Send events to userspace | High-throughput streaming | `mastersecret_events` [kern/openssl_masterkey.h:48-53]() |\n| `LRU_HASH` | PID/connection tracking | Auto-eviction on capacity | `bpf_context` [kern/boringssl_masterkey.h:115-119](), `network_map` [kern/tc.h:73-77]() |\n| `ARRAY` | Fixed-size lookup | Fast indexed access | `bpf_context_gen` [kern/openssl_masterkey.h:62-67]() |\n| `PERCPU_ARRAY` | Temporary per-CPU buffers | Lock-free operation | `skb_data_buffer_heap` [kern/tc.h:65-69]() |\n\n### Common Map Definitions\n\n**Event Output Map (Master Secret Extraction):**\n```c\nstruct {\n    __uint(type, BPF_MAP_TYPE_PERF_EVENT_ARRAY);\n    __uint(key_size, sizeof(u32));\n    __uint(value_size, sizeof(u32));\n    __uint(max_entries, 1024);\n} mastersecret_events SEC(\".maps\");\n```\n\n**Network Connection Tracking Map:**\n```c\nstruct {\n    __uint(type, BPF_MAP_TYPE_LRU_HASH);\n    __type(key, struct net_id_t);      // 4-tuple\n    __type(value, struct net_ctx_t);   // PID/UID/comm\n    __uint(max_entries, 10240);\n} network_map SEC(\".maps\");\n```\n\n**Sources:** [kern/tc.h:57-77](), [kern/openssl_masterkey.h:48-67](), [kern/boringssl_masterkey.h:107-126]()\n\n---\n\n## Probe Types and Attachment Points\n\neCapture uses three primary eBPF program types for different interception scenarios:\n\n```mermaid\ngraph LR\n    subgraph \"Application Space\"\n        APP[\"User Application<br/>OpenSSL/Go/MySQL\"]\n    end\n    \n    subgraph \"eBPF Probe Types\"\n        UPROBE[\"uprobe<br/>SEC('uprobe/SSL_write_key')<br/>User function hooks\"]\n        \n        KPROBE[\"kprobe<br/>SEC('kprobe/tcp_sendmsg')<br/>Kernel function hooks\"]\n        \n        TC[\"TC Classifier<br/>SEC('classifier')<br/>Network packet hooks\"]\n    end\n    \n    subgraph \"Kernel Space\"\n        KERNEL_FUNC[\"tcp_sendmsg()<br/>udp_sendmsg()<br/>Network stack\"]\n        \n        NET_LAYER[\"Network Device<br/>Ingress/Egress\"]\n    end\n    \n    APP -->|\"Calls SSL functions\"| UPROBE\n    UPROBE -->|\"Reads memory\"| APP\n    \n    APP -->|\"Makes syscalls\"| KERNEL_FUNC\n    KERNEL_FUNC --> KPROBE\n    \n    NET_LAYER -->|\"Packet processing\"| TC\n    TC -->|\"Reads packet data\"| NET_LAYER\n```\n\n### Uprobe Programs\n\nUprobes attach to user-space functions to intercept function calls and extract data. Primary use case: SSL/TLS master secret extraction.\n\n**Example: SSL Master Key Capture**\n[kern/openssl_masterkey.h:81-82]()\n```c\nSEC(\"uprobe/SSL_write_key\")\nint probe_ssl_master_key(struct pt_regs *ctx)\n```\n\n**Key Patterns:**\n1. **Access function parameters:** `PT_REGS_PARM1(ctx)` for first argument (ssl_st pointer)\n2. **Read user-space memory:** `bpf_probe_read_user()` for structure fields\n3. **Filter by PID/UID:** Check against `target_pid`, `target_uid` in CO-RE mode\n\n**Sources:** [kern/openssl_masterkey.h:81-257](), [kern/boringssl_masterkey.h:169-403]()\n\n### Kprobe Programs\n\nKprobes attach to kernel functions for connection tracking and network attribution.\n\n**Example: TCP Connection Tracking**\n[kern/tc.h:290-347]()\n```c\nSEC(\"kprobe/tcp_sendmsg\")\nint tcp_sendmsg(struct pt_regs *ctx)\n```\n\n**Purpose:** Extract connection 4-tuple (src_ip, src_port, dst_ip, dst_port) and associate with PID/UID.\n\n**Key Operations:**\n1. Extract PID/UID: `bpf_get_current_pid_tgid()`, `bpf_get_current_uid_gid()`\n2. Read socket structure: `PT_REGS_PARM1(ctx)` gets `struct sock *`\n3. Extract connection info: IPv4/IPv6 addresses and ports\n4. Store in map: `bpf_map_update_elem(&network_map, &conn_id, &net_ctx, BPF_ANY)`\n\n**Sources:** [kern/tc.h:290-397]()\n\n### TC Classifier Programs\n\nTC (Traffic Control) classifiers capture network packets at the device layer for both ingress and egress traffic.\n\n**Example: Packet Capture**\n[kern/tc.h:279-288]()\n```c\nSEC(\"classifier\")\nint egress_cls_func(struct __sk_buff *skb)\nSEC(\"classifier\")\nint ingress_cls_func(struct __sk_buff *skb)\n```\n\n**Both call common function:** [kern/tc.h:135-276]()\n```c\nstatic __always_inline int capture_packets(struct __sk_buff *skb, bool is_ingress)\n```\n\n**Key Operations:**\n1. Parse packet headers: Ethernet → IP/IPv6 → TCP/UDP\n2. Extract 4-tuple from packet\n3. Lookup in `network_map` for PID attribution\n4. Apply PID/UID filters\n5. Send to userspace via `bpf_perf_event_output()`\n\n**Sources:** [kern/tc.h:135-288]()\n\n---\n\n## Memory Management and Stack Limitations\n\n### The 512-Byte Stack Problem\n\neBPF programs have a strict **512-byte stack limit**. Large structures (e.g., `mastersecret_t` ~320 bytes) cannot be allocated on stack.\n\n### Workaround: Heap-like Allocation Pattern\n\neCapture uses a clever pattern with `BPF_MAP_TYPE_ARRAY` to simulate heap allocation:\n\n```mermaid\ngraph LR\n    subgraph \"Map as Heap\"\n        ARRAY_MAP[\"BPF_MAP_TYPE_ARRAY<br/>bpf_context_gen<br/>max_entries: 1<br/>value: struct mastersecret_t\"]\n    end\n    \n    subgraph \"Temporary Storage\"\n        HASH_MAP[\"BPF_MAP_TYPE_LRU_HASH<br/>bpf_context<br/>key: u64 (pid_tgid)<br/>value: struct mastersecret_t\"]\n    end\n    \n    subgraph \"eBPF Program Flow\"\n        LOOKUP1[\"1. Lookup key=0<br/>in bpf_context_gen\"]\n        UPDATE[\"2. Update bpf_context<br/>with current PID as key\"]\n        LOOKUP2[\"3. Lookup in bpf_context<br/>Returns pointer to map memory\"]\n        USE[\"4. Use pointer<br/>to fill structure\"]\n    end\n    \n    ARRAY_MAP --> LOOKUP1\n    LOOKUP1 --> UPDATE\n    UPDATE --> HASH_MAP\n    HASH_MAP --> LOOKUP2\n    LOOKUP2 --> USE\n```\n\n**Implementation:**\n[kern/openssl_masterkey.h:71-78]()\n```c\nstatic __always_inline struct mastersecret_t *make_event() {\n    u32 key_gen = 0;\n    struct mastersecret_t *bpf_ctx = bpf_map_lookup_elem(&bpf_context_gen, &key_gen);\n    if (!bpf_ctx) return 0;\n    u64 id = bpf_get_current_pid_tgid();\n    bpf_map_update_elem(&bpf_context, &id, bpf_ctx, BPF_ANY);\n    return bpf_map_lookup_elem(&bpf_context, &id);\n}\n```\n\n**How it works:**\n1. `bpf_context_gen` is a single-entry array holding the structure template\n2. Lookup at key 0 returns pointer to map-allocated memory\n3. Copy to `bpf_context` hash map with PID as key\n4. Return pointer from hash map (guaranteed valid for duration of program)\n5. This pointer references map memory (not stack), bypassing the 512-byte limit\n\n**Alternative: Per-CPU Array**\n[kern/tc.h:92-100]()\n```c\nstatic __always_inline struct skb_data_event_t *make_skb_data_event() {\n    u32 kZero = 0;\n    struct skb_data_event_t *event =\n        bpf_map_lookup_elem(&skb_data_buffer_heap, &kZero);\n    if (event == NULL) {\n        return NULL;\n    }\n    return event;\n}\n```\n\nThis uses `BPF_MAP_TYPE_PERCPU_ARRAY` for lock-free per-CPU temporary storage.\n\n**Sources:** [kern/openssl_masterkey.h:71-78](), [kern/boringssl_masterkey.h:130-137](), [kern/tc.h:92-100]()\n\n---\n\n## Filtering and Target Selection\n\n### PID and UID Filtering\n\neCapture implements optional filtering to reduce overhead and focus on specific processes:\n\n```mermaid\ngraph TB\n    subgraph \"Userspace Configuration\"\n        CLI[\"CLI Flag<br/>--pid=1234<br/>--uid=1000\"]\n    end\n    \n    subgraph \"eBPF .rodata Section - CO-RE Only\"\n        RODATA[\"const volatile u64 target_pid = 0;<br/>const volatile u64 target_uid = 0;\"]\n    end\n    \n    subgraph \"eBPF Program Filtering\"\n        GET_PID[\"u32 pid = bpf_get_current_pid_tgid() >> 32;<br/>u32 uid = bpf_get_current_uid_gid();\"]\n        \n        CHECK_PID{\"target_pid != 0 &&<br/>target_pid != pid?\"}\n        CHECK_UID{\"target_uid != 0 &&<br/>target_uid != uid?\"}\n        \n        RETURN_EARLY[\"return 0;<br/>Skip processing\"]\n        CONTINUE[\"Continue processing<br/>Capture event\"]\n    end\n    \n    CLI -->|\"Set before load\"| RODATA\n    RODATA --> GET_PID\n    GET_PID --> CHECK_PID\n    CHECK_PID -->|Yes| RETURN_EARLY\n    CHECK_PID -->|No| CHECK_UID\n    CHECK_UID -->|Yes| RETURN_EARLY\n    CHECK_UID -->|No| CONTINUE\n```\n\n**Implementation Pattern:**\n[kern/openssl_masterkey.h:88-96]()\n```c\n#ifndef KERNEL_LESS_5_2\n    // if target_ppid is 0 then we target all pids\n    if (target_pid != 0 && target_pid != pid) {\n        return 0;\n    }\n    if (target_uid != 0 && target_uid != uid) {\n        return 0;\n    }\n#endif\n```\n\n**Key Points:**\n- Only available in CO-RE mode (kernel 5.2+)\n- Variables declared as `const volatile` in `.rodata`\n- Value 0 means \"capture all\" (no filtering)\n- Early return minimizes overhead for filtered processes\n\n### Network-Level Filtering\n\nTC programs additionally support L2/L3/L4 packet filtering via a stub function:\n\n[kern/tc.h:122-132]()\n```c\n// filter_pcap_ebpf_l2 is a stub to inject pcap-filter.\nstatic __noinline bool filter_pcap_ebpf_l2(void *_skb, void *__skb,\n                                           void *___skb, void *data,\n                                           void* data_end) {\n    return data != data_end && _skb == __skb && __skb == ___skb;\n}\n\nstatic __always_inline bool filter_pcap_l2(struct __sk_buff *skb, void *data,\n                                           void *data_end) {\n    return filter_pcap_ebpf_l2((void *) skb, (void *) skb, (void *) skb, data,\n                               data_end);\n}\n```\n\nThis stub can be replaced at compile-time with pcap-filter bytecode for BPF-level packet filtering.\n\n**Sources:** [kern/common.h:66-71](), [kern/openssl_masterkey.h:88-96](), [kern/tc.h:122-150]()\n\n---\n\n## Helper Functions and Macros\n\n### Memory Access Helpers\n\n**CO-RE Safe Reading:**\n[kern/tc.h:22-28]()\n```c\n#define READ_KERN(ptr)                                                  \\\n    ({                                                                  \\\n        typeof(ptr) _val;                                               \\\n        __builtin_memset((void *)&_val, 0, sizeof(_val));               \\\n        bpf_core_read((void *)&_val, sizeof(_val), &ptr);               \\\n        _val;                                                           \\\n    })\n```\n\n**User-Space Memory Reading:**\n- `bpf_probe_read_user()` - Read from user-space addresses\n- `bpf_probe_read_kernel()` - Read from kernel memory (after initial copy)\n\n### SKB Data Validation\n\nNetwork packet processing requires careful bounds checking due to eBPF verifier:\n\n[kern/tc.h:102-119]()\n```c\nstatic __always_inline bool skb_revalidate_data(struct __sk_buff *skb,\n                                                uint8_t **head, uint8_t **tail,\n                                                const u32 offset) {\n    if (*head + offset > *tail) {\n        if (bpf_skb_pull_data(skb, offset) < 0) {\n            return false;\n        }\n\n        *head = (uint8_t *)(long)skb->data;\n        *tail = (uint8_t *)(long)skb->data_end;\n\n        if (*head + offset > *tail) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```\n\n**Purpose:** Ensure packet data is available in linear buffer before access. The verifier tracks `skb->data` and `skb->data_end` pointers and requires proof that accesses are within bounds.\n\n### Helper Function Summary Table\n\n| Function | Purpose | Usage Context |\n|----------|---------|---------------|\n| `bpf_get_current_pid_tgid()` | Get current PID/TID | All probe types |\n| `bpf_get_current_uid_gid()` | Get current UID/GID | All probe types |\n| `bpf_get_current_comm()` | Get process name | All probe types |\n| `bpf_probe_read_user()` | Read user-space memory | Uprobe programs |\n| `bpf_probe_read_kernel()` | Read kernel memory | After copying to stack |\n| `bpf_map_lookup_elem()` | Lookup map entry | All contexts |\n| `bpf_map_update_elem()` | Update map entry | All contexts |\n| `bpf_perf_event_output()` | Send event to userspace | Event reporting |\n| `bpf_ntohs()` / `bpf_htons()` | Network byte order conversion | Network programs |\n| `bpf_skb_pull_data()` | Pull packet data to linear | TC programs |\n| `bpf_core_read()` | CO-RE safe field reading | CO-RE mode only |\n\n**Sources:** [kern/tc.h:22-119](), [kern/openssl_masterkey.h:71-78]()\n\n---\n\n## Event Reporting Mechanisms\n\n### Perf Event Output\n\nThe primary mechanism for sending data from eBPF to userspace:\n\n```mermaid\ngraph LR\n    subgraph \"eBPF Program\"\n        EVENT_STRUCT[\"struct mastersecret_t<br/>or<br/>struct skb_data_event_t\"]\n        \n        OUTPUT_CALL[\"bpf_perf_event_output(ctx,<br/>&events_map,<br/>BPF_F_CURRENT_CPU,<br/>event, size)\"]\n    end\n    \n    subgraph \"Kernel\"\n        PERF_MAP[\"BPF_MAP_TYPE_PERF_EVENT_ARRAY<br/>Per-CPU ring buffers\"]\n    end\n    \n    subgraph \"Userspace\"\n        READER[\"perfEventReader<br/>or<br/>ringbufEventReader\"]\n        \n        WORKER[\"Event Worker<br/>Decode & Process\"]\n    end\n    \n    EVENT_STRUCT --> OUTPUT_CALL\n    OUTPUT_CALL --> PERF_MAP\n    PERF_MAP --> READER\n    READER --> WORKER\n```\n\n**Standard Pattern:**\n[kern/openssl_masterkey.h:165-168]()\n```c\nbpf_perf_event_output(\n    ctx, &mastersecret_events, BPF_F_CURRENT_CPU, \n    mastersecret, sizeof(struct mastersecret_t));\n```\n\n**Flags:**\n- `BPF_F_CURRENT_CPU` - Send to current CPU's buffer (no locking)\n- For TC programs, encode packet length: `flags |= (u64)skb->len << 32;` [kern/tc.h:260-261]()\n\n### Minimal vs Full Event Data\n\nTC programs optimize bandwidth by sending minimal metadata when possible:\n\n[kern/tc.h:263-271]()\n```c\n// if net_packet event not chosen, send minimal data only:\n//     timestamp (u64)      8 bytes\n//     pid (u32)            4 bytes\n//     comm (char[])       16 bytes\n//     packet len (u32)     4 bytes\n//     ifindex (u32)        4 bytes\nsize_t pkt_size = TC_PACKET_MIN_SIZE;\nbpf_perf_event_output(skb, &skb_events, flags, &event, pkt_size);\n```\n\nThis allows the eBPF program to send metadata plus full packet data when needed, or just metadata for volume reduction.\n\n**Sources:** [kern/tc.h:260-271](), [kern/openssl_masterkey.h:165-168](), [kern/boringssl_masterkey.h:339-341]()\n\n---\n\n## Debugging Techniques\n\n### Debug Print Macro\n\n[kern/common.h:18-26]()\n```c\n#ifdef DEBUG_PRINT\n#define debug_bpf_printk(fmt, ...)                     \\\n    do {                                               \\\n        char s[] = fmt;                                \\\n        bpf_trace_printk(s, sizeof(s), ##__VA_ARGS__); \\\n    } while (0)\n#else\n#define debug_bpf_printk(fmt, ...)\n#endif\n```\n\n**Usage Pattern:**\n```c\ndebug_bpf_printk(\"TLS version :%d\\n\", mastersecret->version);\ndebug_bpf_printk(\"client_random: %x %x %x\\n\", \n    mastersecret->client_random[0], \n    mastersecret->client_random[1],\n    mastersecret->client_random[2]);\n```\n\n**Viewing Output:**\n```bash\n# Read trace_pipe to see bpf_printk output\nsudo cat /sys/kernel/debug/tracing/trace_pipe\n```\n\n### Debugging Workflow\n\n```mermaid\ngraph TB\n    subgraph \"Development Cycle\"\n        WRITE[\"1. Write eBPF Program<br/>Add debug_bpf_printk calls\"]\n        COMPILE[\"2. Compile with DEBUG_PRINT<br/>make DEBUG=1\"]\n        LOAD[\"3. Load Program\"]\n        RUN[\"4. Run Test Application<br/>Trigger probe\"]\n        VIEW[\"5. View trace_pipe<br/>Check debug output\"]\n        VERIFY[\"6. Verify Logic<br/>Check offsets/values\"]\n    end\n    \n    subgraph \"Common Issues\"\n        VERIFIER[\"Verifier Rejection<br/>Check bounds, stack usage\"]\n        OFFSET[\"Wrong Offsets<br/>Structure changed\"]\n        NULL[\"Null Pointers<br/>Invalid memory access\"]\n    end\n    \n    WRITE --> COMPILE\n    COMPILE --> LOAD\n    LOAD --> RUN\n    RUN --> VIEW\n    VIEW --> VERIFY\n    \n    VERIFY -->|\"Verifier error\"| VERIFIER\n    VERIFY -->|\"Wrong values\"| OFFSET\n    VERIFY -->|\"Read failure\"| NULL\n    \n    VERIFIER --> WRITE\n    OFFSET --> WRITE\n    NULL --> WRITE\n```\n\n### Common Debugging Scenarios\n\n**Scenario 1: Verifier Rejection**\n```\n; ret = bpf_probe_read_user(&mastersecret->secret_, sizeof(mastersecret->secret_), ms_ptr);\nR0=inv(id=0) R1_w=map_value(id=0,off=40,ks=4,vs=320,imm=0) \nR2=inv48 R3_w=inv(id=0) R6=ctx(id=0,off=0,imm=0) R10=fp0\n; stack out of bounds\n```\n\n**Solution:** Use map-based allocation pattern instead of stack allocation\n\n**Scenario 2: Read Failures (ret != 0)**\n```c\nret = bpf_probe_read_user(&version, sizeof(version), (void *)ssl_version_ptr);\nif (ret) {\n    debug_bpf_printk(\"bpf_probe_read tls_version failed, ret :%d\\n\", ret);\n    return 0;\n}\n```\n\n**Possible causes:** Invalid pointer, wrong offset, paged-out memory\n\n**Scenario 3: Wrong Structure Offsets**\n\nUse userspace tools to verify offsets:\n- [utils/boringssl-offset.c:1-78]() - Generate BoringSSL offsets\n- Compile against target library headers\n- Compare with eBPF program's offset constants\n\n**Sources:** [kern/common.h:18-26](), [kern/openssl_masterkey.h:97-257]()\n\n---\n\n## Code Organization Patterns\n\n### Structure Declaration Pattern\n\n```mermaid\ngraph TB\n    subgraph \"eBPF Source File Organization\"\n        INCLUDE[\"1. Include Headers<br/>ecapture.h (CO-RE/non-CO-RE)<br/>common.h (constants)\"]\n        \n        CONSTANTS[\"2. Define Constants<br/>TLS1_3_VERSION<br/>SSL3_RANDOM_SIZE<br/>Structure offsets\"]\n        \n        STRUCTS[\"3. Define Event Structures<br/>struct mastersecret_t<br/>struct skb_data_event_t\"]\n        \n        MAPS[\"4. Declare eBPF Maps<br/>BPF_MAP_TYPE_PERF_EVENT_ARRAY<br/>BPF_MAP_TYPE_LRU_HASH\"]\n        \n        HELPERS[\"5. Static Helper Functions<br/>make_event()<br/>skb_revalidate_data()\"]\n        \n        PROBES[\"6. Probe Functions<br/>SEC('uprobe/...')<br/>SEC('kprobe/...')<br/>SEC('classifier')\"]\n    end\n    \n    INCLUDE --> CONSTANTS\n    CONSTANTS --> STRUCTS\n    STRUCTS --> MAPS\n    MAPS --> HELPERS\n    HELPERS --> PROBES\n```\n\n### File Naming Conventions\n\n| Pattern | Purpose | Examples |\n|---------|---------|----------|\n| `*_masterkey.h` | Master secret extraction | `openssl_masterkey.h`, `boringssl_masterkey.h` |\n| `*_const.h` | Offset constants | `boringssl_const.h` |\n| `tc.h` | Traffic control programs | Packet capture and connection tracking |\n| `common.h` | Shared definitions | Constants, macros, license |\n| `ecapture.h` | Main header | Mode switching, includes |\n\n### Multi-Version Support Pattern\n\neCapture maintains separate eBPF programs for different library versions:\n\n```\nkern/\n├── openssl_1_0_2a_kern.c        # OpenSSL 1.0.2a\n├── openssl_1_1_0a_kern.c        # OpenSSL 1.1.0a\n├── openssl_1_1_1j_kern.c        # OpenSSL 1.1.1j\n├── openssl_3_0_0_kern.c         # OpenSSL 3.0.0\n├── openssl_3_2_0_kern.c         # OpenSSL 3.2.0\n├── boringssl_a_13_kern.c        # Android 13 BoringSSL\n├── boringssl_a_14_kern.c        # Android 14 BoringSSL\n└── ...\n```\n\nEach includes version-specific offset constants but shares common logic from header files.\n\n**Sources:** [kern/openssl_masterkey.h:1-257](), [kern/boringssl_masterkey.h:1-403](), [kern/tc.h:1-397]()\n\n---\n\n## Best Practices Summary\n\n| Practice | Rationale | Implementation |\n|----------|-----------|----------------|\n| **Use map-based allocation** | Avoid 512-byte stack limit | `make_event()` pattern |\n| **Always check bpf_probe_read return** | Detect invalid memory access | `if (ret) return 0;` |\n| **Use `__always_inline` for helpers** | Reduce stack usage, improve performance | All helper functions |\n| **Validate pointers before dereferencing** | Prevent verifier rejection | `if (!ptr) return 0;` |\n| **Use `debug_bpf_printk` liberally** | Aid debugging during development | Throughout probe functions |\n| **Apply early filtering** | Minimize overhead | PID/UID checks at function start |\n| **Revalidate SKB data after pulls** | Satisfy verifier for packet access | `skb_revalidate_data()` |\n| **Use CO-RE when possible** | Improve portability | `bpf_core_read()` macros |\n| **Keep probe functions focused** | Reduce complexity, aid verifier | Single responsibility per probe |\n| **Document offset calculations** | Maintain version compatibility | Comments + offset tool |\n\n**Sources:** [kern/common.h:1-85](), [kern/tc.h:1-397](), [kern/openssl_masterkey.h:1-257]()"
          },
          {
            "page_plan": {
              "id": "5.2.1",
              "title": "eBPF Program Structure"
            },
            "content": "# eBPF Program Structure\n\n<details>\n<summary>Relevant source files</summary>\n\nThe following files were used as context for generating this wiki page:\n\n- [kern/bash_kern.c](kern/bash_kern.c)\n- [kern/common.h](kern/common.h)\n- [kern/ecapture.h](kern/ecapture.h)\n- [kern/mysqld_kern.c](kern/mysqld_kern.c)\n- [kern/nspr_kern.c](kern/nspr_kern.c)\n- [kern/postgres_kern.c](kern/postgres_kern.c)\n- [kern/tc.h](kern/tc.h)\n\n</details>\n\n\n\nThis page documents the common structural patterns, conventions, and mechanisms used in eCapture's eBPF programs. It covers map types, probe attachment strategies, event structures, filtering patterns, and data export mechanisms that are shared across all capture modules.\n\nFor information about building and compiling eBPF programs, see [Build System](#5.1). For guidance on calculating structure offsets for library-specific hooks, see [Structure Offset Calculation](#5.2.2). For information about creating new modules that use eBPF programs, see [Adding New Modules](#5.3).\n\n## eBPF Program Anatomy\n\nAll eBPF programs in eCapture follow a common structure consisting of header inclusion, map definitions, event structures, helper functions, and probe entry points. The following diagram illustrates this standard anatomy:\n\n```mermaid\ngraph TB\n    subgraph \"Header Inclusion\"\n        H1[\"ecapture.h<br/>(CO-RE or non-CO-RE setup)\"]\n        H2[\"common.h<br/>(constants, macros)\"]\n        H3[\"tc.h<br/>(TC-specific helpers)\"]\n    end\n    \n    subgraph \"Map Definitions\"\n        M1[\"BPF_MAP_TYPE_PERF_EVENT_ARRAY<br/>events map\"]\n        M2[\"BPF_MAP_TYPE_HASH<br/>state tracking maps\"]\n        M3[\"BPF_MAP_TYPE_PERCPU_ARRAY<br/>heap buffer\"]\n        M4[\"BPF_MAP_TYPE_LRU_HASH<br/>connection tracking\"]\n    end\n    \n    subgraph \"Data Structures\"\n        D1[\"Event Structures<br/>(struct event, ssl_data_event_t, etc)\"]\n        D2[\"Key Structures<br/>(net_id_t, etc)\"]\n        D3[\"Context Structures<br/>(net_ctx_t, etc)\"]\n    end\n    \n    subgraph \"Helper Functions\"\n        F1[\"create_*_event()<br/>event initialization\"]\n        F2[\"process_*_data()<br/>data processing\"]\n        F3[\"filter functions<br/>PID/UID checks\"]\n    end\n    \n    subgraph \"Probe Entry Points\"\n        P1[\"SEC(uprobe/*)<br/>function entry hooks\"]\n        P2[\"SEC(uretprobe/*)<br/>function return hooks\"]\n        P3[\"SEC(kprobe/*)<br/>kernel hooks\"]\n        P4[\"SEC(classifier)<br/>TC classifiers\"]\n    end\n    \n    H1 --> M1\n    H2 --> M1\n    H3 --> M4\n    M1 --> D1\n    M2 --> D1\n    D1 --> F1\n    F1 --> P1\n    F1 --> P2\n    P1 --> P2\n    P3 --> M4\n    P4 --> M4\n```\n\nSources: [kern/ecapture.h](), [kern/common.h](), [kern/bash_kern.c](), [kern/nspr_kern.c](), [kern/mysqld_kern.c](), [kern/postgres_kern.c](), [kern/tc.h]()\n\n## Header Files and Compilation Modes\n\neCapture supports two eBPF compilation modes: CO-RE (Compile Once - Run Everywhere) and non-CO-RE. The mode is determined by the presence of the `NOCORE` preprocessor define.\n\n### CO-RE Mode (BTF-enabled)\n\nWhen CO-RE is enabled (no `NOCORE` define), programs use:\n- `vmlinux.h` - kernel type definitions from BTF\n- `bpf/bpf_core_read.h` - CO-RE field access macros\n- `core_fixes.bpf.h` - workarounds for kernel compatibility issues\n\n### Non-CO-RE Mode (Traditional)\n\nWhen `NOCORE` is defined, programs use:\n- Kernel headers from the build system\n- Traditional `bpf_probe_read()` helpers\n- Architecture-specific structure definitions\n\nBoth modes include:\n- `bpf/bpf_helpers.h` - BPF helper function declarations\n- `bpf/bpf_tracing.h` - tracing macros like `PT_REGS_PARM*`\n- `bpf/bpf_endian.h` - endianness conversion helpers\n\n**Header Inclusion Pattern:**\n\n```\necapture.h includes:\n├── CO-RE mode (#ifndef NOCORE)\n│   ├── vmlinux.h\n│   ├── bpf/bpf_core_read.h\n│   ├── bpf/bpf_helpers.h\n│   ├── bpf/bpf_tracing.h\n│   ├── bpf/bpf_endian.h\n│   └── core_fixes.bpf.h\n├── Non-CO-RE mode (#ifdef NOCORE)\n│   ├── linux/types.h\n│   ├── uapi/linux/ptrace.h\n│   ├── linux/bpf.h\n│   ├── linux/socket.h\n│   ├── net/sock.h\n│   ├── bpf/bpf_helpers.h\n│   ├── bpf/bpf_tracing.h\n│   ├── bpf/bpf_endian.h\n│   └── uapi/linux/pkt_cls.h (for TC programs)\n└── common.h (always included)\n```\n\nSources: [kern/ecapture.h:15-93](), [kern/common.h:15-85]()\n\n## Map Types and Usage Patterns\n\neCapture eBPF programs use several BPF map types, each serving a specific purpose in the data flow from kernel to userspace.\n\n```mermaid\ngraph LR\n    subgraph \"Probe Functions\"\n        ENTRY[\"uprobe/kprobe entry<br/>Capture arguments\"]\n        EXIT[\"uretprobe/kretprobe return<br/>Capture return values\"]\n    end\n    \n    subgraph \"Map Types\"\n        PERF[\"BPF_MAP_TYPE_PERF_EVENT_ARRAY<br/>Send events to userspace\"]\n        HASH[\"BPF_MAP_TYPE_HASH<br/>Store state between entry/return<br/>Key: pid/tid\"]\n        PERCPU[\"BPF_MAP_TYPE_PERCPU_ARRAY<br/>Per-CPU heap allocation<br/>Avoid 512-byte stack limit\"]\n        LRU[\"BPF_MAP_TYPE_LRU_HASH<br/>Connection tracking<br/>Auto-eviction\"]\n    end\n    \n    subgraph \"Userspace\"\n        READER[\"Event readers<br/>perfEventReader<br/>ringbufEventReader\"]\n    end\n    \n    ENTRY -->|\"store args\"| HASH\n    ENTRY -->|\"allocate buffer\"| PERCPU\n    EXIT -->|\"lookup args\"| HASH\n    EXIT -->|\"delete state\"| HASH\n    PERCPU -->|\"build event\"| PERF\n    HASH -->|\"build event\"| PERF\n    PERF -->|\"bpf_perf_event_output()\"| READER\n    \n    TC[\"TC classifier<br/>capture_packets()\"] -->|\"lookup conn\"| LRU\n    KPROBE[\"kprobe tcp_sendmsg<br/>udp_sendmsg\"] -->|\"store conn\"| LRU\n```\n\n### BPF_MAP_TYPE_PERF_EVENT_ARRAY\n\nUsed for sending captured events from kernel to userspace. Each module defines one or more perf event arrays:\n\n| Module | Map Name | Event Type |\n|--------|----------|------------|\n| bash | `events` | `struct event` |\n| nspr | `nspr_events` | `struct ssl_data_event_t` |\n| mysqld | `events` | `struct data_t` |\n| postgres | `events` | `struct data_t` |\n| tc | `skb_events` | `struct skb_data_event_t` |\n\n**Definition Pattern:**\n```c\nstruct {\n    __uint(type, BPF_MAP_TYPE_PERF_EVENT_ARRAY);\n    __uint(key_size, sizeof(u32));\n    __uint(value_size, sizeof(u32));\n    __uint(max_entries, 1024);\n} events SEC(\".maps\");\n```\n\nSources: [kern/bash_kern.c:26-31](), [kern/nspr_kern.c:29-34](), [kern/mysqld_kern.c:36-41](), [kern/postgres_kern.c:24-29](), [kern/tc.h:57-62]()\n\n### BPF_MAP_TYPE_HASH\n\nUsed for storing state between probe entry and return, typically mapping thread ID to captured arguments:\n\n**Common Pattern - Argument Storage:**\n```c\n// Store buffer pointer at function entry\nstruct {\n    __uint(type, BPF_MAP_TYPE_HASH);\n    __type(key, u64);              // pid_tgid\n    __type(value, const char*);    // buffer pointer\n    __uint(max_entries, 1024);\n} active_ssl_read_args_map SEC(\".maps\");\n\n// Store complete event for return value tracking\nstruct {\n    __uint(type, BPF_MAP_TYPE_HASH);\n    __type(key, u32);              // pid\n    __type(value, struct event);\n    __uint(max_entries, 1024);\n} events_t SEC(\".maps\");\n```\n\n**Lifecycle Pattern:**\n1. Entry probe: `bpf_map_update_elem(&map, &key, &value, BPF_ANY)`\n2. Return probe: `bpf_map_lookup_elem(&map, &key)`\n3. Return probe: `bpf_map_delete_elem(&map, &key)` (cleanup)\n\nSources: [kern/nspr_kern.c:41-53](), [kern/bash_kern.c:33-38](), [kern/mysqld_kern.c:29-34]()\n\n### BPF_MAP_TYPE_PERCPU_ARRAY\n\nUsed as a per-CPU heap to avoid the 512-byte BPF stack limit. Allows allocating large event structures:\n\n```c\nstruct {\n    __uint(type, BPF_MAP_TYPE_PERCPU_ARRAY);\n    __type(key, u32);\n    __type(value, struct ssl_data_event_t);  // Can be > 512 bytes\n    __uint(max_entries, 1);\n} data_buffer_heap SEC(\".maps\");\n\n// Usage in helper function:\nstatic __inline struct ssl_data_event_t* create_ssl_data_event(u64 current_pid_tgid) {\n    u32 kZero = 0;\n    struct ssl_data_event_t* event = bpf_map_lookup_elem(&data_buffer_heap, &kZero);\n    if (event == NULL) {\n        return NULL;\n    }\n    // Initialize event fields...\n    return event;\n}\n```\n\nSources: [kern/nspr_kern.c:57-62,68-80](), [kern/tc.h:64-69,92-100]()\n\n### BPF_MAP_TYPE_LRU_HASH\n\nUsed for connection tracking in TC programs. Automatically evicts least-recently-used entries when full:\n\n```c\nstruct {\n    __uint(type, BPF_MAP_TYPE_LRU_HASH);\n    __type(key, struct net_id_t);      // 4-tuple + protocol\n    __type(value, struct net_ctx_t);    // pid, uid, comm\n    __uint(max_entries, 10240);\n} network_map SEC(\".maps\");\n```\n\nThis map is populated by kprobes on `tcp_sendmsg`/`udp_sendmsg` and queried by TC classifiers to attribute packets to processes.\n\nSources: [kern/tc.h:72-77,290-347,349-397]()\n\n## Event Structures\n\nEach eBPF program defines event structures that match the data captured. These structures have size constraints based on the data they carry.\n\n### Event Structure Pattern\n\n```mermaid\ngraph TB\n    subgraph \"Common Fields\"\n        F1[\"type: u32<br/>Event type identifier\"]\n        F2[\"pid: u32/u64<br/>Process ID\"]\n        F3[\"uid: u32<br/>User ID\"]\n        F4[\"timestamp: u64<br/>Nanosecond timestamp\"]\n        F5[\"comm: char[16]<br/>Process name\"]\n    end\n    \n    subgraph \"Payload Fields\"\n        P1[\"data/query/line: char[]<br/>Captured data<br/>Size limited by MAX_DATA_SIZE_*\"]\n        P2[\"len/data_len: u32/s32<br/>Actual data length\"]\n        P3[\"retval: s8/u8<br/>Return value\"]\n    end\n    \n    subgraph \"Size Limits (common.h)\"\n        L1[\"MAX_DATA_SIZE_OPENSSL: 16384<br/>(16 KB TLS record limit)\"]\n        L2[\"MAX_DATA_SIZE_MYSQL: 256\"]\n        L3[\"MAX_DATA_SIZE_POSTGRES: 256\"]\n        L4[\"MAX_DATA_SIZE_BASH: 256\"]\n        L5[\"SKB_MAX_DATA_SIZE: 2048\"]\n    end\n    \n    F1 --> P1\n    F2 --> P1\n    F3 --> P1\n    F4 --> P1\n    F5 --> P1\n    L1 --> P1\n    L2 --> P1\n    L3 --> P1\n    L4 --> P1\n    L5 --> P1\n```\n\n### Event Structure Examples\n\n| Module | Structure | Data Field | Max Size |\n|--------|-----------|------------|----------|\n| bash | `struct event` | `line[256]` | 256 bytes |\n| nspr | `struct ssl_data_event_t` | `data[16384]` | 16 KB |\n| mysqld | `struct data_t` | `query[256]` | 256 bytes |\n| postgres | `struct data_t` | `query[256]` | 256 bytes |\n| tc | `struct skb_data_event_t` | (no data, uses perf flags) | 36 bytes (header only) |\n\n**Size Rationale:**\n- TLS/SSL modules use `MAX_DATA_SIZE_OPENSSL` (16384) to accommodate maximum TLS record size per RFC 5246\n- Database modules use smaller buffers (256) since only query text is captured\n- Shell modules use 256 bytes for command lines\n- TC module sends minimal metadata and uses `bpf_perf_event_output()` flags to include packet data\n\nSources: [kern/common.h:28-43](), [kern/bash_kern.c:17-24](), [kern/nspr_kern.c:19-27](), [kern/mysqld_kern.c:19-27](), [kern/postgres_kern.c:17-22](), [kern/tc.h:30-37]()\n\n## Probe Attachment and SEC() Macros\n\nThe `SEC()` macro defines the probe type and attachment point. eCapture uses four primary probe types:\n\n```mermaid\ngraph TB\n    subgraph \"Userspace Probes\"\n        U1[\"SEC(uprobe/function_name)<br/>Entry point hook<br/>Captures arguments\"]\n        U2[\"SEC(uretprobe/function_name)<br/>Return point hook<br/>Captures return value\"]\n    end\n    \n    subgraph \"Kernel Probes\"\n        K1[\"SEC(kprobe/kernel_function)<br/>Kernel function entry<br/>E.g., tcp_sendmsg\"]\n        K2[\"SEC(kretprobe/kernel_function)<br/>Kernel function return<br/>(rarely used in eCapture)\"]\n    end\n    \n    subgraph \"Network Probes\"\n        N1[\"SEC(classifier)<br/>TC ingress/egress<br/>Packet interception\"]\n    end\n    \n    U1 -->|\"store args in map\"| U2\n    U2 -->|\"lookup args from map\"| EVENT[\"Send event<br/>bpf_perf_event_output()\"]\n    K1 -->|\"populate map\"| N1\n    N1 -->|\"lookup map for attribution\"| EVENT\n```\n\n### Uprobe/Uretprobe Pattern\n\nMost eCapture modules follow the entry/return probe pair pattern:\n\n```\nEntry Probe (uprobe):\n1. Extract function arguments using PT_REGS_PARM* macros\n2. Store arguments in hash map (key: pid/tid)\n3. Optionally: filter by PID/UID\n4. Return\n\nReturn Probe (uretprobe):\n1. Extract return value using PT_REGS_RC()\n2. Lookup stored arguments from hash map\n3. Combine arguments + return value into event\n4. Send event via bpf_perf_event_output()\n5. Delete map entry for cleanup\n```\n\n**Example - NSPR SSL_write:**\n- Entry: `SEC(\"uprobe/PR_Write\")` stores buffer pointer\n- Return: `SEC(\"uretprobe/PR_Write\")` reads buffer content and length\n\nSources: [kern/nspr_kern.c:114-162]()\n\n**Example - Bash readline:**\n- Entry: Not hooked (function pointer from readline library)\n- Return: `SEC(\"uretprobe/bash_readline\")` captures returned string\n- Additional: `SEC(\"uretprobe/bash_retval\")` captures command exit status\n\nSources: [kern/bash_kern.c:42-112]()\n\n### Kprobe Usage\n\neCapture uses kprobes primarily for connection tracking, not data capture:\n\n```c\nSEC(\"kprobe/tcp_sendmsg\")\nint tcp_sendmsg(struct pt_regs *ctx) {\n    // Extract socket structure\n    struct sock *sk = (struct sock *)PT_REGS_PARM1(ctx);\n    \n    // Read connection 4-tuple from socket\n    bpf_probe_read(&family, sizeof(family), &sk->__sk_common.skc_family);\n    bpf_probe_read(&lport, sizeof(lport), &sk->__sk_common.skc_num);\n    bpf_probe_read(&dport, sizeof(dport), &sk->__sk_common.skc_dport);\n    bpf_probe_read(&src_ip4, sizeof(src_ip4), &sk->__sk_common.skc_rcv_saddr);\n    bpf_probe_read(&dst_ip4, sizeof(dst_ip4), &sk->__sk_common.skc_daddr);\n    \n    // Store pid/uid/comm associated with connection\n    struct net_ctx_t net_ctx = {.pid = pid, .uid = uid};\n    bpf_get_current_comm(&net_ctx.comm, sizeof(net_ctx.comm));\n    bpf_map_update_elem(&network_map, &conn_id, &net_ctx, BPF_ANY);\n}\n```\n\nThe same pattern is used for `udp_sendmsg`. The TC classifier later uses this map to attribute packets to processes.\n\nSources: [kern/tc.h:290-347,349-397]()\n\n### TC Classifier Pattern\n\nTC classifiers (`SEC(\"classifier\")`) are attached to network interfaces for packet capture:\n\n```c\nSEC(\"classifier\")\nint egress_cls_func(struct __sk_buff *skb) {\n    return capture_packets(skb, false);  // false = egress\n}\n\nSEC(\"classifier\")\nint ingress_cls_func(struct __sk_buff *skb) {\n    return capture_packets(skb, true);   // true = ingress\n}\n```\n\nThe `capture_packets()` function:\n1. Parses Ethernet, IP, and TCP/UDP headers\n2. Extracts 4-tuple (src_ip, dst_ip, src_port, dst_port)\n3. Looks up connection in `network_map` (populated by kprobes)\n4. Applies PID/UID filters if connection found\n5. Sends packet metadata + data via `bpf_perf_event_output()`\n\nSources: [kern/tc.h:135-289]()\n\n## PID/UID Filtering\n\neCapture supports optional filtering by process ID and user ID. The filtering mechanism depends on kernel version:\n\n```mermaid\ngraph TB\n    START[\"Probe Entry\"]\n    \n    KERNEL_CHECK{\"Kernel >= 5.2?<br/>(#ifndef KERNEL_LESS_5_2)\"}\n    \n    OLD_KERNEL[\"Skip filtering<br/>(rodata not supported)\"]\n    NEW_KERNEL[\"Check rodata variables\"]\n    \n    PID_CHECK{\"target_pid != 0 &&<br/>target_pid != current_pid?\"}\n    UID_CHECK{\"target_uid != 0 &&<br/>target_uid != current_uid?\"}\n    \n    SKIP[\"return 0<br/>(skip this event)\"]\n    CONTINUE[\"Continue processing\"]\n    \n    START --> KERNEL_CHECK\n    KERNEL_CHECK -->|\"< 5.2\"| OLD_KERNEL\n    KERNEL_CHECK -->|\">= 5.2\"| NEW_KERNEL\n    \n    OLD_KERNEL --> CONTINUE\n    NEW_KERNEL --> PID_CHECK\n    \n    PID_CHECK -->|\"yes\"| SKIP\n    PID_CHECK -->|\"no\"| UID_CHECK\n    \n    UID_CHECK -->|\"yes\"| SKIP\n    UID_CHECK -->|\"no\"| CONTINUE\n```\n\n### Read-Only Data Variables (Kernel >= 5.2)\n\nFor kernels that support BTF and rodata, filter targets are defined as constants in `common.h`:\n\n```c\n#ifndef KERNEL_LESS_5_2\nconst volatile u64 target_pid = 0;  // 0 = capture all processes\nconst volatile u64 target_uid = 0;  // 0 = capture all users\nconst volatile u64 target_errno = BASH_ERRNO_DEFAULT;\n#endif\n```\n\nThese variables are marked `const volatile` so the BPF verifier can optimize them but userspace can still modify them before program loading. When set to 0, no filtering is applied.\n\nSources: [kern/common.h:64-71]()\n\n### Filter Application Pattern\n\nStandard filtering code appears in every probe:\n\n```c\nu64 current_pid_tgid = bpf_get_current_pid_tgid();\nu32 pid = current_pid_tgid >> 32;\nu64 current_uid_gid = bpf_get_current_uid_gid();\nu32 uid = current_uid_gid;\n\n#ifndef KERNEL_LESS_5_2\n    if (target_pid != 0 && target_pid != pid) {\n        return 0;  // Skip this event\n    }\n    if (target_uid != 0 && target_uid != uid) {\n        return 0;  // Skip this event\n    }\n#endif\n```\n\nThe filter checks are omitted for kernels < 5.2 (when `KERNEL_LESS_5_2` is defined during compilation).\n\nSources: [kern/bash_kern.c:44-57](), [kern/nspr_kern.c:116-130](), [kern/mysqld_kern.c:64-77](), [kern/postgres_kern.c:37-49]()\n\n### Special Case - Bash Return Value Filtering\n\nThe bash module includes an additional filter for command exit codes:\n\n```c\n#ifndef KERNEL_LESS_5_2\n    if (target_errno != BASH_ERRNO_DEFAULT && target_errno != retval) {\n        // Command exit code doesn't match target\n        if (event_p) {\n            // Send event with default errno to indicate mismatch\n            event_p->retval = BASH_ERRNO_DEFAULT;\n            event_p->type = BASH_EVENT_TYPE_RETVAL;\n            bpf_perf_event_output(ctx, &events, BPF_F_CURRENT_CPU, event_p, \n                                  sizeof(struct event));\n            bpf_map_delete_elem(&events_t, &pid);\n        }\n        return 0;\n    }\n#endif\n```\n\nWhen `target_errno` is set to a value other than `BASH_ERRNO_DEFAULT` (128), only commands with that exit code are fully captured.\n\nSources: [kern/bash_kern.c:79-102](), [kern/common.h:51,69]()\n\n## Data Extraction Patterns\n\neCapture uses different BPF helpers to read data depending on the source location.\n\n### Reading from User Space\n\nFor data in userspace memory (function arguments, buffers):\n\n```c\n// Read into local variable\nchar buf[256];\nbpf_probe_read_user(buf, sizeof(buf), user_ptr);\n\n// Read into event structure\nbpf_probe_read_user(&event.data, event.data_len, buf_ptr);\n\n// Read struct members\nstruct COM_QUERY_DATA query;\nbpf_probe_read_user(&query, sizeof(query), st);\nbpf_probe_read_user(&data.query, sizeof(data.query), query.query);\n```\n\nSources: [kern/bash_kern.c:64](), [kern/nspr_kern.c:101](), [kern/mysqld_kern.c:214-216]()\n\n### Reading from Kernel Space\n\nFor kernel structures (sockets, tasks):\n\n```c\n// Read socket family\nu16 family;\nbpf_probe_read(&family, sizeof(family), &sk->__sk_common.skc_family);\n\n// Read IP addresses\nu32 src_ip4, dst_ip4;\nbpf_probe_read(&src_ip4, sizeof(src_ip4), &sk->__sk_common.skc_rcv_saddr);\nbpf_probe_read(&dst_ip4, sizeof(dst_ip4), &sk->__sk_common.skc_daddr);\n\n// CO-RE alternative (when BTF available):\nfamily = BPF_CORE_READ(sk, __sk_common.skc_family);\n```\n\nSources: [kern/tc.h:311-336]()\n\n### Reading from pt_regs\n\nFunction arguments and return values are extracted from `struct pt_regs`:\n\n```c\n// Function arguments (x86_64):\nvoid *arg1 = (void *)PT_REGS_PARM1(ctx);\nvoid *arg2 = (void *)PT_REGS_PARM2(ctx);\nvoid *arg3 = (void *)PT_REGS_PARM3(ctx);\nu64 arg4 = (u64)PT_REGS_PARM4(ctx);\n\n// Return value:\nint retval = (int)PT_REGS_RC(ctx);\n```\n\nThe `PT_REGS_PARM*` and `PT_REGS_RC` macros are architecture-aware and defined in `bpf/bpf_tracing.h`. They abstract register access for x86_64, aarch64, etc.\n\nSources: [kern/bash_kern.c:64,77](), [kern/nspr_kern.c:87,132](), [kern/mysqld_kern.c:59,79]()\n\n### Getting Process Information\n\nStandard helpers for retrieving process context:\n\n```c\n// Get PID and TID\nu64 pid_tgid = bpf_get_current_pid_tgid();\nu32 pid = pid_tgid >> 32;\nu32 tid = pid_tgid & 0xFFFFFFFF;\n\n// Get UID and GID\nu64 uid_gid = bpf_get_current_uid_gid();\nu32 uid = uid_gid;\nu32 gid = uid_gid >> 32;\n\n// Get process name\nchar comm[TASK_COMM_LEN];  // TASK_COMM_LEN = 16\nbpf_get_current_comm(&comm, sizeof(comm));\n\n// Get timestamp\nu64 timestamp_ns = bpf_ktime_get_ns();\n```\n\nSources: [kern/bash_kern.c:44-46,65](), [kern/nspr_kern.c:76-78]()\n\n## Helper Functions\n\neBPF programs define helper functions to avoid code duplication and stay within the BPF complexity limits.\n\n### Event Creation Helpers\n\nAllocate events from per-CPU heap and initialize common fields:\n\n```c\nstatic __inline struct ssl_data_event_t* create_ssl_data_event(u64 current_pid_tgid) {\n    u32 kZero = 0;\n    struct ssl_data_event_t* event = bpf_map_lookup_elem(&data_buffer_heap, &kZero);\n    if (event == NULL) {\n        return NULL;\n    }\n    \n    const u32 kMask32b = 0xffffffff;\n    event->timestamp_ns = bpf_ktime_get_ns();\n    event->pid = current_pid_tgid >> 32;\n    event->tid = current_pid_tgid & kMask32b;\n    return event;\n}\n```\n\nSources: [kern/nspr_kern.c:68-80](), [kern/tc.h:92-100]()\n\n### Data Processing Helpers\n\nCentralize common processing logic:\n\n```c\nstatic int process_SSL_data(struct pt_regs* ctx, u64 id, \n                           enum ssl_data_event_type type, const char* buf) {\n    // Get return value (bytes read/written)\n    int len = (int)PT_REGS_RC(ctx);\n    if (len < 0) {\n        return 0;\n    }\n    \n    // Create event\n    struct ssl_data_event_t* event = create_ssl_data_event(id);\n    if (event == NULL) {\n        return 0;\n    }\n    \n    // Fill event fields\n    event->type = type;\n    event->data_len = (len < MAX_DATA_SIZE_OPENSSL ? \n                       (len & (MAX_DATA_SIZE_OPENSSL - 1)) : \n                       MAX_DATA_SIZE_OPENSSL);\n    bpf_probe_read_user(event->data, event->data_len, buf);\n    bpf_get_current_comm(&event->comm, sizeof(event->comm));\n    \n    // Send to userspace\n    bpf_perf_event_output(ctx, &nspr_events, BPF_F_CURRENT_CPU, \n                         event, sizeof(struct ssl_data_event_t));\n    return 0;\n}\n```\n\nSources: [kern/nspr_kern.c:86-105]()\n\n### Packet Validation Helpers\n\nTC programs need to handle packet boundary checks:\n\n```c\nstatic __always_inline bool skb_revalidate_data(struct __sk_buff *skb,\n                                                uint8_t **head, uint8_t **tail,\n                                                const u32 offset) {\n    if (*head + offset > *tail) {\n        // Need to pull more data into linear section\n        if (bpf_skb_pull_data(skb, offset) < 0) {\n            return false;\n        }\n        \n        // Update pointers after pull\n        *head = (uint8_t *)(long)skb->data;\n        *tail = (uint8_t *)(long)skb->data_end;\n        \n        // Verify offset is now accessible\n        if (*head + offset > *tail) {\n            return false;\n        }\n    }\n    \n    return true;\n}\n```\n\nThis helper ensures packet data is accessible before dereferencing, required for BPF verifier to prove safety.\n\nSources: [kern/tc.h:102-119]()\n\n### PCAP Filter Injection Point\n\neCapture supports injecting pcap-filter expressions as eBPF code. The injection point is marked with a stub function:\n\n```c\n// Stub function for pcap-filter injection\nstatic __noinline bool filter_pcap_ebpf_l2(void *_skb, void *__skb,\n                                           void *___skb, void *data,\n                                           void* data_end) {\n    return data != data_end && _skb == __skb && __skb == ___skb;\n}\n\nstatic __always_inline bool filter_pcap_l2(struct __sk_buff *skb, void *data,\n                                           void *data_end) {\n    return filter_pcap_ebpf_l2((void *) skb, (void *) skb, (void *) skb, data,\n                               data_end);\n}\n```\n\nThe `__noinline` attribute prevents inlining, allowing the userspace program to replace this function's bytecode with compiled pcap-filter logic.\n\nSources: [kern/tc.h:121-132]()\n\n## Event Output Mechanisms\n\nEvents are sent from kernel to userspace via `bpf_perf_event_output()`.\n\n### Standard Event Output\n\n```c\nbpf_perf_event_output(ctx, &events, BPF_F_CURRENT_CPU, &event, sizeof(event));\n```\n\nParameters:\n- `ctx` - probe context (`struct pt_regs*` or `struct __sk_buff*`)\n- `&events` - perf event array map\n- `BPF_F_CURRENT_CPU` - send to current CPU's perf buffer\n- `&event` - pointer to event structure\n- `sizeof(event)` - size to copy\n\nSources: [kern/bash_kern.c:67](), [kern/nspr_kern.c:103](), [kern/mysqld_kern.c:139,263](), [kern/postgres_kern.c:58]()\n\n### Variable-Size Event Output\n\nFor events with variable-length data, adjust the size parameter:\n\n```c\n// MySQL: only send actual query length\nsize_t event_size = sizeof(struct data_t);\nbpf_perf_event_output(ctx, &events, BPF_F_CURRENT_CPU, data, event_size);\n\n// TC: send minimal header + use flags for packet data\nu64 flags = BPF_F_CURRENT_CPU;\nflags |= (u64)skb->len << 32;  // Encode packet length in upper 32 bits\nsize_t pkt_size = TC_PACKET_MIN_SIZE;  // 36 bytes\nbpf_perf_event_output(skb, &skb_events, flags, &event, pkt_size);\n```\n\nThe TC approach encodes the packet length in the flags parameter, allowing the kernel to append packet data to the perf event without copying it into an event structure.\n\nSources: [kern/tc.h:260-271]()\n\n## Debugging\n\neCapture provides conditional debug output using BPF trace printk.\n\n### Debug Macro\n\n```c\n#ifdef DEBUG_PRINT\n#define debug_bpf_printk(fmt, ...)                     \\\n    do {                                               \\\n        char s[] = fmt;                                \\\n        bpf_trace_printk(s, sizeof(s), ##__VA_ARGS__); \\\n    } while (0)\n#else\n#define debug_bpf_printk(fmt, ...)\n#endif\n```\n\nWhen `DEBUG_PRINT` is defined during compilation, debug messages are written to `/sys/kernel/debug/tracing/trace_pipe`. When not defined, the macro compiles to nothing (zero overhead).\n\nSources: [kern/common.h:18-26]()\n\n### Debug Usage Examples\n\n```c\ndebug_bpf_printk(\"nspr uprobe/PR_Write pid :%d\\n\", pid);\ndebug_bpf_printk(\"capture packet process found, pid: %d, comm :%s\\n\", \n                 event.pid, event.comm);\ndebug_bpf_printk(\"mysql query:%s\\n\", data->query);\ndebug_bpf_printk(\"tcp_sendmsg pid : %d, comm :%s\\n\", net_ctx.pid, net_ctx.comm);\n```\n\nDebug statements help trace program execution, verify filters, and diagnose issues without modifying the main logic.\n\nSources: [kern/nspr_kern.c:120](), [kern/tc.h:253](), [kern/mysqld_kern.c:136](), [kern/tc.h:344]()\n\n## License and Version Metadata\n\nAll eBPF programs must include license and version information:\n\n```c\nchar __license[] SEC(\"license\") = \"Dual MIT/GPL\";\n__u32 _version SEC(\"version\") = 0xFFFFFFFE;\n```\n\n- License must be GPL-compatible for using GPL-only BPF helpers\n- Version `0xFFFFFFFE` is a special value indicating the program works across kernel versions\n\nSources: [kern/common.h:82-83]()\n\n## Summary Table: Common Patterns\n\n| Pattern | Location | Purpose |\n|---------|----------|---------|\n| `struct { __uint(type, BPF_MAP_TYPE_*); } map SEC(\".maps\")` | All modules | Define BPF maps |\n| `SEC(\"uprobe/function\")` / `SEC(\"uretprobe/function\")` | TLS, shell, DB modules | Hook userspace functions |\n| `SEC(\"kprobe/function\")` | tc.h | Hook kernel functions |\n| `SEC(\"classifier\")` | tc.h | TC packet capture |\n| `#ifndef KERNEL_LESS_5_2` ... `#endif` | All modules | Kernel version-specific code |\n| `const volatile u64 target_pid` | common.h | Filtering targets (rodata) |\n| `bpf_get_current_pid_tgid()` | All modules | Get PID/TID |\n| `bpf_get_current_uid_gid()` | All modules | Get UID/GID |\n| `PT_REGS_PARM*()` / `PT_REGS_RC()` | All modules | Extract function args/return |\n| `bpf_probe_read_user()` | All modules | Read userspace memory |\n| `bpf_probe_read()` / `BPF_CORE_READ()` | tc.h | Read kernel memory |\n| `bpf_map_update_elem()` | All modules | Store state |\n| `bpf_map_lookup_elem()` | All modules | Retrieve state |\n| `bpf_map_delete_elem()` | All modules | Cleanup state |\n| `bpf_perf_event_output()` | All modules | Send events to userspace |\n| `BPF_MAP_TYPE_PERCPU_ARRAY` | nspr, tc | Avoid stack limit |\n| `static __always_inline` / `static __inline` | All modules | Helper functions |\n| `debug_bpf_printk()` | All modules | Conditional debug output |\n\nSources: All kern/*.c and kern/*.h files referenced throughout this document."
          },
          {
            "page_plan": {
              "id": "5.2.2",
              "title": "Structure Offset Calculation"
            },
            "content": "# Structure Offset Calculation\n\n<details>\n<summary>Relevant source files</summary>\n\nThe following files were used as context for generating this wiki page:\n\n- [kern/boringssl_const.h](kern/boringssl_const.h)\n- [kern/boringssl_masterkey.h](kern/boringssl_masterkey.h)\n- [kern/openssl_masterkey.h](kern/openssl_masterkey.h)\n- [kern/openssl_masterkey_3.0.h](kern/openssl_masterkey_3.0.h)\n- [user/module/probe_openssl_lib.go](user/module/probe_openssl_lib.go)\n- [utils/boringssl-offset.c](utils/boringssl-offset.c)\n- [variables.mk](variables.mk)\n\n</details>\n\n\n\n## Purpose and Scope\n\nThis document explains the techniques used in eCapture to calculate memory offsets within SSL/TLS library structures for eBPF programs. Structure offset calculation is necessary because eBPF programs must read internal, non-public structures from OpenSSL and BoringSSL, which change between versions. \n\nFor general eBPF program structure, see [eBPF Program Structure](#5.2.1). For adding new capture modules, see [Adding New Modules](#5.3). For the version detection system that uses these offsets, see [Version Detection and Bytecode Selection](#2.5).\n\n---\n\n## The Offset Problem\n\neBPF programs attached to SSL/TLS functions need to extract cryptographic keys and session data from internal library structures. These structures are not part of the public API and their memory layout varies across versions. The challenge has three dimensions:\n\n**Version Diversity**: eCapture supports OpenSSL 1.0.2 through 3.5.x and BoringSSL Android 13-16, with each version potentially having different structure layouts [user/module/probe_openssl_lib.go:30-62]().\n\n**Public vs Private Fields**: Some critical fields are marked `private` in C++, making them inaccessible to standard offset calculation tools [kern/boringssl_const.h:11-27]().\n\n**Compile-Time Requirements**: eBPF bytecode must embed offset values at compile time since runtime introspection is not possible in the kernel.\n\n```mermaid\ngraph TB\n    subgraph \"Runtime Challenge\"\n        APP[\"Application<br/>OpenSSL 3.2.0\"]\n        MEM[\"Memory Layout<br/>ssl_st at 0x7fff000\"]\n        FIELD[\"version at +0x10<br/>s3 at +0x30<br/>session at +0x38\"]\n    end\n    \n    subgraph \"eBPF Requirement\"\n        BPF[\"eBPF Program<br/>probe_ssl_master_key\"]\n        OFFSET[\"Hardcoded Offsets<br/>#define SSL_ST_VERSION 0x10<br/>#define SSL_ST_S3 0x30\"]\n        READ[\"bpf_probe_read_user<br/>ptr + offset\"]\n    end\n    \n    subgraph \"Problem Space\"\n        V1[\"OpenSSL 1.1.1<br/>s3 at +0x28\"]\n        V2[\"OpenSSL 3.0.0<br/>s3 at +0x30\"]\n        V3[\"OpenSSL 3.2.0<br/>s3 at +0x38\"]\n        MISMATCH[\"❌ Wrong offset = crash<br/>or garbage data\"]\n    end\n    \n    APP --> MEM\n    MEM --> FIELD\n    \n    BPF --> OFFSET\n    OFFSET --> READ\n    READ -.->|must match| FIELD\n    \n    V1 --> MISMATCH\n    V2 --> MISMATCH\n    V3 --> MISMATCH\n    MISMATCH -.->|requires| OFFSET\n    \n    style MISMATCH fill:#fff,stroke:#333,stroke-width:2px\n```\n\n**Diagram: The Offset Mismatch Problem**\n\nSources: [kern/boringssl_masterkey.h:169-257](), [user/module/probe_openssl_lib.go:73-187]()\n\n---\n\n## Offset Calculation Techniques\n\n### Using offsetof() with Library Headers\n\nThe primary method for calculating offsets is using the C `offsetof()` macro with the actual library headers. The utility program [utils/boringssl-offset.c]() demonstrates this approach:\n\n| Technique | Description | Example |\n|-----------|-------------|---------|\n| **Macro Definition** | Define structure/field pairs to process | `X(ssl_st, version)` |\n| **offsetof() Application** | Standard C macro calculates offset | `offsetof(struct ssl_st, version)` |\n| **Code Generation** | Output C preprocessor defines | `#define SSL_ST_VERSION 0x10` |\n\n**Key Implementation**:\n\n```c\n#define SSL_STRUCT_OFFSETS                   \\\n    X(ssl_st, version)                       \\\n    X(ssl_st, session)                       \\\n    X(ssl_st, s3)                            \\\n    X(ssl_session_st, secret_length)         \\\n    X(ssl_session_st, secret)\n```\n\nThe `X` macro pattern enables iteration over all structure/field pairs [utils/boringssl-offset.c:23-46](). Each pair is processed to generate offset defines:\n\n```c\n#define X(struct_name, field_name) \\\n    format(#struct_name, #field_name, offsetof(struct struct_name, field_name));\nSSL_STRUCT_OFFSETS\n#undef X\n```\n\nThis technique requires:\n1. Access to library headers during build\n2. Compilation against specific library versions\n3. Separate compilation for each supported version\n\nSources: [utils/boringssl-offset.c:1-78]()\n\n---\n\n### Manual Calculation for Private Fields\n\nBoringSSL uses C++ private fields for TLS 1.3 secrets, making them inaccessible to `offsetof()`. The solution is manual offset calculation based on memory layout analysis:\n\n```mermaid\ngraph LR\n    subgraph \"SSL_HANDSHAKE Structure Layout\"\n        PUBLIC[\"Public Fields<br/>max_version (uint16_t)<br/>offset: 0x00\"]\n        PADDING[\"Alignment Padding<br/>6 bytes\"]\n        PRIVATE_START[\"Private Section Start<br/>offset: 0x08\"]\n        HASH_LEN[\"hash_len_<br/>size_t (8 bytes)<br/>offset: 0x08\"]\n        SECRET[\"secret_[48]<br/>offset: 0x10\"]\n        EARLY[\"early_traffic_secret_[48]<br/>offset: 0x40\"]\n        CLIENT_HS[\"client_handshake_secret_[48]<br/>offset: 0x70\"]\n    end\n    \n    PUBLIC --> PADDING\n    PADDING --> PRIVATE_START\n    PRIVATE_START --> HASH_LEN\n    HASH_LEN --> SECRET\n    SECRET --> EARLY\n    EARLY --> CLIENT_HS\n```\n\n**Diagram: Private Field Layout in BoringSSL SSL_HANDSHAKE**\n\nThe calculation process [kern/boringssl_const.h:34-60]():\n\n| Step | Calculation | Result | Comment |\n|------|-------------|--------|---------|\n| 1. Find last public field | `BSSL__SSL_HANDSHAKE_MAX_VERSION` | Varies | From offsetof() |\n| 2. Add field size | `+sizeof(uint16_t)` = `+2` | offset+2 | Size of max_version |\n| 3. Apply alignment | `roundup(offset+2, 8)` | Aligned | 8-byte boundary |\n| 4. First private field | `+sizeof(size_t)` = `+8` | `hash_len_` offset | |\n| 5. Subsequent fields | `+SSL_MAX_MD_SIZE` | Sequential | Each secret is 48 bytes |\n\n**Offset Formulas**:\n- `SSL_HANDSHAKE_HASH_LEN_ = roundup(BSSL__SSL_HANDSHAKE_MAX_VERSION+2, 8)`\n- `SSL_HANDSHAKE_SECRET_ = SSL_HANDSHAKE_HASH_LEN_ + 8`\n- `SSL_HANDSHAKE_EARLY_TRAFFIC_SECRET_ = SSL_HANDSHAKE_SECRET_ + 48*1`\n- `SSL_HANDSHAKE_CLIENT_HANDSHAKE_SECRET_ = SSL_HANDSHAKE_SECRET_ + 48*2`\n\nThis approach requires understanding:\n1. C++ memory layout rules\n2. Structure alignment (typically 8 bytes on x86_64)\n3. Member declaration order in source code\n\nSources: [kern/boringssl_const.h:1-63]()\n\n---\n\n### Memory Alignment Considerations\n\nStructure padding affects offset calculations. eBPF programs must account for compiler-inserted padding:\n\n**Alignment Rules**:\n- Scalar types align to their size (uint16_t → 2 bytes, uint64_t → 8 bytes)\n- Structure alignment matches largest member\n- Padding inserted to maintain alignment\n\n**Example from ssl3_state_st**:\n\n```c\nstruct ssl3_state_st {\n    u64 read_sequence;          // offset: 0x00, size: 8\n    u64 write_sequence;         // offset: 0x08, size: 8\n    unsigned char server_random[32];  // offset: 0x10, size: 32\n    unsigned char client_random[32];  // offset: 0x30, size: 32\n};\n```\n\nThe `client_random` field is at offset `0x30` (48 bytes) because:\n- `read_sequence`: 0 + 8 = 8\n- `write_sequence`: 8 + 8 = 16 (0x10)\n- `server_random`: 16 + 32 = 48 (0x30)\n\nSources: [kern/boringssl_masterkey.h:59-65]()\n\n---\n\n## Version-Specific Bytecode Strategy\n\neCapture solves the offset variation problem by pre-compiling separate eBPF bytecode for each supported library version. The build system generates multiple bytecode files, each with version-specific offsets.\n\n### Bytecode Variant Matrix\n\n```mermaid\ngraph TB\n    subgraph \"OpenSSL Variants\"\n        O102[\"openssl_1_0_2a_kern.o<br/>Versions: 1.0.2a-u\"]\n        O110[\"openssl_1_1_0a_kern.o<br/>Versions: 1.1.0a-l\"]\n        O111A[\"openssl_1_1_1a_kern.o<br/>Version: 1.1.1a\"]\n        O111B[\"openssl_1_1_1b_kern.o<br/>Versions: 1.1.1b-c\"]\n        O111D[\"openssl_1_1_1d_kern.o<br/>Versions: 1.1.1d-i\"]\n        O111J[\"openssl_1_1_1j_kern.o<br/>Versions: 1.1.1j-w\"]\n        O300[\"openssl_3_0_0_kern.o<br/>Versions: 3.0.0-11,13-17\"]\n        O3012[\"openssl_3_0_12_kern.o<br/>Version: 3.0.12\"]\n        O320[\"openssl_3_2_0_kern.o<br/>Versions: 3.2.0-2\"]\n        O350[\"openssl_3_5_0_kern.o<br/>Versions: 3.5.0-4\"]\n    end\n    \n    subgraph \"BoringSSL Variants\"\n        BA13[\"boringssl_a_13_kern.o<br/>Android 13\"]\n        BA14[\"boringssl_a_14_kern.o<br/>Android 14\"]\n        BA15[\"boringssl_a_15_kern.o<br/>Android 15\"]\n        BA16[\"boringssl_a_16_kern.o<br/>Android 16\"]\n        BNA[\"boringssl_na_kern.o<br/>Non-Android\"]\n    end\n    \n    subgraph \"Selection Logic\"\n        DETECT[\"Version Detection<br/>Parse .rodata section\"]\n        MAP[\"sslVersionBpfMap<br/>version → bytecode\"]\n        LOAD[\"Load Appropriate<br/>Bytecode\"]\n    end\n    \n    DETECT --> MAP\n    MAP --> LOAD\n    \n    O102 -.-> LOAD\n    O111J -.-> LOAD\n    O300 -.-> LOAD\n    BA13 -.-> LOAD\n```\n\n**Diagram: Bytecode Variant Selection System**\n\nThe mapping is defined in `initOpensslOffset()` [user/module/probe_openssl_lib.go:73-187]():\n\n| Version Pattern | Bytecode File | Offset Source |\n|-----------------|---------------|---------------|\n| OpenSSL 1.0.2a-u (21 versions) | `openssl_1_0_2a_kern.o` | Single offset set |\n| OpenSSL 1.1.1a | `openssl_1_1_1a_kern.o` | Unique offsets |\n| OpenSSL 1.1.1b-c | `openssl_1_1_1b_kern.o` | Shared offsets |\n| OpenSSL 1.1.1d-i | `openssl_1_1_1d_kern.o` | Shared offsets |\n| OpenSSL 1.1.1j-w | `openssl_1_1_1j_kern.o` | Shared offsets |\n| OpenSSL 3.0.12 | `openssl_3_0_12_kern.o` | Special case |\n| OpenSSL 3.0.x (others) | `openssl_3_0_0_kern.o` | Shared offsets |\n\nSources: [user/module/probe_openssl_lib.go:73-187](), [variables.mk:189-228]()\n\n---\n\n## Practical Examples\n\n### Example 1: Reading TLS 1.2 Master Secret (OpenSSL)\n\nThe eBPF program must navigate multiple pointer indirections to read the master secret:\n\n**Navigation Path**: `ssl_st` → `ssl_st->session` → `ssl_session_st->master_key`\n\n```mermaid\ngraph LR\n    SSL_ST[\"ssl_st<br/>(SSL* argument)\"]\n    SESSION_PTR[\"ssl_st->session<br/>(pointer at +SSL_ST_SESSION)\"]\n    SESSION_STRUCT[\"ssl_session_st<br/>(dereferenced)\"]\n    MASTER_KEY[\"ssl_session_st->master_key<br/>(at +SSL_SESSION_ST_MASTER_KEY)\"]\n    \n    SSL_ST -->|\"offset = SSL_ST_SESSION\"| SESSION_PTR\n    SESSION_PTR -->|\"bpf_probe_read_user\"| SESSION_STRUCT\n    SESSION_STRUCT -->|\"offset = SSL_SESSION_ST_MASTER_KEY\"| MASTER_KEY\n```\n\n**Diagram: TLS 1.2 Master Secret Access Path**\n\n**Code Implementation** [kern/openssl_masterkey.h:140-165]():\n\n```c\n// Step 1: Get ssl_session_st pointer from ssl_st\nu64 *ssl_session_st_ptr = (u64 *)(ssl_st_ptr + SSL_ST_SESSION);\nu64 ssl_session_st_addr;\nret = bpf_probe_read_user(&ssl_session_st_addr, sizeof(ssl_session_st_addr), \n                          ssl_session_st_ptr);\n\n// Step 2: Read master_key from ssl_session_st\nvoid *ms_ptr = (void *)(ssl_session_st_addr + SSL_SESSION_ST_MASTER_KEY);\nret = bpf_probe_read_user(&mastersecret->master_key, \n                          sizeof(mastersecret->master_key), ms_ptr);\n```\n\n**Offset Dependencies**:\n- `SSL_ST_SESSION`: Varies by OpenSSL version (typically 0x38 for 3.0+)\n- `SSL_SESSION_ST_MASTER_KEY`: Varies by version (typically 0x50-0x60)\n\nSources: [kern/openssl_masterkey.h:140-168]()\n\n---\n\n### Example 2: Reading TLS 1.3 Secrets (BoringSSL)\n\nTLS 1.3 secrets in BoringSSL require accessing private fields through the handshake structure:\n\n**Navigation Path**: `ssl_st` → `ssl_st->s3` → `SSL3_STATE->hs` → `SSL_HANDSHAKE-><private fields>`\n\n```mermaid\ngraph TB\n    SSL_ST[\"ssl_st<br/>(SSL* ctx argument)\"]\n    S3_PTR[\"ssl_st->s3<br/>(at +SSL_ST_S3)\"]\n    S3_STRUCT[\"SSL3_STATE\"]\n    HS_PTR[\"SSL3_STATE->hs<br/>(at +BSSL__SSL3_STATE_HS)\"]\n    HS_STRUCT[\"SSL_HANDSHAKE\"]\n    \n    subgraph \"Private Fields\"\n        HASH_LEN[\"hash_len_<br/>(+SSL_HANDSHAKE_HASH_LEN_)\"]\n        SECRET[\"secret_<br/>(+SSL_HANDSHAKE_SECRET_)\"]\n        EARLY[\"early_traffic_secret_<br/>(+SSL_HANDSHAKE_EARLY_TRAFFIC_SECRET_)\"]\n        CLIENT_HS[\"client_handshake_secret_<br/>(+SSL_HANDSHAKE_CLIENT_HANDSHAKE_SECRET_)\"]\n        CLIENT_APP[\"client_traffic_secret_0_<br/>(+SSL_HANDSHAKE_CLIENT_TRAFFIC_SECRET_0_)\"]\n    end\n    \n    SSL_ST --> S3_PTR\n    S3_PTR --> S3_STRUCT\n    S3_STRUCT --> HS_PTR\n    HS_PTR --> HS_STRUCT\n    HS_STRUCT --> HASH_LEN\n    HS_STRUCT --> SECRET\n    HS_STRUCT --> EARLY\n    HS_STRUCT --> CLIENT_HS\n    HS_STRUCT --> CLIENT_APP\n```\n\n**Diagram: TLS 1.3 Secret Access in BoringSSL**\n\n**Code Implementation** [kern/boringssl_masterkey.h:235-382]():\n\n```c\n// Step 1: Get s3 pointer\nu64 *ssl_s3_st_ptr = (u64 *)(ssl_st_ptr + SSL_ST_S3);\nret = bpf_probe_read_user(&s3_address, sizeof(s3_address), ssl_s3_st_ptr);\n\n// Step 2: Get handshake structure pointer\nu64 *ssl_hs_st_ptr = (u64 *)(s3_address + BSSL__SSL3_STATE_HS);\nret = bpf_probe_read_user(&ssl_hs_st_addr, sizeof(ssl_hs_st_addr), ssl_hs_st_ptr);\n\n// Step 3: Read hash length\nu64 *ssl_hs_hashlen_ptr = (u64 *)(ssl_hs_st_addr + SSL_HANDSHAKE_HASH_LEN_);\nret = bpf_probe_read_user(&hash_len, sizeof(hash_len), ssl_hs_hashlen_ptr);\n\n// Step 4: Read TLS 1.3 secrets (using calculated offsets for private fields)\nvoid *cats_ptr_tls13 = (void *)(ssl_hs_st_addr + SSL_HANDSHAKE_CLIENT_TRAFFIC_SECRET_0_);\nret = bpf_probe_read_user(&mastersecret->client_traffic_secret_0_, \n                          sizeof(mastersecret->client_traffic_secret_0_),\n                          cats_ptr_tls13);\n```\n\n**Critical Offsets**:\n- `SSL_HANDSHAKE_CLIENT_TRAFFIC_SECRET_0_ = SSL_HANDSHAKE_SECRET_ + 48*4`\n- Each TLS 1.3 secret is 48 bytes (`SSL_MAX_MD_SIZE`)\n- Sequential layout enables arithmetic offset calculation\n\nSources: [kern/boringssl_masterkey.h:235-402](), [kern/boringssl_const.h:34-60]()\n\n---\n\n### Example 3: Version-Specific Offset Differences\n\nOpenSSL 3.0.12 is a special case where structure offsets differ from other 3.0.x versions:\n\n**Build System Logic** [user/module/probe_openssl_lib.go:128-130]():\n\n```go\n// OpenSSL 3.0.0-3.0.11 and 3.0.13-3.0.17 use same bytecode\nfor ch := 0; ch <= MaxSupportedOpenSSL30Version; ch++ {\n    m.sslVersionBpfMap[fmt.Sprintf(\"openssl 3.0.%d\", ch)] = \"openssl_3_0_0_kern.o\"\n}\n\n// OpenSSL 3.0.12 requires special bytecode\nm.sslVersionBpfMap[\"openssl 3.0.12\"] = \"openssl_3_0_12_kern.o\"\n```\n\n**Rationale**: Internal structure reorganization in 3.0.12 changed field offsets, requiring separate offset calculations and bytecode compilation.\n\n**Detection and Selection Flow**:\n\n| Step | Function | Action |\n|------|----------|--------|\n| 1 | `detectOpenssl()` | Parse `.rodata` section for version string |\n| 2 | Version normalization | Convert \"OpenSSL 3.0.12\" → \"openssl 3.0.12\" |\n| 3 | Map lookup | Check `sslVersionBpfMap[\"openssl 3.0.12\"]` |\n| 4 | Bytecode selection | Return `\"openssl_3_0_12_kern.o\"` |\n\nSources: [user/module/probe_openssl_lib.go:128-136](), [variables.mk:202]()\n\n---\n\n## Tools and Utilities\n\n### Offset Calculator Utility\n\nThe `boringssl-offset.c` utility generates offset definitions for a specific BoringSSL version:\n\n**Compilation and Usage**:\n```bash\n# Compile against BoringSSL headers\ng++ -I include/ -I src/ utils/boringssl-offset.c -o offset-calc\n\n# Run to generate offset definitions\n./offset-calc > generated_offsets.h\n```\n\n**Output Format** [utils/boringssl-offset.c:60-67]():\n```c\n// ssl_st->version\n#define SSL_ST_VERSION 0x10\n\n// ssl_st->session\n#define SSL_ST_SESSION 0x38\n\n// bssl::SSL3_STATE->hs\n#define BSSL__SSL3_STATE_HS 0x50\n```\n\n**Supported Structures**:\n- `ssl_st`: Main SSL context structure\n- `ssl_session_st`: Session state including master secrets\n- `ssl_cipher_st`: Cipher suite information\n- `bssl::SSL3_STATE`: SSL 3.0/TLS state\n- `bssl::SSL_HANDSHAKE`: Handshake state and secrets\n\nSources: [utils/boringssl-offset.c:1-78]()\n\n---\n\n### Build System Integration\n\nThe Makefile orchestrates offset generation and bytecode compilation for all versions:\n\n```mermaid\ngraph TB\n    subgraph \"Per-Version Build Process\"\n        HEADERS[\"Library Headers<br/>openssl-dev packages\"]\n        CALC[\"Offset Calculation<br/>offsetof() or manual\"]\n        DEFINES[\"Offset Defines<br/>Header files\"]\n        COMPILE[\"eBPF Compilation<br/>clang -target bpf\"]\n        BYTECODE[\"Version-Specific<br/>Bytecode (.o)\"]\n    end\n    \n    subgraph \"Aggregation\"\n        ALL_BYTECODE[\"All Bytecode Files<br/>27+ variants\"]\n        BINDATA[\"go-bindata<br/>Embed in binary\"]\n        GO_BUILD[\"Go Compilation<br/>ecapture binary\"]\n        FINAL[\"Final Binary<br/>with embedded bytecode\"]\n    end\n    \n    HEADERS --> CALC\n    CALC --> DEFINES\n    DEFINES --> COMPILE\n    COMPILE --> BYTECODE\n    \n    BYTECODE --> ALL_BYTECODE\n    ALL_BYTECODE --> BINDATA\n    BINDATA --> GO_BUILD\n    GO_BUILD --> FINAL\n```\n\n**Diagram: Build System Flow for Offset-Aware Bytecode**\n\n**Target Definitions** [variables.mk:190-228]():\n- 27+ TARGETS entries, each representing a library version\n- Each target compiles to `<name>_kern.o`\n- Separate compilation for CO-RE and non-CO-RE modes\n- Android variants excluded from shell/database modules\n\n**Compilation Flags for Offset Support**:\n- `-D__TARGET_ARCH_x86` or `-D__TARGET_ARCH_arm64`: Architecture-specific\n- `-I ./kern/bpf/$(LINUX_ARCH)`: Include architecture headers\n- Version-specific offset headers included via `#include` directives\n\nSources: [variables.mk:189-228](), [Makefile (referenced)]()\n\n---\n\n## Version Detection and Downgrade Strategy\n\nWhen the exact version's bytecode is not available, eCapture implements a fallback strategy:\n\n### Downgrade Algorithm\n\n**Logic** [user/module/probe_openssl_lib.go:341-369]():\n\n1. **Progressive Prefix Matching**: Iteratively shorten version string\n   - \"openssl 3.2.7\" → try \"openssl 3.2\", then \"openssl 3\", etc.\n\n2. **Version Comparison**: Select highest compatible version ≤ detected version\n   - If version 3.2.7 detected and only 3.2.0 available, use 3.2.0\n\n3. **Library Path Heuristics**: Fallback based on library filename\n   - `libssl.so.3` → use OpenSSL 3.0 default\n   - Other → use OpenSSL 1.1.1 default\n\n**Implementation**:\n\n```go\nfunc (m *MOpenSSLProbe) downgradeOpensslVersion(ver string, soPath string) (string, bool) {\n    var candidates []string\n    for i := len(ver) - 1; i > 0; i-- {\n        prefix := ver[:i]\n        for libKey := range m.sslVersionBpfMap {\n            if strings.HasPrefix(libKey, prefix) && isVersionLessOrEqual(libKey, ver) {\n                candidates = append(candidates, libKey)\n            }\n        }\n        if len(candidates) > 0 {\n            sort.Strings(candidates)\n            return m.sslVersionBpfMap[candidates[len(candidates)-1]], true\n        }\n    }\n    // Fallback logic based on soPath\n}\n```\n\n**Version Comparison**: Custom comparison handles both numeric and alphabetic suffixes (e.g., \"1.1.1w\") [user/module/probe_openssl_lib.go:371-448]().\n\nSources: [user/module/probe_openssl_lib.go:341-448]()\n\n---\n\n## Best Practices for Offset Maintenance\n\n### When Adding New Library Versions\n\n1. **Obtain Source Code**: Download exact version source code\n2. **Generate Offsets**: Use offset calculator utility or manual analysis\n3. **Create Header File**: Generate version-specific offset definitions\n4. **Compile Bytecode**: Build eBPF program with new offsets\n5. **Update Mapping**: Add entry to `sslVersionBpfMap`\n6. **Update Build System**: Add target to `variables.mk`\n7. **Test**: Verify with actual applications using that version\n\n### Common Pitfalls\n\n| Issue | Cause | Solution |\n|-------|-------|----------|\n| **Incorrect alignment** | Missed compiler padding | Use `pahole` tool to inspect actual layout |\n| **Private field access** | C++ access control | Manual calculation from public fields |\n| **Pointer chase errors** | Wrong dereference order | Draw structure navigation diagram |\n| **Version detection failure** | Missing version string | Add version to detection regex |\n\n### Debugging Offset Issues\n\n**eBPF Debug Prints** [kern/boringssl_masterkey.h:273-275]():\n```c\ndebug_bpf_printk(\"client_version:%d, state:%d, tls13_state:%d\\n\", \n                 client_version, ssl3_hs_state.state, ssl3_hs_state.tls13_state);\n```\n\n**Verification Steps**:\n1. Enable debug prints (`DEBUG=1` build flag)\n2. Check `bpf_probe_read_user()` return values\n3. Verify pointer addresses are non-zero\n4. Compare extracted values against known good data\n5. Use GDB to inspect actual structure layout in target process\n\nSources: [kern/boringssl_masterkey.h:169-402](), [kern/openssl_masterkey.h:80-257]()"
          },
          {
            "page_plan": {
              "id": "5.3",
              "title": "Adding New Modules"
            },
            "content": "# Adding New Modules\n\n<details>\n<summary>Relevant source files</summary>\n\nThe following files were used as context for generating this wiki page:\n\n- [cli/cmd/bash.go](cli/cmd/bash.go)\n- [cli/cmd/gnutls.go](cli/cmd/gnutls.go)\n- [cli/cmd/gotls.go](cli/cmd/gotls.go)\n- [cli/cmd/mysqld.go](cli/cmd/mysqld.go)\n- [cli/cmd/nspr.go](cli/cmd/nspr.go)\n- [cli/cmd/postgres.go](cli/cmd/postgres.go)\n- [cli/cmd/root.go](cli/cmd/root.go)\n- [cli/cmd/tls.go](cli/cmd/tls.go)\n- [cli/cmd/zsh.go](cli/cmd/zsh.go)\n- [pkg/util/ws/client.go](pkg/util/ws/client.go)\n- [pkg/util/ws/client_test.go](pkg/util/ws/client_test.go)\n- [user/config/iconfig.go](user/config/iconfig.go)\n- [user/module/imodule.go](user/module/imodule.go)\n- [user/module/probe_openssl.go](user/module/probe_openssl.go)\n\n</details>\n\n\n\nThis document provides a comprehensive guide for implementing new capture modules in the ecapture system. It covers the module architecture, interface requirements, eBPF integration, and step-by-step implementation process.\n\nFor information about the overall system architecture, see [Architecture](#2). For details on the existing capture modules, see [Capture Modules](#3). For eBPF program development specifics, see [eBPF Programs](#5.2).\n\n## Module Architecture Overview\n\nThe ecapture module system is built around a plugin-like architecture where each module implements the `IModule` interface to capture specific types of network traffic or system events. All modules follow a consistent pattern of eBPF program management, event processing, and data output.\n\n```mermaid\ngraph TB\n    subgraph \"Module Interface Layer\"\n        IModule[\"IModule Interface<br/>Init(), Start(), Close()\"]\n        Module[\"Module Base Struct<br/>Common functionality\"]\n    end\n    \n    subgraph \"Concrete Module Implementation\"\n        OpenSSL[\"MOpenSSLProbe<br/>TLS/SSL capture\"]\n        Bash[\"MBashProbe<br/>Shell command capture\"]\n        MySQL[\"MMysqldProbe<br/>Database query capture\"]\n        Custom[\"MCustomProbe<br/>Your new module\"]\n    end\n    \n    subgraph \"eBPF Management\"\n        Manager[\"manager.Manager<br/>eBPF program lifecycle\"]\n        Programs[\"eBPF Programs<br/>Kernel-space hooks\"]\n        Maps[\"eBPF Maps<br/>Data exchange\"]\n    end\n    \n    subgraph \"Event Processing\"\n        EventMaps[\"eventMaps []*ebpf.Map<br/>Event sources\"]\n        DecodeFun[\"eventFuncMaps<br/>Decode functions\"]\n        Dispatcher[\"Dispatcher()<br/>Event routing\"]\n    end\n    \n    subgraph \"Registration System\"\n        Factory[\"NewXxxProbe()<br/>Factory function\"]\n        Register[\"RegisteFunc()<br/>Module registration\"]\n    end\n    \n    IModule --> Module\n    Module --> OpenSSL\n    Module --> Bash\n    Module --> MySQL\n    Module --> Custom\n    \n    OpenSSL --> Manager\n    Bash --> Manager\n    MySQL --> Manager\n    Custom --> Manager\n    \n    Manager --> Programs\n    Manager --> Maps\n    \n    Maps --> EventMaps\n    EventMaps --> DecodeFun\n    DecodeFun --> Dispatcher\n    \n    Custom --> Factory\n    Factory --> Register\n```\n\nSources: [user/module/imodule.go:38-66](), [user/module/probe_openssl.go:83-106](), [user/module/probe_bash.go:42-49]()\n\n## Core Interface Requirements\n\nEvery module must implement the `IModule` interface and embed the `Module` base struct. The interface defines the essential lifecycle and functionality methods:\n\n```mermaid\ngraph LR\n    subgraph \"IModule Interface Methods\"\n        Init[\"Init()<br/>Initialization\"]\n        Start[\"Start()<br/>Begin capture\"]\n        Stop[\"Stop()<br/>Pause capture\"]\n        Close[\"Close()<br/>Cleanup\"]\n        Run[\"Run()<br/>Event loop\"]\n    end\n    \n    subgraph \"Event Handling Methods\"\n        Events[\"Events()<br/>Return eBPF maps\"]\n        Decode[\"Decode()<br/>Parse raw events\"]\n        DecodeFun[\"DecodeFun()<br/>Get decoder\"]\n        Dispatcher[\"Dispatcher()<br/>Process events\"]\n    end\n    \n    subgraph \"Metadata Methods\"\n        Name[\"Name()<br/>Module identifier\"]\n        SetChild[\"SetChild()<br/>Set implementation\"]\n    end\n    \n    Init --> Start\n    Start --> Run\n    Run --> Events\n    Events --> Decode\n    Decode --> DecodeFun\n    DecodeFun --> Dispatcher\n    Stop --> Close\n```\n\nThe base `Module` struct provides common functionality including event processing, BTF detection, and eBPF program lifecycle management.\n\nSources: [user/module/imodule.go:38-66](), [user/module/imodule.go:74-97]()\n\n## Module Implementation Pattern\n\nAll concrete modules follow a consistent implementation pattern with specific struct fields and initialization steps:\n\n| Component | Purpose | Implementation |\n|-----------|---------|----------------|\n| `bpfManager` | eBPF program lifecycle management | `*manager.Manager` |\n| `bpfManagerOptions` | eBPF program configuration | `manager.Options` |\n| `eventFuncMaps` | Event type to decoder mapping | `map[*ebpf.Map]event.IEventStruct` |\n| `eventMaps` | eBPF maps for event data | `[]*ebpf.Map` |\n| Module-specific fields | Custom state and configuration | Varies by module |\n\n```mermaid\ngraph TD\n    subgraph \"Module Struct Layout\"\n        Base[\"Module (embedded)<br/>Base functionality\"]\n        Manager[\"bpfManager<br/>*manager.Manager\"]\n        Options[\"bpfManagerOptions<br/>manager.Options\"]\n        EventMaps[\"eventMaps<br/>[]*ebpf.Map\"]\n        EventFuncs[\"eventFuncMaps<br/>map[*ebpf.Map]event.IEventStruct\"]\n        Custom[\"Module-specific fields<br/>Configuration, state, etc.\"]\n    end\n    \n    subgraph \"Initialization Flow\"\n        InitCall[\"Init() called\"]\n        BaseInit[\"Module.Init()\"]\n        SetChild[\"SetChild(m)\"]\n        InitMaps[\"Initialize maps\"]\n        InitState[\"Initialize module state\"]\n    end\n    \n    InitCall --> BaseInit\n    BaseInit --> SetChild\n    SetChild --> InitMaps\n    InitMaps --> InitState\n    \n    Base --> Manager\n    Manager --> Options\n    Options --> EventMaps\n    EventMaps --> EventFuncs\n    EventFuncs --> Custom\n```\n\nSources: [user/module/probe_openssl.go:83-106](), [user/module/probe_bash.go:42-49](), [user/module/probe_nspr.go:38-44]()\n\n## eBPF Program Integration\n\nModules integrate with eBPF programs through the `manager.Manager` system, which handles program loading, attachment, and map management. Each module must define its probe configuration and map requirements:\n\n```mermaid\ngraph TB\n    subgraph \"eBPF Program Setup\"\n        setupManagers[\"setupManagers()<br/>Configure probes and maps\"]\n        Probes[\"manager.Probe[]<br/>Attachment points\"]\n        Maps[\"manager.Map[]<br/>Data structures\"]\n    end\n    \n    subgraph \"Program Lifecycle\"\n        LoadAsset[\"assets.Asset()<br/>Load bytecode\"]\n        InitManager[\"InitWithOptions()<br/>Initialize\"]\n        StartManager[\"Start()<br/>Attach probes\"]\n        InitDecode[\"initDecodeFun()<br/>Setup decoders\"]\n    end\n    \n    subgraph \"Probe Configuration\"\n        Section[\"Section<br/>eBPF program section\"]\n        EbpfFunc[\"EbpfFuncName<br/>Function name\"]\n        AttachFunc[\"AttachToFuncName<br/>Target function\"]\n        BinaryPath[\"BinaryPath<br/>Target binary\"]\n    end\n    \n    setupManagers --> Probes\n    setupManagers --> Maps\n    LoadAsset --> InitManager\n    InitManager --> StartManager\n    StartManager --> InitDecode\n    \n    Probes --> Section\n    Probes --> EbpfFunc\n    Probes --> AttachFunc\n    Probes --> BinaryPath\n```\n\nSources: [user/module/probe_bash.go:147-236](), [user/module/probe_openssl.go:285-355](), [user/module/probe_nspr.go:135-247]()\n\n## Event Processing Pipeline\n\nModules integrate with the event processing system by providing event maps and decode functions. The pipeline handles event routing, parsing, and output formatting:\n\n```mermaid\ngraph LR\n    subgraph \"Kernel Space\"\n        eBPFProg[\"eBPF Programs\"]\n        eBPFMaps[\"eBPF Maps\"]\n    end\n    \n    subgraph \"Module Event Handling\"\n        Events[\"Events()<br/>Return event maps\"]\n        DecodeFun[\"DecodeFun()<br/>Get event decoder\"]\n        Decode[\"Decode()<br/>Parse raw bytes\"]\n        Dispatcher[\"Dispatcher()<br/>Handle parsed event\"]\n    end\n    \n    subgraph \"Event Processing System\"\n        Processor[\"EventProcessor<br/>Main event loop\"]\n        Workers[\"EventWorkers<br/>Per-connection processing\"]\n        Parsers[\"IParser<br/>Protocol parsing\"]\n    end\n    \n    eBPFProg --> eBPFMaps\n    eBPFMaps --> Events\n    Events --> DecodeFun\n    DecodeFun --> Decode\n    Decode --> Dispatcher\n    Dispatcher --> Processor\n    Processor --> Workers\n    Workers --> Parsers\n```\n\nSources: [user/module/imodule.go:267-333](), [pkg/event_processor/processor.go:66-89](), [pkg/event_processor/iworker.go:87-94]()\n\n## Module Registration System\n\nModules self-register using a factory pattern with the `RegisteFunc()` system. This enables dynamic module discovery and instantiation:\n\n```mermaid\ngraph TD\n    subgraph \"Registration Pattern\"\n        Factory[\"NewXxxProbe()<br/>Factory function\"]\n        ModStruct[\"Create module struct\"]\n        SetName[\"Set module name\"]\n        SetType[\"Set probe type\"]\n        Return[\"Return IModule\"]\n    end\n    \n    subgraph \"Registration Process\"\n        InitFunc[\"init() function\"]\n        CallRegister[\"RegisteFunc(NewXxxProbe)\"]\n        ModuleMap[\"Global module registry\"]\n    end\n    \n    subgraph \"Module Discovery\"\n        GetModules[\"Module enumeration\"]\n        CreateInstance[\"Factory invocation\"]\n        ModuleInit[\"Module initialization\"]\n    end\n    \n    Factory --> ModStruct\n    ModStruct --> SetName\n    SetName --> SetType\n    SetType --> Return\n    \n    InitFunc --> CallRegister\n    CallRegister --> ModuleMap\n    \n    GetModules --> CreateInstance\n    CreateInstance --> ModuleInit\n```\n\nSources: [user/module/probe_bash.go:311-320](), [user/module/probe_openssl.go:782-791](), [user/module/probe_nspr.go:273-282]()\n\n## Step-by-Step Implementation Guide\n\n### 1. Create Module Structure\n\nCreate a new file `user/module/probe_yourmodule.go` with the basic module structure:\n\n```go\ntype MYourModuleProbe struct {\n    Module                    // Embed base module\n    bpfManager        *manager.Manager\n    bpfManagerOptions manager.Options\n    eventFuncMaps     map[*ebpf.Map]event.IEventStruct\n    eventMaps         []*ebpf.Map\n    // Add module-specific fields here\n}\n```\n\n### 2. Implement Core Interface Methods\n\nImplement the required `IModule` interface methods:\n\n| Method | Purpose | Key Responsibilities |\n|--------|---------|---------------------|\n| `Init()` | Initialize module | Call `Module.Init()`, set child, initialize maps |\n| `Start()` | Begin capture | Load eBPF programs, attach probes, setup decoders |\n| `Close()` | Cleanup | Stop eBPF manager, close resources |\n| `Events()` | Return event maps | Provide eBPF maps for event reading |\n| `DecodeFun()` | Get decoder | Return appropriate event decoder for map |\n| `Dispatcher()` | Process events | Handle parsed events, apply business logic |\n\n### 3. Configure eBPF Programs\n\nImplement `setupManagers()` to define probe attachment points and maps:\n\n```mermaid\ngraph TB\n    subgraph \"Probe Configuration Steps\"\n        DefineProbes[\"Define manager.Probe[]<br/>Specify attachment points\"]\n        DefineMaps[\"Define manager.Map[]<br/>Specify data maps\"]\n        SetOptions[\"Set manager.Options<br/>Configure limits, verification\"]\n        CreateManager[\"Create manager.Manager<br/>Wire probes and maps\"]\n    end\n    \n    subgraph \"Probe Parameters\"\n        Section[\"Section: eBPF section name\"]\n        EbpfName[\"EbpfFuncName: kernel function\"]\n        AttachName[\"AttachToFuncName: target function\"]\n        BinPath[\"BinaryPath: target binary\"]\n    end\n    \n    DefineProbes --> DefineMaps\n    DefineMaps --> SetOptions\n    SetOptions --> CreateManager\n    \n    DefineProbes --> Section\n    DefineProbes --> EbpfName\n    DefineProbes --> AttachName\n    DefineProbes --> BinPath\n```\n\n### 4. Implement Event Handling\n\nCreate event structures and decoder mappings in `initDecodeFun()`:\n\n```mermaid\ngraph LR\n    subgraph \"Event Setup Process\"\n        GetMap[\"bpfManager.GetMap()<br/>Get eBPF map\"]\n        CreateEvent[\"Create event struct<br/>Implement IEventStruct\"]\n        MapDecoder[\"Map to decoder<br/>eventFuncMaps[map] = event\"]\n        AddToMaps[\"Add to event maps<br/>eventMaps.append(map)\"]\n    end\n    \n    GetMap --> CreateEvent\n    CreateEvent --> MapDecoder\n    MapDecoder --> AddToMaps\n```\n\n### 5. Register Module\n\nAdd registration code at the end of your module file:\n\n```go\nfunc init() {\n    RegisteFunc(NewYourModuleProbe)\n}\n\nfunc NewYourModuleProbe() IModule {\n    mod := &MYourModuleProbe{}\n    mod.name = ModuleNameYourModule\n    mod.mType = ProbeTypeUprobe\n    return mod\n}\n```\n\nSources: [user/module/probe_bash.go:52-63](), [user/module/probe_bash.go:72-104](), [user/module/probe_bash.go:243-258]()\n\n## Event Structure Development\n\nCreate event structures that implement `event.IEventStruct` to handle data from your eBPF programs:\n\n```mermaid\ngraph TB\n    subgraph \"IEventStruct Interface\"\n        Clone[\"Clone()<br/>Create copy\"]\n        EventType[\"EventType()<br/>Return event type\"]\n        GetUUID[\"GetUUID()<br/>Unique identifier\"]\n        Payload[\"Payload()<br/>Raw data\"]\n        String[\"String()<br/>Human readable\"]\n        StringHex[\"StringHex()<br/>Hex format\"]\n        Decode[\"Decode()<br/>Parse raw bytes\"]\n    end\n    \n    subgraph \"Event Implementation\"\n        BaseEvent[\"Embed common fields<br/>Timestamp, PID, etc.\"]\n        CustomFields[\"Module-specific fields<br/>Captured data\"]\n        DecodeLogic[\"Parsing logic<br/>Binary to struct\"]\n        FormatLogic[\"Output formatting<br/>Text and hex\"]\n    end\n    \n    Clone --> BaseEvent\n    EventType --> BaseEvent\n    GetUUID --> BaseEvent\n    Payload --> CustomFields\n    String --> FormatLogic\n    StringHex --> FormatLogic\n    Decode --> DecodeLogic\n```\n\nSources: [user/event/event_bash.go](), [user/event/event_nspr.go](), [pkg/event_processor/iworker.go:32-46]()\n\n## Testing and Debugging\n\nUse the following approaches to test and debug your new module:\n\n| Testing Phase | Techniques | Tools |\n|---------------|------------|-------|\n| eBPF Program | Use `bpftrace` to verify probe attachment | `bpftrace`, `bpftool` |\n| Event Flow | Add debug logging in `Dispatcher()` | `zerolog` logging |\n| Data Parsing | Test event decode with sample data | Unit tests |\n| Integration | Run with target application | Full system test |\n\n### Common Issues and Solutions\n\n| Issue | Symptoms | Solution |\n|-------|----------|----------|\n| Probe attachment fails | \"couldn't attach\" errors | Verify target binary path and function names |\n| No events received | Silent operation | Check eBPF map configuration and event trigger conditions |\n| Decode errors | Malformed event data | Verify eBPF and Go struct field alignment |\n| Memory leaks | Increasing memory usage | Ensure proper cleanup in `Close()` method |\n\nSources: [user/module/probe_bash.go:65-104](), [user/module/imodule.go:267-333](), [pkg/event_processor/processor.go:187-200]()\n\nThis comprehensive guide provides the framework for implementing new capture modules in ecapture. Follow the established patterns and interface requirements to ensure proper integration with the existing system architecture."
          },
          {
            "page_plan": {
              "id": "5.4",
              "title": "Event Processing and Parsers"
            },
            "content": "# Event Processing and Parsers\n\n<details>\n<summary>Relevant source files</summary>\n\nThe following files were used as context for generating this wiki page:\n\n- [pkg/event_processor/base_event.go](pkg/event_processor/base_event.go)\n- [pkg/event_processor/http_request.go](pkg/event_processor/http_request.go)\n- [pkg/event_processor/http_response.go](pkg/event_processor/http_response.go)\n- [pkg/event_processor/iparser.go](pkg/event_processor/iparser.go)\n- [pkg/event_processor/iworker.go](pkg/event_processor/iworker.go)\n- [pkg/event_processor/processor.go](pkg/event_processor/processor.go)\n- [user/event/event_bash.go](user/event/event_bash.go)\n- [user/event/event_gnutls.go](user/event/event_gnutls.go)\n- [user/event/event_masterkey.go](user/event/event_masterkey.go)\n- [user/event/event_mysqld.go](user/event/event_mysqld.go)\n- [user/event/event_nspr.go](user/event/event_nspr.go)\n- [user/event/event_openssl.go](user/event/event_openssl.go)\n- [user/event/event_openssl_tc.go](user/event/event_openssl_tc.go)\n- [user/event/event_postgres.go](user/event/event_postgres.go)\n- [user/event/ievent.go](user/event/ievent.go)\n\n</details>\n\n\n\nThis document explains the event processing system and protocol parsers in eCapture. This system bridges the gap between raw eBPF events and formatted output, handling event deserialization, aggregation, protocol parsing, and output formatting.\n\nFor information about output formats (text, PCAP, keylog), see [Output Formats](#4). For information about how modules generate events, see [Capture Modules](#3).\n\n## Overview\n\nThe event processing pipeline consists of three major components:\n\n1. **Event Structures** - Strongly-typed events implementing the `IEventStruct` interface that deserialize eBPF data\n2. **Event Processor** - Manages worker lifecycle and routes events based on UUIDs\n3. **Protocol Parsers** - Detect and parse application protocols (HTTP/1.x, HTTP/2) from aggregated payloads\n\n## Event Structure System\n\n### IEventStruct Interface\n\nAll events in eCapture implement the `IEventStruct` interface, which defines a standard contract for event handling:\n\n```mermaid\ngraph TB\n    IEventStruct[\"IEventStruct Interface\"]\n    \n    IEventStruct --> Decode[\"Decode(payload []byte) error\"]\n    IEventStruct --> Payload[\"Payload() []byte\"]\n    IEventStruct --> PayloadLen[\"PayloadLen() int\"]\n    IEventStruct --> String[\"String() string\"]\n    IEventStruct --> StringHex[\"StringHex() string\"]\n    IEventStruct --> Clone[\"Clone() IEventStruct\"]\n    IEventStruct --> EventType[\"EventType() Type\"]\n    IEventStruct --> GetUUID[\"GetUUID() string\"]\n    IEventStruct --> Base[\"Base() Base\"]\n    IEventStruct --> ToProtobufEvent[\"ToProtobufEvent() *pb.Event\"]\n    \n    style IEventStruct fill:#e3f2fd\n```\n\n**Sources:** [user/event/ievent.go:41-52]()\n\nThe interface methods serve specific purposes:\n\n| Method | Purpose |\n|--------|---------|\n| `Decode()` | Deserialize binary payload from eBPF maps into structured fields |\n| `Payload()` / `PayloadLen()` | Access raw data bytes (e.g., SSL plaintext, SQL queries) |\n| `String()` / `StringHex()` | Format event for text output with or without hex dump |\n| `Clone()` | Create empty instance for polymorphic event reading |\n| `EventType()` | Determine routing: `TypeOutput`, `TypeModuleData`, or `TypeEventProcessor` |\n| `GetUUID()` | Generate unique identifier for grouping related events |\n| `Base()` | Extract common metadata (timestamp, PID, IP addresses) for text output |\n| `ToProtobufEvent()` | Serialize to protobuf format for eCaptureQ GUI integration |\n\n### Event Type Classification\n\nEvents are classified by `Type` enum to control their processing path:\n\n```mermaid\ngraph LR\n    Type[\"event.Type Enum\"]\n    \n    Type --> TypeOutput[\"TypeOutput<br/>Direct write to log\"]\n    Type --> TypeModuleData[\"TypeModuleData<br/>Module caching\"]\n    Type --> TypeEventProcessor[\"TypeEventProcessor<br/>Parser aggregation\"]\n    \n    TypeOutput --> Logger[\"io.Writer\"]\n    TypeModuleData --> ModuleState[\"Module State<br/>pidConns, masterKeys\"]\n    TypeEventProcessor --> EventProcessor[\"EventProcessor<br/>IWorker routing\"]\n```\n\n**Sources:** [user/event/ievent.go:26-37]()\n\n- **`TypeOutput`** - Events written directly to output without aggregation (e.g., Bash commands, database queries)\n- **`TypeModuleData`** - Events stored in module state for correlation (e.g., connection metadata, master keys)\n- **`TypeEventProcessor`** - Events routed through EventProcessor for payload aggregation and parsing (e.g., SSL data events)\n\n### Concrete Event Implementations\n\nThe following diagram maps event structures to their source modules:\n\n```mermaid\ngraph TB\n    subgraph \"TLS Events\"\n        SSLDataEvent[\"SSLDataEvent<br/>OpenSSL/BoringSSL plaintext\"]\n        ConnDataEvent[\"ConnDataEvent<br/>TCP connection metadata\"]\n        MasterSecretEvent[\"MasterSecretEvent<br/>TLS 1.2 master keys\"]\n        MasterSecretBSSLEvent[\"MasterSecretBSSLEvent<br/>TLS 1.3 BoringSSL keys\"]\n    end\n    \n    subgraph \"TLS Library Events\"\n        GnutlsDataEvent[\"GnutlsDataEvent<br/>GnuTLS plaintext\"]\n        NsprDataEvent[\"NsprDataEvent<br/>NSPR/NSS plaintext\"]\n    end\n    \n    subgraph \"Database Events\"\n        MysqldEvent[\"MysqldEvent<br/>MySQL queries\"]\n        PostgresEvent[\"PostgresEvent<br/>PostgreSQL queries\"]\n    end\n    \n    subgraph \"Shell Events\"\n        BashEvent[\"BashEvent<br/>Bash commands\"]\n    end\n    \n    subgraph \"Network Events\"\n        TcSkbEvent[\"TcSkbEvent<br/>TC packet capture\"]\n    end\n    \n    IEventStruct[\"IEventStruct Interface\"]\n    \n    SSLDataEvent -.->|implements| IEventStruct\n    ConnDataEvent -.->|implements| IEventStruct\n    MasterSecretEvent -.->|implements| IEventStruct\n    MasterSecretBSSLEvent -.->|implements| IEventStruct\n    GnutlsDataEvent -.->|implements| IEventStruct\n    NsprDataEvent -.->|implements| IEventStruct\n    MysqldEvent -.->|implements| IEventStruct\n    PostgresEvent -.->|implements| IEventStruct\n    BashEvent -.->|implements| IEventStruct\n    TcSkbEvent -.->|implements| IEventStruct\n```\n\n**Sources:** [user/event/event_openssl.go:77-92](), [user/event/event_openssl.go:289-294](), [user/event/event_masterkey.go:37-55](), [user/event/event_masterkey.go:156-174](), [user/event/event_gnutls.go:25-35](), [user/event/event_nspr.go:26-36](), [user/event/event_mysqld.go:68-78](), [user/event/event_postgres.go:38-44](), [user/event/event_bash.go:37-47](), [user/event/event_openssl_tc.go:30-40]()\n\n#### SSLDataEvent Structure\n\nThe `SSLDataEvent` is the most commonly used event, capturing SSL/TLS plaintext from OpenSSL/BoringSSL:\n\n```mermaid\ngraph TB\n    SSLDataEvent[\"SSLDataEvent\"]\n    \n    SSLDataEvent --> Fields[\"Key Fields\"]\n    Fields --> DataType[\"DataType: int64<br/>ProbeEntry(0) or ProbeRet(1)\"]\n    Fields --> Timestamp[\"Timestamp: uint64\"]\n    Fields --> Pid[\"Pid: uint32\"]\n    Fields --> Tid[\"Tid: uint32\"]\n    Fields --> Data[\"Data: [16384]byte<br/>Plaintext payload\"]\n    Fields --> DataLen[\"DataLen: int32<br/>Actual payload length\"]\n    Fields --> Comm[\"Comm: [16]byte<br/>Process name\"]\n    Fields --> Fd[\"Fd: uint32<br/>File descriptor\"]\n    Fields --> Version[\"Version: int32<br/>TLS version\"]\n    Fields --> Tuple[\"Tuple: string<br/>IP:Port-IP:Port\"]\n    Fields --> Sock[\"Sock: uint64<br/>Socket pointer\"]\n    \n    UUID[\"GetUUID() Format\"]\n    UUID --> UUIDFormat[\"sock:Pid_Tid_Comm_Fd_DataType_Tuple_Sock<br/>Example: sock:1234_5678_curl_3_0_192.168.1.1:443-1.2.3.4:12345_0x7f8a9b0c1d2e\"]\n```\n\n**Sources:** [user/event/event_openssl.go:77-92](), [user/event/event_openssl.go:138-141]()\n\nThe UUID format includes the `sock:` prefix for socket-lifecycle-managed workers (see Worker Lifecycle Management section).\n\n#### ConnDataEvent Structure\n\n`ConnDataEvent` provides connection metadata from TC eBPF hooks:\n\n```mermaid\ngraph LR\n    ConnDataEvent[\"ConnDataEvent\"]\n    \n    ConnDataEvent --> Decode[\"Decode()\"]\n    Decode --> ParseAddrs[\"Parse Saddr/Daddr\"]\n    ParseAddrs --> IPv4[\"AF_INET<br/>netip.AddrFrom4\"]\n    ParseAddrs --> IPv6[\"AF_INET6<br/>netip.AddrFrom16\"]\n    IPv4 --> Tuple[\"Tuple: 'IP:Port-IP:Port'\"]\n    IPv6 --> Tuple\n    \n    ConnDataEvent --> Fields[\"Saddr/Daddr: [16]byte<br/>Sport/Dport: uint16<br/>Family: uint16<br/>Sock: uint64\"]\n```\n\n**Sources:** [user/event/event_openssl.go:272-308]()\n\n### Event Decoding Process\n\nEvent decoding follows a standard pattern using `binary.Read()`:\n\n```mermaid\nsequenceDiagram\n    participant eBPF as eBPF Map\n    participant Module as Module Reader\n    participant Event as IEventStruct\n    participant Buffer as bytes.Buffer\n    \n    eBPF->>Module: Raw bytes\n    Module->>Event: Call Decode(payload)\n    Event->>Buffer: Create buffer from payload\n    \n    loop For each field\n        Event->>Buffer: binary.Read(buf, binary.LittleEndian, &field)\n    end\n    \n    Event->>Event: Post-processing<br/>(decode ktime, parse tuple)\n    Event->>Module: Return decoded event\n```\n\n**Sources:** [user/event/event_openssl.go:94-132](), [user/event/event_bash.go:49-69](), [user/event/event_mysqld.go:80-109]()\n\nAll events use `binary.LittleEndian` to match eBPF data layout. Events containing timestamps call `DecodeKtime()` to convert kernel time to Unix nanoseconds.\n\n## EventProcessor Architecture\n\n### Core Components\n\nThe `EventProcessor` manages the event processing pipeline:\n\n```mermaid\ngraph TB\n    subgraph \"EventProcessor Structure\"\n        EP[\"EventProcessor\"]\n        \n        EP --> incoming[\"incoming chan<br/>IEventStruct<br/>Buffer: 1024\"]\n        EP --> outComing[\"outComing chan<br/>[]byte<br/>Buffer: 1024\"]\n        EP --> destroyConn[\"destroyConn chan<br/>uint64<br/>Socket cleanup\"]\n        EP --> workerQueue[\"workerQueue<br/>map[string]IWorker<br/>UUID -> Worker\"]\n        EP --> logger[\"logger io.Writer<br/>Output destination\"]\n        EP --> closeChan[\"closeChan bool<br/>Shutdown signal\"]\n    end\n    \n    Module[\"Module\"] --> incoming\n    workerQueue --> Workers[\"eventWorker instances\"]\n    Workers --> outComing\n    outComing --> logger\n```\n\n**Sources:** [pkg/event_processor/processor.go:30-50]()\n\nThe processor maintains:\n- **`incoming` channel** - Receives events from modules (buffer size 1024)\n- **`outComing` channel** - Formatted output to logger (buffer size 1024)\n- **`destroyConn` channel** - Socket destruction notifications\n- **`workerQueue` map** - UUID to worker mapping for event routing\n- **`logger` io.Writer** - Output destination (console, file, or CollectorWriter)\n\n### Event Dispatch Flow\n\n```mermaid\nsequenceDiagram\n    participant Module as Module\n    participant EP as EventProcessor\n    participant WQ as workerQueue\n    participant EW as eventWorker\n    \n    Module->>EP: Write(event)\n    EP->>EP: incoming <- event\n    \n    EP->>EP: Serve() select incoming\n    EP->>EP: dispatch(event)\n    \n    EP->>EP: uuid = event.GetUUID()\n    EP->>WQ: getWorkerByUUID(uuid)\n    \n    alt Worker exists\n        WQ->>EW: Return existing worker\n        EW->>EW: worker.Get()<br/>(atomic reference)\n    else Worker not found\n        EP->>EW: NewEventWorker(uuid, ep)\n        EP->>WQ: addWorkerByUUID(worker)\n    end\n    \n    EP->>EW: worker.Write(event)\n    EW->>EW: incoming <- event\n    EP->>EW: worker.Put()<br/>(release reference)\n```\n\n**Sources:** [pkg/event_processor/processor.go:66-109](), [pkg/event_processor/processor.go:130-148]()\n\nKey aspects:\n1. **UUID-based routing** - `GetUUID()` groups related events into the same worker\n2. **Lazy worker creation** - Workers created on first event for a UUID\n3. **Reference counting** - `Get()`/`Put()` prevent race conditions during deletion\n4. **Non-blocking writes** - Events dropped if incoming channel is full\n\n## Worker System\n\n### IWorker Interface\n\nWorkers aggregate events and invoke parsers:\n\n```mermaid\ngraph TB\n    IWorker[\"IWorker Interface\"]\n    \n    IWorker --> Write[\"Write(event.IEventStruct) error<br/>Add event to worker\"]\n    IWorker --> GetUUID[\"GetUUID() string<br/>Return worker UUID\"]\n    IWorker --> GetDestroyUUID[\"GetDestroyUUID() uint64<br/>Socket pointer for cleanup\"]\n    IWorker --> IfUsed[\"IfUsed() bool<br/>Reference counting\"]\n    IWorker --> Get[\"Get()<br/>Acquire reference\"]\n    IWorker --> Put[\"Put()<br/>Release reference\"]\n    IWorker --> CloseEventWorker[\"CloseEventWorker()<br/>External shutdown signal\"]\n```\n\n**Sources:** [pkg/event_processor/iworker.go:35-49]()\n\n### eventWorker Implementation\n\n```mermaid\ngraph TB\n    subgraph \"eventWorker Structure\"\n        EW[\"eventWorker\"]\n        \n        EW --> incoming[\"incoming chan<br/>IEventStruct<br/>Buffer: 1024\"]\n        EW --> outComing[\"outComing chan<br/>[]byte<br/>Shared with processor\"]\n        EW --> ticker[\"ticker *time.Ticker<br/>100ms interval\"]\n        EW --> tickerCount[\"tickerCount uint8<br/>Idle detection\"]\n        EW --> UUID[\"UUID string<br/>Full UUID\"]\n        EW --> uuidOutput[\"uuidOutput string<br/>Display UUID\"]\n        EW --> DestroyUUID[\"DestroyUUID uint64<br/>Socket pointer\"]\n        EW --> parser[\"parser IParser<br/>Protocol parser\"]\n        EW --> payload[\"payload *bytes.Buffer<br/>Aggregated data\"]\n        EW --> used[\"used atomic.Bool<br/>Reference count\"]\n        EW --> closeChan[\"closeChan chan struct{}<br/>Shutdown signal\"]\n        EW --> ewLifeCycleState[\"ewLifeCycleState<br/>LifeCycleState\"]\n    end\n```\n\n**Sources:** [pkg/event_processor/iworker.go:70-89]()\n\n### Worker Lifecycle Management\n\nWorkers support two lifecycle modes based on UUID prefix:\n\n```mermaid\ngraph TB\n    UUID[\"event.GetUUID()\"]\n    \n    UUID --> CheckPrefix[\"Check for 'sock:' prefix\"]\n    \n    CheckPrefix -->|Has prefix| Socket[\"LifeCycleStateSock\"]\n    CheckPrefix -->|No prefix| Default[\"LifeCycleStateDefault\"]\n    \n    Socket --> ParseSock[\"Parse socket pointer<br/>from UUID suffix\"]\n    Socket --> CreateClose[\"closeChan = make(chan struct{})\"]\n    Socket --> SetDestroy[\"DestroyUUID = sock pointer\"]\n    Socket --> Lifecycle1[\"Lifecycle:<br/>1. Ticker timeout: Display() and continue<br/>2. closeChan signal: Destroy worker\"]\n    \n    Default --> NilClose[\"closeChan = nil\"]\n    Default --> NoDestroy[\"DestroyUUID = 0\"]\n    Default --> Lifecycle2[\"Lifecycle:<br/>1. Ticker timeout: Destroy worker\"]\n    \n    style Socket fill:#e3f2fd\n    style Default fill:#fff3e0\n```\n\n**Sources:** [pkg/event_processor/iworker.go:57-63](), [pkg/event_processor/iworker.go:100-123]()\n\n**LifeCycleStateDefault:**\n- Used when UUID does not start with `sock:`\n- Worker destroyed after idle timeout (1 second = 10 ticks × 100ms)\n- Example: Bash events, MySQL queries with UUID `PID_TID_Comm`\n\n**LifeCycleStateSock:**\n- Used when UUID starts with `sock:` prefix\n- Worker persists across idle periods\n- Destroyed only when socket closes (external `CloseEventWorker()` call)\n- Example: SSL data events with UUID `sock:PID_TID_Comm_Fd_DataType_Tuple_Sock`\n- `DestroyUUID` contains socket pointer for cleanup matching\n\n### Worker Event Loop\n\n```mermaid\nsequenceDiagram\n    participant Ticker as ticker.C\n    participant Worker as eventWorker\n    participant Channel as incoming\n    participant Close as closeChan\n    \n    loop Run() Forever\n        alt Ticker fires (100ms)\n            Ticker->>Worker: Tick\n            Worker->>Worker: tickerCount++\n            \n            alt tickerCount > 10 (1 second idle)\n                alt LifeCycleStateSock\n                    Worker->>Worker: drainAndClose()\n                    Worker->>Worker: tickerCount = 0\n                    Worker->>Worker: ticker restart flag\n                else LifeCycleStateDefault\n                    Worker->>Worker: processor.delWorkerByUUID()\n                    Worker->>Worker: drainAndClose()\n                    Worker->>Worker: Return (exit)\n                end\n            end\n            \n        else Event arrives\n            Channel->>Worker: event\n            Worker->>Worker: tickerCount = 0\n            Worker->>Worker: writeEvent(event)\n            Worker->>Worker: payload.Write(event.Payload())\n            \n        else Socket closed (Sock lifecycle only)\n            Close->>Worker: Signal\n            Worker->>Worker: processor.delWorkerByUUID()\n            Worker->>Worker: drainAndClose()\n            Worker->>Worker: Return (exit)\n        end\n    end\n```\n\n**Sources:** [pkg/event_processor/iworker.go:262-306]()\n\nKey behaviors:\n- **Ticker resets** on each event arrival (`tickerCount = 0`)\n- **Payload aggregation** - Events accumulated in `payload` buffer\n- **Idle timeout** - 10 ticks (1 second) without events triggers lifecycle action\n- **Socket lifecycle** - `closeChan` signal from external socket destruction\n\n### Event Display and Parsing\n\nWhen a worker is ready to output (timeout or socket close), it invokes the display pipeline:\n\n```mermaid\nsequenceDiagram\n    participant Worker as eventWorker\n    participant Parser as IParser\n    participant Processor as EventProcessor\n    participant Logger as io.Writer\n    \n    Worker->>Worker: Display()\n    Worker->>Worker: parserEvents()\n    \n    alt parser == nil (first call)\n        Worker->>Parser: NewParser(payload.Bytes())\n        Parser->>Parser: detect() all parsers\n        Parser-->>Worker: Return matched parser\n    end\n    \n    Worker->>Parser: parser.Write(payload.Bytes())\n    Parser->>Parser: Parse protocol data\n    Worker->>Parser: parser.Display()\n    Parser-->>Worker: Formatted bytes\n    \n    alt isHex == true\n        Worker->>Worker: hex.Dump(bytes)\n    end\n    \n    alt logger is CollectorWriter\n        Worker->>Worker: Format with Base info\n        Worker->>Processor: writeToChan(formatted)\n    else logger is protobuf\n        Worker->>Worker: ToProtobufEvent()\n        Worker->>Worker: proto.Marshal()\n        Worker->>Processor: writeToChan(marshalled)\n    end\n    \n    Processor->>Logger: Write(bytes)\n    \n    Worker->>Parser: parser.Reset()\n    Worker->>Worker: payload.Reset()\n```\n\n**Sources:** [pkg/event_processor/iworker.go:175-228](), [pkg/event_processor/iworker.go:248-260]()\n\nThe display process:\n1. Aggregated payload passed to parser\n2. Parser detects protocol and formats output\n3. Output formatted based on logger type (text vs protobuf)\n4. Worker state reset for next batch\n\n## Parser System\n\n### IParser Interface\n\nParsers detect and format application protocols:\n\n```mermaid\ngraph TB\n    IParser[\"IParser Interface\"]\n    \n    IParser --> detect[\"detect(b []byte) error<br/>Test if payload matches protocol\"]\n    IParser --> Write[\"Write(b []byte) (int, error)<br/>Accumulate payload data\"]\n    IParser --> ParserType[\"ParserType() ParserType<br/>Return parser type enum\"]\n    IParser --> PacketType[\"PacketType() PacketType<br/>Encoding: Null/Gzip/WebSocket\"]\n    IParser --> Name[\"Name() string<br/>Parser identifier\"]\n    IParser --> IsDone[\"IsDone() bool<br/>Full message received\"]\n    IParser --> Init[\"Init()<br/>Initialize buffers\"]\n    IParser --> Display[\"Display() []byte<br/>Format parsed output\"]\n    IParser --> Reset[\"Reset()<br/>Prepare for next message\"]\n```\n\n**Sources:** [pkg/event_processor/iparser.go:49-60]()\n\n### Parser Types\n\n```mermaid\ngraph TB\n    ParserType[\"ParserType Enum\"]\n    \n    ParserType --> Null[\"ParserTypeNull (0)<br/>DefaultParser\"]\n    ParserType --> HttpReq[\"ParserTypeHttpRequest (1)<br/>HTTPRequest\"]\n    ParserType --> Http2Req[\"ParserTypeHttp2Request (2)<br/>HTTP2Request\"]\n    ParserType --> HttpResp[\"ParserTypeHttpResponse (3)<br/>HTTPResponse\"]\n    ParserType --> Http2Resp[\"ParserTypeHttp2Response (4)<br/>HTTP2Response\"]\n    ParserType --> WebSocket[\"ParserTypeWebSocket (5)<br/>WebSocket\"]\n    \n    Null --> DefaultBehavior[\"Raw text or hex dump<br/>No protocol parsing\"]\n    HttpReq --> HTTP1Req[\"Go net/http.ReadRequest\"]\n    Http2Req --> H2Frame[\"HTTP/2 frame parsing\"]\n    HttpResp --> HTTP1Resp[\"Go net/http.ReadResponse\"]\n    Http2Resp --> H2FrameResp[\"HTTP/2 frame parsing\"]\n```\n\n**Sources:** [pkg/event_processor/iparser.go:40-47]()\n\n### Parser Selection\n\nThe `NewParser()` function auto-detects protocol:\n\n```mermaid\nsequenceDiagram\n    participant Worker as eventWorker\n    participant Factory as NewParser()\n    participant Registry as parsers map\n    participant Parser as IParser\n    \n    Worker->>Factory: NewParser(payload)\n    \n    alt payload not empty\n        Factory->>Registry: Iterate all parsers\n        \n        loop For each registered parser\n            Factory->>Parser: detect(payload)\n            \n            alt No error\n                Factory->>Factory: Switch on ParserType()\n                Factory->>Parser: Create new instance\n                Factory->>Parser: Init()\n                Factory-->>Worker: Return parser\n            end\n        end\n        \n        alt No parser matched\n            Factory->>Parser: new(DefaultParser)\n            Factory->>Parser: Init()\n            Factory-->>Worker: Return DefaultParser\n        end\n        \n    else payload empty\n        Factory->>Parser: new(DefaultParser)\n        Factory->>Parser: Init()\n        Factory-->>Worker: Return DefaultParser\n    end\n```\n\n**Sources:** [pkg/event_processor/iparser.go:85-115]()\n\nThe detection sequence:\n1. Try each registered parser's `detect()` method\n2. First successful match creates typed parser instance\n3. Fallback to `DefaultParser` if no match\n\n### Parser Registration\n\nParsers self-register during package initialization:\n\n```mermaid\ngraph LR\n    init1[\"http_request.go init()\"]\n    init2[\"http_response.go init()\"]\n    init3[\"http2_request.go init()\"]\n    init4[\"http2_response.go init()\"]\n    \n    init1 --> Register[\"Register(*HTTPRequest)\"]\n    init2 --> Register\n    init3 --> Register\n    init4 --> Register\n    \n    Register --> parsers[\"parsers map[string]IParser\"]\n```\n\n**Sources:** [pkg/event_processor/http_request.go:159-163](), [pkg/event_processor/http_response.go:177-181](), [pkg/event_processor/iparser.go:64-73]()\n\n### HTTP Request Parser\n\nThe `HTTPRequest` parser handles HTTP/1.x requests:\n\n```mermaid\ngraph TB\n    subgraph \"HTTPRequest Structure\"\n        HR[\"HTTPRequest\"]\n        \n        HR --> request[\"request *http.Request<br/>Parsed request\"]\n        HR --> reader[\"reader *bytes.Buffer<br/>Accumulator\"]\n        HR --> bufReader[\"bufReader *bufio.Reader<br/>Buffered reader\"]\n        HR --> isInit[\"isInit bool<br/>Header parsed\"]\n        HR --> isDone[\"isDone bool<br/>Body complete\"]\n        HR --> packerType[\"packerType PacketType<br/>Null/Gzip\"]\n    end\n    \n    subgraph \"Processing Steps\"\n        Write[\"Write(b []byte)\"]\n        \n        Write --> Check[\"Check isInit\"]\n        Check -->|false| Parse[\"reader.Write(b)<br/>http.ReadRequest(bufReader)\"]\n        Parse --> SetInit[\"isInit = true\"]\n        Check -->|true| Append[\"reader.Write(b)\"]\n        \n        Display[\"Display()\"]\n        Display --> ReadBody[\"io.ReadAll(request.Body)\"]\n        Display --> CheckGzip[\"Check Content-Encoding\"]\n        CheckGzip -->|gzip| Decompress[\"gzip.NewReader<br/>io.ReadAll\"]\n        CheckGzip -->|other| Raw[\"Use raw body\"]\n        Display --> Dump[\"httputil.DumpRequest\"]\n        Display --> Combine[\"Combine header + body\"]\n    end\n```\n\n**Sources:** [pkg/event_processor/http_request.go:28-35](), [pkg/event_processor/http_request.go:54-81](), [pkg/event_processor/http_request.go:105-157]()\n\nKey features:\n- **Incremental parsing** - `http.ReadRequest()` called once when headers complete\n- **Body accumulation** - Additional writes append to body buffer\n- **Gzip decompression** - Automatic for `Content-Encoding: gzip`\n- **HTTP/2 detection** - Returns raw bytes if `Proto == \"HTTP/2.0\"`\n\n### HTTP Response Parser\n\nSimilar to request parser but uses `http.ReadResponse()`:\n\n```mermaid\ngraph TB\n    subgraph \"HTTPResponse Structure\"\n        HResp[\"HTTPResponse\"]\n        \n        HResp --> response[\"response *http.Response\"]\n        HResp --> reader[\"reader *bytes.Buffer\"]\n        HResp --> bufReader[\"bufReader *bufio.Reader\"]\n        HResp --> receivedLen[\"receivedLen int64<br/>Bytes accumulated\"]\n        HResp --> headerLength[\"headerLength int64\"]\n        HResp --> isInit[\"isInit bool\"]\n        HResp --> isDone[\"isDone bool\"]\n        HResp --> packerType[\"packerType PacketType\"]\n    end\n    \n    Display[\"Display()\"]\n    Display --> ReadBody[\"io.ReadAll(response.Body)\"]\n    Display --> HandleEOF[\"Handle io.ErrUnexpectedEOF<br/>Content-Length mismatch\"]\n    Display --> CheckEnc[\"Check Content-Encoding\"]\n    CheckEnc -->|gzip| Gunzip[\"gzip.NewReader\"]\n    CheckEnc -->|chunked| ChunkLog[\"Log chunked transfer\"]\n    Display --> DumpResp[\"httputil.DumpResponse\"]\n```\n\n**Sources:** [pkg/event_processor/http_response.go:28-37](), [pkg/event_processor/http_response.go:58-92](), [pkg/event_processor/http_response.go:115-175]()\n\nResponse parser handles:\n- **Chunked encoding** - Detected via `ContentLength < 0`\n- **Truncated responses** - Gracefully handles `ErrUnexpectedEOF`\n- **Content-Length mismatches** - Logs warnings for debugging\n\n### DefaultParser\n\nFallback parser for non-HTTP protocols:\n\n```mermaid\ngraph TB\n    DefaultParser[\"DefaultParser\"]\n    \n    DefaultParser --> Structure[\"reader *bytes.Buffer<br/>isdone bool\"]\n    \n    Write[\"Write(b []byte)\"]\n    Write --> WriteBuffer[\"reader.Write(b)\"]\n    Write --> SetDone[\"isdone = true\"]\n    \n    Display[\"Display()\"]\n    Display --> GetBytes[\"reader.Bytes()\"]\n    Display --> CheckFirst[\"Check first byte\"]\n    CheckFirst -->|\"< 32 or > 126\"| HexDump[\"hex.Dump(bytes)\"]\n    CheckFirst -->|printable| String[\"CToGoString(bytes)\"]\n```\n\n**Sources:** [pkg/event_processor/iparser.go:117-166]()\n\nThe DefaultParser:\n- Accumulates all data immediately (`isdone = true`)\n- Auto-detects binary vs text (checks first byte)\n- Uses hex dump for non-printable data\n- Strips null terminators from C strings\n\n## Complete Event Flow Example\n\n### TLS Capture Pipeline\n\n```mermaid\nsequenceDiagram\n    participant eBPF as SSL_read uprobe\n    participant PerfMap as perfEventMap\n    participant Module as MOpenSSLProbe\n    participant EP as EventProcessor\n    participant EW as eventWorker\n    participant Parser as HTTPRequest\n    participant Logger as io.Writer\n    \n    eBPF->>PerfMap: SSL data event\n    Module->>PerfMap: perfReader.Read()\n    Module->>Module: SSLDataEvent.Decode()\n    Module->>Module: GetUUID()<br/>sock:1234_5678_curl_3_0_IP:Port_Sock\n    \n    Module->>EP: eventProcessor.Write(event)\n    EP->>EP: incoming <- event\n    EP->>EP: Serve() dispatch(event)\n    \n    EP->>EW: getWorkerByUUID() or NewEventWorker()\n    EP->>EW: worker.Write(event)\n    EW->>EW: incoming <- event\n    \n    EW->>EW: Run() select incoming\n    EW->>EW: tickerCount = 0\n    EW->>EW: writeEvent(event)\n    EW->>EW: payload.Write(event.Payload())\n    \n    Note over EW: Wait for timeout or socket close\n    \n    EW->>EW: Ticker fires (idle detected)\n    EW->>EW: Display()\n    EW->>EW: parserEvents()\n    \n    EW->>Parser: NewParser(payload.Bytes())\n    Parser->>Parser: detect() -> HTTPRequest\n    EW->>Parser: parser.Write(payload.Bytes())\n    Parser->>Parser: http.ReadRequest()\n    EW->>Parser: parser.Display()\n    Parser->>Parser: httputil.DumpRequest()\n    Parser-->>EW: Formatted bytes\n    \n    EW->>EP: outComing <- formatted\n    EP->>Logger: logger.Write(formatted)\n    \n    EW->>Parser: parser.Reset()\n    EW->>EW: payload.Reset()\n```\n\n**Sources:** [pkg/event_processor/processor.go:66-109](), [pkg/event_processor/iworker.go:262-306](), [pkg/event_processor/iworker.go:175-228](), [pkg/event_processor/iparser.go:85-115]()\n\n## Output Formatting\n\n### Text Mode\n\nFor `CollectorWriter` logger:\n\n```mermaid\ngraph TB\n    Display[\"eventWorker.Display()\"]\n    \n    Display --> GetBase[\"originEvent.Base()\"]\n    GetBase --> Metadata[\"PID, Comm<br/>SrcIP:SrcPort<br/>DstIP:DstPort\"]\n    \n    Display --> GetType[\"parser.ParserType()\"]\n    Display --> GetPayload[\"parser.Display()\"]\n    \n    Display --> CheckHex[\"Check isHex flag\"]\n    CheckHex -->|true| HexDump[\"hex.Dump(payload)\"]\n    CheckHex -->|false| Raw[\"Use raw payload\"]\n    \n    Display --> Format[\"fmt.Fprintf()\"]\n    Format --> Output[\"PID:123, Comm:curl, Src:IP:Port, Dest:IP:Port,<br/>Payload:<br/>GET / HTTP/1.1...\"]\n```\n\n**Sources:** [pkg/event_processor/iworker.go:175-228]()\n\n### Protobuf Mode\n\nFor protobuf logger (eCaptureQ GUI):\n\n```mermaid\ngraph TB\n    Display[\"eventWorker.Display()\"]\n    \n    Display --> CreateLogEntry[\"new(pb.LogEntry)\"]\n    Display --> SetType[\"LogType = LOG_TYPE_EVENT\"]\n    \n    Display --> ToProto[\"originEvent.ToProtobufEvent()\"]\n    ToProto --> ProtoEvent[\"pb.Event{<br/>  Timestamp, UUID, PID, Pname,<br/>  SrcIP, SrcPort, DstIP, DstPort<br/>}\"]\n    \n    Display --> SetPayload[\"ep.Payload = parser.Display()\"]\n    Display --> SetMeta[\"ep.Type = parser.ParserType()<br/>ep.Length = len(payload)\"]\n    \n    Display --> Marshal[\"proto.Marshal(logEntry)\"]\n    Display --> WriteChan[\"outComing <- marshalled\"]\n```\n\n**Sources:** [pkg/event_processor/iworker.go:214-227]()\n\n## Event Truncation\n\nThe EventProcessor supports payload truncation:\n\n```mermaid\ngraph TB\n    writeEvent[\"eventWorker.writeEvent()\"]\n    \n    writeEvent --> CheckSize[\"truncateSize > 0?\"]\n    CheckSize -->|false| Append[\"payload.Write(event.Payload())\"]\n    \n    CheckSize -->|true| CheckLen[\"payload.Len() >= truncateSize?\"]\n    CheckLen -->|false| Append\n    CheckLen -->|true| Truncate[\"payload.Truncate(truncateSize)\"]\n    Truncate --> Log[\"Log 'Events truncated, size: N bytes'\"]\n    Truncate --> Return[\"Return (no write)\"]\n```\n\n**Sources:** [pkg/event_processor/iworker.go:230-245]()\n\nTruncation prevents excessive memory usage for large payloads (configurable via `--truncate` flag).\n\n## Error Handling\n\n### Event Worker Errors\n\nWorkers use error channels for non-fatal errors:\n\n```mermaid\ngraph TB\n    Error[\"Error Occurs\"]\n    \n    Error --> Type1[\"ErrEventWorkerIncomingFull\"]\n    Error --> Type2[\"ErrEventWorkerOutcomingFull\"]\n    Error --> Type3[\"Parser Write Error\"]\n    \n    Type1 --> Log1[\"Event dropped<br/>incoming channel full\"]\n    Type2 --> Log2[\"Output dropped<br/>outComing channel full\"]\n    Type3 --> Log3[\"Parser error logged<br/>Continue processing\"]\n    \n    All[\"All Errors\"] --> EP[\"EventProcessor.errChan\"]\n    EP --> Caller[\"Module decides<br/>whether to continue\"]\n```\n\n**Sources:** [pkg/event_processor/iworker.go:66-68](), [pkg/event_processor/processor.go:72-79]()\n\nKey error behaviors:\n- **Non-blocking channels** - Drops events rather than blocking if buffers full\n- **Parser errors** - Logged but don't stop processing\n- **Worker panics** - `Get()`/`Put()` panics indicate incorrect usage\n\n### Socket Lifecycle Cleanup\n\nSocket-based workers cleaned up via `destroyConn` channel:\n\n```mermaid\nsequenceDiagram\n    participant TC as TC eBPF\n    participant Module as Module\n    participant EP as EventProcessor\n    participant EW as eventWorker\n    \n    TC->>Module: ConnDataEvent<br/>IsDestroy=1\n    Module->>Module: GetSockPointer()\n    Module->>EP: WriteDestroyConn(sockPtr)\n    \n    EP->>EP: destroyConn <- sockPtr\n    EP->>EP: Serve() select destroyConn\n    EP->>EP: destroyWorkers(sockPtr)\n    \n    loop For each worker\n        EP->>EW: GetDestroyUUID()\n        \n        alt Match found\n            EP->>EW: CloseEventWorker()\n            EW->>EW: close(closeChan)\n            EW->>EW: Run() receives close signal\n            EW->>EW: drainAndClose()\n            EW->>EP: delWorkerByUUID()\n        end\n    end\n```\n\n**Sources:** [pkg/event_processor/processor.go:177-185](), [pkg/event_processor/processor.go:115-128](), [pkg/event_processor/iworker.go:142-148]()\n\nThis mechanism ensures workers for closed sockets are properly cleaned up, preventing memory leaks.\n\n## Summary\n\nThe event processing system provides:\n\n1. **Strong typing** via `IEventStruct` interface for type-safe event handling\n2. **UUID-based routing** to aggregate related events into workers\n3. **Dual lifecycle modes** for efficient resource management\n4. **Automatic protocol detection** and parsing for HTTP/1.x and HTTP/2\n5. **Multiple output formats** supporting text, hex, and protobuf\n6. **Graceful error handling** with non-blocking channels and event dropping\n\nThis architecture enables eCapture to handle high-volume event streams from multiple eBPF programs while maintaining structured output suitable for both human and machine consumption."
          },
          {
            "page_plan": {
              "id": "6",
              "title": "Troubleshooting and FAQ"
            },
            "content": "# Troubleshooting and FAQ\n\n<details>\n<summary>Relevant source files</summary>\n\nThe following files were used as context for generating this wiki page:\n\n- [CHANGELOG.md](CHANGELOG.md)\n- [README.md](README.md)\n- [README_CN.md](README_CN.md)\n- [images/ecapture-help-v0.8.9.svg](images/ecapture-help-v0.8.9.svg)\n- [main.go](main.go)\n- [user/module/probe_openssl_lib.go](user/module/probe_openssl_lib.go)\n- [variables.mk](variables.mk)\n\n</details>\n\n\n\nThis page provides solutions to common problems encountered when using eCapture, along with debugging techniques and frequently asked questions. For information about system requirements and installation, see [Dependencies and System Requirements](#1.3). For build issues, refer to [Build System](#5.1).\n\n---\n\n## Common Issues Decision Tree\n\nThe following diagram shows the decision tree for diagnosing common eCapture issues:\n\n```mermaid\ngraph TB\n    START[\"eCapture Issue\"]\n    \n    STARTS[\"Does eCapture start?\"]\n    PERM[\"Permission Error?\"]\n    KERNEL[\"Kernel Version Check\"]\n    BTF[\"BTF Support Check\"]\n    \n    CAPTURE[\"Does capture work?\"]\n    VERSION[\"Version Detection Error?\"]\n    NODATA[\"No Data Captured?\"]\n    CORRUPT[\"Corrupted Output?\"]\n    \n    PERM_FIX[\"Run with sudo<br/>Check CAP_BPF capability\"]\n    KERNEL_FIX[\"Upgrade kernel to 4.18+ (x86_64)<br/>or 5.5+ (aarch64)\"]\n    BTF_FIX[\"Check CONFIG_DEBUG_INFO_BTF=y<br/>Or use non-CO-RE build\"]\n    \n    VERSION_FIX[\"Specify --ssl_version manually<br/>Check library path with --libssl\"]\n    NODATA_FIX[\"Check PID/UID filters<br/>Verify target process uses target library\"]\n    CORRUPT_FIX[\"Check output mode settings<br/>Verify disk space<br/>Review file permissions\"]\n    \n    START --> STARTS\n    STARTS -->|No| PERM\n    PERM -->|Yes| PERM_FIX\n    PERM -->|No| KERNEL\n    KERNEL -->|< 4.18 x86_64<br/>< 5.5 aarch64| KERNEL_FIX\n    KERNEL -->|OK| BTF\n    BTF -->|Missing| BTF_FIX\n    \n    STARTS -->|Yes| CAPTURE\n    CAPTURE -->|No| VERSION\n    VERSION -->|Yes| VERSION_FIX\n    VERSION -->|No| NODATA\n    NODATA -->|Yes| NODATA_FIX\n    NODATA -->|No| CORRUPT\n    CORRUPT -->|Yes| CORRUPT_FIX\n```\n\nSources: [README.md:13-17](), [CHANGELOG.md:41-50](), [user/module/probe_openssl_lib.go:64-70]()\n\n---\n\n## Kernel and System Requirements Issues\n\n### Issue: \"kernel version is too low\" or eCapture fails to start\n\n**Symptoms:**\n- Error message about kernel version\n- Program exits immediately\n- eBPF program load failures\n\n**Required Kernel Versions:**\n\n| Architecture | Minimum Kernel Version | CO-RE Support |\n|--------------|----------------------|---------------|\n| x86_64       | 4.18                | Yes           |\n| aarch64      | 5.5                 | Yes           |\n\n**Solutions:**\n\n1. Check your kernel version:\n```bash\nuname -r\n```\n\n2. Verify BTF support (required for CO-RE mode):\n```bash\ncat /boot/config-$(uname -r) | grep CONFIG_DEBUG_INFO_BTF\n# Should return: CONFIG_DEBUG_INFO_BTF=y\n```\n\n3. If BTF is not available:\n   - Check if BTF data exists: `ls -l /sys/kernel/btf/vmlinux`\n   - eCapture automatically falls back to non-CO-RE mode if BTF is unavailable\n\n**Troubleshooting Diagram:**\n\n```mermaid\ngraph LR\n    CHECK[\"Check Kernel Version\"]\n    BTF_CHECK[\"BTF Available?\"]\n    CORE_MODE[\"CO-RE Mode\"]\n    NONCORE_MODE[\"Non-CO-RE Mode\"]\n    UPGRADE[\"Upgrade Kernel\"]\n    \n    CHECK -->|\">= 4.18 (x86_64)<br/>>= 5.5 (aarch64)\"| BTF_CHECK\n    CHECK -->|\"< 4.18 (x86_64)<br/>< 5.5 (aarch64)\"| UPGRADE\n    \n    BTF_CHECK -->|Yes| CORE_MODE\n    BTF_CHECK -->|No| NONCORE_MODE\n    \n    CORE_MODE -->|\"Uses BTF for portability<br/>Single binary works across kernels\"|DONE[\"Ready to Run\"]\n    NONCORE_MODE -->|\"Uses kernel headers<br/>Kernel-specific bytecode\"|DONE\n```\n\nSources: [README.md:13-17](), [variables.mk:153-167](), [CHANGELOG.md:41]()\n\n---\n\n## Permission Issues\n\n### Issue: \"Operation not permitted\" or \"Permission denied\"\n\n**Symptoms:**\n- Error when loading eBPF programs\n- \"failed to load BPF program\" messages\n- CAP_BPF related errors\n\n**Required Permissions:**\n\neCapture requires **ROOT privileges** or specific capabilities:\n\n1. **CAP_BPF** - Load eBPF programs (Linux 5.8+)\n2. **CAP_PERFMON** - Access performance monitoring\n3. **CAP_NET_ADMIN** - Attach TC programs\n4. **CAP_SYS_ADMIN** - Legacy capability for older kernels\n\n**Solutions:**\n\n1. Run with sudo:\n```bash\nsudo ecapture tls\n```\n\n2. Check capabilities (Linux 5.8+):\n```bash\n# eCapture automatically detects CAP_BPF\n# If detection fails, you'll see a warning\n```\n\n3. For Docker containers:\n```bash\ndocker run --rm --privileged=true --net=host gojue/ecapture tls\n```\n\n**Capability Check Flow:**\n\n```mermaid\ngraph TB\n    START[\"Permission Check\"]\n    ROOT[\"Running as root?\"]\n    KERNEL58[\"Kernel >= 5.8?\"]\n    CAPBPF[\"CAP_BPF available?\"]\n    LEGACY[\"Use CAP_SYS_ADMIN\"]\n    SUCCESS[\"Permission OK\"]\n    FAIL[\"Permission Denied\"]\n    \n    START --> ROOT\n    ROOT -->|Yes| SUCCESS\n    ROOT -->|No| KERNEL58\n    KERNEL58 -->|Yes| CAPBPF\n    KERNEL58 -->|No| LEGACY\n    CAPBPF -->|Yes| SUCCESS\n    CAPBPF -->|No| FAIL\n    LEGACY -->|Available| SUCCESS\n    LEGACY -->|Not Available| FAIL\n```\n\nSources: [CHANGELOG.md:322-323](), [CHANGELOG.md:343](), [CHANGELOG.md:370]()\n\n---\n\n## Version Detection Issues\n\n### Issue: \"OpenSSL/BoringSSL version not found\" or \"used default version\"\n\n**Symptoms:**\n- Warning: \"OpenSSL/BoringSSL version not found from shared library file\"\n- Warning: \"used default version\"\n- No data captured or incorrect data\n\n**Version Detection Process:**\n\n```mermaid\ngraph TB\n    START[\"Start Version Detection\"]\n    SCAN[\".rodata Section Scan<br/>detectOpenssl function\"]\n    REGEX[\"Regex Match:<br/>OpenSSL \\d\\.\\d\\.[0-9a-z]+\"]\n    FOUND{\"Version String<br/>Found?\"}\n    MAP[\"Check sslVersionBpfMap\"]\n    BYTECODE{\"Bytecode<br/>Exists?\"}\n    DOWNGRADE[\"downgradeOpensslVersion<br/>Find closest match\"]\n    DEFAULT[\"Use Default Version<br/>Based on library name\"]\n    LOAD[\"Load Bytecode\"]\n    \n    START --> SCAN\n    SCAN --> REGEX\n    REGEX --> FOUND\n    FOUND -->|Yes| MAP\n    FOUND -->|No| DEFAULT\n    MAP --> BYTECODE\n    BYTECODE -->|Yes| LOAD\n    BYTECODE -->|No| DOWNGRADE\n    DOWNGRADE --> LOAD\n    DEFAULT --> LOAD\n    \n    LOAD --> END[\"Version: linux_default_3_0<br/>or linux_default_1_1_1\"]\n```\n\n**Solutions:**\n\n1. **Manually specify OpenSSL version:**\n```bash\n# For OpenSSL 3.0.x\nsudo ecapture tls --ssl_version=\"openssl 3.0.0\"\n\n# For OpenSSL 1.1.1\nsudo ecapture tls --ssl_version=\"openssl 1.1.1\"\n\n# For Android BoringSSL\nsudo ecapture tls --ssl_version=\"boringssl_a_14\"\n```\n\n2. **Specify library path explicitly:**\n```bash\n# If library is in non-standard location\nsudo ecapture tls --libssl=/usr/local/lib/libssl.so.3\n\n# For statically linked binaries\nsudo ecapture tls --libssl=/path/to/static/binary\n```\n\n3. **Supported OpenSSL/BoringSSL Versions:**\n\n| Library Type | Supported Versions |\n|--------------|-------------------|\n| OpenSSL 1.0.2 | 1.0.2a - 1.0.2u |\n| OpenSSL 1.1.0 | 1.1.0a - 1.1.0l |\n| OpenSSL 1.1.1 | 1.1.1a - 1.1.1w |\n| OpenSSL 3.0.x | 3.0.0 - 3.0.17 |\n| OpenSSL 3.1.x | 3.1.0 - 3.1.8 |\n| OpenSSL 3.2.x | 3.2.0 - 3.2.5 |\n| OpenSSL 3.3.x | 3.3.0 - 3.3.4 |\n| OpenSSL 3.4.x | 3.4.0 - 3.4.2 |\n| OpenSSL 3.5.x | 3.5.0 - 3.5.4 |\n| BoringSSL (Android) | Android 12-16 (A12-A16) |\n| BoringSSL (Non-Android) | Latest master branch |\n\n4. **Version Downgrade Logic:**\n\neCapture implements automatic version downgrade to find the closest supported version when exact match is not found.\n\n**Error Message Mapping:**\n\n| Error/Warning | Meaning | Solution |\n|--------------|---------|----------|\n| `OpenSSL/BoringSSL version not found from shared library file` | Version string not found in .rodata section | Specify `--ssl_version` manually |\n| `used default version` | Using fallback bytecode | Verify capture works; if not, specify version |\n| `Can not find Default BoringSSL version` | sslVersionBpfMap missing Android default | Check Android version with `--android_ver` |\n| `OpenSSL/BoringSSL version bytecode not found` | No compiled bytecode for detected version | Use supported version or default |\n\nSources: [user/module/probe_openssl_lib.go:189-282](), [user/module/probe_openssl_lib.go:284-317](), [user/module/probe_openssl_lib.go:341-369](), [user/module/probe_openssl_lib.go:44-62](), [variables.mk:190-212]()\n\n---\n\n## Library Detection Issues\n\n### Issue: \"couldn't find bpf bytecode file error\" or library not found\n\n**Symptoms:**\n- Error: \"couldn't find bpf bytecode file error\"\n- Library path detection fails\n- No hooks attached\n\n**Library Search Order:**\n\n```mermaid\ngraph TB\n    START[\"Library Detection Start\"]\n    LIBSSL[\"--libssl flag<br/>specified?\"]\n    MANUAL[\"Use specified path\"]\n    LDCONF[\"Parse /etc/ld.so.conf\"]\n    SEARCH[\"Search in:<br/>/lib64<br/>/usr/lib64<br/>/lib<br/>/usr/lib\"]\n    PATTERN[\"Match pattern:<br/>libssl.so*<br/>libcrypto.so*\"]\n    FOUND{\"Library<br/>Found?\"}\n    ERROR[\"Error: Library not found\"]\n    ELF[\"Parse ELF file<br/>Check architecture\"]\n    SUCCESS[\"Library loaded\"]\n    \n    START --> LIBSSL\n    LIBSSL -->|Yes| MANUAL\n    LIBSSL -->|No| LDCONF\n    MANUAL --> ELF\n    LDCONF --> SEARCH\n    SEARCH --> PATTERN\n    PATTERN --> FOUND\n    FOUND -->|Yes| ELF\n    FOUND -->|No| ERROR\n    ELF --> SUCCESS\n```\n\n**Solutions:**\n\n1. **Check library existence:**\n```bash\n# Find OpenSSL libraries\nldconfig -p | grep libssl\n\n# Check library version\nstrings /usr/lib/x86_64-linux-gnu/libssl.so.3 | grep \"OpenSSL\"\n```\n\n2. **Fix /etc/ld.so.conf path issues:**\n```bash\n# Verify ld.so.conf\ncat /etc/ld.so.conf\n\n# Update library cache\nsudo ldconfig\n```\n\n3. **Specify library path explicitly:**\n```bash\n# For custom installation\nsudo ecapture tls --libssl=/opt/openssl/lib/libssl.so\n\n# For container environments with non-standard paths\nsudo ecapture tls --libssl=/custom/path/libssl.so.1.1\n```\n\n4. **Common library locations:**\n\n| Distribution | Typical Path |\n|--------------|--------------|\n| Ubuntu/Debian | `/usr/lib/x86_64-linux-gnu/libssl.so.3` |\n| CentOS/RHEL | `/usr/lib64/libssl.so.1.1` |\n| Alpine Linux | `/usr/lib/libssl.so.3` |\n| Android | `/apex/com.android.conscrypt/lib64/libssl.so` |\n\nSources: [CHANGELOG.md:84](), [CHANGELOG.md:436](), [user/module/probe_openssl_lib.go:189-217]()\n\n---\n\n## Runtime Errors\n\n### Issue: Nil Pointer Panics\n\n**Symptoms:**\n- Program crashes with nil pointer dereference\n- Panic in probe initialization\n\n**Common Causes and Solutions:**\n\n1. **GnuTLS probe setup failure:**\n```\npanic: runtime error: invalid memory address or nil pointer dereference\nin gnutls probe\n```\n\n**Solution:** Fixed in v1.5.0 - ensure you're using the latest version.\n\n2. **Uninitialized channel:**\n```\npanic: send on nil channel\n```\n\n**Solution:** Module initialization order issue. File a bug report with reproduction steps.\n\nSources: [CHANGELOG.md:20](), [CHANGELOG.md:603]()\n\n### Issue: Concurrent Map Access\n\n**Symptoms:**\n- Error: \"concurrent map read and map write\"\n- Program crash during high load\n- Data corruption\n\n**Solution:**\n\nThis was a known issue fixed in v0.7.3. Update to the latest version:\n```bash\n# Check your version\necapture -v\n\n# Update to latest version\nwget https://github.com/gojue/ecapture/releases/latest/download/ecapture-linux-amd64.tar.gz\n```\n\nSources: [CHANGELOG.md:650]()\n\n### Issue: \"incoming chan is full\" Error\n\n**Symptoms:**\n- Warning: \"incoming chan is full\"\n- Process exits unexpectedly\n- Data loss during capture\n\n**Solution:**\n\nThis indicates the event processing pipeline is overwhelmed. Fixed in v0.9.0.\n\n1. **Reduce capture scope:**\n```bash\n# Filter by PID\nsudo ecapture tls --pid=1234\n\n# Filter by UID\nsudo ecapture tls --uid=1000\n```\n\n2. **Increase map size:**\n```bash\n# Default is 5120 KB, increase if needed\nsudo ecapture tls --mapsize=10240\n```\n\n3. **Use pcap mode instead of text mode:**\n```bash\n# PCAP mode has better performance for high-volume capture\nsudo ecapture tls -m pcap -w output.pcapng -i eth0\n```\n\nSources: [CHANGELOG.md:373](), [CHANGELOG.md:709]()\n\n---\n\n## Module-Specific Troubleshooting\n\n### OpenSSL/TLS Module\n\n#### Issue: No data captured despite successful start\n\n**Diagnostic Steps:**\n\n```mermaid\ngraph TB\n    START[\"No Data Captured\"]\n    PROCESS[\"Target process<br/>running?\"]\n    LIBRARY[\"Uses OpenSSL<br/>library?\"]\n    VERSION[\"Correct version<br/>detected?\"]\n    FILTER[\"PID/UID filters<br/>too restrictive?\"]\n    PORT[\"Target port<br/>correct?\"]\n    TRAFFIC[\"Actual TLS<br/>traffic occurring?\"]\n    \n    RESTART[\"Start target process<br/>after eCapture\"]\n    CHECK_LIB[\"Check with lsof -p PID\"]\n    FIX_VER[\"Specify --ssl_version\"]\n    REMOVE_FILTER[\"Remove --pid/--uid\"]\n    FIX_PORT[\"Use --target_port<br/>or --target_port=0 for all\"]\n    GENERATE[\"Generate test traffic\"]\n    \n    START --> PROCESS\n    PROCESS -->|No| RESTART\n    PROCESS -->|Yes| LIBRARY\n    LIBRARY -->|No| CHECK_LIB\n    LIBRARY -->|Yes| VERSION\n    VERSION -->|No| FIX_VER\n    VERSION -->|Yes| FILTER\n    FILTER -->|Yes| REMOVE_FILTER\n    FILTER -->|No| PORT\n    PORT -->|Wrong| FIX_PORT\n    PORT -->|OK| TRAFFIC\n    TRAFFIC -->|No| GENERATE\n```\n\n**Example Commands:**\n\n```bash\n# Capture all ports\nsudo ecapture tls --target_port=0\n\n# Capture specific process\nsudo ecapture tls --pid=$(pgrep curl)\n\n# Verbose output for debugging\nsudo ecapture tls --log-level=debug\n```\n\nSources: [README.md:72-149](), [CHANGELOG.md:778]()\n\n#### Issue: Keylog file empty or incomplete\n\n**Symptoms:**\n- `--keylogfile` created but empty\n- Missing CLIENT_RANDOM entries\n- Wireshark cannot decrypt traffic\n\n**Solutions:**\n\n1. **Verify keylog mode:**\n```bash\n# Correct syntax for keylog mode\nsudo ecapture tls -m keylog --keylogfile=keys.log\n```\n\n2. **Check TLS version:**\n- TLS 1.2: Captures `CLIENT_RANDOM` with master secret\n- TLS 1.3: Captures traffic secrets (requires OpenSSL 3.0+)\n\n3. **Common issues:**\n- OpenSSL 3.0.12 had a specific bug (fixed in v1.4.1)\n- Missing trailing bytes in GoTLS keylog (fixed in v1.4.0)\n- Keylog lost in certain OpenSSL versions (fixed in v1.3.0)\n\nSources: [CHANGELOG.md:69](), [CHANGELOG.md:85](), [CHANGELOG.md:127]()\n\n#### Issue: PCAP file corrupted or Wireshark cannot open\n\n**Symptoms:**\n- PCAP file cannot be opened in Wireshark\n- \"Invalid format\" error\n- Missing packets\n\n**Solutions:**\n\n1. **Ensure proper termination:**\n```bash\n# Use Ctrl+C to properly close the PCAP file\n# Don't use kill -9\n```\n\n2. **Check disk space:**\n```bash\ndf -h /path/to/pcap/directory\n```\n\n3. **Verify PCAP-NG format:**\n```bash\n# eCapture uses PCAP-NG format\nfile output.pcapng\n# Should show: pcapng capture file\n```\n\n4. **DSB (Decryption Secrets Block):**\neCapture writes TLS keys as DSB in PCAP-NG files. Ensure you're using a recent version of Wireshark (3.0+).\n\nSources: [CHANGELOG.md:161](), [CHANGELOG.md:542](), [CHANGELOG.md:664]()\n\n### GoTLS Module\n\n#### Issue: \"cant found RET offset\" or stripped Go binary\n\n**Symptoms:**\n- Error: \"cant found RET offset in gotls mode\"\n- Stripped Go binaries not working\n- PIE executable offset errors\n\n**Solutions:**\n\n1. **Stripped binary support:**\nAdded in v0.7.0 - update to latest version.\n\n2. **PIE executable issues:**\n```bash\n# Check if binary is PIE\nfile /path/to/go/binary\n# Should show: \"dynamically linked\" or \"pie executable\"\n```\n\nFixed in v0.7.7 for aarch64 PIE executables.\n\n3. **Specify Go binary path:**\n```bash\nsudo ecapture gotls --elfpath=/path/to/go/binary\n```\n\nSources: [CHANGELOG.md:593](), [CHANGELOG.md:752](), [CHANGELOG.md:573]()\n\n#### Issue: No GoTLS data captured\n\n**Checklist:**\n\n```mermaid\ngraph LR\n    CHECK1[\"Go binary uses<br/>crypto/tls?\"]\n    CHECK2[\"--elfpath specified<br/>correctly?\"]\n    CHECK3[\"Go version<br/>supported?\"]\n    CHECK4[\"TLS connections<br/>active?\"]\n    \n    FIX1[\"Verify with:<br/>strings binary | grep crypto/tls\"]\n    FIX2[\"Use full path:<br/>--elfpath=/full/path\"]\n    FIX3[\"Supports Go 1.18+<br/>Update Go if needed\"]\n    FIX4[\"Generate test traffic\"]\n    \n    CHECK1 -->|No| FIX1\n    CHECK2 -->|No| FIX2\n    CHECK3 -->|No| FIX3\n    CHECK4 -->|No| FIX4\n```\n\nSources: [README.md:259-276]()\n\n### Bash/Zsh Module\n\n#### Issue: Bash commands not captured\n\n**Symptoms:**\n- No bash output\n- Probe attachment fails\n- \"incorrect probe attachment\" warning\n\n**Solutions:**\n\n1. **Check bash path:**\n```bash\nwhich bash\n# Common paths: /bin/bash, /usr/bin/bash\n```\n\n2. **Improved bash path detection:**\nFixed in v1.3.1 with better path detection and probe attachment.\n\n3. **Readline hook verification:**\n```bash\n# Check if bash uses readline\nldd $(which bash) | grep readline\n```\n\nSources: [CHANGELOG.md:114-115](), [CHANGELOG.md:592]()\n\n### MySQL/PostgreSQL Module\n\n#### Issue: No SQL queries captured\n\n**Supported Versions:**\n\n| Database | Supported Versions |\n|----------|-------------------|\n| MySQL | 5.6, 5.7, 8.0 |\n| MariaDB | All versions |\n| PostgreSQL | 10+ |\n\n**Solutions:**\n\n1. **Verify mysqld process:**\n```bash\nps aux | grep mysqld\n```\n\n2. **Check dispatch_command symbol:**\n```bash\n# For MySQL\nnm /usr/sbin/mysqld | grep dispatch_command\n```\n\n3. **Module-specific flags:**\n```bash\n# MySQL\nsudo ecapture mysqld\n\n# PostgreSQL\nsudo ecapture postgres\n```\n\nSources: [README.md:42](), [README.md:157-159]()\n\n---\n\n## Performance Issues\n\n### Issue: High CPU or Memory Usage\n\n**Symptoms:**\n- eCapture consuming excessive CPU\n- Memory continuously growing\n- System slowdown\n\n**Solutions:**\n\n1. **Memory optimization (v0.9.5+):**\n```bash\n# Set truncate size to reduce memory cost\nsudo ecapture tls --truncate_size=1024\n```\n\n2. **Reduce map size:**\n```bash\n# Default is 5120 KB\nsudo ecapture tls --mapsize=2048\n```\n\n3. **Use filters:**\n```bash\n# Filter by PID\nsudo ecapture tls --pid=1234\n\n# Filter by UID\nsudo ecapture tls --uid=1000\n\n# Filter by port (pcap mode)\nsudo ecapture tls -m pcap -i eth0 \"tcp port 443\"\n```\n\n4. **Dual lifecycle management (v1.2.0+):**\neCapture now implements optimized event worker lifecycle management for better resource usage.\n\nSources: [CHANGELOG.md:291](), [CHANGELOG.md:137](), [CHANGELOG.md:709]()\n\n### Issue: Incomplete SSL Data or Truncation\n\n**Symptoms:**\n- Truncated HTTP responses\n- \"incomplete SSL data for excessively long lengths\"\n- Missing data chunks\n\n**Solutions:**\n\n1. **Adjust truncate size:**\n```bash\n# Default truncate size\nsudo ecapture tls --truncate_size=4096\n```\n\n2. **Fixed in v0.9.5:**\nBug with incomplete SSL data for long lengths was resolved.\n\nSources: [CHANGELOG.md:289](), [CHANGELOG.md:154]()\n\n---\n\n## Build and Compilation Issues\n\n### Issue: Build fails with \"header not found\"\n\n**Symptoms:**\n- Error during kernel header generation\n- Missing vmlinux.h\n- Cross-compilation failures\n\n**Solutions:**\n\n1. **Install required tools:**\n```bash\n# Ubuntu/Debian\nsudo apt-get install clang llvm libelf-dev linux-headers-$(uname -r)\n\n# CentOS/RHEL\nsudo yum install clang llvm elfutils-libelf-devel kernel-devel\n```\n\n2. **Cross-compilation setup:**\n```bash\n# For ARM64 on x86_64\nsudo apt-get install gcc-aarch64-linux-gnu\n\n# Set CROSS_ARCH\nmake CROSS_ARCH=arm64\n```\n\n3. **Kernel headers path:**\n```bash\n# Specify kernel headers if non-standard\nmake KERN_HEADERS=/path/to/kernel/headers\n```\n\nSources: [CHANGELOG.md:447](), [variables.mk:172-179]()\n\n### Issue: Docker build errors\n\n**Symptoms:**\n- Docker image build fails\n- CVE vulnerabilities in base image\n\n**Solutions:**\n\n1. **Use official Docker image:**\n```bash\ndocker pull gojue/ecapture:latest\n```\n\n2. **Build from source:**\n```bash\n# Clone repository\ngit clone https://github.com/gojue/ecapture.git\ncd ecapture\n\n# Build\nmake\n```\n\nSources: [CHANGELOG.md:372](), [README.md:59-68]()\n\n---\n\n## Frequently Asked Questions\n\n### Q: Does eCapture support Windows or macOS?\n\n**A:** No, eCapture only supports Linux and Android systems. It relies on eBPF technology which is Linux-specific. For cross-platform visualization, use [eCaptureQ](#README.md:287-302) GUI in remote mode.\n\nSources: [README.md:13-17]()\n\n### Q: Can I capture traffic without root privileges?\n\n**A:** eCapture requires root privileges or specific capabilities (CAP_BPF, CAP_PERFMON, CAP_NET_ADMIN) to load eBPF programs. There is no way to bypass this requirement.\n\nSources: [README.md:15]()\n\n### Q: Why does eCapture show \"OpenSSL version not found\"?\n\n**A:** eCapture attempts to automatically detect the OpenSSL version by parsing the `.rodata` section of the library. If detection fails:\n1. It uses automatic downgrade logic to find the closest version\n2. Falls back to default version (usually 3.0 or 1.1.1)\n3. You can manually specify the version with `--ssl_version`\n\nSources: [user/module/probe_openssl_lib.go:189-282](), [user/module/probe_openssl_lib.go:284-317]()\n\n### Q: What's the difference between CO-RE and non-CO-RE mode?\n\n**A:** \n- **CO-RE (Compile Once - Run Everywhere):** Uses BTF information to make eBPF programs portable across different kernel versions. Requires kernel with BTF support (CONFIG_DEBUG_INFO_BTF=y).\n- **Non-CO-RE:** Compiles eBPF programs with specific kernel headers. Works on older kernels without BTF but requires kernel-specific bytecode.\n\neCapture automatically detects BTF availability and selects the appropriate mode.\n\nSources: [variables.mk:270-272]()\n\n### Q: Can I capture traffic from statically linked binaries?\n\n**A:** Yes, for statically linked binaries, specify the binary path directly with `--libssl`:\n```bash\nsudo ecapture tls --libssl=/path/to/static/binary\n```\n\nSources: [README.md:169]()\n\n### Q: How do I use the captured keylog with Wireshark?\n\n**A:** \n1. Capture TLS keys:\n```bash\nsudo ecapture tls -m keylog --keylogfile=keys.log\n```\n\n2. In Wireshark:\n   - Go to Edit → Preferences → Protocols → TLS\n   - Set \"(Pre)-Master-Secret log filename\" to the path of keys.log\n   - Reload the capture\n\n3. Or use tshark directly:\n```bash\ntshark -o tls.keylog_file:keys.log -Y http -f \"port 443\" -i eth0\n```\n\nSources: [README.md:235-247]()\n\n### Q: Does eCapture affect the performance of monitored applications?\n\n**A:** eCapture has minimal performance impact because:\n1. eBPF runs in kernel space with low overhead\n2. Uses efficient perf ring buffers for data transfer\n3. Implements filtering at the eBPF level\n4. Memory-optimized truncation (v0.9.5+)\n\nHowever, capturing very high-traffic applications may require tuning `--mapsize` and `--truncate_size`.\n\nSources: [CHANGELOG.md:291](), [CHANGELOG.md:709]()\n\n### Q: Can I filter capture by process or user?\n\n**A:** Yes, eCapture supports multiple filtering options:\n\n```bash\n# Filter by PID\nsudo ecapture tls --pid=1234\n\n# Filter by UID\nsudo ecapture tls --uid=1000\n\n# Filter by port (all modules)\nsudo ecapture tls --target_port=443\n\n# PCAP filter (pcap mode only)\nsudo ecapture tls -m pcap -i eth0 \"host 192.168.1.1 and port 443\"\n```\n\nSources: [README.md:183-184](), [CHANGELOG.md:472]()\n\n### Q: How do I capture HTTP/2 or HTTP/3 traffic?\n\n**A:** \n- **HTTP/2:** Automatically supported in text mode (v0.8.5+). eCapture parses HTTP/2 frames and displays headers/data.\n- **HTTP/3 (QUIC):** Supported in PCAP mode. Use:\n```bash\nsudo ecapture tls -m pcap -i eth0 \"udp port 443\"\n```\n\nSources: [README.md:179](), [CHANGELOG.md:487]()\n\n### Q: What Android versions are supported?\n\n**A:** eCapture supports Android 12 through Android 16 with BoringSSL. Specify Android version:\n```bash\nsudo ecapture tls --android_ver=14\n```\n\nAvailable versions: a_13 (Android 12/13), a_14 (Android 14), a_15 (Android 15), a_16 (Android 16).\n\nSources: [variables.mk:94-97](), [CHANGELOG.md:23](), [CHANGELOG.md:305]()\n\n### Q: Can I use eCapture for security auditing?\n\n**A:** Yes, eCapture is designed for security auditing scenarios:\n- **Host Security:** Capture bash/zsh commands\n- **Database Audit:** Capture MySQL/PostgreSQL queries\n- **Network Security:** Capture and analyze encrypted traffic\n- **Compliance:** Generate audit logs with `--eventcollector` flag\n\nSources: [README.md:40-42]()\n\n### Q: Does eCapture work in containers?\n\n**A:** Yes, but with considerations:\n1. Container must run in privileged mode or have BPF capabilities\n2. Can monitor processes both inside and outside containers\n3. Use host network mode for network capture\n\n```bash\ndocker run --rm --privileged=true --net=host \\\n  -v /path/to/output:/output \\\n  gojue/ecapture tls --eventcollector=/output/events.log\n```\n\nSources: [README.md:63-68]()\n\n---\n\n## Debugging Techniques\n\n### Enable Debug Logging\n\n```bash\n# Enable debug output\nsudo ecapture tls --log-level=debug\n\n# Save logs to file\nsudo ecapture tls --logaddr=/var/log/ecapture.log\n```\n\n### Verify eBPF Program Loading\n\n```bash\n# Check loaded eBPF programs\nsudo bpftool prog list | grep ecapture\n\n# Check eBPF maps\nsudo bpftool map list\n\n# Dump map contents (advanced)\nsudo bpftool map dump id <map_id>\n```\n\n### Trace System Calls\n\n```bash\n# Trace eCapture system calls\nsudo strace -f ecapture tls\n\n# Trace specific syscalls\nsudo strace -e trace=bpf,perf_event_open ecapture tls\n```\n\n### Check Library Loading\n\n```bash\n# Verify library is loaded by target process\nsudo lsof -p <PID> | grep libssl\n\n# Check library dependencies\nldd /path/to/target/binary | grep ssl\n```\n\n### Network Verification\n\n```bash\n# Verify network interface\nip link show\n\n# Check TC filters (for packet capture)\nsudo tc filter show dev eth0 ingress\nsudo tc filter show dev eth0 egress\n\n# Monitor network traffic\nsudo tcpdump -i eth0 -n \"port 443\"\n```\n\n### Core Dump Analysis\n\nIf eCapture crashes:\n```bash\n# Enable core dumps\nulimit -c unlimited\n\n# Run eCapture\nsudo ecapture tls\n\n# Analyze core dump (if crash occurs)\ngdb ecapture core\n```\n\n### Useful Diagnostic Commands\n\n| Command | Purpose |\n|---------|---------|\n| `ecapture -v` | Show version information |\n| `uname -r` | Check kernel version |\n| `cat /boot/config-$(uname -r) \\| grep BTF` | Verify BTF support |\n| `ls -l /sys/kernel/btf/vmlinux` | Check BTF availability |\n| `sudo bpftool prog list` | List eBPF programs |\n| `ldd $(which ecapture)` | Check dependencies |\n| `file /path/to/libssl.so` | Verify library architecture |\n\nSources: [CHANGELOG.md:521](), [README_CN.md:84-126]()\n\n---\n\n## Getting Help\n\nIf you encounter an issue not covered here:\n\n1. **Check GitHub Issues:** Search existing issues at https://github.com/gojue/ecapture/issues\n2. **Create New Issue:** Include:\n   - eCapture version (`ecapture -v`)\n   - Kernel version (`uname -r`)\n   - Distribution and architecture\n   - Complete error messages\n   - Steps to reproduce\n   - Output of debug logging\n3. **Join Community:** QQ群 or GitHub Discussions\n4. **Review Changelog:** Recent fixes may address your issue: [CHANGELOG.md:1-782]()\n\n---\n\n## Quick Reference: Error Messages\n\n| Error Message | Page Section | Quick Fix |\n|--------------|--------------|-----------|\n| \"kernel version is too low\" | [Kernel Requirements](#kernel-and-system-requirements-issues) | Upgrade kernel |\n| \"Operation not permitted\" | [Permission Issues](#permission-issues) | Use `sudo` |\n| \"OpenSSL version not found\" | [Version Detection](#version-detection-issues) | Use `--ssl_version` flag |\n| \"couldn't find bpf bytecode\" | [Library Detection](#library-detection-issues) | Use `--libssl` flag |\n| \"incoming chan is full\" | [Runtime Errors](#issue-incoming-chan-is-full-error) | Reduce scope or increase mapsize |\n| \"concurrent map access\" | [Runtime Errors](#issue-concurrent-map-access) | Update to v0.7.3+ |\n| \"cant found RET offset\" | [GoTLS Module](#issue-cant-found-ret-offset-or-stripped-go-binary) | Update to v0.7.0+ |\n\nSources: [CHANGELOG.md:1-782](), [user/module/probe_openssl_lib.go:64-70](), [README.md:1-335]()"
          }
        ]
      },
      "zh": {
        "metadata": {
          "repo_name": "gojue/ecapture",
          "commit_hash": "0766a93b",
          "generated_at": "2025-12-22T04:32:54.412647",
          "config": null,
          "config_source": "none"
        },
        "pages": [
          {
            "page_plan": {
              "id": "1",
              "title": "概述"
            },
            "content": "# 概述\n\n本文档介绍 eCapture（旁观者），这是一个基于 eBPF 的网络流量捕获和系统审计工具。eCapture 拦截 SSL/TLS 加密通信并提取明文数据，无需 CA 证书或修改应用程序。它还提供了 Shell 命令和数据库查询的系统审计能力。\n\n有关安装和使用说明，请参阅[安装与快速入门](#1.1)。有关详细的模块文档，请参阅[捕获模块](#3)。有关构建和开发信息，请参阅[开发指南](#5)。\n\n## 系统目的与功能\n\neCapture 使用 eBPF（扩展伯克利包过滤器）技术在用户空间和内核空间边界捕获加密网络流量。系统将探针附加到 SSL/TLS 库函数和网络栈入口点，实现加密通信的明文捕获和系统活动的运行时审计。\n\n**核心功能：**\n- **SSL/TLS 明文捕获**：拦截来自 OpenSSL、BoringSSL、GnuTLS、NSS/NSPR 库的加密数据\n- **Go TLS 捕获**：支持原生 Go `crypto/tls` 库加密\n- **系统审计**：捕获 Bash/Zsh 命令和 MySQL/PostgreSQL SQL 查询\n- **无需 CA 证书**：透明工作，无需证书安装\n- **多种输出格式**：文本、PCAP-NG、密钥日志（SSLKEYLOGFILE）、Protobuf 流\n\n来源：[README.md:1-43]()、[README_CN.md:40-43]()、[CHANGELOG.md:188-273]()\n\n## 平台支持\n\neCapture 支持 Linux 和 Android 操作系统，具有特定的内核版本要求：\n\n| 架构 | 最低内核版本 | 备注 |\n|------|-------------|------|\n| x86_64 | 4.18 | 完整功能支持 |\n| aarch64 | 5.5 | 完整功能支持 |\n\n**要求：**\n- eBPF 操作需要 ROOT 权限\n- 推荐但不强制要求 BTF（BPF Type Format）支持\n- 非 CO-RE 编译模式需要内核头文件\n\n**不支持的平台：**\n- Windows（无 eBPF 支持）\n- macOS（无 eBPF 支持）\n\n系统会自动检测内核能力，并在运行时选择 CO-RE（一次编译，到处运行）或非 CO-RE 字节码。\n\n来源：[README.md:14-16]()、[README_CN.md:15-17]()、[go.mod:1-60]()\n\n## 系统架构\n\n```mermaid\ngraph TB\n    subgraph CLI[\"CLI 入口点\"]\n        main[\"main.go<br/>cli.Start()\"]\n        cobra[\"cobra/pflag<br/>命令框架\"]\n    end\n    \n    subgraph Modules[\"捕获模块\"]\n        tls[\"EBPFProbeOPENSSL<br/>OpenSSL/BoringSSL\"]\n        gotls[\"EBPFProbeGOTLS<br/>Go crypto/tls\"]\n        gnutls[\"EBPFProbeGNUTLS<br/>GnuTLS\"]\n        nspr[\"EBPFProbeNSPR<br/>NSS/NSPR\"]\n        bash[\"EBPFProbeBASH<br/>Bash readline\"]\n        zsh[\"EBPFProbeZSH<br/>Zsh zle\"]\n        mysql[\"EBPFProbeMYSQLD<br/>MySQL dispatch_command\"]\n        postgres[\"EBPFProbePOSTGRES<br/>PostgreSQL exec_simple_query\"]\n    end\n    \n    subgraph eBPF[\"eBPF 运行时\"]\n        manager[\"ebpfmanager<br/>生命周期管理\"]\n        uprobe[\"Uprobe 程序<br/>函数钩子\"]\n        tc[\"TC 程序<br/>网络数据包\"]\n        kprobe[\"Kprobe 程序<br/>内核钩子\"]\n        maps[\"eBPF Maps<br/>Perf/RingBuffer\"]\n    end\n    \n    subgraph Events[\"事件处理\"]\n        reader[\"perfEventReader<br/>ringbufEventReader\"]\n        worker[\"eventWorker<br/>连接生命周期\"]\n        parser[\"IParser<br/>HTTP/HTTP2 解析\"]\n    end\n    \n    subgraph Output[\"输出层\"]\n        text[\"文本日志器<br/>控制台/文件\"]\n        pcap[\"PCAP 写入器<br/>pcapng 格式\"]\n        keylog[\"密钥日志写入器<br/>SSLKEYLOGFILE\"]\n        proto[\"Protobuf 流<br/>WebSocket\"]\n    end\n    \n    main --> cobra\n    cobra --> tls\n    cobra --> gotls\n    cobra --> gnutls\n    cobra --> nspr\n    cobra --> bash\n    cobra --> zsh\n    cobra --> mysql\n    cobra --> postgres\n    \n    tls --> manager\n    gotls --> manager\n    gnutls --> manager\n    nspr --> manager\n    bash --> manager\n    zsh --> manager\n    mysql --> manager\n    postgres --> manager\n    \n    manager --> uprobe\n    manager --> tc\n    manager --> kprobe\n    \n    uprobe --> maps\n    tc --> maps\n    kprobe --> maps\n    \n    maps --> reader\n    reader --> worker\n    worker --> parser\n    \n    parser --> text\n    parser --> pcap\n    parser --> keylog\n    parser --> proto\n```\n\n**系统层次：**\n\n1. **CLI 入口点**：使用 Cobra 框架的命令行界面，用于子命令路由\n2. **捕获模块**：八个专用模块，实现 `IModule` 接口，用于不同协议\n3. **eBPF 运行时**：探针管理、字节码加载和 eBPF 程序生命周期\n4. **事件处理**：事件读取、连接跟踪和协议解析\n5. **输出层**：针对不同消费场景的多种输出格式\n\n每个模块通过 `IModule` 接口进行协调，使用自己的 eBPF 程序和事件处理程序独立运行。\n\n来源：[main.go:1-12]()、[README.md:152-161]()、[README_CN.md:129-140]()\n\n## 捕获模块\n\neCapture 提供八个模块用于捕获不同的协议和应用程序：\n\n| 模块 | 目标 | 描述 | 命令 |\n|------|------|------|------|\n| `tls` | OpenSSL/BoringSSL | 从 OpenSSL 1.0.x-3.5.x 和 BoringSSL（Android 12-16）捕获 SSL/TLS 明文 | `ecapture tls` |\n| `gotls` | Go crypto/tls | 从使用原生 crypto/tls 库的 Go 应用程序捕获 TLS 流量 | `ecapture gotls` |\n| `gnutls` | GnuTLS | 从 GnuTLS 库应用程序捕获 TLS 流量 | `ecapture gnutls` |\n| `nss` | NSS/NSPR | 从 Firefox 和其他基于 NSS/NSPR 的应用程序捕获流量 | `ecapture nss` |\n| `bash` | Bash | 通过 readline 库钩子审计 bash 命令执行 | `ecapture bash` |\n| `zsh` | Zsh | 通过 zle（Z-Shell 行编辑器）钩子审计 zsh 命令执行 | `ecapture zsh` |\n| `mysqld` | MySQL/MariaDB | 从 MySQL 5.6/5.7/8.0 和 MariaDB 捕获 SQL 查询 | `ecapture mysqld` |\n| `postgres` | PostgreSQL | 从 PostgreSQL 10+ 捕获 SQL 查询 | `ecapture postgres` |\n\n每个模块实现 `IModule` 接口，可以独立运行或与其他模块组合使用。\n\n来源：[README.md:152-161]()、[README_CN.md:129-140]()、[CHANGELOG.md:38-42]()\n\n## eBPF 技术使用\n\n```mermaid\ngraph LR\n    subgraph UserSpace[\"用户空间应用程序\"]\n        app[\"目标应用程序<br/>OpenSSL/Go/MySQL/Bash\"]\n    end\n    \n    subgraph Kernel[\"内核空间\"]\n        uprobe_entry[\"uprobe<br/>SSL_read 入口\"]\n        uprobe_ret[\"uretprobe<br/>SSL_read 返回\"]\n        tc_ingress[\"TC ingress<br/>capture_packets\"]\n        tc_egress[\"TC egress<br/>capture_packets\"]\n        kprobe_hook[\"kprobe<br/>tcp_sendmsg<br/>udp_sendmsg\"]\n    end\n    \n    subgraph Maps[\"eBPF Maps\"]\n        perf[\"Perf Array<br/>数据事件\"]\n        ring[\"Ring Buffer<br/>事件\"]\n        hash[\"Hash Maps<br/>pidConns<br/>sock2pidFd<br/>masterKeys\"]\n    end\n    \n    app -->|\"函数调用\"| uprobe_entry\n    app -->|\"函数返回\"| uprobe_ret\n    app -->|\"网络数据包\"| tc_ingress\n    app -->|\"网络数据包\"| tc_egress\n    app -->|\"套接字操作\"| kprobe_hook\n    \n    uprobe_entry --> perf\n    uprobe_ret --> perf\n    tc_ingress --> ring\n    tc_egress --> ring\n    kprobe_hook --> hash\n    \n    perf --> reader[\"perfEventReader<br/>用户空间\"]\n    ring --> reader\n    hash --> reader\n```\n\n**eBPF 探针类型：**\n\n1. **Uprobe/Uretprobe**：附加到用户空间库函数\n   - 入口探针捕获函数参数（例如 `SSL_read(ssl, buf, len)`）\n   - 返回探针捕获返回值和输出缓冲区\n   - 用途：SSL/TLS 函数、数据库查询、Shell 命令\n\n2. **TC（流量控制）**：附加到网络接口入口/出口\n   - 在内核级别捕获网络数据包\n   - 提取 4 元组（源/目的 IP:端口）用于连接跟踪\n   - 用途：PCAP 模式数据包捕获，带进程归属\n\n3. **Kprobe**：附加到内核函数\n   - 钩取套接字操作（`tcp_sendmsg`、`udp_sendmsg`）\n   - 将套接字文件描述符映射到进程\n   - 用途：连接跟踪和进程识别\n\n**CO-RE vs 非 CO-RE：**\n- **CO-RE（启用 BTF）**：单一字节码适用于所有内核版本\n- **非 CO-RE**：需要带头文件的内核特定字节码\n- eCapture 自动检测 BTF 可用性并加载适当的字节码\n\n来源：[README.md:38-43]()、[CHANGELOG.md:249-251]()、[CHANGELOG.md:552-556]()\n\n## 输出模式和格式\n\neCapture 支持四种主要输出模式，每个模块可配置：\n\n### 文本模式\n\n**命令**：`ecapture tls -m text`（默认模式）\n\n直接将明文数据输出到控制台或文件。包括 HTTP/1.x 和 HTTP/2 协议解析，自动解码压缩响应。\n\n**功能：**\n- 实时输出到 stdout\n- 使用 `-w <文件名>` 输出到文件\n- HTTP/HTTP2 请求/响应解析\n- 彩色输出，提高可读性\n- 使用 `--hex` 标志的十六进制转储模式\n\n### PCAP 模式\n\n**命令**：`ecapture tls -m pcap --pcapfile=output.pcapng -i eth0`\n\n生成与 Wireshark 兼容的 PCAP-NG 文件，将捕获的明文与重构的网络数据包结合。\n\n**功能：**\n- 标准 pcapng 格式，带 EPB（增强数据包块）\n- DSB（解密密钥块）用于 TLS 主密钥\n- IPv4/IPv6 支持，带 4 元组跟踪\n- TCP 和 UDP 协议支持（包括 QUIC）\n- 通过 eBPF 进行 PID/UID 过滤\n\n### 密钥日志模式\n\n**命令**：`ecapture tls -m keylog --keylogfile=keys.log`\n\n以 `SSLKEYLOGFILE` 格式导出 TLS 主密钥，供 Wireshark 或 tshark 使用。\n\n**格式：**\n```\nCLIENT_RANDOM <client_random_hex> <master_secret_hex>\nCLIENT_HANDSHAKE_TRAFFIC_SECRET <client_random_hex> <secret_hex>\nSERVER_HANDSHAKE_TRAFFIC_SECRET <client_random_hex> <secret_hex>\n```\n\n**使用案例：**\n```shell\n# 捕获密钥\necapture tls -m keylog --keylogfile=keys.log\n\n# 使用 tshark 解密\ntshark -o tls.keylog_file:keys.log -Y http -T fields -e http.file_data -f \"port 443\" -i eth0\n```\n\n### Protobuf 模式\n\n**命令**：`ecapture tls`，启用 WebSocket 服务器（默认：`localhost:28256`）\n\n以 Protocol Buffer 格式将事件流式传输到已连接的客户端（例如 eCaptureQ GUI 应用程序）。\n\n**事件类型：**\n- `SSLDataEvent`：SSL/TLS 明文数据\n- `MasterSecretEvent`：TLS 主密钥\n- `BashEvent`：Shell 命令\n- `MysqldEvent`：SQL 查询\n\n来源：[README.md:172-253]()、[README_CN.md:150-220]()、[CHANGELOG.md:715-747]()\n\n## 数据流管道\n\n```mermaid\nflowchart TD\n    subgraph Capture[\"eBPF 捕获\"]\n        ssl[\"SSL_read/SSL_write<br/>Uprobe 钩子\"]\n        gotls_read[\"crypto/tls.Conn.Read<br/>Uprobe 钩子\"]\n        tc[\"TC 数据包捕获<br/>4元组提取\"]\n        mysql[\"dispatch_command<br/>Uprobe 钩子\"]\n    end\n    \n    subgraph Maps[\"eBPF Maps\"]\n        perf[\"Perf 事件<br/>明文数据\"]\n        master[\"主密钥映射<br/>TLS 密钥\"]\n        conn[\"连接映射<br/>pidConns<br/>sock2pidFd\"]\n    end\n    \n    subgraph Reader[\"事件读取器\"]\n        perf_reader[\"perfEventReader<br/>4MB 环形缓冲区\"]\n        ring_reader[\"ringbufEventReader<br/>内核 5.8+\"]\n    end\n    \n    subgraph Worker[\"事件工作器\"]\n        dispatch[\"分发器<br/>事件类型路由\"]\n        lifecycle[\"连接生命周期<br/>默认 vs 套接字模式\"]\n    end\n    \n    subgraph Parser[\"协议解析器\"]\n        http1[\"HTTP/1.x 解析器<br/>请求/响应\"]\n        http2[\"HTTP/2 解析器<br/>HPACK 解码器\"]\n        sql[\"SQL 解析器<br/>查询提取\"]\n    end\n    \n    subgraph Collector[\"事件收集器\"]\n        aggregate[\"聚合<br/>多缓冲区组装\"]\n        truncate[\"截断<br/>--truncate 大小\"]\n        rotate[\"轮转<br/>--eventrotatesize\"]\n    end\n    \n    subgraph Writers[\"输出写入器\"]\n        text_w[\"文本写入器<br/>控制台/文件\"]\n        pcap_w[\"PCAP 写入器<br/>gopacket\"]\n        key_w[\"密钥日志写入器<br/>SSLKEYLOGFILE\"]\n        proto_w[\"Protobuf 写入器<br/>WebSocket\"]\n    end\n    \n    ssl --> perf\n    gotls_read --> perf\n    mysql --> perf\n    ssl --> master\n    tc --> conn\n    \n    perf --> perf_reader\n    perf --> ring_reader\n    master --> perf_reader\n    conn --> perf_reader\n    \n    perf_reader --> dispatch\n    ring_reader --> dispatch\n    \n    dispatch --> lifecycle\n    lifecycle --> http1\n    lifecycle --> http2\n    lifecycle --> sql\n    \n    http1 --> aggregate\n    http2 --> aggregate\n    sql --> aggregate\n    \n    aggregate --> truncate\n    truncate --> rotate\n    \n    rotate --> text_w\n    rotate --> pcap_w\n    rotate --> key_w\n    rotate --> proto_w\n```\n\n**管道阶段：**\n\n1. **捕获**：eBPF 探针拦截函数调用和网络数据包\n2. **Maps**：事件和连接状态的内核空间存储\n3. **读取器**：eBPF 映射数据的用户空间消费者（perf 数组或 ring buffer）\n4. **工作器**：事件类型分发和连接生命周期管理\n5. **解析器**：协议特定解析（HTTP、HTTP/2、SQL）\n6. **收集器**：事件聚合、截断和轮转\n7. **写入器**：格式特定的输出生成\n\n管道支持可配置的事件截断（`--truncate`）、文件轮转（`--eventrotatesize`、`--eventrotatetime`）以及按 PID（`--pid`）或 UID（`--uid`）进行选择性过滤。\n\n来源：[CHANGELOG.md:137-163]()、[CHANGELOG.md:647-653]()、[CHANGELOG.md:491-493]()\n\n## 版本检测与字节码选择\n\n```mermaid\ngraph TD\n    start[\"模块初始化<br/>例如 MOpenSSLProbe.Init()\"]\n    detect[\"版本检测<br/>ELF 解析\"]\n    check_ver{{\"是否找到<br/>版本?\"}}\n    map[\"字节码映射<br/>OpenSSL 1.0.2-3.5.x<br/>BoringSSL A12-A16\"]\n    check_btf{{\"BTF<br/>已启用?\"}}\n    core[\"加载 CO-RE 字节码<br/>*_core.o\"]\n    noncore[\"加载非 CO-RE<br/>*_noncore.o\"]\n    fallback[\"使用默认<br/>linux_default_3_0\"]\n    attach[\"附加探针<br/>ebpfmanager\"]\n    \n    start --> detect\n    detect --> check_ver\n    check_ver -->|\"是\"| map\n    check_ver -->|\"否\"| fallback\n    map --> check_btf\n    fallback --> check_btf\n    check_btf -->|\"是\"| core\n    check_btf -->|\"否\"| noncore\n    core --> attach\n    noncore --> attach\n```\n\n**版本检测过程：**\n\n1. **ELF 解析**：读取共享库文件（例如 `libssl.so.3`）以提取版本字符串\n2. **版本映射**：将检测到的版本映射到特定的结构体偏移量\n3. **字节码选择**：根据版本和 BTF 可用性选择适当的 eBPF 字节码\n4. **回退策略**：如果检测失败，使用默认版本偏移量\n\n**支持的 OpenSSL 版本：**\n- 1.0.2 系列：1.0.2a-1.0.2zg\n- 1.1.0 系列：1.1.0-1.1.0l\n- 1.1.1 系列：1.1.1-1.1.1w\n- 3.0 系列：3.0.0-3.0.15\n- 3.1 系列：3.1.0-3.1.7\n- 3.2 系列：3.2.0-3.2.3\n- 3.3 系列：3.3.0-3.3.3\n- 3.4 系列：3.4.0-3.4.1\n- 3.5 系列：3.5.0-3.5.4\n\n**支持的 BoringSSL 版本：**\n- Android 12（API 31，A12）\n- Android 13（API 33，A13）\n- Android 14（API 34，A14）\n- Android 15（API 35，A15）\n- Android 16（API 36，A16）\n\n当版本检测失败时，系统会发出警告，但会继续使用默认偏移量。\n\n来源：[CHANGELOG.md:14-35]()、[CHANGELOG.md:98-99]()、[CHANGELOG.md:305-308]()、[CHANGELOG.md:540-541]()、[CHANGELOG.md:651-654]()、[CHANGELOG.md:779-781]()\n\n## 使用场景\n\n### 网络调试与开发\n\n**场景**：调试 HTTPS API 调用，无需修改应用程序代码\n\n```shell\n# 捕获特定进程的明文\necapture tls --pid=12345\n\n# 捕获带 HTTP/2 解析\necapture tls -m text\n\n# 生成 PCAP 供 Wireshark 分析\necapture tls -m pcap -i eth0 --pcapfile=debug.pcapng\n```\n\n### 安全分析与监控\n\n**场景**：实时监控加密通信以进行安全审计\n\n```shell\n# 捕获系统上所有 HTTPS 流量\necapture tls\n\n# 监控特定用户的连接\necapture tls --uid=1000\n\n# 导出密钥进行离线分析\necapture tls -m keylog --keylogfile=audit_keys.log\n```\n\n### 数据库活动审计\n\n**场景**：监控 SQL 查询以进行合规性和性能分析\n\n```shell\n# 捕获 MySQL 查询\necapture mysqld --pid=$(pidof mysqld)\n\n# 捕获 PostgreSQL 查询\necapture postgres --pid=$(pidof postgres)\n```\n\n### Shell 命令审计\n\n**场景**：跟踪 Shell 命令以进行安全审计和事件响应\n\n```shell\n# 审计所有 bash 会话\necapture bash\n\n# 审计 zsh 会话\necapture zsh\n```\n\n### Go 应用程序 TLS 捕获\n\n**场景**：调试使用原生 crypto/tls 库的 Go 应用程序\n\n```shell\n# 指定 Go 二进制文件路径\necapture gotls --elfpath=/path/to/go_binary\n\n# 使用密钥日志模式捕获\necapture gotls --elfpath=/path/to/go_binary -m keylog\n```\n\n来源：[README.md:72-280]()、[README_CN.md:69-251]()、[CHANGELOG.md:260-273]()\n\n## 远程配置与集成\n\neCapture 提供 HTTP API 用于运行时配置更新和事件转发：\n\n**HTTP 配置 API**：可在 `localhost:28256` 访问（可使用 `--listen` 标志配置）\n\n**事件转发：**\n- WebSocket 流式传输到外部客户端\n- Protocol Buffer 序列化用于结构化数据\n- 与 eCaptureQ GUI 应用程序集成\n- 支持 Burp Suite 和其他分析工具\n\n详细 API 文档请参阅：\n- 远程配置：[docs/remote-config-update-api.md]()\n- 事件转发：[docs/event-forward-api.md]()\n- Protobuf 协议：[protobuf/PROTOCOLS.md]()\n\n来源：[CHANGELOG.md:16-17]()、[CHANGELOG.md:27-28]()、[CHANGELOG.md:43-45]()、[CHANGELOG.md:82-89]()、[README.md:288-327]()、[README_CN.md:268-307]()\n\n## 构建与部署\n\neCapture 使用复杂的构建系统生成独立的二进制文件：\n\n**构建产物：**\n- **Linux ELF 二进制文件**：嵌入 eBPF 字节码的静态二进制文件\n- **Docker 镜像**：多架构镜像（linux/amd64、linux/arm64）\n- **Debian 软件包**：用于软件包管理的 `.deb` 格式\n- **Android 发行版**：仅非 CO-RE，支持 BoringSSL\n\n**二进制嵌入**：所有 eBPF 字节码变体都使用 `go-bindata` 嵌入，消除对外部字节码文件的运行时依赖。\n\n**交叉编译**：支持在 aarch64 主机上构建 x86_64 二进制文件，反之亦然。\n\n有关构建说明和开发设置，请参阅[构建系统](#5.1)。\n\n来源：[CHANGELOG.md:537-538]()、[README.md:316-319]()、[README_CN.md:297-300]()"
          },
          {
            "page_plan": {
              "id": "1.1",
              "title": "安装与快速入门"
            },
            "content": "# 安装与快速入门\n\n本页提供 eCapture 的安装说明和首次捕获运行指南。内容涵盖系统要求、安装方法（二进制下载、Docker、源码编译）以及基本使用示例，帮助您开始捕获 SSL/TLS 明文流量。\n\n关于编译选项和自定义的详细信息，请参阅[构建系统](#5.1)。关于完整的 CLI 文档，请参阅[命令行界面](#1.2)。关于底层架构的理解，请参阅[架构设计](#2)。\n\n---\n\n## 系统要求\n\n由于基于 eBPF 实现，eCapture 对内核和架构有特定要求：\n\n### 内核版本要求\n\n| 架构 | 最低内核版本 | 说明 |\n|-------------|------------------------|-------|\n| x86_64 (amd64) | 4.18 | 完整功能支持 |\n| aarch64 (arm64) | 5.5 | 完整功能支持 |\n\n### 其他要求\n\n- **权限**：需要 ROOT（超级用户）权限\n- **BTF 支持**：可选但推荐用于 CO-RE 模式（更好的可移植性）\n- **支持平台**：Linux、Android\n- **不支持平台**：Windows、macOS\n\n可通过以下命令验证 BTF（BPF Type Format）支持：\n\n```bash\n# 检查内核是否支持 BTF\ncat /boot/config-$(uname -r) | grep CONFIG_DEBUG_INFO_BTF\n# 应输出：CONFIG_DEBUG_INFO_BTF=y\n```\n\n### 系统架构检测流程图\n\n```mermaid\ngraph TB\n    subgraph \"系统验证\"\n        CHECK_KERN[\"检查内核版本<br/>uname -r\"]\n        CHECK_ARCH[\"检查 CPU 架构<br/>uname -m\"]\n        CHECK_BTF[\"检查 BTF 支持<br/>CONFIG_DEBUG_INFO_BTF\"]\n        CHECK_ROOT[\"验证 ROOT 权限<br/>sudo/CAP_BPF\"]\n    end\n    \n    subgraph \"执行模式选择\"\n        BTF_YES[\"BTF 可用\"]\n        BTF_NO[\"BTF 不可用\"]\n        CORE_MODE[\"CO-RE 模式<br/>*_core.o 字节码\"]\n        NONCORE_MODE[\"Non-CO-RE 模式<br/>*_noncore.o 字节码\"]\n    end\n    \n    subgraph \"二进制选择\"\n        AMD64_BIN[\"ecapture-linux-amd64\"]\n        ARM64_BIN[\"ecapture-linux-arm64\"]\n        ANDROID_BIN[\"ecapture-android-arm64\"]\n    end\n    \n    CHECK_KERN --> CHECK_ARCH\n    CHECK_ARCH --> CHECK_BTF\n    CHECK_BTF --> BTF_YES\n    CHECK_BTF --> BTF_NO\n    CHECK_BTF --> CHECK_ROOT\n    \n    BTF_YES --> CORE_MODE\n    BTF_NO --> NONCORE_MODE\n    \n    CHECK_ARCH --> AMD64_BIN\n    CHECK_ARCH --> ARM64_BIN\n    CHECK_ARCH --> ANDROID_BIN\n    \n    CORE_MODE -.->|\"内嵌于\"| AMD64_BIN\n    NONCORE_MODE -.->|\"内嵌于\"| AMD64_BIN\n```\n\n**来源**: [README.md:13-16](), [README_CN.md:14-17](), [.github/workflows/go-c-cpp.yml:10-127]()\n\n---\n\n## 安装方法\n\neCapture 提供三种主要安装方法：预编译二进制下载、Docker 容器和源码编译。\n\n### 方法 1：二进制发行版下载\n\n最简单的安装方法是从 GitHub releases 下载预编译二进制文件。\n\n#### 下载和解压\n\n```bash\n# 下载最新版本（将 VERSION 替换为实际版本号，如 v0.8.6）\nVERSION=v1.5.1\nARCH=amd64  # 或 arm64\n\n# 下载压缩包\nwget https://github.com/gojue/ecapture/releases/download/${VERSION}/ecapture-${VERSION}-linux-${ARCH}.tar.gz\n\n# 解压\ntar -xzf ecapture-${VERSION}-linux-${ARCH}.tar.gz\ncd ecapture-${VERSION}-linux-${ARCH}\n\n# 验证\nsudo ./ecapture --help\n```\n\n#### 二进制包内容\n\n每个发行压缩包包含：\n\n| 文件 | 说明 |\n|------|-------------|\n| `ecapture` | 主可执行二进制文件 |\n| `LICENSE` | 项目许可证 |\n| `CHANGELOG.md` | 发行说明和版本历史 |\n| `README.md` | 英文文档 |\n| `README_CN.md` | 中文文档 |\n\n#### 架构特定的二进制文件\n\n```mermaid\ngraph LR\n    subgraph \"发布产物\"\n        RELEASE[\"GitHub Release<br/>github.com/gojue/ecapture/releases\"]\n    end\n    \n    subgraph \"Linux x86_64\"\n        LINUX_AMD64[\"ecapture-VERSION-linux-amd64.tar.gz\"]\n        CORE_AMD64[\"包含 CO-RE 字节码\"]\n        NONCORE_AMD64[\"包含 non-CO-RE 字节码\"]\n    end\n    \n    subgraph \"Linux aarch64\"\n        LINUX_ARM64[\"ecapture-VERSION-linux-arm64.tar.gz\"]\n        CORE_ARM64[\"包含 CO-RE 字节码\"]\n        NONCORE_ARM64[\"包含 non-CO-RE 字节码\"]\n    end\n    \n    subgraph \"Android aarch64\"\n        ANDROID_ARM64[\"ecapture-VERSION-android-arm64-nocore.tar.gz\"]\n        ANDROID_NONCORE[\"仅 Non-CO-RE\"]\n        ANDROID_BORING[\"专注 BoringSSL\"]\n    end\n    \n    RELEASE --> LINUX_AMD64\n    RELEASE --> LINUX_ARM64\n    RELEASE --> ANDROID_ARM64\n    \n    LINUX_AMD64 --> CORE_AMD64\n    LINUX_AMD64 --> NONCORE_AMD64\n    LINUX_ARM64 --> CORE_ARM64\n    LINUX_ARM64 --> NONCORE_ARM64\n    ANDROID_ARM64 --> ANDROID_NONCORE\n    ANDROID_ARM64 --> ANDROID_BORING\n```\n\n**来源**: [README.md:48-56](), [README_CN.md:48-55](), [.github/workflows/release.yml:88-100]()\n\n### 方法 2：Docker 容器\n\nDocker 提供了一个隔离环境来运行 eCapture，无需在主机系统上安装依赖。\n\n#### 拉取并运行 Docker 镜像\n\n```bash\n# 拉取最新镜像\ndocker pull gojue/ecapture:latest\n\n# 使用必需的权限运行\ndocker run --rm \\\n  --privileged=true \\\n  --net=host \\\n  -v /path/on/host:/path/in/container \\\n  gojue/ecapture:latest tls\n\n# 示例：保存输出到主机目录\ndocker run --rm \\\n  --privileged=true \\\n  --net=host \\\n  -v $(pwd)/captures:/captures \\\n  gojue/ecapture:latest tls --pcapfile=/captures/output.pcapng\n```\n\n#### Docker 构建流程\n\nDocker 镜像使用多阶段构建过程：\n\n```mermaid\ngraph TB\n    subgraph \"阶段 1：构建器\"\n        BASE[\"ubuntu:22.04\"]\n        DEPS[\"安装依赖<br/>clang-14, llvm-14<br/>golang 1.24.6<br/>linux-headers\"]\n        SOURCE[\"复制源代码<br/>/build/ecapture\"]\n        COMPILE[\"make all<br/>SNAPSHOT_VERSION\"]\n        BINARY[\"bin/ecapture\"]\n    end\n    \n    subgraph \"阶段 2：运行时\"\n        ALPINE[\"alpine:latest\"]\n        COPY_BIN[\"复制 /build/ecapture/bin/ecapture\"]\n        FINAL[\"ecapture 运行时镜像\"]\n    end\n    \n    BASE --> DEPS\n    DEPS --> SOURCE\n    SOURCE --> COMPILE\n    COMPILE --> BINARY\n    \n    BINARY -.->|\"COPY --from=ecapture_builder\"| COPY_BIN\n    ALPINE --> COPY_BIN\n    COPY_BIN --> FINAL\n```\n\n**Docker 配置详情**：\n\n- **基础镜像**：构建时使用 Ubuntu 22.04，运行时使用 Alpine\n- **必需标志**：`--privileged=true`（eBPF 需要内核访问），`--net=host`（网络监控）\n- **卷挂载**：使用 `-v` 将输出文件保存到主机\n- **多架构**：支持 linux/amd64 和 linux/arm64\n\n**来源**: [README.md:58-70](), [README_CN.md:57-67](), [builder/Dockerfile:1-39]()\n\n### 方法 3：从源码构建\n\n从源码构建允许自定义并提供最新的开发功能。\n\n#### 快速构建\n\n```bash\n# 克隆仓库\ngit clone https://github.com/gojue/ecapture.git\ncd ecapture\ngit submodule update --init\n\n# 安装依赖（Ubuntu/Debian）\nsudo apt-get update\nsudo apt-get install -y \\\n  build-essential \\\n  pkgconf \\\n  libelf-dev \\\n  llvm-14 \\\n  clang-14 \\\n  linux-tools-common \\\n  linux-tools-generic \\\n  linux-source\n\n# 设置环境\nmake env\n\n# 构建（包括 CO-RE 和 non-CO-RE）\nmake all\n\n# 二进制输出位置\n./bin/ecapture --help\n```\n\n#### 构建系统概览\n\n```mermaid\ngraph TB\n    subgraph \"源文件\"\n        KERN_C[\"kern/*.c<br/>27+ eBPF 程序\"]\n        GO_SRC[\"user/module/*.go<br/>cli/cmd/*.go<br/>pkg/*\"]\n        LIBPCAP[\"lib/libpcap/<br/>子模块\"]\n    end\n    \n    subgraph \"构建流程 - Makefile\"\n        EBPF_CORE[\"编译 CO-RE<br/>clang -target bpfel<br/>*_core.o\"]\n        EBPF_NONCORE[\"编译 Non-CO-RE<br/>clang + llc<br/>*_noncore.o\"]\n        LESS52[\"编译 <5.2 变体<br/>*_less52.o\"]\n        \n        EMBED[\"go-bindata<br/>嵌入字节码<br/>assets/ebpf_probe.go\"]\n        \n        LIBPCAP_BUILD[\"构建 libpcap<br/>静态库\"]\n        \n        GO_BUILD[\"Go 构建<br/>CGO_ENABLED=1<br/>静态链接\"]\n    end\n    \n    subgraph \"输出\"\n        BINARY[\"bin/ecapture<br/>单一二进制<br/>所有字节码已嵌入\"]\n    end\n    \n    KERN_C --> EBPF_CORE\n    KERN_C --> EBPF_NONCORE\n    KERN_C --> LESS52\n    \n    EBPF_CORE --> EMBED\n    EBPF_NONCORE --> EMBED\n    LESS52 --> EMBED\n    \n    LIBPCAP --> LIBPCAP_BUILD\n    \n    EMBED --> GO_BUILD\n    GO_SRC --> GO_BUILD\n    LIBPCAP_BUILD --> GO_BUILD\n    \n    GO_BUILD --> BINARY\n```\n\n**构建目标**：\n\n| 目标 | 说明 | 命令 |\n|--------|-------------|---------|\n| `all` | 完整构建，包含 CO-RE 和 non-CO-RE | `make all` |\n| `nocore` | 仅 non-CO-RE（旧内核） | `make nocore` |\n| `env` | 显示构建环境 | `make env` |\n| `clean` | 清理构建产物 | `make clean` |\n\n**交叉编译**：\n\n```bash\n# 在 x86_64 主机上为 ARM64 构建\nCROSS_ARCH=arm64 make env\nCROSS_ARCH=arm64 make all\n\n# 为 Android 构建\nANDROID=1 CROSS_ARCH=arm64 make nocore\n```\n\n**来源**: [Makefile:1-269](), [README.md:316-319](), [CHANGELOG.md:553-562](), [builder/init_env.sh:1-106]()\n\n---\n\n## 首次捕获：TLS 模块\n\n安装完成后，通过捕获 SSL/TLS 流量来验证 eCapture 是否正常工作。\n\n### 基础 TLS 捕获\n\n最简单的捕获命令可以监控所有 OpenSSL/BoringSSL 加密流量：\n\n```bash\nsudo ecapture tls\n```\n\n**预期输出结构**：\n\n```mermaid\ngraph TB\n    subgraph \"初始化阶段\"\n        BANNER[\"AppName, Version, Homepage\"]\n        SYSINFO[\"内核信息, BTF 模式\"]\n        LIBDETECT[\"库检测<br/>OpenSSL/BoringSSL 版本\"]\n        HOOKSETUP[\"Hook 设置<br/>SSL_read, SSL_write 等\"]\n    end\n    \n    subgraph \"运行时阶段\"\n        EVENTS[\"事件流<br/>UUID, 类型, 长度\"]\n        HTTP_REQ[\"HTTP 请求<br/>GET /path HTTP/1.1\"]\n        HTTP_RESP[\"HTTP 响应<br/>HTTP/1.1 200 OK\"]\n        HTTP2_FRAME[\"HTTP/2 帧<br/>HEADERS, DATA 等\"]\n    end\n    \n    BANNER --> SYSINFO\n    SYSINFO --> LIBDETECT\n    LIBDETECT --> HOOKSETUP\n    \n    HOOKSETUP --> EVENTS\n    EVENTS --> HTTP_REQ\n    EVENTS --> HTTP_RESP\n    EVENTS --> HTTP2_FRAME\n```\n\n### 示例输出解读\n\n```\n2024-09-15T11:51:31Z INF AppName=\"eCapture(旁观者)\"\n2024-09-15T11:51:31Z INF Version=linux_arm64:0.8.6-20240915-d87ae48:5.15.0-113-generic\n2024-09-15T11:51:31Z INF Listen=localhost:28256\n2024-09-15T11:51:31Z WRN ========== module starting. ==========\n2024-09-15T11:51:31Z INF Kernel Info=5.15.152 Pid=233698\n2024-09-15T11:51:31Z INF BTF bytecode mode: CORE. btfMode=0\n2024-09-15T11:51:31Z INF Hook masterKey function Functions=[\"SSL_get_wbio\",\"SSL_in_before\",\"SSL_do_handshake\"]\n2024-09-15T11:51:31Z INF target all process.\n```\n\n**输出字段说明**：\n\n| 字段 | 说明 | 示例值 |\n|-------|-------------|---------------|\n| `Version` | 构建信息：OS_ARCH:VERSION:KERNEL | `linux_arm64:0.8.6:5.15.0-113` |\n| `Listen` | 用于远程配置的 HTTP API 端点 | `localhost:28256` |\n| `BTF bytecode mode` | CO-RE (0) 或 Non-CO-RE (1) | `CORE. btfMode=0` |\n| `Hook masterKey function` | eBPF 探针附加点 | `[\"SSL_get_wbio\",...]` |\n\n### 理解捕获的事件\n\n当流量被捕获时，事件将以以下结构显示：\n\n```\n2024-09-15T11:51:53Z ??? UUID:233851_233851_curl_5_1_172.16.71.1:51837, Name:HTTP2Request, Type:2, Length:304\n\nFrame Type\t=>\tHEADERS\nheader field \":method\" = \"GET\"\nheader field \":path\" = \"/\"\nheader field \":authority\" = \"google.com\"\n```\n\n**事件 UUID 格式**：`{pid}_{pid}_{comm}_{fd}_{direction}_{remote_addr}:{remote_port}`\n\n| 组成部分 | 含义 |\n|-----------|---------|\n| `233851` | 进程 ID |\n| `curl` | 进程名（截断至 16 字符） |\n| `5` | 文件描述符 |\n| `1` | 方向（0=读取/响应，1=写入/请求） |\n| `172.16.71.1:51837` | 远程端点 |\n\n**来源**: [README.md:72-149](), [README_CN.md:73-126]()\n\n---\n\n## 常见使用模式\n\n### 捕获模式\n\neCapture TLS 模块支持三种输出模式：\n\n#### 文本模式（默认）\n\n直接将明文输出到控制台或文件：\n\n```bash\n# 输出到控制台\nsudo ecapture tls\n\n# 输出到文件\nsudo ecapture tls > capture_output.txt\n\n# 指定 PID 过滤\nsudo ecapture tls --pid=1234\n```\n\n#### PCAP 模式\n\n保存为数据包捕获文件用于 Wireshark 分析：\n\n```bash\n# 基础 pcap 捕获\nsudo ecapture tls -m pcap -i eth0 --pcapfile=capture.pcapng\n\n# 使用网络过滤器\nsudo ecapture tls -m pcap -i eth0 --pcapfile=https.pcapng tcp port 443\n\n# 多个网络接口\nsudo ecapture tls -m pcap -i eth0,wlan0 --pcapfile=multi.pcapng\n```\n\n**PCAP 过滤器语法**：支持 tcpdump/BPF 过滤器表达式（如 `host 192.168.1.1 and tcp port 443`）\n\n#### Keylog 模式\n\n导出 TLS 主密钥用于离线解密：\n\n```bash\n# 生成 keylog 文件\nsudo ecapture tls -m keylog --keylogfile=tls_keys.log\n\n# 与 tshark 结合实现实时解密\nsudo ecapture tls -m keylog --keylogfile=keys.log &\ntshark -o tls.keylog_file:keys.log -Y http -T fields -e http.file_data -f \"port 443\" -i eth0\n```\n\n**来源**: [README.md:172-253](), [README_CN.md:150-219](), [CHANGELOG.md:688-757]()\n\n### 模块选择\n\neCapture 为不同目标提供专门的模块：\n\n```mermaid\ngraph LR\n    subgraph \"CLI 入口点\"\n        ECAPTURE[\"ecapture<br/>主命令\"]\n    end\n    \n    subgraph \"TLS/SSL 模块\"\n        TLS[\"ecapture tls<br/>OpenSSL/BoringSSL\"]\n        GOTLS[\"ecapture gotls<br/>Go crypto/tls\"]\n        GNUTLS[\"ecapture gnutls<br/>GnuTLS 库\"]\n        NSS[\"ecapture nss<br/>NSS/NSPR/Firefox\"]\n    end\n    \n    subgraph \"审计模块\"\n        BASH[\"ecapture bash<br/>Bash 命令\"]\n        ZSH[\"ecapture zsh<br/>Zsh 命令\"]\n        MYSQLD[\"ecapture mysqld<br/>MySQL 查询\"]\n        POSTGRES[\"ecapture postgres<br/>PostgreSQL 查询\"]\n    end\n    \n    ECAPTURE --> TLS\n    ECAPTURE --> GOTLS\n    ECAPTURE --> GNUTLS\n    ECAPTURE --> NSS\n    ECAPTURE --> BASH\n    ECAPTURE --> ZSH\n    ECAPTURE --> MYSQLD\n    ECAPTURE --> POSTGRES\n```\n\n**快速模块示例**：\n\n```bash\n# 捕获 bash 命令\nsudo ecapture bash\n\n# 捕获 MySQL 查询\nsudo ecapture mysqld\n\n# 捕获 Go TLS 流量\nsudo ecapture gotls --elfpath=/path/to/go/binary\n```\n\n**来源**: [README.md:151-161](), [README_CN.md:128-139](), [main.go:1-11]()\n\n---\n\n## 验证和故障排除\n\n### 验证安装\n\n```bash\n# 检查版本\nsudo ecapture --version\n\n# 显示帮助\nsudo ecapture --help\n\n# 测试模块可用性\nsudo ecapture tls --help\n```\n\n### 常见问题\n\n#### 问题：\"内核版本过低\"\n\n**解决方案**：验证内核版本满足最低要求：\n\n```bash\nuname -r\n# x86_64 应 >= 4.18，aarch64 应 >= 5.5\n```\n\n#### 问题：\"权限被拒绝\"\n\n**解决方案**：eCapture 需要 ROOT 权限：\n\n```bash\n# 使用 sudo\nsudo ecapture tls\n\n# 或检查 capabilities\nsudo setcap cap_sys_admin,cap_bpf+ep ./ecapture\n./ecapture tls\n```\n\n#### 问题：\"未找到 OpenSSL 版本\"\n\n**解决方案**：eCapture 将使用默认版本。您可以指定库路径：\n\n```bash\n# 从 ld.so.conf 自动检测\nsudo ecapture tls\n\n# 手动指定库\nsudo ecapture tls --libssl=/usr/lib/x86_64-linux-gnu/libssl.so.3\n\n# 对于静态二进制\nsudo ecapture tls --libssl=/path/to/static/binary\n```\n\n#### 问题：\"BTF 不可用\"\n\n**解决方案**：将自动选择 non-CO-RE 模式。为获得更好的兼容性：\n\n```bash\n# 安装 linux-headers\nsudo apt-get install linux-headers-$(uname -r)\n\n# 或显式使用 non-CO-RE 构建\n# （二进制包含两种模式，自动选择）\n```\n\n**来源**: [README.md:163-170](), [.github/workflows/go-c-cpp.yml:16-33]()\n\n---\n\n## 环境设置脚本\n\n对于开发环境，eCapture 提供了自动化设置脚本：\n\n```bash\n# 运行初始化脚本（仅支持 Ubuntu）\n/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/gojue/ecapture/master/builder/init_env.sh)\"\n```\n\n**脚本操作**：\n\n1. 检测 Ubuntu 版本并设置适当的 clang 版本\n2. 安装构建依赖（clang、llvm、linux-source、gcc 交叉编译器）\n3. 提取并准备内核头文件\n4. 安装 Go 1.24.6\n5. 克隆 eCapture 仓库\n6. 配置交叉编译支持\n\n**支持的 Ubuntu 版本**：\n\n| 版本 | Clang 版本 |\n|---------|---------------|\n| 20.04, 20.10 | clang-10 |\n| 21.04 | clang-11 |\n| 21.10, 22.04, 22.10 | clang-12 |\n| 23.04, 23.10 | clang-15 |\n| 24.04 | clang-18 |\n\n**来源**: [builder/init_env.sh:1-106]()\n\n---\n\n## CI/CD 构建验证\n\neCapture 使用 GitHub Actions 进行持续集成。构建流程验证：\n\n```mermaid\ngraph TB\n    subgraph \"CI 构建矩阵\"\n        AMD64[\"ubuntu-22.04<br/>x86_64 主机\"]\n        ARM64[\"ubuntu-22.04-arm<br/>aarch64 主机\"]\n    end\n    \n    subgraph \"构建步骤\"\n        ENV[\"安装编译器<br/>clang-14, linux-source\"]\n        CORE[\"构建 CO-RE<br/>make all\"]\n        NONCORE[\"构建 non-CO-RE<br/>make nocore\"]\n        CROSS[\"交叉编译<br/>CROSS_ARCH=\"]\n        ANDROID[\"Android 构建<br/>ANDROID=1\"]\n        TEST[\"运行测试<br/>go test -race\"]\n    end\n    \n    subgraph \"输出\"\n        BINARY[\"ecapture 二进制\"]\n        ARTIFACT[\"构建产物\"]\n    end\n    \n    AMD64 --> ENV\n    ARM64 --> ENV\n    \n    ENV --> CORE\n    CORE --> NONCORE\n    NONCORE --> CROSS\n    CROSS --> ANDROID\n    ANDROID --> TEST\n    \n    TEST --> BINARY\n    BINARY --> ARTIFACT\n```\n\n**构建验证**：\n\n- **原生编译**：x86_64 和 aarch64 运行器\n- **交叉编译**：双向（x86_64 ↔ aarch64）\n- **多种模式**：两种架构的 CO-RE 和 non-CO-RE\n- **Android 支持**：针对 Android 的 non-CO-RE，专注 BoringSSL\n- **代码质量**：golangci-lint 和 race 检测器测试\n\n**来源**: [.github/workflows/go-c-cpp.yml:1-128](), [.github/workflows/release.yml:1-129]()\n\n---\n\n## 后续步骤\n\n完成安装并运行首次捕获后：\n\n- **探索 CLI 选项**：参阅[命令行界面](#1.2)了解详细的标志文档\n- **理解架构**：在[架构设计](#2)中学习 eCapture 的工作原理\n- **模块深入**： \n  - [OpenSSL 模块](#3.1.1) 了解 TLS/SSL 捕获详情\n  - [Go TLS 模块](#3.1.2) 了解 Go 特定捕获\n  - [系统审计模块](#3.2) 了解 bash/数据库审计\n- **输出格式**：参阅[输出格式](#4)了解 PCAP、keylog 和文本模式详情\n- **自定义构建**：参考[构建系统](#5.1)了解编译自定义\n- **依赖**：查看[依赖与系统要求](#1.3)了解详细的前置条件\n\n**来源**: [README.md:1-335](), [README_CN.md:1-315](), [CHANGELOG.md:1-100]()"
          },
          {
            "page_plan": {
              "id": "1.2",
              "title": "命令行界面"
            },
            "content": "# 命令行界面\n\n本文档描述了 eCapture 的命令行界面（CLI），它提供了模块选择、配置和运行时控制的主要机制。CLI 使用 [Cobra](https://github.com/spf13/cobra) 命令框架实现，通过配置对象将子命令映射到捕获模块。\n\nCLI 执行三个主要功能：\n1. **模块选择** - 通过 `runModule()` 将子命令路由到特定的捕获模块\n2. **配置填充** - 将标志解析为模块特定的配置结构体\n3. **过滤表达式解析** - 处理数据包捕获模式的 pcap 过滤表达式\n\n关于 CLI 初始化后的模块生命周期，请参阅[模块系统与生命周期](2.4)。关于通过 HTTP API 进行运行时配置更新，请参阅[配置系统](2.3)。\n\n---\n\n## 命令结构概述\n\neCapture 使用基于模块的命令架构，其中每个子命令对应一个特定的捕获模块。入口点调用 Cobra 命令框架，该框架路由到模块初始化函数。\n\n**CLI 命令到模块分发**\n\n```mermaid\ngraph TB\n    Main[\"main()<br/>main.go:9\"]\n    Start[\"cli.Start()<br/>调用 cobra.Execute()\"]\n    RootCmd[\"rootCmd<br/>全局标志 + 子命令\"]\n    \n    TLSCmd[\"opensslCmd<br/>cli/cmd/tls.go:29\"]\n    GoTLSCmd[\"gotlsCmd<br/>cli/cmd/gotls.go:29\"]\n    GnuTLSCmd[\"gnutlsCmd<br/>cli/cmd/gnutls.go:32\"]\n    NSSCmd[\"nssCmd<br/>cli/cmd/nspr.go:30\"]\n    BashCmd[\"bashCmd<br/>cli/cmd/bash.go:27\"]\n    ZshCmd[\"zshCmd<br/>cli/cmd/zsh.go:30\"]\n    MySQLCmd[\"mysqldCmd<br/>cli/cmd/mysqld.go:30\"]\n    PostgresCmd[\"postgresCmd<br/>cli/cmd/postgres.go:30\"]\n    \n    TLSFunc[\"openSSLCommandFunc()<br/>cli/cmd/tls.go:62\"]\n    GoTLSFunc[\"goTLSCommandFunc()<br/>cli/cmd/gotls.go:52\"]\n    GnuTLSFunc[\"gnuTlsCommandFunc()<br/>cli/cmd/gnutls.go:59\"]\n    BashFunc[\"bashCommandFunc()<br/>cli/cmd/bash.go:53\"]\n    \n    OCConfig[\"oc = OpensslConfig<br/>cli/cmd/tls.go:26\"]\n    GoCConfig[\"goc = GoTLSConfig<br/>cli/cmd/gotls.go:26\"]\n    GCConfig[\"gc = GnutlsConfig<br/>cli/cmd/gnutls.go:29\"]\n    BCConfig[\"bc = BashConfig<br/>cli/cmd/bash.go:24\"]\n    \n    RunMod[\"runModule(moduleName, config)\"]\n    \n    Main --> Start\n    Start --> RootCmd\n    RootCmd --> TLSCmd\n    RootCmd --> GoTLSCmd\n    RootCmd --> GnuTLSCmd\n    RootCmd --> NSSCmd\n    RootCmd --> BashCmd\n    RootCmd --> ZshCmd\n    RootCmd --> MySQLCmd\n    RootCmd --> PostgresCmd\n    \n    TLSCmd --> TLSFunc\n    GoTLSCmd --> GoTLSFunc\n    GnuTLSCmd --> GnuTLSFunc\n    BashCmd --> BashFunc\n    \n    TLSFunc --> OCConfig\n    GoTLSFunc --> GoCConfig\n    GnuTLSFunc --> GCConfig\n    BashFunc --> BCConfig\n    \n    OCConfig --> RunMod\n    GoCConfig --> RunMod\n    GCConfig --> RunMod\n    BCConfig --> RunMod\n```\n\n来源：[main.go:1-11](), [cli/cmd/tls.go:26-67](), [cli/cmd/gotls.go:26-58](), [cli/cmd/gnutls.go:29-64](), [cli/cmd/bash.go:24-55]()\n\n**命令到模块的映射**\n\n每个子命令创建一个模块特定的配置对象，并使用适当的模块名称常量调用 `runModule()`。\n\n| 命令 | 别名 | 模块名称 | 配置类型 | 命令函数 |\n|---------|---------|-------------|-------------|------------------|\n| `tls` | `openssl` | `ModuleNameOpenssl` | `OpensslConfig` | `openSSLCommandFunc` |\n| `gotls` | `tlsgo` | `ModuleNameGotls` | `GoTLSConfig` | `goTLSCommandFunc` |\n| `gnutls` | `gnu` | `ModuleNameGnutls` | `GnutlsConfig` | `gnuTlsCommandFunc` |\n| `nspr` | `nss` | `ModuleNameNspr` | `NsprConfig` | `nssCommandFunc` |\n| `bash` | - | `ModuleNameBash` | `BashConfig` | `bashCommandFunc` |\n| `zsh` | - | `ModuleNameZsh` | `ZshConfig` | `zshCommandFunc` |\n| `mysqld` | - | `ModuleNameMysqld` | `MysqldConfig` | `mysqldCommandFunc` |\n| `postgres` | - | `ModuleNamePostgres` | `PostgresConfig` | `postgresCommandFunc` |\n\n来源：[cli/cmd/tls.go:26-67](), [cli/cmd/gotls.go:26-58](), [cli/cmd/gnutls.go:29-64](), [cli/cmd/nspr.go:27-51](), [cli/cmd/bash.go:24-55](), [cli/cmd/zsh.go:27-57](), [cli/cmd/mysqld.go:27-49](), [cli/cmd/postgres.go:27-45]()\n\n---\n\n## 全局标志\n\n全局标志在根命令级别定义，适用于所有子命令。这些标志通过 Cobra 的持久标志机制被模块特定的命令继承。\n\n**通用全局标志层次结构**\n\n```mermaid\ngraph LR\n    Root[\"rootCmd<br/>全局标志\"]\n    \n    Output[\"输出控制<br/>--output-file<br/>--log-addr<br/>--hex\"]\n    Process[\"进程过滤<br/>--pid<br/>--uid\"]\n    Performance[\"性能<br/>--mapsize<br/>--event_chan_size\"]\n    Network[\"网络<br/>--pcap_size\"]\n    \n    Root --> Output\n    Root --> Process\n    Root --> Performance\n    Root --> Network\n```\n\n### 输出控制标志\n\n| 标志 | 简写 | 类型 | 默认值 | 描述 |\n|------|-------|------|---------|-------------|\n| `--output-file` | `-l` | string | - | 事件输出的文件路径（文本模式） |\n| `--logaddr` | - | string | `localhost:28256` | 用于配置更新的 HTTP 服务器地址 |\n| `--hex` | - | bool | `false` | 以十六进制格式显示数据 |\n| `--event_rotate_size` | - | uint64 | `0` | 文件轮转大小（0=禁用） |\n| `--event_rotate_time` | - | uint64 | `0` | 文件轮转间隔（秒）（0=禁用） |\n\n### 进程过滤标志\n\n| 标志 | 简写 | 类型 | 默认值 | 描述 |\n|------|-------|------|---------|-------------|\n| `--pid` | `-p` | uint64 | `0` | 目标进程 ID（0=所有进程） |\n| `--uid` | `-u` | uint64 | `0` | 目标用户 ID（0=所有用户） |\n\n### 性能调优标志\n\n| 标志 | 类型 | 默认值 | 描述 |\n|------|------|---------|-------------|\n| `--mapsize` | uint64 | `5120` | eBPF map 大小（KB） |\n| `--event_chan_size` | uint32 | `100` | 事件通道缓冲区大小 |\n| `--pcap_size` | uint64 | `4096` | 网络数据包捕获缓冲区大小 |\n\n来源：基于 [cli/cmd/tls.go:50-57](), [cli/cmd/gotls.go:42-48](), [README.md:44]() 中的通用模式\n\n---\n\n## TLS 模块（`tls`/`openssl`）\n\nTLS 模块从 OpenSSL/BoringSSL 库捕获明文，支持版本 1.0.x 到 3.5.x 以及 Android 12-16 上的 BoringSSL。\n\n### TLS 特定标志\n\n**TLS 配置结构体字段映射**\n\n```mermaid\ngraph TB\n    OCStruct[\"oc *OpensslConfig<br/>cli/cmd/tls.go:26\"]\n    \n    Openssl[\"oc.Openssl<br/>--libssl<br/>默认值: 自动检测\"]\n    Model[\"oc.Model<br/>--model (-m)<br/>默认值: 'text'\"]\n    KeylogFile[\"oc.KeylogFile<br/>--keylogfile (-k)<br/>默认值: 'ecapture_openssl_key.log'\"]\n    PcapFile[\"oc.PcapFile<br/>--pcapfile (-w)<br/>默认值: 'save.pcapng'\"]\n    Ifname[\"oc.Ifname<br/>--ifname (-i)<br/>默认值: 空\"]\n    CGroupPath[\"oc.CGroupPath<br/>--cgroup_path<br/>默认值: '/sys/fs/cgroup'\"]\n    SslVersion[\"oc.SslVersion<br/>--ssl_version<br/>默认值: 自动检测\"]\n    PcapFilter[\"oc.PcapFilter<br/>从参数解析<br/>cli/cmd/tls.go:63-64\"]\n    \n    OCStruct --> Openssl\n    OCStruct --> Model\n    OCStruct --> KeylogFile\n    OCStruct --> PcapFile\n    OCStruct --> Ifname\n    OCStruct --> CGroupPath\n    OCStruct --> SslVersion\n    OCStruct --> PcapFilter\n```\n\n| 标志 | 简写 | 结构体字段 | 类型 | 默认值 | 行引用 |\n|------|-------|--------------|------|---------|----------------|\n| `--libssl` | - | `oc.Openssl` | string | （自动检测） | [cli/cmd/tls.go:51]() |\n| `--model` | `-m` | `oc.Model` | string | `\"text\"` | [cli/cmd/tls.go:53]() |\n| `--keylogfile` | `-k` | `oc.KeylogFile` | string | `\"ecapture_openssl_key.log\"` | [cli/cmd/tls.go:54]() |\n| `--pcapfile` | `-w` | `oc.PcapFile` | string | `\"save.pcapng\"` | [cli/cmd/tls.go:55]() |\n| `--ifname` | `-i` | `oc.Ifname` | string | `\"\"` | [cli/cmd/tls.go:56]() |\n| `--cgroup_path` | - | `oc.CGroupPath` | string | `\"/sys/fs/cgroup\"` | [cli/cmd/tls.go:52]() |\n| `--ssl_version` | - | `oc.SslVersion` | string | （自动检测） | [cli/cmd/tls.go:57]() |\n| （尾部参数） | - | `oc.PcapFilter` | string | `\"\"` | [cli/cmd/tls.go:63-64]() |\n\n**Pcap 过滤表达式**：尾部命令行参数通过 `strings.Join(args, \" \")` 在 [cli/cmd/tls.go:64]() 处连接并存储在 `oc.PcapFilter` 中。\n\n来源：[cli/cmd/tls.go:26-67]()\n\n### TLS 捕获模式\n\n`--model`/`-m` 标志控制捕获和输出行为：\n\n**模式决策流程**\n\n```mermaid\ngraph TB\n    Start[\"ecapture tls -m MODE\"]\n    \n    CheckMode{\"Model 标志\"}\n    \n    TextMode[\"text 模式<br/>直接明文输出<br/>到 stdout 或 --output-file\"]\n    PcapMode[\"pcap/pcapng 模式<br/>保存数据包 + DSB 块<br/>需要 --ifname, --pcapfile\"]\n    KeylogMode[\"keylog/key 模式<br/>保存主密钥<br/>到 --keylogfile\"]\n    \n    Start --> CheckMode\n    CheckMode -->|\"text（默认）\"| TextMode\n    CheckMode -->|\"pcap/pcapng\"| PcapMode\n    CheckMode -->|\"keylog/key\"| KeylogMode\n    \n    PcapMode --> TCHook[\"挂载 TC 钩子<br/>捕获加密数据包<br/>嵌入主密钥\"]\n    KeylogMode --> UprobeOnly[\"仅挂载 uprobe<br/>提取 SSL_SESSION 密钥<br/>NSS Key Log 格式\"]\n    TextMode --> UprobeText[\"仅挂载 uprobe<br/>直接捕获明文<br/>解析 HTTP/HTTP2\"]\n```\n\n来源：[cli/cmd/tls.go:32-47](), [README.md:171-253]()\n\n### TLS 命令示例\n\n**文本模式（默认）**\n```shell\nsudo ecapture tls --pid=1234 --hex\nsudo ecapture tls -l output.log --libssl=/lib/x86_64-linux-gnu/libssl.so.3\n```\n\n**Keylog 模式**\n```shell\nsudo ecapture tls -m keylog -k ecapture_key.log\nsudo ecapture tls -m key --keylogfile=/tmp/keys.log --pid=5678\n```\n\n**Pcap 模式**\n```shell\nsudo ecapture tls -m pcap -i eth0 -w capture.pcapng tcp port 443\nsudo ecapture tls -m pcapng -i wlan0 --pcapfile=save.pcapng host 192.168.1.1 and tcp port 443\n```\n\n**Android BoringSSL**\n```shell\nsudo ecapture tls -m pcap --pcapfile=android.pcapng -i wlan0 \\\n  --libssl=/apex/com.android.conscrypt/lib64/libssl.so \\\n  --ssl_version=\"boringssl 1.1.1\" tcp port 443\n```\n\n来源：[cli/cmd/tls.go:32-47](), [README.md:74-253]()\n\n---\n\n## GoTLS 模块（`gotls`）\n\nGoTLS 模块从使用 `crypto/tls` 标准库的 Go 程序捕获明文，支持基于寄存器和基于栈的 ABI（Go 1.17+ PIE 模式）。\n\n### GoTLS 特定标志\n\n**GoTLS 配置结构体字段映射**\n\n```mermaid\ngraph TB\n    GOCStruct[\"goc *GoTLSConfig<br/>cli/cmd/gotls.go:26\"]\n    \n    Path[\"goc.Path<br/>--elfpath (-e)<br/>必需字段\"]\n    Model[\"goc.Model<br/>--model (-m)<br/>默认值: 'text'\"]\n    PcapFile[\"goc.PcapFile<br/>--pcapfile (-w)<br/>默认值: 'ecapture_gotls.pcapng'\"]\n    KeylogFile[\"goc.KeylogFile<br/>--keylogfile (-k)<br/>默认值: 'ecapture_gotls_key.log'\"]\n    Ifname[\"goc.Ifname<br/>--ifname (-i)<br/>默认值: 空\"]\n    PcapFilter[\"goc.PcapFilter<br/>从参数解析<br/>cli/cmd/gotls.go:53-54\"]\n    \n    GOCStruct --> Path\n    GOCStruct --> Model\n    GOCStruct --> PcapFile\n    GOCStruct --> KeylogFile\n    GOCStruct --> Ifname\n    GOCStruct --> PcapFilter\n```\n\n| 标志 | 简写 | 结构体字段 | 类型 | 默认值 | 行引用 |\n|------|-------|--------------|------|---------|----------------|\n| `--elfpath` | `-e` | `goc.Path` | string | `\"\"`（必需） | [cli/cmd/gotls.go:43]() |\n| `--model` | `-m` | `goc.Model` | string | `\"text\"` | [cli/cmd/gotls.go:45]() |\n| `--pcapfile` | `-w` | `goc.PcapFile` | string | `\"ecapture_gotls.pcapng\"` | [cli/cmd/gotls.go:44]() |\n| `--keylogfile` | `-k` | `goc.KeylogFile` | string | `\"ecapture_gotls_key.log\"` | [cli/cmd/gotls.go:46]() |\n| `--ifname` | `-i` | `goc.Ifname` | string | `\"\"` | [cli/cmd/gotls.go:47]() |\n| （尾部参数） | - | `goc.PcapFilter` | string | `\"\"` | [cli/cmd/gotls.go:53-54]() |\n\n**Pcap 过滤表达式**：尾部参数通过 `strings.Join(args, \" \")` 在 [cli/cmd/gotls.go:54]() 处连接并存储在 `goc.PcapFilter` 中。\n\n来源：[cli/cmd/gotls.go:26-58]()\n\n### GoTLS 命令示例\n\n**文本模式**\n```shell\nsudo ecapture gotls --elfpath=/usr/local/bin/go_app --hex\nsudo ecapture gotls -e /home/user/myapp --pid=9876 -l output.log\n```\n\n**Keylog 模式**\n```shell\nsudo ecapture gotls -m keylog -k gotls_keys.log --elfpath=/usr/bin/go_https_server\nsudo ecapture gotls -m key --keylogfile=/tmp/gotls.log -e /app/binary --pid=4321\n```\n\n**Pcap 模式**\n```shell\nsudo ecapture gotls -m pcap --pcapfile=go_capture.pcapng -i eth0 \\\n  --elfpath=/usr/bin/go_client tcp port 443\nsudo ecapture gotls -m pcapng -w output.pcapng -i wlan0 -e /app/server\n```\n\n来源：[cli/cmd/gotls.go:33-38](), [README.md:257-280]()\n\n---\n\n## 其他 SSL/TLS 模块\n\n### GnuTLS 模块（`gnutls`）\n\n从 GnuTLS 库捕获明文，支持 keylog 和 pcap 模式。\n\n| 标志 | 简写 | 类型 | 默认值 | 描述 |\n|------|-------|------|---------|-------------|\n| `--gnutls` | - | string | （自动检测） | `libgnutls.so` 的路径 |\n| `--model` | `-m` | string | `text` | 捕获模式：`text`、`pcap`、`keylog` |\n| `--keylogfile` | `-k` | string | `ecapture_gnutls_key.log` | Keylog 输出文件 |\n| `--pcapfile` | `-w` | string | `save.pcapng` | PCAP 输出文件 |\n| `--ifname` | `-i` | string | - | 网络接口 |\n| `--ssl_version` | - | string | - | GnuTLS 版本（例如 `\"3.7.9\"`） |\n\n**示例**：\n```shell\nsudo ecapture gnutls -m keylog -k gnutls_keys.log --ssl_version=3.7.9\nsudo ecapture gnutls -m pcap -i eth0 -w gnutls.pcapng tcp port 443\n```\n\n来源：[cli/cmd/gnutls.go:29-64](), [README.md:155-161](), [CHANGELOG.md:126]()\n\n### NSS/NSPR 模块（`nspr`/`nss`）\n\n从 NSS/NSPR 库（Firefox、Thunderbird 使用）捕获明文。\n\n| 标志 | 简写 | 类型 | 默认值 | 描述 |\n|------|-------|------|---------|-------------|\n| `--nspr` | - | string | （自动检测） | `libnspr44.so` 的路径 |\n\n**示例**：\n```shell\nsudo ecapture nspr --hex --pid=3423\nsudo ecapture nss -l firefox_capture.log --pid=5678\n```\n\n来源：[cli/cmd/nspr.go:27-51](), [README.md:158]()\n\n---\n\n## 系统审计模块\n\n### Bash 模块（`bash`）\n\n捕获 bash 命令输入/输出用于安全审计。\n\n**Bash 命令流程**\n\n```mermaid\ngraph LR\n    CLI[\"ecapture bash\"]\n    \n    BashConfig[\"BashConfig<br/>cli/cmd/bash.go\"]\n    AutoDetect[\"自动检测<br/>$SHELL 路径<br/>readline.so\"]\n    ErrFilter[\"错误号过滤<br/>--errnumber\"]\n    \n    CLI --> BashConfig\n    BashConfig --> AutoDetect\n    BashConfig --> ErrFilter\n    \n    RunModule[\"runModule()<br/>ModuleNameBash\"]\n    BashConfig --> RunModule\n```\n\n| 标志 | 简写 | 类型 | 默认值 | 描述 |\n|------|-------|------|---------|-------------|\n| `--bash` | - | string | （自动检测） | bash 二进制文件的路径 |\n| `--readlineso` | - | string | （自动检测） | `readline.so` 的路径 |\n| `--errnumber` | `-e` | int | `BashErrnoDefault` | 按退出代码过滤命令 |\n\n**示例**：\n```shell\nsudo ecapture bash\nsudo ecapture bash --bash=/bin/bash -l bash_audit.log\nsudo ecapture bash -e 0  # 仅显示成功的命令\n```\n\n来源：[cli/cmd/bash.go:24-55](), [README.md:153-154]()\n\n### Zsh 模块（`zsh`）\n\n与 bash 模块类似，捕获 zsh 命令活动。\n\n| 标志 | 简写 | 类型 | 默认值 | 描述 |\n|------|-------|------|---------|-------------|\n| `--zsh` | - | string | （自动检测） | zsh 二进制文件的路径 |\n| `--errnumber` | `-e` | int | `ZshErrnoDefault` | 按退出代码过滤命令 |\n\n**示例**：\n```shell\nsudo ecapture zsh\nsudo ecapture zsh --zsh=/usr/bin/zsh -l zsh_audit.log\n```\n\n来源：[cli/cmd/zsh.go:27-57](), [README.md:154]()\n\n### MySQL 模块（`mysqld`）\n\n从 MySQL/MariaDB 服务器进程捕获 SQL 查询，支持版本 5.6、5.7、8.0 和 MariaDB 10.5+。\n\n| 标志 | 简写 | 类型 | 默认值 | 描述 |\n|------|-------|------|---------|-------------|\n| `--mysqld` | `-m` | string | `/usr/sbin/mariadbd` | mysqld 二进制文件的路径 |\n| `--offset` | - | uint64 | `0` | `dispatch_command` 函数的手动偏移量 |\n| `--funcname` | `-f` | string | - | 要挂钩的函数名称（覆盖自动检测） |\n\n**示例**：\n```shell\nsudo ecapture mysqld -m /usr/sbin/mysqld -l mysql_queries.log\nsudo ecapture mysqld --mysqld=/usr/local/mysql/bin/mysqld --pid=1234\n```\n\n来源：[cli/cmd/mysqld.go:27-49](), [README.md:157]()\n\n### PostgreSQL 模块（`postgres`）\n\n从 PostgreSQL 服务器进程捕获 SQL 查询（版本 10+）。\n\n| 标志 | 简写 | 类型 | 默认值 | 描述 |\n|------|-------|------|---------|-------------|\n| `--postgres` | `-m` | string | `/usr/bin/postgres` | postgres 二进制文件的路径 |\n| `--funcname` | `-f` | string | - | 要挂钩的函数名称 |\n\n**示例**：\n```shell\nsudo ecapture postgres -m /usr/lib/postgresql/14/bin/postgres\nsudo ecapture postgres --postgres=/opt/pgsql/bin/postgres -l pg_queries.log\n```\n\n来源：[cli/cmd/postgres.go:27-45](), [README.md:159]()\n\n---\n\n## 标志处理和 Pcap 过滤器\n\nTLS、GoTLS 和 GnuTLS 模块在 `pcap` 模式下支持 pcap 过滤表达式。这些表达式在 Cobra 标志解析完成后从尾部命令行参数处理。\n\n**openSSLCommandFunc 中的 Pcap 过滤器处理**\n\n```mermaid\ngraph TB\n    CobraExec[\"cobra.Command.Execute()<br/>解析标志，提取参数\"]\n    \n    CommandFunc[\"openSSLCommandFunc(command, args)<br/>cli/cmd/tls.go:62\"]\n    \n    CheckEmpty{\"oc.PcapFilter == ''<br/>AND len(args) != 0<br/>cli/cmd/tls.go:63\"}\n    \n    JoinArgs[\"strings.Join(args, ' ')<br/>cli/cmd/tls.go:64\"]\n    \n    SetFilter[\"oc.PcapFilter = joined<br/>cli/cmd/tls.go:64\"]\n    \n    RunModule[\"runModule(ModuleNameOpenssl, oc)<br/>cli/cmd/tls.go:66\"]\n    \n    CobraExec --> CommandFunc\n    CommandFunc --> CheckEmpty\n    CheckEmpty -->|\"True\"| JoinArgs\n    CheckEmpty -->|\"False\"| RunModule\n    JoinArgs --> SetFilter\n    SetFilter --> RunModule\n```\n\n**代码实现模式**（TLS、GoTLS、GnuTLS 中相同）：\n```go\n// cli/cmd/tls.go:62-67\nfunc openSSLCommandFunc(command *cobra.Command, args []string) error {\n    if oc.PcapFilter == \"\" && len(args) != 0 {\n        oc.PcapFilter = strings.Join(args, \" \")\n    }\n    return runModule(module.ModuleNameOpenssl, oc)\n}\n```\n\n**过滤器示例**：\n```shell\n# 主机过滤\nsudo ecapture tls -m pcap -i eth0 -w out.pcapng host 192.168.1.1\n\n# 端口和协议\nsudo ecapture tls -m pcap -i wlan0 tcp port 443\n\n# 复杂表达式（多个条件）\nsudo ecapture gotls -m pcap -i eth0 -w output.pcapng \\\n  host 192.168.1.1 and tcp port 443 and not port 22\n```\n\n来源：[cli/cmd/tls.go:62-67](), [cli/cmd/gotls.go:52-58](), [cli/cmd/gnutls.go:59-64]()\n\n---\n\n## 命令执行模式\n\n所有模块命令遵循一致的三阶段执行模式：配置初始化、标志解析和模块分发。\n\n**从 CLI 到模块的完整执行流程**\n\n```mermaid\ngraph TB\n    Init[\"init() 函数<br/>cli/cmd/*.go\"]\n    \n    CreateConfig[\"创建配置单例<br/>oc = config.NewOpensslConfig()<br/>goc = config.NewGoTLSConfig()<br/>等\"]\n    \n    RegisterFlags[\"PersistentFlags()<br/>定义绑定到配置字段的标志<br/>cli/cmd/tls.go:51-57\"]\n    \n    AddCommand[\"rootCmd.AddCommand(opensslCmd)<br/>注册子命令<br/>cli/cmd/tls.go:58\"]\n    \n    UserInvoke[\"用户运行：<br/>ecapture tls -m pcap -i eth0\"]\n    \n    CobraParse[\"cobra.Execute()<br/>将标志解析到配置<br/>提取尾部参数\"]\n    \n    CommandFunc[\"openSSLCommandFunc(cmd, args)<br/>cli/cmd/tls.go:62\"]\n    \n    ParseFilter[\"解析 pcap 过滤器<br/>if oc.PcapFilter == '' && len(args) != 0<br/>cli/cmd/tls.go:63-64\"]\n    \n    RunModule[\"runModule(ModuleNameOpenssl, oc)<br/>cli/cmd/tls.go:66\"]\n    \n    ModuleFactory[\"GetModuleFunc(moduleName)<br/>返回模块构造函数\"]\n    \n    ModuleInit[\"module.Init(config)<br/>版本检测<br/>字节码选择<br/>钩子配置\"]\n    \n    ModuleRun[\"module.Run()<br/>挂载 eBPF 程序<br/>启动事件读取器<br/>事件处理循环\"]\n    \n    Init --> CreateConfig\n    CreateConfig --> RegisterFlags\n    RegisterFlags --> AddCommand\n    AddCommand --> UserInvoke\n    UserInvoke --> CobraParse\n    CobraParse --> CommandFunc\n    CommandFunc --> ParseFilter\n    ParseFilter --> RunModule\n    RunModule --> ModuleFactory\n    ModuleFactory --> ModuleInit\n    ModuleInit --> ModuleRun\n```\n\n**三阶段命令函数模式**：\n\n所有命令函数实现这个结构：\n```go\n// 阶段 1：在包初始化时创建配置对象\nvar oc = config.NewOpensslConfig()  // cli/cmd/tls.go:26\n\n// 阶段 2：注册标志并绑定到配置\nfunc init() {\n    opensslCmd.PersistentFlags().StringVarP(&oc.Model, \"model\", \"m\", ...)\n    rootCmd.AddCommand(opensslCmd)  // cli/cmd/tls.go:58\n}\n\n// 阶段 3：使用过滤器解析执行命令\nfunc openSSLCommandFunc(command *cobra.Command, args []string) error {\n    if oc.PcapFilter == \"\" && len(args) != 0 {\n        oc.PcapFilter = strings.Join(args, \" \")  // cli/cmd/tls.go:64\n    }\n    return runModule(module.ModuleNameOpenssl, oc)  // cli/cmd/tls.go:66\n}\n```\n\n来源：[cli/cmd/tls.go:26-67](), [cli/cmd/gotls.go:26-58](), [cli/cmd/bash.go:24-55]()\n\n---\n\n## Docker 使用\n\nTLS 模块文档包括容器化部署的 Docker 特定使用模式。\n\n**Docker 卷挂载要求**：\n```shell\ndocker run --rm --privileged=true --net=host \\\n  -v /etc:/etc \\\n  -v /usr:/usr \\\n  -v ${PWD}:/output \\\n  gojue/ecapture tls -m pcap -i eth0 \\\n    --pcapfile=/output/capture.pcapng tcp port 443\n```\n\n容器需要：\n- `--privileged=true` 用于 eBPF 能力\n- `--net=host` 访问主机网络接口\n- 挂载 `/etc` 用于 `ld.so.conf` 库路径发现\n- 挂载 `/usr` 用于访问系统库\n- 挂载输出目录用于保存捕获文件\n\n来源：[cli/cmd/tls.go:42-44](), [README.md:59-68]()\n\n---\n\n## 帮助文本和文档\n\n每个命令通过 `-h` 或 `--help` 标志提供详细的帮助文本：\n\n```shell\n# 查看所有可用命令\nsudo ecapture -h\n\n# 查看 TLS 模块帮助\nsudo ecapture tls -h\n\n# 查看 GoTLS 模块帮助\nsudo ecapture gotls -h\n```\n\n帮助系统内置于 Cobra 的命令结构中，根据标志定义和命令描述自动生成使用信息。\n\n来源：[cli/cmd/tls.go:29-47](), [cli/cmd/gotls.go:29-39](), [README.md:44]()"
          },
          {
            "page_plan": {
              "id": "1.3",
              "title": "依赖与系统要求"
            },
            "content": "# 依赖与系统要求\n\n本页面文档记录了构建和运行 eCapture 所需的系统要求、依赖项和工具链前置条件。内容涵盖内核版本要求、支持的架构、构建时工具、运行时依赖以及 Go 包依赖。\n\n关于构建过程本身的信息，请参阅[构建系统](#5.1)。关于安装说明，请参阅[安装与快速入门](#1.1)。\n\n---\n\n## 概述\n\neCapture 在构建时（编译 eBPF 程序和 Go 二进制文件）和运行时（执行已编译的二进制文件）有不同的要求。系统支持两种编译模式，具有不同的要求：\n\n- **CO-RE（一次编译 - 到处运行）**：运行时需要支持 BTF 的内核（≥5.2），但产生可移植的二进制文件\n- **Non-CO-RE（非 CO-RE）**：构建时需要内核头文件，为旧系统产生特定于内核的二进制文件\n\n---\n\n## 内核要求\n\n### 最低内核版本\n\n| 模式 | 最低版本 | 需要 BTF | 备注 |\n|------|----------------|--------------|-------|\n| CO-RE | 5.2+ | 是 | 推荐用于可移植性 |\n| CO-RE（传统） | 4.18-5.1 | 否 | 特殊的 `_less52.o` 字节码变体 |\n| Non-CO-RE | 4.18+ | 否 | 需要精确的内核头文件 |\n\n内核版本检测和处理在 [variables.mk]() 中实现，为内核 < 5.2 设置 `KERNEL_LESS_5_2_PREFIX`。\n\n### BTF（BPF 类型格式）支持\n\nBTF 是 CO-RE 模式的关键特性。构建系统检查 BTF 可用性：\n\n```mermaid\ngraph TB\n    START[\"eCapture 二进制执行\"]\n    CHECK_BTF[\"检查 /sys/kernel/btf/vmlinux\"]\n    BTF_YES[\"BTF 可用\"]\n    BTF_NO[\"BTF 不可用\"]\n    LOAD_CORE[\"加载 *_core.o 字节码<br/>CO-RE 重定位\"]\n    LOAD_NONCORE[\"加载 *_noncore.o 字节码<br/>固定偏移量\"]\n    LOAD_LESS52[\"加载 *_less52.o 字节码<br/>传统内核支持\"]\n    CHECK_KERNEL[\"检查内核版本\"]\n    \n    START --> CHECK_BTF\n    CHECK_BTF --> BTF_YES\n    CHECK_BTF --> BTF_NO\n    BTF_YES --> LOAD_CORE\n    BTF_NO --> CHECK_KERNEL\n    CHECK_KERNEL -->|\">=5.2\"| LOAD_NONCORE\n    CHECK_KERNEL -->|\"<5.2\"| LOAD_LESS52\n    \n    style LOAD_CORE fill:#e8f5e9\n    style LOAD_NONCORE fill:#fff9c4\n    style LOAD_LESS52 fill:#ffccbc\n```\n\n**BTF 检测**：系统在运行时检查 `/sys/kernel/btf/vmlinux`。如果存在，则使用 CO-RE 字节码；否则，采用 non-CO-RE 回退。\n\n来源：[Makefile:122-134](), [functions.mk:13-22]()\n\n---\n\n## 支持的架构\n\n| 架构 | 状态 | 交叉编译 | 备注 |\n|--------------|--------|-------------------|-------|\n| x86_64 (amd64) | ✅ 完整支持 | 到 arm64 | 主要开发平台 |\n| aarch64 (arm64) | ✅ 完整支持 | 到 x86_64 | 功能完全对等 |\n| Android arm64 | ⚠️ 有限支持 | 从 x86_64/arm64 | 仅 non-CO-RE，专注 BoringSSL |\n\n架构检测在 [variables.mk]() 中处理，根据 `uname -m` 或 `CROSS_ARCH` 环境变量设置 `TARGET_ARCH`、`GOARCH`、`LINUX_ARCH` 和 `LIBPCAP_ARCH`。\n\n```mermaid\ngraph LR\n    subgraph \"原生构建\"\n        X86_HOST[\"x86_64 主机\"]\n        ARM_HOST[\"arm64 主机\"]\n        X86_BIN[\"x86_64 二进制\"]\n        ARM_BIN[\"arm64 二进制\"]\n        \n        X86_HOST --> X86_BIN\n        ARM_HOST --> ARM_BIN\n    end\n    \n    subgraph \"交叉编译\"\n        X86_CROSS[\"x86_64 主机<br/>CROSS_ARCH=arm64\"]\n        ARM_CROSS[\"arm64 主机<br/>CROSS_ARCH=amd64\"]\n        X86_TO_ARM[\"arm64 二进制\"]\n        ARM_TO_X86[\"x86_64 二进制\"]\n        \n        X86_CROSS --> X86_TO_ARM\n        ARM_CROSS --> ARM_TO_X86\n    end\n    \n    TOOLCHAIN[\"交叉工具链<br/>gcc-aarch64-linux-gnu<br/>gcc-x86-64-linux-gnu\"]\n    HEADERS[\"架构头文件<br/>kern/bpf/x86<br/>kern/bpf/arm64\"]\n    \n    TOOLCHAIN -.-> X86_TO_ARM\n    TOOLCHAIN -.-> ARM_TO_X86\n    HEADERS -.-> X86_TO_ARM\n    HEADERS -.-> ARM_TO_X86\n```\n\n来源：[.github/workflows/go-c-cpp.yml:59-65](), [.github/workflows/release.yml:93-97](), [builder/init_env.sh:43-61]()\n\n---\n\n## 构建时依赖\n\n### 必需的编译器和工具\n\n下表列出了所有构建时依赖及其最低版本：\n\n| 工具 | 最低版本 | 用途 | 包名（Ubuntu） |\n|------|----------------|---------|----------------------|\n| **clang** | 9.0+ | 编译 eBPF C 到字节码 | `clang-14`（推荐） |\n| **llc** | 9.0+ | LLVM 编译器后端 | `llvm-14` |\n| **llvm-strip** | 9.0+ | 剥离调试符号 | `llvm-14` |\n| **gcc** | 系统默认 | C 编译 | `build-essential` |\n| **go** | 1.24+ | Go 编译 | N/A（从 golang.org 安装） |\n| **bpftool** | 任意 | 生成 vmlinux.h | `linux-tools-generic` |\n| **flex** | 任意 | 内核构建的词法分析器 | `flex` |\n| **bison** | 任意 | 内核构建的解析器 | `bison` |\n| **elfutils** | 任意 | ELF 文件操作 | `libelf-dev` |\n| **pkgconf** | 任意 | 包配置 | `pkgconf` |\n\n版本检查在构建时强制执行：\n\n[functions.mk:13-35]()：\n```\nClang 版本检查：CLANG_VERSION 必须 >= 9\nGo 版本检查：GO_VERSION_MAJ=1，GO_VERSION_MIN >= 24\n```\n\n来源：[.github/workflows/go-c-cpp.yml:16-24](), [functions.mk:13-35](), [builder/init_env.sh:72-79]()\n\n### 内核头文件（仅 Non-CO-RE）\n\n对于 non-CO-RE 构建，需要与目标内核匹配的内核头文件。构建系统在多个位置搜索头文件：\n\n```mermaid\ngraph TD\n    START[\"Non-CO-RE 构建\"]\n    CHECK_SOURCE[\"检查 LINUX_SOURCE_PATH<br/>/usr/src/linux-source-*\"]\n    SOURCE_FOUND[\"找到头文件\"]\n    SOURCE_NOT_FOUND[\"头文件缺失\"]\n    PREPARE[\"运行内核头文件准备<br/>make prepare ARCH=target\"]\n    COMPILE[\"使用头文件编译 eBPF<br/>-I KERN_SRC_PATH\"]\n    ERROR[\"构建错误：<br/>linux source not found\"]\n    \n    START --> CHECK_SOURCE\n    CHECK_SOURCE --> SOURCE_FOUND\n    CHECK_SOURCE --> SOURCE_NOT_FOUND\n    SOURCE_FOUND --> PREPARE\n    PREPARE --> COMPILE\n    SOURCE_NOT_FOUND --> ERROR\n    \n    style ERROR fill:#ffcdd2\n```\n\n编译期间使用的头文件路径 [Makefile:154-161]()：\n- `-I $(KERN_SRC_PATH)/arch/$(LINUX_ARCH)/include`\n- `-I $(KERN_BUILD_PATH)/arch/$(LINUX_ARCH)/include/generated`\n- `-I $(KERN_SRC_PATH)/include`\n- `-I $(KERN_BUILD_PATH)/include/generated/uapi`\n\n来源：[Makefile:98-104](), [Makefile:146-183](), [builder/init_env.sh:81-89]()\n\n### 交叉编译依赖\n\n交叉编译需要特定于架构的工具链：\n\n| 主机 → 目标 | 所需包 | 备注 |\n|---------------|-----------------|-------|\n| x86_64 → arm64 | `gcc-aarch64-linux-gnu` | 设置 `CC=aarch64-linux-gnu-gcc` |\n| arm64 → x86_64 | `gcc-x86-64-linux-gnu` | Ubuntu 24.04+ 包名 |\n| 任意 → Android | 不需要 NDK | 使用标准交叉编译器 |\n\n来源：[.github/workflows/go-c-cpp.yml:19](), [builder/init_env.sh:46-58]()\n\n---\n\n## Go 依赖\n\n### 核心依赖\n\n项目使用 Go 1.24.3+ 及以下主要依赖：\n\n```mermaid\ngraph TB\n    subgraph \"eBPF 框架\"\n        EBPF[\"cilium/ebpf<br/>v0.18.0\"]\n        EBPFMGR[\"gojue/ebpfmanager<br/>v0.5.0\"]\n    end\n    \n    subgraph \"网络分析\"\n        GOPACKET[\"google/gopacket<br/>v1.1.19→cfc4n/gopacket\"]\n        ELIBPCAP[\"jschwinger233/elibpcap<br/>v1.0.2\"]\n    end\n    \n    subgraph \"CLI 与 API\"\n        COBRA[\"spf13/cobra<br/>v1.9.1\"]\n        PFLAG[\"spf13/pflag<br/>v1.0.6\"]\n        GIN[\"gin-gonic/gin<br/>v1.10.0\"]\n    end\n    \n    subgraph \"协议与数据\"\n        PROTOBUF[\"google/protobuf<br/>v1.36.6\"]\n        CRYPTO[\"golang.org/x/crypto<br/>v0.45.0\"]\n    end\n    \n    subgraph \"构建工具\"\n        BINDATA[\"shuLhan/go-bindata<br/>v4.0.0\"]\n    end\n    \n    EBPF --> EBPFMGR\n    GOPACKET --> ELIBPCAP\n```\n\n**关键依赖：**\n\n1. **cilium/ebpf v0.18.0**：核心 eBPF 库，用于加载程序、管理映射和处理 CO-RE 重定位。提供 `ebpf.CollectionSpec` 和映射管理。\n\n2. **gojue/ebpfmanager v0.5.0**：更高级别的 eBPF 生命周期管理。封装 cilium/ebpf，提供探针附加、TC 钩子管理和清理编排。\n\n3. **cfc4n/gopacket v1.1.20**：`google/gopacket` 的分支版本，对 PCAP-NG 格式进行了改进。用于数据包序列化和 PCAP 文件生成。\n\n4. **jschwinger233/elibpcap v1.0.2**：TC 程序的 BPF 过滤器编译器。将伯克利包过滤器（BPF）语法翻译为 eBPF 字节码。\n\n5. **go-bindata**：将编译的 eBPF 字节码（`.o` 文件）作为字节数组嵌入到 [assets/ebpf_probe.go]() 中的 Go 二进制文件中。\n\n来源：[go.mod:5-19](), [go.sum:8-14]()\n\n### 间接依赖\n\n关键的间接依赖包括：\n\n| 包 | 版本 | 用途 |\n|---------|---------|---------|\n| `florianl/go-tc` | v0.4.5 | Linux 流量控制 netlink 接口 |\n| `vishvananda/netlink` | v1.3.1 | 通用 netlink 操作 |\n| `mdlayher/netlink` | v1.7.2 | 低级 netlink 套接字库 |\n| `hashicorp/go-multierror` | v1.1.1 | 错误聚合 |\n\n来源：[go.mod:22-58]()\n\n---\n\n## 运行时依赖\n\n### 最小运行时要求\n\n编译后的 `ecapture` 二进制文件除了内核特性外**没有运行时依赖**：\n\n| 要求 | 描述 |\n|-------------|-------------|\n| Linux 内核 | 4.18+（non-CO-RE）或 5.2+（CO-RE） |\n| BTF 支持 | 仅用于 CO-RE 模式 |\n| `CAP_SYS_ADMIN` | 或 root 权限以加载 eBPF 程序 |\n| `CAP_BPF` + `CAP_PERFMON` | 在 5.8+ 内核上作为 `CAP_SYS_ADMIN` 的替代 |\n\n**静态链接**：二进制文件与 libpcap 静态链接 [functions.mk:48-53]()：\n```\nCGO_LDFLAGS='-O2 -g -L$(CURDIR)/lib/libpcap/ -lpcap -static'\n-ldflags \"... -linkmode=external -extldflags -static\"\n```\n\n这消除了运行时对 libpcap 的需求。\n\n### 各模块的内核特性要求\n\n不同的捕获模块需要不同的内核特性：\n\n```mermaid\ngraph TB\n    subgraph \"TLS 模块\"\n        OPENSSL[\"OpenSSL 模块\"]\n        GOTLS[\"GoTLS 模块\"]\n        GNUTLS[\"GnuTLS 模块\"]\n        \n        UPROBE[\"Uprobe 支持<br/>CONFIG_UPROBE_EVENTS\"]\n    end\n    \n    subgraph \"网络模块\"\n        TC[\"TC 分类器\"]\n        \n        TC_FEATURE[\"TC eBPF 支持<br/>CONFIG_NET_CLS_BPF\"]\n        SKB[\"sk_buff 处理\"]\n    end\n    \n    subgraph \"系统审计\"\n        BASH[\"Bash/Zsh 模块\"]\n        DB[\"MySQL/PostgreSQL 模块\"]\n        \n        UPROBE2[\"Uprobe 支持\"]\n    end\n    \n    OPENSSL --> UPROBE\n    GOTLS --> UPROBE\n    GNUTLS --> UPROBE\n    BASH --> UPROBE2\n    DB --> UPROBE2\n    TC --> TC_FEATURE\n    TC --> SKB\n    \n    UPROBE -.->|\"需要\"| KPROBE_REG[\"Kprobe 注册\"]\n    TC_FEATURE -.->|\"需要\"| NETFILTER[\"Netfilter 钩子\"]\n```\n\n来源：[variables.mk](), [Makefile:122-134]()\n\n---\n\n## 编译模式比较\n\n### CO-RE 与 Non-CO-RE\n\n| 方面 | CO-RE 模式 | Non-CO-RE 模式 |\n|--------|-----------|----------------|\n| **构建要求** | clang、llc、BTF 头文件 | clang、llc、完整内核头文件 |\n| **运行时要求** | 支持 BTF 的内核（5.2+） | 任意 4.18+ 内核 |\n| **可移植性** | 一个二进制适用所有内核 | 特定于内核的二进制 |\n| **字节码大小** | 较大（包含重定位信息） | 较小（固定偏移量） |\n| **构建时间** | 更快（无需内核准备） | 较慢（内核头文件准备） |\n| **使用场景** | 通用分发 | 传统系统、Android |\n\n**编译标志比较：**\n\nCO-RE [Makefile:122-134]()：\n```\n-target bpfel -g -D__BPF_TARGET_MISSING=\"...\"\n# 使用 BTF 信息进行重定位\n```\n\nNon-CO-RE [Makefile:151-166]()：\n```\n-I $(KERN_SRC_PATH)/arch/$(LINUX_ARCH)/include\n-I $(KERN_BUILD_PATH)/include/generated/uapi\n# 需要所有内核头文件路径\n```\n\n来源：[Makefile:122-183](), [variables.mk]()\n\n---\n\n## 开发环境设置\n\n### 自动化设置（Ubuntu）\n\n项目提供 [builder/init_env.sh]() 用于自动化环境设置：\n\n```mermaid\ngraph TD\n    START[\"运行 init_env.sh\"]\n    DETECT[\"检测 Ubuntu 版本\"]\n    SELECT_CLANG[\"选择 Clang 版本<br/>基于发行版 10-18\"]\n    INSTALL_DEPS[\"apt-get install<br/>编译器 + 工具\"]\n    SYMLINK[\"创建符号链接<br/>clang→clang-N\"]\n    PREPARE_KERNEL[\"解压并准备<br/>linux-source\"]\n    INSTALL_GO[\"下载 Go 1.24.6\"]\n    CLONE[\"克隆 ecapture 仓库\"]\n    DONE[\"准备构建\"]\n    \n    START --> DETECT\n    DETECT --> SELECT_CLANG\n    SELECT_CLANG --> INSTALL_DEPS\n    INSTALL_DEPS --> SYMLINK\n    SYMLINK --> PREPARE_KERNEL\n    PREPARE_KERNEL --> INSTALL_GO\n    INSTALL_GO --> CLONE\n    CLONE --> DONE\n    \n    style DONE fill:#e8f5e9\n```\n\n特定版本的 clang 选择 [builder/init_env.sh:16-39]()：\n- Ubuntu 20.04：clang-10\n- Ubuntu 22.04：clang-12\n- Ubuntu 23.04+：clang-15\n- Ubuntu 24.04：clang-18\n\n来源：[builder/init_env.sh:1-106]()\n\n### 手动设置\n\n对于手动设置，安装这些包组：\n\n**基础工具：**\n```bash\nsudo apt-get install build-essential pkgconf libelf-dev\n```\n\n**LLVM 工具链：**\n```bash\nsudo apt-get install llvm-14 clang-14\nsudo ln -sf /usr/bin/clang-14 /usr/bin/clang\nsudo ln -sf /usr/bin/llc-14 /usr/bin/llc\nsudo ln -sf /usr/bin/llvm-strip-14 /usr/bin/llvm-strip\n```\n\n**内核工具：**\n```bash\nsudo apt-get install linux-tools-common linux-tools-generic flex bison\n```\n\n**交叉编译（可选）：**\n```bash\n# 在 x86_64 上编译 arm64\nsudo apt-get install gcc-aarch64-linux-gnu\n\n# 在 arm64 上编译 x86_64\nsudo apt-get install gcc-x86-64-linux-gnu\n```\n\n**内核头文件（用于 non-CO-RE）：**\n```bash\nsudo apt-get install linux-source\ncd /usr/src\nsudo tar -xf linux-source-*.tar.bz2\ncd linux-source-*/\nsudo make oldconfig\nsudo make prepare\n```\n\n来源：[.github/workflows/go-c-cpp.yml:16-33](), [builder/init_env.sh:72-89]()\n\n---\n\n## Docker 构建环境\n\n项目提供 Dockerfile 用于容器化构建：\n\n```mermaid\ngraph LR\n    subgraph \"基础镜像\"\n        UBUNTU[\"ubuntu:22.04\"]\n    end\n    \n    subgraph \"编译器安装\"\n        COMPILERS[\"apt-get install<br/>llvm-14, clang-14<br/>build-essential\"]\n    end\n    \n    subgraph \"Go 安装\"\n        GO_INSTALL[\"下载 Go 1.24.6<br/>架构：amd64/arm64\"]\n    end\n    \n    subgraph \"构建阶段\"\n        COPY_SRC[\"COPY 源代码\"]\n        MAKE[\"make all\"]\n        BINARY[\"bin/ecapture\"]\n    end\n    \n    subgraph \"发布镜像\"\n        ALPINE[\"alpine:latest\"]\n        FINAL[\"最小镜像<br/>仅包含二进制\"]\n    end\n    \n    UBUNTU --> COMPILERS\n    COMPILERS --> GO_INSTALL\n    GO_INSTALL --> COPY_SRC\n    COPY_SRC --> MAKE\n    MAKE --> BINARY\n    BINARY --> ALPINE\n    ALPINE --> FINAL\n```\n\n多阶段构建 [builder/Dockerfile:1-39]()：\n1. **构建器阶段**：Ubuntu 22.04 上的完整工具链\n2. **发布阶段**：带有静态二进制文件的最小 Alpine 镜像\n\n为多个架构构建：\n```bash\ndocker buildx build --platform linux/amd64,linux/arm64 -t ecapture:latest .\n```\n\n来源：[builder/Dockerfile:1-39](), [.github/workflows/release.yml:101-129]()\n\n---\n\n## 验证命令\n\n设置后，验证依赖：\n\n```bash\n# 检查工具版本\nclang --version          # 应该 >= 9.0\ngo version               # 应该 >= 1.24.0\nllc --version            # 应该与 clang 版本匹配\nbpftool version          # 任意版本\n\n# 检查 BTF 支持（运行时）\nls -l /sys/kernel/btf/vmlinux  # CO-RE 应该存在\n\n# 检查 eBPF 内核配置\ngrep CONFIG_BPF /boot/config-$(uname -r)\n# 应该显示：\n# CONFIG_BPF=y\n# CONFIG_BPF_SYSCALL=y\n# CONFIG_HAVE_EBPF_JIT=y\n```\n\n来源：[functions.mk:2-39](), [variables.mk]()\n\n---\n\n## 常见问题\n\n### Clang 版本过旧\n\n**问题**：构建失败，提示 \"you MUST use clang 9 or newer\"\n\n**解决方案**：安装较新的 clang 版本并创建符号链接 [builder/init_env.sh:75-79]()：\n```bash\nsudo apt-get install clang-14 llc-14 llvm-strip-14\nsudo ln -sf /usr/bin/clang-14 /usr/bin/clang\n```\n\n### 缺少内核头文件\n\n**问题**：Non-CO-RE 构建失败，提示 \"linux source not found\"\n\n**解决方案**：安装并准备内核头文件 [Makefile:98-104]()：\n```bash\nsudo apt-get install linux-source\ncd /usr/src && sudo tar -xf linux-source-*.tar.bz2\ncd linux-source-*/ && sudo make prepare\n```\n\n### Go 版本过旧\n\n**问题**：构建失败，提示 \"you MUST use golang 1.24 or newer\"\n\n**解决方案**：从 [golang.org/dl](https://golang.org/dl/) 下载 Go 1.24.6+ 并更新 PATH。\n\n来源：[functions.mk:13-35](), [Makefile:98-104](), [builder/init_env.sh:72-89]()"
          },
          {
            "page_plan": {
              "id": "2",
              "title": "架构设计"
            },
            "content": "# 架构设计\n\neCapture 是一个基于 eBPF 的复杂可观测性平台，能够在不需要 CA 证书或代码修改的情况下捕获 SSL/TLS 明文并执行系统审计。系统架构由五个主要层级组成，它们协同工作以在不同系统级别拦截加密流量并生成格式化输出。\n\n本页面提供高层次的架构概述。有关特定组件的详细信息，请参阅：\n- [eBPF 引擎](#2.1) - eBPF 技术使用、探针附加、CO-RE 与 non-CO-RE 模式\n- [事件处理流程](#2.2) - 从 eBPF maps 到 workers 和 parsers 的事件流\n- [配置系统](#2.3) - IConfig 接口和运行时配置\n- [模块系统与生命周期](#2.4) - IModule 接口和模块管理\n- [版本检测与字节码选择](#2.5) - SSL/TLS 库版本检测策略\n- [网络连接跟踪](#2.6) - 基于 TC 的数据包捕获和连接映射\n\n有关模块特定的实现细节，请参阅[捕获模块](#3)。有关构建系统架构，请参阅[构建系统](#5.1)。\n\n## 系统架构概述\n\neCapture 实现了一个五层架构，具有清晰的关注点分离。数据从被监控的应用程序通过内核空间的 eBPF 钩子流向用户空间的事件处理，最终以多种格式（文本、PCAP-NG、密钥日志文件或 protobuf 流）生成格式化输出。\n\n**图表：五层架构**\n\n```mermaid\ngraph TB\n    subgraph Layer1[\"1. 用户界面层\"]\n        CLI[\"rootCmd<br/>cli/cmd/root.go:81<br/>cobra.Command\"]\n        HTTPServer[\"http.NewHttpServer<br/>cli/http/server.go<br/>localhost:28256\"]\n        eCaptureQ[\"eCaptureQ 模式<br/>ecaptureq.NewServer<br/>Tauri/React GUI\"]\n    end\n    \n    subgraph Layer2[\"2. 捕获模块层\"]\n        ModuleFactory[\"module.GetModuleFunc<br/>user/module/imodule.go\"]\n        \n        TLSModule[\"MOpenSSLProbe<br/>user/module/probe_openssl.go:83<br/>OpenSSL/BoringSSL/NSS/GnuTLS\"]\n        GoTLSModule[\"MGoTLSProbe<br/>Go crypto/tls\"]\n        AuditModules[\"Bash/Zsh/MySQL/PostgreSQL<br/>系统审计模块\"]\n    end\n    \n    subgraph Layer3[\"3. eBPF 运行时层\"]\n        VersionDetect[\"getSslBpfFile<br/>detectOpenssl<br/>user/module/probe_openssl.go:179\"]\n        BytecodeSelect[\"geteBPFName<br/>user/module/imodule.go:191<br/>CO-RE/_core.o vs non-CO-RE/_noncore.o\"]\n        Manager[\"manager.Manager<br/>ebpfmanager.InitWithOptions<br/>ebpfmanager.Start\"]\n        \n        Uprobes[\"Uprobe 程序<br/>SSL_read/SSL_write<br/>SSL_do_handshake\"]\n        TCProgs[\"TC 程序<br/>capture_packets<br/>ingress/egress\"]\n        Kprobes[\"Kprobe 程序<br/>tcp_sendmsg<br/>udp_sendmsg\"]\n    end\n    \n    subgraph Layer4[\"4. 事件处理层\"]\n        Readers[\"事件读取器<br/>perf.NewReader<br/>ringbuf.NewReader<br/>user/module/imodule.go:308\"]\n        Processor[\"EventProcessor<br/>event_processor.EventProcessor<br/>pkg/event_processor\"]\n        Workers[\"eventWorker<br/>基于 UUID 的生命周期<br/>Socket vs Default\"]\n        Parsers[\"协议解析器<br/>IParser 接口<br/>HTTP/HTTP2/H2C\"]\n    end\n    \n    subgraph Layer5[\"5. 输出层\"]\n        TextOut[\"文本模式<br/>TlsCaptureModelTypeText<br/>直接控制台输出\"]\n        PcapOut[\"PCAP 模式<br/>TlsCaptureModelTypePcap<br/>savePcapngSslKeyLog\"]\n        KeylogOut[\"密钥日志模式<br/>TlsCaptureModelTypeKeylog<br/>saveMasterSecret\"]\n        ProtobufOut[\"Protobuf 流<br/>pb.LogEntry<br/>WebSocket/TCP\"]\n    end\n    \n    CLI --> ModuleFactory\n    HTTPServer -.->|运行时配置| ModuleFactory\n    eCaptureQ -.->|远程模式| ProtobufOut\n    \n    ModuleFactory --> TLSModule\n    ModuleFactory --> GoTLSModule\n    ModuleFactory --> AuditModules\n    \n    TLSModule --> VersionDetect\n    GoTLSModule --> VersionDetect\n    VersionDetect --> BytecodeSelect\n    BytecodeSelect --> Manager\n    \n    Manager --> Uprobes\n    Manager --> TCProgs\n    Manager --> Kprobes\n    \n    Uprobes --> Readers\n    TCProgs --> Readers\n    Kprobes --> Readers\n    \n    Readers --> Processor\n    Processor --> Workers\n    Workers --> Parsers\n    \n    Parsers --> TextOut\n    Parsers --> PcapOut\n    Parsers --> KeylogOut\n    Parsers --> ProtobufOut\n```\n\n来源：[cli/cmd/root.go:80-153](), [user/module/probe_openssl.go:83-106](), [user/module/imodule.go:47-75](), [user/module/probe_openssl.go:178-278](), [user/module/imodule.go:191-214]()\n\n### 架构层级说明\n\n每一层都有特定的职责：\n\n| 层级 | 职责 | 关键组件 |\n|-------|------------------|----------------|\n| **1. 用户界面** | 命令解析、配置输入、运行时更新 | `rootCmd` (Cobra CLI)、HTTP 配置服务器、eCaptureQ 集成 |\n| **2. 捕获模块** | 协议特定逻辑、字节码选择、探针附加 | `IModule` 接口、`MOpenSSLProbe`、`MGoTLSProbe` 等 |\n| **3. eBPF 运行时** | 版本检测、CO-RE/non-CO-RE 选择、eBPF 程序生命周期 | `manager.Manager`、uprobe/TC/kprobe 程序、BTF 检测 |\n| **4. 事件处理** | 事件读取、聚合、协议解析、连接跟踪 | `EventProcessor`、`eventWorker`、`IParser` 实现 |\n| **5. 输出** | 格式转换、文件写入、网络流 | Text/PCAP/Keylog/Protobuf 写入器、PCAP-NG DSB 块 |\n\n有关 IModule 接口的详细信息，请参阅[模块系统与生命周期](#2.4)；有关事件流详细信息，请参阅[事件处理流程](#2.2)。\n\n### 关键架构决策\n\n架构做出了几个关键的设计决策以实现其功能：\n\n| 决策 | 理由 | 实现 |\n|----------|-----------|----------------|\n| **模块的工厂模式** | 支持基于 CLI 命令的动态模块加载 | `IModule` 接口 [user/module/imodule.go:47-75]()；模块通过 `RegisteFunc` 在包初始化时注册 |\n| **双字节码编译** | 支持 BTF 启用（CO-RE）和非 BTF 内核 | 构建系统生成 `*_core.o` 和 `*_noncore.o` 变体；运行时通过 `geteBPFName` 选择 [user/module/imodule.go:191-214]() |\n| **版本检测层** | 处理 20+ 个具有不同结构布局的 OpenSSL/BoringSSL 版本 | `detectOpenssl` [user/module/probe_openssl.go:178-278]() 解析 ELF `.rodata`，通过 `sslVersionBpfMap` 将版本映射到字节码 |\n| **事件处理流程** | 将捕获与输出格式化解耦，支持协议解析 | `EventProcessor` [user/module/imodule.go:104]() 按 UUID 聚合事件，应用 HTTP/HTTP2 解析器 |\n| **多种输出格式** | 支持实时分析（文本）、取证（PCAP）、解密（密钥日志） | `TlsCaptureModelType` 枚举 [user/module/probe_openssl.go:58-76]() 控制捕获模式 |\n| **连接跟踪** | 在没有用户空间协作的情况下将网络数据包映射到进程 | Kprobes 填充 `network_map` LRU 哈希表；TC 钩子查找 PID/UID。参见[网络连接跟踪](#2.6) |\n| **双 Worker 生命周期** | 针对不同连接模式优化资源使用 | 持久连接使用基于 Socket 的生命周期，短期连接使用默认（10-tick 超时）。参见[事件处理流程](#2.2) |\n\n来源：[user/module/imodule.go:47-75](), [user/module/probe_openssl.go:58-76](), [user/module/probe_openssl.go:178-278](), [user/module/imodule.go:191-214]()\n\n## 数据流管道\n\n以下图表显示了数据如何从应用程序流向输出：\n\n**图表：完整数据流**\n\n```mermaid\ngraph LR\n    App[\"被监控的应用程序<br/>curl, browser, etc.<br/>使用 OpenSSL/Go TLS\"] --> LibraryCall[\"库函数调用<br/>SSL_write/SSL_read<br/>tls.Conn.Write/Read\"]\n    \n    LibraryCall --> UprobeHook[\"Uprobe 钩子<br/>内核拦截<br/>函数入口/返回\"]\n    \n    UprobeHook --> PlaintextCapture[\"明文捕获<br/>加密前<br/>解密后\"]\n    \n    PlaintextCapture --> eBPFMap[\"eBPF Map<br/>perf_event_array<br/>或 ring_buffer\"]\n    \n    eBPFMap --> UserSpaceRead[\"perf.NewReader.Read<br/>user/module/imodule.go:308<br/>每个 map 一个 goroutine\"]\n    \n    UserSpaceRead --> DecodeEvent[\"解码事件<br/>child.Decode(map, bytes)<br/>→ IEventStruct\"]\n    \n    DecodeEvent --> Dispatcher[\"Module.Dispatcher<br/>user/module/imodule.go:409<br/>根据 EventType 路由\"]\n    \n    Dispatcher --> ProcessorQueue{\"EventType?\"}\n    ProcessorQueue -->|TypeEventProcessor| EventProcessor[\"EventProcessor.Write<br/>按 UUID 聚合\"]\n    ProcessorQueue -->|TypeOutput| DirectOutput[\"直接输出\"]\n    ProcessorQueue -->|TypeModuleData| ModuleCache[\"模块缓存<br/>主密钥、元组\"]\n    \n    EventProcessor --> WorkerPool[\"eventWorker 池<br/>解析 HTTP/HTTP2<br/>格式化输出\"]\n    \n    WorkerPool --> FinalOutput[\"最终输出\"]\n    DirectOutput --> FinalOutput\n    \n    FinalOutput --> OutputFormat{\"输出模式\"}\n    OutputFormat -->|Text| Console[\"控制台/文件<br/>zerolog.Logger\"]\n    OutputFormat -->|PCAP| PcapFile[\"PCAP-NG 文件<br/>+ DSB 密钥日志块\"]\n    OutputFormat -->|Keylog| KeylogFile[\"密钥日志文件<br/>CLIENT_RANDOM 格式\"]\n    OutputFormat -->|Protobuf| WebSocket[\"WebSocket/TCP<br/>pb.LogEntry 消息\"]\n```\n\n来源：[user/module/imodule.go:285-391](), [user/module/imodule.go:409-448](), [cli/cmd/root.go:250-403]()\n\n## 用户界面层\n\neCapture 提供三种用户交互界面：CLI 命令、HTTP 配置 API 和 eCaptureQ GUI 集成。\n\n### CLI 入口点\n\nCLI 使用 Cobra 命令框架。每个子命令对应一个捕获模块。\n\n**图表：CLI 命令结构**\n\n```mermaid\ngraph TB\n    main[\"main()<br/>main.go:10\"] --> rootCmd[\"rootCmd.Execute<br/>cli/cmd/root.go:81\"]\n    \n    rootCmd --> SubCommands[\"子命令\"]\n    \n    SubCommands --> tls[\"tls<br/>OpenSSL/BoringSSL\"]\n    SubCommands --> gotls[\"gotls<br/>Go crypto/tls\"]\n    SubCommands --> gnutls[\"gnutls<br/>GnuTLS 库\"]\n    SubCommands --> nss[\"nss<br/>NSS/NSPR\"]\n    SubCommands --> bash[\"bash<br/>命令审计\"]\n    SubCommands --> zsh[\"zsh<br/>命令审计\"]\n    SubCommands --> mysqld[\"mysqld<br/>查询审计\"]\n    SubCommands --> postgres[\"postgres<br/>查询审计\"]\n    \n    tls --> OpensslConfig[\"config.OpensslConfig<br/>--libssl, --model, --pcapfile\"]\n    gotls --> GotlsConfig[\"config.GoTLSConfig<br/>--elfpath, --model\"]\n    bash --> BashConfig[\"config.BashConfig<br/>--bashpath\"]\n    \n    OpensslConfig --> runModule[\"runModule<br/>cli/cmd/root.go:250\"]\n    GotlsConfig --> runModule\n    BashConfig --> runModule\n    \n    runModule --> SetModConfig[\"setModConfig<br/>PID, UID, BTF 模式<br/>PerCpuMapSize\"]\n    SetModConfig --> GetModuleFunc[\"module.GetModuleFunc<br/>工厂查找\"]\n    \n    GetModuleFunc --> ModInit[\"mod.Init()<br/>IModule.Init\"]\n    ModInit --> ModRun[\"mod.Run()<br/>启动 eBPF，事件循环\"]\n```\n\n来源：[main.go:9-11](), [cli/cmd/root.go:80-153](), [cli/cmd/root.go:250-403](), [cli/cmd/root.go:156-175]()\n\n**持久化标志**（应用于所有模块）[cli/cmd/root.go:140-153]()：\n\n| 标志 | 类型 | 默认值 | 用途 |\n|------|------|---------|---------|\n| `--pid` / `-p` | uint64 | 0 (全部) | 目标特定进程 ID |\n| `--uid` / `-u` | uint64 | 0 (全部) | 目标特定用户 ID |\n| `--btf` / `-b` | uint8 | 0 (自动) | BTF 模式：0=自动，1=core，2=non-core |\n| `--mapsize` | int | 1024 | 每 CPU 的 eBPF map 大小（KB） |\n| `--logaddr` / `-l` | string | \"\" | 日志目的地：文件路径、`tcp://host:port` 或 `ws://host:port/path` |\n| `--eventaddr` | string | \"\" | 事件目的地（与日志分开） |\n| `--listen` | string | `localhost:28256` | HTTP 配置服务器监听地址 |\n| `--tsize` / `-t` | uint64 | 0 | 文本模式下的截断大小（字节，0=不截断） |\n| `--ecaptureq` | string | \"\" | 监听 eCaptureQ 客户端连接 |\n\n### HTTP 配置服务器\n\nHTTP 服务器并发运行以接受运行时配置更新而无需重启。\n\n**图表：运行时配置更新**\n\n```mermaid\ngraph TB\n    HTTPServer[\"http.NewHttpServer<br/>cli/http/server.go<br/>localhost:28256\"] --> ListenAddr[\"HTTP 监听<br/>POST /config 端点\"]\n    \n    ListenAddr --> ReceiveJSON[\"接收 JSON<br/>更新后的 config.IConfig\"]\n    \n    ReceiveJSON --> ReloadChannel[\"reRloadConfig chan<br/>cli/cmd/root.go:310<br/>缓冲通道\"]\n    \n    ReloadChannel --> RunModuleLoop[\"runModule select 循环<br/>cli/cmd/root.go:368\"]\n    \n    RunModuleLoop --> CloseModule[\"mod.Close()<br/>分离 eBPF 程序\"]\n    \n    CloseModule --> Reinit[\"mod = modFunc()<br/>创建新实例\"]\n    \n    Reinit --> InitWithNewConfig[\"mod.Init(ctx, logger, newConfig)\"]\n    \n    InitWithNewConfig --> RestartModule[\"mod.Run()<br/>使用新配置恢复\"]\n```\n\n来源：[cli/cmd/root.go:313-322](), [cli/cmd/root.go:368-396]()\n\nHTTP 服务器支持动态重新配置。当收到带有更新配置 JSON 的 POST 请求时，系统会：\n1. 关闭当前模块（分离 eBPF 程序）\n2. 创建新的模块实例\n3. 使用更新的配置初始化\n4. 使用新设置重新启动事件捕获\n\n有关配置结构详细信息，请参阅[配置系统](#2.3)；有关 API 详细信息，请参阅 [HTTP API 文档](../docs/remote-config-update-api.md)。\n\n### 输出目的地\n\neCapture 支持多个日志和事件的输出目的地：\n\n**图表：输出路由**\n\n```mermaid\ngraph TB\n    initLogger[\"initLogger()<br/>cli/cmd/root.go:178\"] --> CheckAddr{\"logaddr 标志?\"}\n    \n    CheckAddr -->|\"\"| StdoutOnly[\"zerolog.ConsoleWriter<br/>仅 os.Stdout\"]\n    CheckAddr -->|文件路径| FileWriter[\"os.Create(addr)<br/>MultiLevelWriter\"]\n    CheckAddr -->|tcp://| TCPWriter[\"net.Dial('tcp', addr)<br/>TCP 连接\"]\n    CheckAddr -->|ws://| WSWriter[\"ws.NewClient<br/>WebSocket 连接\"]\n    \n    FileWriter --> MultiWriter[\"zerolog.MultiLevelWriter<br/>控制台 + 文件/TCP/WS\"]\n    TCPWriter --> MultiWriter\n    WSWriter --> MultiWriter\n    \n    MultiWriter --> LoggerInstance[\"zerolog.Logger<br/>被模块使用\"]\n    StdoutOnly --> LoggerInstance\n    \n    LoggerInstance --> EventCollector[\"eventCollector io.Writer<br/>event.CollectorWriter 或 ecaptureQEventWriter\"]\n    \n    EventCollector --> ModuleInit[\"mod.Init(ctx, logger, conf, eventCollector)<br/>user/module/imodule.go:111\"]\n```\n\n来源：[cli/cmd/root.go:178-247](), [cli/cmd/root.go:255-295]()\n\n输出类型 [cli/cmd/root.go:69-73]()：\n- **Stdout**（类型 0）：仅控制台输出\n- **File**（类型 1）：写入本地文件，可通过 `--eventroratesize` 和 `--eventroratetime` 选择性轮转\n- **TCP**（类型 2）：流式传输到 `tcp://host:port`\n- **WebSocket**（类型 3）：流式传输到 `ws://host:port/path` 或 `wss://`（TLS）\n\n`eventCollector` 接收捕获的事件，而 `logger` 接收操作日志。它们可以通过 `--logaddr` 和 `--eventaddr` 标志使用相同或不同的目的地。\n\n## 捕获模块层\n\n模块系统使用工厂模式进行动态模块实例化。每个模块都实现 `IModule` 接口并嵌入基础 `Module` 结构体以获得通用功能。\n\n### 模块工厂和注册\n\n模块在包初始化时自注册。\n\n**图表：模块工厂模式**\n\n```mermaid\ngraph TB\n    InitFuncs[\"init() 函数<br/>user/module/probe_*.go\"] --> CallRegisteFunc[\"RegisteFunc(NewModuleProbe)<br/>注册构造函数\"]\n    \n    CallRegisteFunc --> ModuleFactories[\"moduleFactories map<br/>全局注册表\"]\n    \n    ModuleFactories --> RegisteredModules[\"已注册的构造函数\"]\n    \n    RegisteredModules --> NewOpenSSLProbe[\"NewOpenSSLProbe<br/>user/module/probe_openssl.go:781\"]\n    RegisteredModules --> NewGoTLSProbe[\"NewGoTLSProbe<br/>user/module/probe_gotls.go\"]\n    RegisteredModules --> NewGnuTLSProbe[\"NewGnuTLSProbe\"]\n    RegisteredModules --> NewNSSProbe[\"NewNSSProbe\"]\n    RegisteredModules --> NewBashProbe[\"NewBashProbe\"]\n    RegisteredModules --> NewMysqldProbe[\"NewMysqldProbe\"]\n    RegisteredModules --> NewPostgresProbe[\"NewPostgresProbe\"]\n    RegisteredModules --> NewZshProbe[\"NewZshProbe\"]\n    \n    CLIRunModule[\"runModule<br/>cli/cmd/root.go:250\"] --> GetModuleFunc[\"module.GetModuleFunc(modName)<br/>在注册表中查找\"]\n    \n    GetModuleFunc --> RetrieveConstructor[\"moduleFactories[modName]<br/>返回 func() IModule\"]\n    \n    RetrieveConstructor --> CreateInstance[\"modFunc()<br/>创建模块实例\"]\n```\n\n来源：[user/module/probe_openssl.go:777-786](), [cli/cmd/root.go:344-347]()\n\n来自 OpenSSL 模块的注册示例 [user/module/probe_openssl.go:777-786]()：\n```go\nfunc init() {\n    RegisteFunc(NewOpenSSLProbe)\n}\n\nfunc NewOpenSSLProbe() IModule {\n    mod := &MOpenSSLProbe{}\n    mod.name = ModuleNameOpenssl\n    mod.mType = ProbeTypeUprobe\n    return mod\n}\n```\n\nCLI 通过 `module.GetModuleFunc(modName)` [cli/cmd/root.go:344]() 检索构造函数并调用它来创建实例。\n\n### IModule 接口\n\n所有模块都实现 `IModule` 接口 [user/module/imodule.go:47-75]()，该接口定义了生命周期和事件处理方法。\n\n**IModule 接口方法**\n\n| 方法 | 用途 | 阶段 | 责任 |\n|--------|---------|-------|----------------|\n| `Init(context.Context, *zerolog.Logger, config.IConfig, io.Writer)` | 初始化模块，设置 EventProcessor，BTF 检测 | 初始化 | 基础 `Module` + 子类重写 |\n| `Start()` | 加载 eBPF 字节码，附加探针/钩子 | 启动 | 子类实现 |\n| `Run()` | 启动事件读取器，开始处理循环 | 运行 | 基础 `Module`（调用 child.Start） |\n| `Events() []*ebpf.Map` | 返回要读取事件的 eBPF maps | 运行 | 子类实现 |\n| `Decode(*ebpf.Map, []byte) (event.IEventStruct, error)` | 将原始事件字节解析为结构体 | 事件处理 | 基础委托给 child.DecodeFun |\n| `DecodeFun(*ebpf.Map) (event.IEventStruct, bool)` | 返回特定 map 的解码器 | 事件处理 | 子类实现 |\n| `Dispatcher(event.IEventStruct)` | 路由事件（缓存、处理、输出） | 事件处理 | 基础 + 子类都实现 |\n| `Close()` | 停止 eBPF 程序，清理资源 | 关闭 | 基础 + 子类都实现 |\n\n有关详细的生命周期信息，请参阅[模块系统与生命周期](#2.4)。\n\n来源：[user/module/imodule.go:47-75](), [user/module/imodule.go:110-171]()\n\n### 基础模块实现\n\n`Module` 结构体 [user/module/imodule.go:83-108]() 提供了所有探针通过嵌入继承的通用功能。\n\n**图表：模块结构体组成**\n\n```mermaid\ngraph TB\n    BaseModule[\"Module 结构体<br/>user/module/imodule.go:83<br/>被所有探针嵌入\"] --> CoreFields[\"核心字段\"]\n    BaseModule --> CoreMethods[\"核心方法\"]\n    \n    CoreFields --> ctx[\"ctx context.Context<br/>取消信号\"]\n    CoreFields --> logger[\"logger *zerolog.Logger<br/>日志接口\"]\n    CoreFields --> conf[\"conf config.IConfig<br/>模块配置\"]\n    CoreFields --> processor[\"processor *EventProcessor<br/>pkg/event_processor\"]\n    CoreFields --> reader[\"reader []IClose<br/>perf/ringbuf 读取器\"]\n    CoreFields --> child[\"child IModule<br/>实际探针（例如 MOpenSSLProbe）\"]\n    CoreFields --> eventCollector[\"eventCollector io.Writer<br/>输出目的地\"]\n    CoreFields --> flags[\"isCoreUsed bool<br/>isKernelLess5_2 bool\"]\n    \n    CoreMethods --> InitMethod[\"Init()<br/>BTF 检测<br/>EventProcessor 设置<br/>user/module/imodule.go:111\"]\n    CoreMethods --> RunMethod[\"Run()<br/>启动 child.Start()<br/>readEvents()<br/>user/module/imodule.go:236\"]\n    CoreMethods --> readEvents[\"readEvents()<br/>perfEventReader<br/>ringbufEventReader<br/>user/module/imodule.go:285\"]\n    CoreMethods --> DecodeMethod[\"Decode()<br/>委托给 child.DecodeFun<br/>user/module/imodule.go:393\"]\n    CoreMethods --> DispatcherMethod[\"Dispatcher()<br/>路由事件<br/>user/module/imodule.go:409\"]\n    CoreMethods --> CloseMethod[\"Close()<br/>清理读取器<br/>user/module/imodule.go:450\"]\n    \n    ProbeModules[\"探针模块\"] --> MOpenSSL[\"MOpenSSLProbe<br/>user/module/probe_openssl.go:83<br/>嵌入 Module\"]\n    ProbeModules --> MGoTLS[\"MGoTLSProbe<br/>嵌入 Module\"]\n    ProbeModules --> MGnuTLS[\"MGnuTLSProbe<br/>嵌入 Module\"]\n    ProbeModules --> MBash[\"MBashProbe<br/>嵌入 Module\"]\n    \n    MOpenSSL --> ImplStart[\"实现 Start()<br/>setupManagers*<br/>加载 eBPF 字节码\"]\n    MOpenSSL --> ImplEvents[\"实现 Events()<br/>返回事件 maps\"]\n    MOpenSSL --> ImplDecodeFun[\"实现 DecodeFun()<br/>Map → 事件结构体类型\"]\n    MOpenSSL --> ImplDispatcher[\"实现 Dispatcher()<br/>saveMasterSecret<br/>AddConn/DelConn\"]\n```\n\n来源：[user/module/imodule.go:83-108](), [user/module/probe_openssl.go:83-106]()\n\n**基础模块职责** [user/module/imodule.go:83-460]()：\n\n1. **BTF 检测**：`autoDetectBTF()` 检查 `/sys/kernel/btf/vmlinux` 和容器环境 [user/module/imodule.go:173-190]()\n2. **字节码选择**：`geteBPFName()` 附加 `_core.o`/`_noncore.o` 和 `_less52.o` 后缀 [user/module/imodule.go:191-214]()\n3. **事件读取器**：`perfEventReader()` 和 `ringbufEventReader()` 为每个 eBPF map 设置 goroutines [user/module/imodule.go:308-391]()\n4. **EventProcessor**：使用截断大小和十六进制模式初始化 [user/module/imodule.go:127]()\n5. **输出路由**：检测 `eventCollector` 类型以选择文本或 protobuf 编码 [user/module/imodule.go:122-126](), [user/module/imodule.go:461-479]()\n6. **生命周期管理**：通过 `Start()`、`Run()`、`Close()` 协调子模块的生命周期 [user/module/imodule.go:236-262]()\n\n### 模块特定实现\n\n每个探针模块都嵌入 `Module` 并添加模块特定的状态和逻辑。有关详细的实现信息，请参阅[捕获模块](#3)。\n\n**关键模块类型**\n\n| 模块 | 用途 | 目标库/二进制文件 | 关键状态 | 另请参阅 |\n|--------|---------|---------------------------|-----------|----------|\n| `MOpenSSLProbe` | TLS 明文捕获 | libssl.so、libcrypto.so、BoringSSL | `sslVersionBpfMap`、`pidConns`、`masterKeys`、`eBPFProgramType` | [OpenSSL 模块](#3.1.1) |\n| `MGoTLSProbe` | Go TLS 明文捕获 | Go 二进制文件（crypto/tls） | `isRegisterABI`、`tcPacketsChan`、`keylogger` | [Go TLS 模块](#3.1.2) |\n| `MGnuTLSProbe` | GnuTLS 明文捕获 | libgnutls.so | `keylogger`、`masterKeys` | [GnuTLS 与 NSS 模块](#3.1.3) |\n| `MNSSProbe` | NSS/NSPR 明文捕获 | libnss3.so、libnspr4.so | 主密钥提取 | [GnuTLS 与 NSS 模块](#3.1.3) |\n| `MBashProbe` | Bash 命令审计 | bash 二进制文件 | 通过 readline 钩子过滤命令 | [Shell 命令审计](#3.2.1) |\n| `MZshProbe` | Zsh 命令审计 | zsh 二进制文件 | 通过 zle 钩子过滤命令 | [Shell 命令审计](#3.2.1) |\n| `MMysqldProbe` | MySQL 查询审计 | mysqld 二进制文件 | `funcName`，从 dispatch_command 提取 SQL | [数据库查询审计](#3.2.2) |\n| `MPostgresProbe` | PostgreSQL 查询审计 | postgres 二进制文件 | 从 exec_simple_query 提取查询 | [数据库查询审计](#3.2.2) |\n\n来源：[user/module/probe_openssl.go:83-106]()\n\n**示例：MOpenSSLProbe 状态** [user/module/probe_openssl.go:83-106]()：\n\n| 字段 | 类型 | 用途 |\n|-------|------|---------|\n| `pidConns` | `map[uint32]map[uint32]ConnInfo` | 映射 PID → FD → 连接元组和套接字 [user/module/probe_openssl.go:91]() |\n| `sock2pidFd` | `map[uint64][2]uint32` | 反向映射：套接字 → [PID, FD] 用于连接清理 [user/module/probe_openssl.go:93]() |\n| `masterKeys` | `map[string]bool` | 通过客户端随机数去重 TLS 主密钥 [user/module/probe_openssl.go:98]() |\n| `sslVersionBpfMap` | `map[string]string` | 将 SSL 版本字符串映射到字节码文件名 [user/module/probe_openssl.go:101]() |\n| `eBPFProgramType` | `TlsCaptureModelType` | 确定捕获模式（Text/Pcap/Keylog）[user/module/probe_openssl.go:99]() |\n| `keylogger` | `*os.File` | 密钥日志模式输出的文件句柄 [user/module/probe_openssl.go:96]() |\n| `bpfManager` | `*manager.Manager` | eBPF 程序生命周期管理器 [user/module/probe_openssl.go:85]() |\n\n这些映射表启用了 SSL 数据事件（由 PID/FD 标识）与 TC 钩子捕获的网络元组之间的关联。有关 `sslVersionBpfMap` 的使用，请参阅[版本检测与字节码选择](#2.5)；有关连接映射的详细信息，请参阅[网络连接跟踪](#2.6)。\n\n## eBPF 运行时层\n\neBPF 运行时层连接用户空间模块和内核空间检测。它通过 `ebpfmanager` 库处理版本检测、字节码选择和 eBPF 程序生命周期。\n\n有关 eBPF 程序和钩子的综合详细信息，请参阅 [eBPF 引擎](#2.1)。有关版本检测算法，请参阅[版本检测与字节码选择](#2.5)。\n\n### eBPF 运行时组件概述\n\n**图表：eBPF 运行时组件**\n\n```mermaid\ngraph TB\n    Module[\"捕获模块<br/>（例如 MOpenSSLProbe）\"] --> VersionDetection[\"版本检测<br/>getSslBpfFile()<br/>detectOpenssl()\"]\n    \n    VersionDetection --> BytecodeSelection[\"字节码选择<br/>geteBPFName()<br/>CO-RE vs non-CO-RE\"]\n    \n    BytecodeSelection --> AssetLoad[\"资源加载<br/>assets.Asset(bpfFileName)<br/>嵌入的字节码\"]\n    \n    AssetLoad --> ManagerInit[\"Manager 初始化<br/>manager.InitWithOptions()<br/>eBPF 验证器\"]\n    \n    ManagerInit --> ManagerStart[\"Manager 启动<br/>manager.Start()<br/>附加探针\"]\n    \n    ManagerStart --> ProbeTypes[\"探针类型\"]\n    \n    ProbeTypes --> Uprobes[\"Uprobes<br/>用户函数钩子<br/>SSL_read, SSL_write\"]\n    ProbeTypes --> TC[\"TC 分类器<br/>网络数据包捕获<br/>ingress/egress\"]\n    ProbeTypes --> Kprobes[\"Kprobes<br/>内核函数钩子<br/>tcp_sendmsg, etc.\"]\n    \n    Uprobes --> eBPFMaps[\"eBPF Maps<br/>perf_event_array<br/>ring_buffer\"]\n    TC --> eBPFMaps\n    Kprobes --> eBPFMaps\n    \n    eBPFMaps --> UserSpaceRead[\"用户空间读取<br/>Module.readEvents()<br/>perfEventReader, ringbufEventReader\"]\n```\n\n来源：[user/module/probe_openssl.go:178-278](), [user/module/imodule.go:191-214](), [user/module/probe_openssl.go:312-331](), [user/module/imodule.go:285-391]()\n\n运行时层执行以下操作：\n\n1. **版本检测**：确定目标库版本（参见[版本检测与字节码选择](#2.5)）\n2. **字节码选择**：根据 BTF 可用性选择 CO-RE 或 non-CO-RE 字节码\n3. **资源加载**：从 `assets` 包加载嵌入的字节码\n4. **eBPF 验证**：内核验证程序安全性\n5. **探针附加**：附加 uprobes、TC 分类器、kprobes\n6. **事件读取**：为 eBPF maps 设置读取器\n\n### BTF 检测与字节码选择\n\neCapture 编译每个 eBPF 程序的两个变体：**CO-RE**（启用 BTF，内核 >= 5.2）和 **non-CO-RE**（传统，所有内核）。运行时选择基于内核 BTF 支持。\n\n**图表：BTF 检测与字节码模式选择**\n\n```mermaid\ngraph TB\n    ModuleInit[\"Module.Init()<br/>user/module/imodule.go:111\"] --> CheckBTFMode{\"conf.GetBTF()\"}\n    \n    CheckBTFMode -->|0: BTFModeAutoDetect| AutoDetect[\"autoDetectBTF()<br/>user/module/imodule.go:173\"]\n    CheckBTFMode -->|1: BTFModeCore| ForceCore[\"m.isCoreUsed = true\"]\n    CheckBTFMode -->|2: BTFModeNonCore| ForceNonCore[\"m.isCoreUsed = false\"]\n    \n    AutoDetect --> CheckContainer[\"ebpfenv.IsContainer()<br/>检测容器环境\"]\n    CheckContainer --> CheckBTFFile[\"ebpfenv.IsEnableBTF()<br/>检查 /sys/kernel/btf/vmlinux\"]\n    CheckBTFFile --> SetCoreFlag[\"m.isCoreUsed = (BTF 可用)\"]\n    \n    ForceCore --> ApplyFilename[\"geteBPFName()<br/>user/module/imodule.go:191\"]\n    ForceNonCore --> ApplyFilename\n    SetCoreFlag --> ApplyFilename\n    \n    ApplyFilename --> CheckMode{\"m.isCoreUsed?\"}\n    CheckMode -->|true| AppendCore[\"filename.o<br/>→ filename_core.o\"]\n    CheckMode -->|false| AppendNonCore[\"filename.o<br/>→ filename_noncore.o\"]\n    \n    AppendCore --> CheckKernel{\"内核 < 5.2?\"}\n    AppendNonCore --> CheckKernel\n    \n    CheckKernel -->|是| AppendLess52[\"附加 _less52.o<br/>例如 filename_core_less52.o\"]\n    CheckKernel -->|否| FinalFilename[\"最终字节码文件名\"]\n    \n    AppendLess52 --> FinalFilename\n    \n    FinalFilename --> AssetLookup[\"assets.Asset(bpfFileName)<br/>从嵌入式 FS 加载\"]\n```\n\n来源：[user/module/imodule.go:154-170](), [user/module/imodule.go:173-190](), [user/module/imodule.go:191-214]()\n\n**BTF 检测逻辑** [user/module/imodule.go:173-190]()：\n1. 检查是否在容器中运行（在容器中 BTF 检测可能不可靠）\n2. 查找 `/sys/kernel/btf/vmlinux` 文件以确认 BTF 支持\n3. 根据检测结果设置 `m.isCoreUsed` 标志\n\n**文件名转换示例** [user/module/imodule.go:191-214]()：\n- `openssl_3_0_0_kern.o` → `openssl_3_0_0_kern_core.o`（BTF 内核 >= 5.2）\n- `openssl_3_0_0_kern.o` → `openssl_3_0_0_kern_noncore.o`（非 BTF 内核 >= 5.2）\n- `openssl_3_0_0_kern.o` → `openssl_3_0_0_kern_core_less52.o`（BTF 内核 < 5.2）\n- `openssl_3_0_0_kern.o` → `openssl_3_0_0_kern_noncore_less52.o`（非 BTF 内核 < 5.2）\n\nCO-RE 字节码使用 BTF 类型信息在加载时解析结构布局，实现**一次编译 - 随处运行**。non-CO-RE 字节码为特定内核版本硬编码偏移量。有关编译详细信息，请参阅[构建系统](#5.1)。\n\n### eBPF 程序生命周期\n\n`ebpfmanager.Manager` [user/module/probe_openssl.go:85]() 管理 eBPF 程序的加载、验证、附加和清理。\n\n**图表：eBPF 生命周期管理**\n\n```mermaid\ngraph TB\n    ModuleStart[\"child.Start()<br/>例如 probe_openssl.go:280\"] --> SetupManagers[\"setupManagers*()<br/>模式特定设置<br/>Text/Pcap/Keylog\"]\n    \n    SetupManagers --> DefineManager[\"创建 manager.Manager<br/>定义 Probes、Maps、ConstantEditors\"]\n    \n    DefineManager --> LoadBytecode[\"assets.Asset(bpfFileName)<br/>从嵌入式 FS 加载<br/>user/module/probe_openssl.go:312\"]\n    \n    LoadBytecode --> ManagerInit[\"bpfManager.InitWithOptions()<br/>bytes.NewReader(byteBuf)<br/>user/module/probe_openssl.go:320\"]\n    \n    ManagerInit --> eBPFVerifier[\"eBPF 验证器<br/>内核验证程序<br/>检查安全性、循环、权限\"]\n    \n    eBPFVerifier --> ManagerStart[\"bpfManager.Start()<br/>附加所有探针<br/>user/module/probe_openssl.go:329\"]\n    \n    ManagerStart --> AttachProbes[\"附加探针\"]\n    \n    AttachProbes --> Uprobes[\"Uprobes<br/>SSL_read, SSL_write<br/>SSL_do_handshake, etc.\"]\n    AttachProbes --> TCProgs[\"TC 分类器<br/>ingress_cls_func<br/>egress_cls_func\"]\n    AttachProbes --> Kprobes[\"Kprobes<br/>tcp_sendmsg<br/>__sys_connect\"]\n    \n    Uprobes --> RegisterMaps[\"initDecodeFun*()<br/>注册事件 maps<br/>user/module/probe_openssl.go:336\"]\n    TCProgs --> RegisterMaps\n    Kprobes --> RegisterMaps\n    \n    RegisterMaps --> EventMaps[\"m.eventMaps<br/>[]*ebpf.Map\"]\n    RegisterMaps --> EventFuncMaps[\"m.eventFuncMaps<br/>map[*ebpf.Map]IEventStruct\"]\n    \n    EventMaps --> ModuleRun[\"Module.Run()<br/>事件处理<br/>user/module/imodule.go:236\"]\n    EventFuncMaps --> ModuleRun\n    \n    ModuleRun --> Running[\"运行状态<br/>从 maps 读取事件\"]\n    \n    Running --> Shutdown[\"Module.Close()<br/>关闭信号\"]\n    \n    Shutdown --> ManagerStop[\"bpfManager.Stop<br/>(manager.CleanAll)<br/>user/module/probe_openssl.go:354\"]\n    \n    ManagerStop --> DetachAll[\"分离所有探针<br/>卸载 eBPF 程序<br/>关闭文件描述符\"]\n```\n\n来源：[user/module/probe_openssl.go:280-357](), [user/module/imodule.go:236-262]()\n\n**生命周期阶段**：\n\n1. **设置**：`Start()` 调用模式特定的设置（`setupManagersText`、`setupManagersPcap`、`setupManagersKeylog`）\n2. **字节码加载**：`assets.Asset(bpfFileName)` 检索嵌入的字节码 [user/module/probe_openssl.go:312-317]()\n3. **初始化**：`bpfManager.InitWithOptions()` 加载字节码，内核验证程序 [user/module/probe_openssl.go:320-326]()\n4. **附加**：`bpfManager.Start()` 附加 uprobes/TC/kprobes [user/module/probe_openssl.go:329-331]()\n5. **Map 注册**：`initDecodeFun*()` 填充 `eventMaps` 和 `eventFuncMaps` [user/module/probe_openssl.go:333-348]()\n6. **运行**：基础 `Module.Run()` 生成事件读取器和 EventProcessor [user/module/imodule.go:236-262]()\n7. **关闭**：`bpfManager.Stop(manager.CleanAll)` 分离并清理 [user/module/probe_openssl.go:352-357]()\n\n### 通过常量编辑器注入配置\n\neBPF 程序定义在加载时重写的常量变量以注入运行时配置（PID、UID 过滤器）。\n\n**常量编辑器机制**\n\n| 常量名称 | 用途 | 类型 | 值来源 | 效果 |\n|---------------|---------|------|--------------|--------|\n| `target_pid` | 按进程 ID 过滤 | `uint64` | `conf.GetPid()` | 0 = 捕获所有 PID，非零 = 仅特定 PID |\n| `target_uid` | 按用户 ID 过滤 | `uint64` | `conf.GetUid()` | 0 = 捕获所有 UID，非零 = 仅特定 UID |\n\n来源：[user/module/probe_openssl.go:361-387]()\n\n`constantEditor()` 方法 [user/module/probe_openssl.go:361-387]() 返回一个 `manager.ConstantEditor` 结构体切片。eBPF 管理器在加载到内核**之前**重写字节码中的这些常量。这使得无需重新编译 eBPF 程序即可实现参数化过滤。\n\n对于内核 < 5.2，全局变量支持受限。`EnableGlobalVar()` 检查 [user/config/iconfig.go:194-203]() 返回 false，禁用某些功能。\n\n## 事件处理层\n\n在 eBPF 程序捕获事件并通过 perf 数组或环形缓冲区传输后，用户空间事件处理流程会聚合、解析并格式化它们以供输出。\n\n有关全面的事件处理详细信息，请参阅[事件处理流程](#2.2)。"
          },
          {
            "page_plan": {
              "id": "2.1",
              "title": "eBPF 引擎"
            },
            "content": "# eBPF 引擎\n\neBPF 引擎是 eCapture 的基础运行时层，负责管理 eBPF 程序的生命周期，通过 CO-RE/非 CO-RE 模式处理内核兼容性，并促进内核空间与用户空间之间的通信。本文档涵盖 eBPF 程序加载、BTF 检测、字节码选择和事件映射管理的技术实现。\n\n关于各个捕获模块如何使用 eBPF 引擎的信息，请参阅[模块系统与生命周期](#2.4)。有关版本检测和字节码映射策略的详细信息，请参阅[版本检测与字节码选择](#2.5)。关于 eBPF 映射将数据传递到用户空间后的事件处理，请参阅[事件处理流程](#2.2)。\n\n## eBPF 程序类型与挂载\n\neCapture 采用三种主要的 eBPF 程序类型来捕获系统行为的不同方面：\n\n**程序类型架构**\n\n```mermaid\ngraph TB\n    subgraph \"用户空间应用程序\"\n        APP1[\"OpenSSL/BoringSSL<br/>libssl.so\"]\n        APP2[\"Go TLS 应用程序<br/>PIE 二进制文件\"]\n        APP3[\"数据库服务器<br/>mysqld/postgres\"]\n        APP4[\"Shell 进程<br/>bash/zsh\"]\n    end\n    \n    subgraph \"内核空间 - eBPF 程序\"\n        UPROBE[\"Uprobe 程序<br/>openssl_kern.c<br/>gotls_kern.c<br/>bash_kern.c\"]\n        TC[\"TC 分类器<br/>tc_kern.c<br/>capture_packets\"]\n        KPROBE[\"Kprobe 程序<br/>conn_kern.c<br/>tcp_sendmsg<br/>tcp_close\"]\n    end\n    \n    subgraph \"eBPF 映射\"\n        PERF[\"Perf 事件数组<br/>BPF_MAP_TYPE_PERF_EVENT_ARRAY\"]\n        RING[\"环形缓冲区<br/>BPF_MAP_TYPE_RINGBUF\"]\n        HASH[\"哈希映射<br/>连接跟踪<br/>进程过滤\"]\n    end\n    \n    APP1 -->|\"uretprobe<br/>SSL_read/SSL_write\"| UPROBE\n    APP2 -->|\"uprobe<br/>crypto/tls.(*Conn).Read\"| UPROBE\n    APP3 -->|\"uprobe<br/>dispatch_command\"| UPROBE\n    APP4 -->|\"uretprobe<br/>readline\"| UPROBE\n    \n    APP1 -.->|\"网络数据包\"| TC\n    APP2 -.->|\"网络数据包\"| TC\n    \n    APP1 -.->|\"套接字操作\"| KPROBE\n    APP2 -.->|\"套接字操作\"| KPROBE\n    \n    UPROBE --> PERF\n    UPROBE --> RING\n    TC --> PERF\n    KPROBE --> HASH\n    \n    UPROBE --> HASH\n```\n\n来源: [Makefile:118-183](), [user/module/probe_openssl.go:83-106]()\n\n### Uprobe 程序\n\nUprobe 挂载到动态链接库和可执行文件中的用户空间函数。主要用例包括：\n\n| 函数钩子 | 目的 | eBPF 程序 |\n|--------------|---------|--------------|\n| `SSL_read` / `SSL_write` | 捕获 TLS 明文 | `openssl_kern.c` |\n| `SSL_do_handshake` | 提取主密钥 | `openssl_kern.c` |\n| `crypto/tls.(*Conn).Read` | Go TLS 捕获 | `gotls_kern.c` |\n| `dispatch_command` | MySQL 查询审计 | `mysqld_kern.c` |\n| `readline` | Bash 命令审计 | `bash_kern.c` |\n\n模块通过 `github.com/gojue/ebpfmanager` 管理 uprobe 挂载，该库处理探针生命周期、错误恢复和清理。\n\n来源: [user/module/probe_openssl.go:280-350]()\n\n### TC（流量控制）分类器\n\nTC eBPF 程序挂载到流量控制层的网络接口上，支持具有进程归属的数据包级捕获：\n\n```mermaid\ngraph LR\n    NET[\"网络接口<br/>eth0/wlan0\"]\n    INGRESS[\"TC 入口钩子<br/>capture_packets_ingress\"]\n    EGRESS[\"TC 出口钩子<br/>capture_packets_egress\"]\n    FILTER[\"数据包过滤<br/>PID/UID/四元组\"]\n    PERF[\"Perf 事件数组<br/>tc_events\"]\n    \n    NET -->|\"传入数据包\"| INGRESS\n    NET -->|\"传出数据包\"| EGRESS\n    INGRESS --> FILTER\n    EGRESS --> FILTER\n    FILTER --> PERF\n```\n\n当指定 cgroup 路径时，TC 程序实现 BPF cgroup 套接字过滤，并可应用 Berkeley 数据包过滤器表达式进行高级过滤。\n\n来源: [user/module/probe_openssl.go:302-307]()\n\n### Kprobe 程序\n\nKprobe 挂载到内核函数，用于连接跟踪和套接字生命周期监控：\n\n- `tcp_sendmsg`：将 TCP 连接关联到进程 ID\n- `tcp_close`：检测连接终止\n- `udp_sendmsg`：UDP 连接跟踪\n\n连接映射使 TC 程序能够将数据包归属到特定进程，这对于 PCAP 输出模式至关重要。\n\n来源: 架构图，内核跟踪的常见模式\n\n## CO-RE 与 BTF 模式\n\neCapture 实现了双重编译策略以最大化内核兼容性：CO-RE（编译一次 - 到处运行）用于具有 BTF 支持的现代内核，传统的非 CO-RE 用于较旧或自定义内核。\n\n**编译与运行时模式选择**\n\n```mermaid\ngraph TB\n    START[\"构建系统<br/>Makefile\"]\n    \n    subgraph \"编译阶段\"\n        CORE_COMP[\"CO-RE 编译<br/>clang -target bpfel<br/>-g 生成 BTF 调试信息\"]\n        NONCORE_COMP[\"非 CO-RE 编译<br/>clang + 内核头文件<br/>-I /usr/src/linux\"]\n        LESS52[\"内核 < 5.2 变体<br/>-DKERNEL_LESS_5_2\"]\n    end\n    \n    subgraph \"字节码产物\"\n        CORE_OBJ[\"*_core.o<br/>BTF 重定位\"]\n        NONCORE_OBJ[\"*_noncore.o<br/>硬编码偏移量\"]\n        LESS52_CORE[\"*_core_less52.o\"]\n        LESS52_NONCORE[\"*_noncore_less52.o\"]\n    end\n    \n    EMBED[\"go-bindata<br/>assets/ebpf_probe.go\"]\n    \n    subgraph \"运行时检测\"\n        BTF_CHECK[\"BTF 可用性检查<br/>IsEnableBTF\"]\n        KVER_CHECK[\"内核版本检查<br/>HostVersion\"]\n        MODE_SELECT[\"模式选择<br/>isCoreUsed 标志\"]\n    end\n    \n    subgraph \"字节码选择\"\n        GETEBPF[\"geteBPFName<br/>字符串替换\"]\n        LOAD[\"assets.Asset<br/>字节码加载\"]\n    end\n    \n    START --> CORE_COMP\n    START --> NONCORE_COMP\n    CORE_COMP --> LESS52\n    NONCORE_COMP --> LESS52\n    \n    CORE_COMP --> CORE_OBJ\n    NONCORE_COMP --> NONCORE_OBJ\n    LESS52 --> LESS52_CORE\n    LESS52 --> LESS52_NONCORE\n    \n    CORE_OBJ --> EMBED\n    NONCORE_OBJ --> EMBED\n    LESS52_CORE --> EMBED\n    LESS52_NONCORE --> EMBED\n    \n    EMBED --> BTF_CHECK\n    BTF_CHECK --> KVER_CHECK\n    KVER_CHECK --> MODE_SELECT\n    MODE_SELECT --> GETEBPF\n    GETEBPF --> LOAD\n```\n\n来源: [Makefile:118-183](), [user/module/imodule.go:173-214]()\n\n### BTF（BPF 类型格式）\n\nBTF 是一种元数据格式，描述内核数据结构的布局，使 eBPF 程序能够跨内核版本移植。eCapture 的 BTF 检测逻辑：\n\n**BTF 检测流程**\n\n| 步骤 | 函数 | 位置 |\n|------|----------|----------|\n| 1. 容器检测 | `ebpfenv.IsContainer()` | [user/module/imodule.go:175-179]() |\n| 2. BTF 可用性检查 | `ebpfenv.IsEnableBTF()` | [user/module/imodule.go:180-186]() |\n| 3. 模式覆盖 | `conf.GetBTF()` | [user/module/imodule.go:154-164]() |\n\nBTF 模式在配置系统中定义：\n\n```\nBTFModeAutoDetect = 0  // 自动检测（默认）\nBTFModeCore       = 1  // 强制 CO-RE 模式\nBTFModeNonCore    = 2  // 强制非 CO-RE 模式\n```\n\n来源: [user/config/iconfig.go:82-86](), [user/module/imodule.go:154-190]()\n\n### CO-RE 编译\n\nCO-RE 字节码编译使用 LLVM 的 BTF 生成和重定位功能：\n\n**编译标志**\n\n```\nclang -D__TARGET_ARCH_x86 \\\n      -target bpfel \\           # 小端 BPF 目标\n      -fno-ident \\              # 省略编译器标识\n      -fdebug-compilation-dir . \\\n      -g \\                       # 生成调试信息（BTF）\n      -D__BPF_TARGET_MISSING=\"...\" \\\n      -MD -MP                    # 依赖项生成\n```\n\n生成的 `*_core.o` 文件包含 BTF 信息，内核的 BTF 加载器使用这些信息在加载时执行字段偏移重定位。\n\n来源: [Makefile:122-134](), [.github/workflows/go-c-cpp.yml:42]()\n\n### 非 CO-RE 编译\n\n非 CO-RE 模式在编译时需要内核头文件来确定精确的结构体偏移量：\n\n**非 CO-RE 构建流程**\n\n```mermaid\ngraph LR\n    HEADERS[\"内核头文件<br/>/usr/src/linux-source\"]\n    KERN_PREP[\"内核准备<br/>make prepare<br/>ARCH=arm64/x86\"]\n    CLANG[\"clang 编译<br/>包含内核头文件\"]\n    LLC[\"llc 汇编<br/>-march=bpf<br/>-filetype=obj\"]\n    NONCORE[\"*_noncore.o<br/>固定偏移量\"]\n    \n    HEADERS --> KERN_PREP\n    KERN_PREP --> CLANG\n    CLANG --> LLC\n    LLC --> NONCORE\n```\n\nMakefile 显式包含架构特定的头文件路径：\n\n```\n-I $(KERN_SRC_PATH)/arch/$(LINUX_ARCH)/include\n-I $(KERN_BUILD_PATH)/arch/$(LINUX_ARCH)/include/generated\n-I $(KERN_SRC_PATH)/include\n```\n\n来源: [Makefile:146-183](), [.github/workflows/go-c-cpp.yml:16-33]()\n\n### 内核 < 5.2 支持\n\n5.2.0 之前的内核缺少某些 eBPF 功能（全局变量、有界循环）。eCapture 生成带有定义 `KERNEL_LESS_5_2` 宏的单独字节码变体：\n\n```c\n#ifdef KERNEL_LESS_5_2\n    // 使用不带全局变量的替代实现\n#else\n    // 现代内核实现\n#endif\n```\n\n运行时检测内核版本并选择适当的后缀：\n\n来源: [Makefile:131-134](), [user/module/imodule.go:140-149](), [user/module/imodule.go:208-211]()\n\n## 字节码资源嵌入\n\n所有编译的 eBPF 字节码使用 `go-bindata` 嵌入到 Go 二进制文件中，消除运行时依赖：\n\n**资源嵌入流程**\n\n```mermaid\ngraph LR\n    BYTECODE[\"user/bytecode/<br/>*.o 文件\"]\n    GOBINDATA[\"go-bindata 工具<br/>生成 Go 代码\"]\n    ASSET_GO[\"assets/ebpf_probe.go<br/>Asset 函数\"]\n    GOBUILD[\"Go 构建<br/>静态链接\"]\n    BINARY[\"ecapture 二进制文件<br/>自包含\"]\n    \n    BYTECODE --> GOBINDATA\n    GOBINDATA --> ASSET_GO\n    ASSET_GO --> GOBUILD\n    GOBUILD --> BINARY\n```\n\n通过以下方式访问嵌入的资源：\n\n```go\nbyteBuf, err := assets.Asset(\"user/bytecode/openssl_3_2_0_kern_core.o\")\n```\n\n这种方法确保二进制文件可以在任何兼容系统上运行，无需外部字节码文件。\n\n来源: [Makefile:186-195](), [user/module/probe_openssl.go:310-317]()\n\n## eBPF 程序生命周期\n\neBPF 程序生命周期通过 `ebpfmanager` 库管理，该库提供了一种结构化方法来加载、挂载和管理多个 eBPF 程序和映射。\n\n**模块初始化与启动流程**\n\n```mermaid\ngraph TB\n    INIT[\"Module.Init<br/>上下文设置<br/>日志器初始化\"]\n    \n    CHILD_INIT[\"子模块初始化<br/>例如 MOpenSSLProbe\"]\n    \n    VERSION[\"版本检测<br/>detectOpenssl<br/>getSslBpfFile\"]\n    \n    SETUP[\"设置管理器<br/>setupManagersText<br/>setupManagersPcap<br/>setupManagersKeylog\"]\n    \n    BYTECODE[\"字节码选择<br/>geteBPFName<br/>assets.Asset\"]\n    \n    INIT_MGR[\"管理器初始化<br/>bpfManager.InitWithOptions\"]\n    \n    START_MGR[\"管理器启动<br/>bpfManager.Start\"]\n    \n    ATTACH[\"探针挂载<br/>Uprobes<br/>TC 钩子<br/>Kprobes\"]\n    \n    DECODE[\"初始化解码映射<br/>eventFuncMaps<br/>eventMaps\"]\n    \n    RUN[\"Module.Run<br/>启动事件读取器\"]\n    \n    INIT --> CHILD_INIT\n    CHILD_INIT --> VERSION\n    VERSION --> SETUP\n    SETUP --> BYTECODE\n    BYTECODE --> INIT_MGR\n    INIT_MGR --> START_MGR\n    START_MGR --> ATTACH\n    ATTACH --> DECODE\n    DECODE --> RUN\n```\n\n来源: [user/module/imodule.go:110-171](), [user/module/probe_openssl.go:109-176](), [user/module/probe_openssl.go:280-350]()\n\n### 管理器初始化\n\n`ebpfmanager.Manager` 结构集中管理 eBPF 程序和映射：\n\n**管理器配置**\n\n```go\ntype MOpenSSLProbe struct {\n    bpfManager        *manager.Manager\n    bpfManagerOptions manager.Options\n    eventFuncMaps     map[*ebpf.Map]event.IEventStruct\n    eventMaps         []*ebpf.Map\n}\n```\n\n管理器选项包括：\n\n- **ConstantEditors**：将用户空间值传递给 eBPF（PID/UID 过滤器）\n- **Probes**：定义 uprobe/kprobe 挂载点\n- **Maps**：指定 eBPF 映射配置\n- **ActivatedProbes**：控制启用哪些探针\n\n来源: [user/module/probe_openssl.go:83-106](), [user/module/probe_openssl.go:361-387]()\n\n### 常量编辑器\n\n常量编辑器允许将配置值从用户空间传递到 eBPF 程序：\n\n```go\nfunc (m *MOpenSSLProbe) constantEditor() []manager.ConstantEditor {\n    return []manager.ConstantEditor{\n        {\n            Name:  \"target_pid\",\n            Value: uint64(m.conf.GetPid()),\n        },\n        {\n            Name:  \"target_uid\",\n            Value: uint64(m.conf.GetUid()),\n        },\n    }\n}\n```\n\neBPF 程序检查这些常量进行过滤：\n\n```c\nconst volatile u64 target_pid = 0;\nconst volatile u64 target_uid = 0;\n\n// 在探针函数中：\nif (target_pid != 0 && current_pid != target_pid) {\n    return 0;  // 过滤掉\n}\n```\n\n来源: [user/module/probe_openssl.go:361-387]()\n\n### 字节码加载\n\n字节码选择算法考虑多个因素：\n\n```go\nfunc (m *Module) geteBPFName(filename string) string {\n    var newFilename = filename\n    \n    // 选择 CO-RE vs 非 CO-RE\n    switch m.conf.GetByteCodeFileMode() {\n    case config.ByteCodeFileCore:\n        newFilename = strings.Replace(newFilename, \".o\", \"_core.o\", 1)\n    case config.ByteCodeFileNonCore:\n        newFilename = strings.Replace(newFilename, \".o\", \"_noncore.o\", 1)\n    default:\n        if m.isCoreUsed {\n            newFilename = strings.Replace(newFilename, \".o\", \"_core.o\", 1)\n        } else {\n            newFilename = strings.Replace(newFilename, \".o\", \"_noncore.o\", 1)\n        }\n    }\n    \n    // 内核版本后缀\n    if m.isKernelLess5_2 {\n        newFilename = strings.Replace(newFilename, \".o\", \"_less52.o\", 1)\n    }\n    \n    return newFilename\n}\n```\n\n这会生成如下文件名：\n- `openssl_3_2_0_kern_core.o`（CO-RE，内核 >= 5.2）\n- `openssl_3_2_0_kern_noncore.o`（非 CO-RE，内核 >= 5.2）\n- `openssl_3_2_0_kern_core_less52.o`（CO-RE，内核 < 5.2）\n- `openssl_3_2_0_kern_noncore_less52.o`（非 CO-RE，内核 < 5.2）\n\n来源: [user/module/imodule.go:191-214](), [user/module/probe_openssl.go:311-312]()\n\n### 管理器启动\n\n`bpfManager.Start()` 调用执行：\n\n1. 使用 `bpf()` 系统调用将 eBPF 程序加载到内核\n2. 针对内核的 eBPF 验证器验证程序字节码\n3. 将探针挂载到目标函数/跟踪点\n4. 创建和配置 eBPF 映射\n5. 如果指定，启用基于 cgroup 的过滤\n\n如果验证失败，错误包含用于调试的验证器日志。\n\n来源: [user/module/probe_openssl.go:328-331]()\n\n## eBPF 映射通信\n\neBPF 映射是内核到用户空间数据传输的主要机制。eCapture 使用两种映射类型来处理事件：\n\n**事件映射架构**\n\n```mermaid\ngraph TB\n    subgraph \"内核空间 - eBPF 程序\"\n        UPROBE[\"Uprobe 处理程序<br/>probe_entry/probe_ret\"]\n        TC[\"TC 分类器<br/>capture_packets\"]\n        EVENT[\"事件结构<br/>ssl_data_event_t<br/>tc_skb_event_t\"]\n    end\n    \n    subgraph \"eBPF 映射\"\n        PERF[\"Perf 事件数组<br/>BPF_MAP_TYPE_PERF_EVENT_ARRAY<br/>每 CPU 缓冲区\"]\n        RING[\"环形缓冲区<br/>BPF_MAP_TYPE_RINGBUF<br/>共享内存\"]\n    end\n    \n    subgraph \"用户空间 - 事件读取器\"\n        PERF_RD[\"perfEventReader<br/>perf.NewReader\"]\n        RING_RD[\"ringbufEventReader<br/>ringbuf.NewReader\"]\n        DECODE[\"Module.Decode<br/>IEventStruct\"]\n        DISPATCH[\"Module.Dispatcher<br/>事件路由\"]\n    end\n    \n    UPROBE --> EVENT\n    TC --> EVENT\n    EVENT -->|\"bpf_perf_event_output\"| PERF\n    EVENT -->|\"bpf_ringbuf_submit\"| RING\n    \n    PERF --> PERF_RD\n    RING --> RING_RD\n    \n    PERF_RD --> DECODE\n    RING_RD --> DECODE\n    DECODE --> DISPATCH\n```\n\n来源: [user/module/imodule.go:285-306](), [user/module/imodule.go:308-391]()\n\n### Perf 事件数组\n\nPerf 事件数组为高吞吐量事件传递提供每 CPU 环形缓冲区：\n\n**Perf 事件读取器配置**\n\n| 参数 | 配置 | 位置 |\n|-----------|---------------|----------|\n| 映射大小 | `conf.GetPerCpuMapSize()` | [user/module/imodule.go:309]() |\n| 默认大小 | 每 CPU 1024 * PAGE_SIZE | [cli/cmd/root.go:143]() |\n| 读取器类型 | `perf.NewReader(em, size)` | [user/module/imodule.go:310]() |\n\n读取器循环：\n\n```go\nfunc (m *Module) perfEventReader(errChan chan error, em *ebpf.Map) {\n    rd, err := perf.NewReader(em, m.conf.GetPerCpuMapSize())\n    // ...\n    go func() {\n        for {\n            select {\n            case <-m.ctx.Done():\n                return\n            default:\n            }\n            \n            record, err := rd.Read()\n            if record.LostSamples != 0 {\n                m.logger.Warn().Uint64(\"lostSamples\", record.LostSamples)\n                continue\n            }\n            \n            evt, err := m.child.Decode(em, record.RawSample)\n            m.Dispatcher(evt)\n        }\n    }()\n}\n```\n\n来源: [user/module/imodule.go:308-351]()\n\n### 环形缓冲区\n\n环形缓冲区（内核 >= 5.8）提供具有更好内存效率的共享内存区域：\n\n```go\nfunc (m *Module) ringbufEventReader(errChan chan error, em *ebpf.Map) {\n    rd, err := ringbuf.NewReader(em)\n    // ...\n    go func() {\n        for {\n            select {\n            case <-m.ctx.Done():\n                return\n            default:\n            }\n            \n            record, err := rd.Read()\n            e, err := m.child.Decode(em, record.RawSample)\n            m.Dispatcher(e)\n        }\n    }()\n}\n```\n\n环形缓冲区的优势：\n- 更好的内存效率（单个共享缓冲区 vs 每 CPU）\n- 可变大小事件的开销更低\n- 保证单个缓冲区内的顺序\n\n来源: [user/module/imodule.go:353-391]()\n\n### 事件解码\n\n每个模块为其映射注册解码函数：\n\n```go\ntype MOpenSSLProbe struct {\n    eventFuncMaps map[*ebpf.Map]event.IEventStruct\n    eventMaps     []*ebpf.Map\n}\n\nfunc (m *MOpenSSLProbe) DecodeFun(p *ebpf.Map) (event.IEventStruct, bool) {\n    fun, found := m.eventFuncMaps[em]\n    return fun, found\n}\n```\n\n解码过程：\n1. 通过映射指针查找解码器\n2. 克隆事件结构模板\n3. 调用 `Decode([]byte)` 解组二进制数据\n4. 返回类型化的事件结构\n\n来源: [user/module/probe_openssl.go:389-396](), [user/module/imodule.go:393-406]()\n\n### 用于状态的哈希映射\n\n哈希映射存储 eBPF 程序查询或更新的状态：\n\n**常见哈希映射用途**\n\n| 映射用途 | 键 | 值 | 使用 |\n|-------------|-----|-------|-------|\n| 连接跟踪 | `(pid, fd)` | `(tuple, sock)` | 将 FD 映射到四元组 |\n| 套接字查找 | `sock` | `(pid, fd)` | 反向映射 |\n| PID 过滤 | `pid` | `1` | 进程白名单 |\n| 主密钥去重 | `client_random` | `1` | 防止重复 |\n\nOpenSSL 模块的示例：\n\n```go\n// 与 eBPF 映射同步的用户空间状态\ntype MOpenSSLProbe struct {\n    pidConns   map[uint32]map[uint32]ConnInfo  // pid -> (fd -> ConnInfo)\n    sock2pidFd map[uint64][2]uint32            // sock -> (pid, fd)\n}\n```\n\n来源: [user/module/probe_openssl.go:90-94](), [user/module/probe_openssl.go:398-480]()\n\n## 内核兼容性策略\n\neCapture 的兼容性矩阵跨越多个维度：\n\n**兼容性矩阵**\n\n| 维度 | 选项 | 检测方法 |\n|-----------|---------|------------------|\n| 内核版本 | < 5.2, >= 5.2 | `kernel.HostVersion()` |\n| BTF 支持 | 启用、禁用 | `ebpfenv.IsEnableBTF()` |\n| 架构 | x86_64, aarch64 | 构建时 `GOARCH` |\n| SSL 库 | OpenSSL 1.0.x-3.5.x, BoringSSL | ELF 解析 |\n\n### 内核版本检测\n\n```go\nkv, err := kernel.HostVersion()\nif kv < kernel.VersionCode(5, 2, 0) {\n    m.isKernelLess5_2 = true\n    m.logger.Warn().Str(\"kernel\", kv.String()).\n        Msg(\"Kernel version is less than 5.2, Process filtering parameters do not take effect\")\n}\n```\n\n内核 < 5.2 限制：\n- eBPF 中没有全局变量（必须使用映射）\n- 没有有界循环（必须展开）\n- 辅助函数有限\n- PID/UID 过滤效果较差\n\n来源: [user/module/imodule.go:140-149]()\n\n### 构建时架构处理\n\n构建系统生成架构特定的字节码：\n\n```makefile\nTARGET_ARCH = $(if $(filter $(CROSS_ARCH),arm64),arm64,x86_64)\nLINUX_ARCH  = $(if $(filter $(CROSS_ARCH),arm64),arm64,x86)\nGOARCH      = $(if $(filter $(CROSS_ARCH),arm64),arm64,amd64)\n```\n\n架构特定注意事项：\n- 不同的指令集（x86 vs ARM）\n- 不同的结构体填充和对齐\n- 架构特定的内核头文件\n\n来源: [variables.mk（在 Makefile 中引用）](), [.github/workflows/go-c-cpp.yml:31](), [.github/workflows/release.yml:45]()\n\n### 容器与 BTF 检测\n\n容器化环境的特殊处理：\n\n```go\nisContainer, err := ebpfenv.IsContainer()\nif isContainer {\n    m.logger.Warn().Msg(\"Your environment is like a container. \" +\n        \"We won't be able to detect the BTF configuration.\")\n}\n```\n\n容器可能没有：\n- `/sys/kernel/btf/vmlinux` 文件\n- 访问宿主机内核头文件\n- 正确的 `/proc/kallsyms` 访问权限\n\n`-b` 标志允许手动指定 BTF 模式以覆盖检测。\n\n来源: [user/module/imodule.go:174-189](), [cli/cmd/root.go:141]()\n\n## 交叉编译支持\n\n构建系统支持双向交叉编译（x86_64 ↔ aarch64）：\n\n**交叉编译架构**\n\n```mermaid\ngraph TB\n    subgraph \"构建配置\"\n        CROSS_VAR[\"CROSS_ARCH=arm64<br/>或 amd64\"]\n        MAKE_ENV[\"make env<br/>检测交叉编译\"]\n    end\n    \n    subgraph \"工具链选择\"\n        GCC_SELECT[\"选择交叉 GCC<br/>aarch64-linux-gnu-gcc<br/>x86_64-linux-gnu-gcc\"]\n        CLANG[\"LLVM/Clang<br/>-target bpfel/bpfeb\"]\n    end\n    \n    subgraph \"内核头文件\"\n        KERN_PREP[\"内核准备<br/>make ARCH=arm64 prepare<br/>make ARCH=x86 prepare\"]\n        HEADERS[\"架构头文件<br/>arch/arm64/include<br/>arch/x86/include\"]\n    end\n    \n    subgraph \"构建产物\"\n        EBPF[\"eBPF 字节码<br/>架构无关\"]\n        BINARY[\"Go 二进制文件<br/>架构特定\"]\n    end\n    \n    CROSS_VAR --> MAKE_ENV\n    MAKE_ENV --> GCC_SELECT\n    MAKE_ENV --> CLANG\n    MAKE_ENV --> KERN_PREP\n    \n    KERN_PREP --> HEADERS\n    GCC_SELECT --> BINARY\n    CLANG --> EBPF\n    HEADERS --> EBPF\n```\n\n来源: [.github/workflows/go-c-cpp.yml:56-65](), [.github/workflows/release.yml:93-97](), [Makefile:92-93]()\n\n### 交叉编译工作流程\n\n在 x86_64 上为 ARM64 构建：\n\n```bash\n# 准备 ARM64 内核头文件\ncd /usr/src/linux-source-X.Y.Z\nmake ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- prepare\n\n# 构建 eCapture\nCROSS_ARCH=arm64 make env\nCROSS_ARCH=arm64 make\n```\n\n构建系统：\n1. 检测 `CROSS_ARCH` 环境变量\n2. 选择适当的交叉编译器和 libc\n3. 为目标架构配置 libpcap\n4. 编译 eBPF 程序（架构中立）\n5. 链接 Go 二进制文件与交叉编译的 libpcap\n\n来源: [.github/workflows/go-c-cpp.yml:16-33](), [Makefile:98-104](), [builder/init_env.sh:43-61]()\n\n### Android 支持\n\nAndroid 构建使用 BoringSSL 特定的字节码，并需要非 CO-RE 模式：\n\n```bash\nANDROID=1 CROSS_ARCH=arm64 make nocore\n```\n\nAndroid 特定注意事项：\n- BoringSSL 而非 OpenSSL\n- 没有 BTF 支持（SELinux 限制）\n- 内核头文件有限\n- 版本特定的 BoringSSL 偏移量（A12-A16）\n\n来源: [.github/workflows/go-c-cpp.yml:61-65](), [user/module/probe_openssl.go:247-262]()\n\n## 错误处理与验证\n\neBPF 程序在加载前经过严格验证。常见失败模式：\n\n**验证错误**\n\n| 错误类型 | 原因 | 解决方案 |\n|------------|-------|------------|\n| 无效内存访问 | 越界读/写 | 修复边界检查 |\n| 无界循环 | 没有保证终止的循环 | 展开或限制迭代 |\n| 无效辅助函数调用 | 上下文中不允许的辅助函数 | 使用替代辅助函数 |\n| 寄存器溢出/填充 | 变量太多 | 减少局部变量 |\n| BTF 不匹配 | 结构体布局改变 | 更新 BTF 信息或偏移量 |\n\n模块记录详细的验证器错误：\n\n```go\nif err = m.bpfManager.InitWithOptions(bytes.NewReader(byteBuf), m.bpfManagerOptions); err != nil {\n    var ve *ebpf.VerifierError\n    if errors.As(err, &ve) {\n        m.logger.Error().Err(ve).Msg(\"couldn't verify bpf prog\")\n    }\n    return fmt.Errorf(\"couldn't init manager %w\", err)\n}\n```\n\n来源: [user/module/probe_openssl.go:320-326]()\n\n## 总结\n\neBPF 引擎通过以下方式为 eCapture 的捕获能力提供强大的基础：\n\n1. **多模式编译**：CO-RE 和非 CO-RE 字节码以实现广泛的内核兼容性\n2. **自动检测**：BTF 可用性、内核版本和架构检测\n3. **灵活挂载**：Uprobe、TC 和 kprobe 程序类型用于多样化的监控需求\n4. **高效通信**：Perf 事件数组和环形缓冲区用于高吞吐量数据传输\n5. **跨平台支持**：x86_64、aarch64、Linux 和 Android 构建\n\n引擎通过 `IModule` 接口从更高级别的模块中抽象出 eBPF 的复杂性，使开发人员能够专注于捕获逻辑而非底层 eBPF 细节。\n\n来源: [user/module/imodule.go:47-75](), [user/module/probe_openssl.go:83-106](), [Makefile:1-269](), [user/config/iconfig.go:24-70]()"
          },
          {
            "page_plan": {
              "id": "2.2",
              "title": "事件处理流程"
            },
            "content": "# 事件处理流程\n\n## 目的与范围\n\n事件处理流程将来自内核空间的原始 eBPF 事件转换为格式化的、协议感知的输出。该流程位于 eBPF 数据收集层（参见 [2.1 eBPF 引擎](#2.1)）和输出系统（参见 [4 输出格式](#4)）之间，负责：\n\n- **事件路由**：通过 `EventProcessor.dispatch()` 将事件分发到每个连接的 worker\n- **有效负载聚合**：在 `eventWorker` 实例中累积数据块\n- **协议检测**：通过 `IParser` 接口识别 HTTP/1.1、HTTP/2 或原始数据\n- **生命周期管理**：支持基于超时和基于 socket 生命周期的 worker 清理\n- **输出格式化**：将二进制有效负载转换为文本、十六进制或 Protobuf 格式\n\n事件流经路径：eBPF maps → 模块解码器 → `EventProcessor` → `eventWorker` 实例 → `IParser` 实现 → 输出写入器。\n\n---\n\n## 架构概览\n\n事件处理流程由三个主要层次组成：事件接收、基于 worker 的聚合和协议感知解析。\n\n**事件处理流程架构**\n\n```mermaid\ngraph TB\n    subgraph \"eBPF Maps（内核空间）\"\n        PerfArray[\"Perf Event Arrays<br/>或 Ring Buffers\"]\n    end\n    \n    subgraph \"模块层（用户空间）\"\n        ModuleDecode[\"Module.Decode()<br/>SSLDataEvent.Decode()<br/>ConnDataEvent.Decode()\"]\n        ModuleWrite[\"模块调用<br/>processor.Write(IEventStruct)\"]\n    end\n    \n    subgraph \"EventProcessor\"\n        Incoming[\"incoming chan event.IEventStruct<br/>容量：1024\"]\n        Serve[\"Serve() 循环<br/>在 4 个通道上 select\"]\n        Dispatch[\"dispatch(e event.IEventStruct)<br/>UUID 路由\"]\n        WorkerQueue[\"workerQueue map[string]IWorker<br/>UUID → worker 映射\"]\n        OutComing[\"outComing chan []byte<br/>容量：1024\"]\n        DestroyConn[\"destroyConn chan uint64<br/>socket 销毁信号\"]\n    end\n    \n    subgraph \"eventWorker 协程\"\n        Worker1[\"eventWorker #1<br/>UUID: 1234_1234_curl_3_0\"]\n        Worker2[\"eventWorker #2<br/>UUID: sock:5678_5678_nginx_5_0_..._140234567890\"]\n        WorkerIncoming[\"incoming chan event.IEventStruct<br/>容量：1024\"]\n        PayloadBuf[\"payload *bytes.Buffer<br/>累积的数据\"]\n        Ticker[\"ticker *time.Ticker<br/>100ms，tickerCount 0-10\"]\n        WorkerRun[\"Run() 循环<br/>3 个 select case\"]\n    end\n    \n    subgraph \"解析器注册表\"\n        NewParser[\"NewParser(payload []byte)<br/>协议检测\"]\n        HTTPRequest[\"HTTPRequest<br/>http.ReadRequest()\"]\n        HTTPResponse[\"HTTPResponse<br/>http.ReadResponse()\"]\n        HTTP2Request[\"HTTP2Request<br/>HPACK 解码\"]\n        HTTP2Response[\"HTTP2Response<br/>HPACK 解码\"]\n        DefaultParser[\"DefaultParser<br/>hex.Dump() 回退\"]\n    end\n    \n    subgraph \"输出写入器\"\n        Logger[\"io.Writer logger<br/>文件或 stdout\"]\n        CollectorWriter[\"CollectorWriter<br/>zerolog.Logger\"]\n    end\n    \n    PerfArray -->|\"读取事件\"| ModuleDecode\n    ModuleDecode --> ModuleWrite\n    ModuleWrite --> Incoming\n    \n    Incoming --> Serve\n    Serve --> Dispatch\n    Dispatch -->|\"getWorkerByUUID()<br/>或 NewEventWorker()\"| WorkerQueue\n    \n    WorkerQueue --> Worker1\n    WorkerQueue --> Worker2\n    \n    Worker1 --> WorkerIncoming\n    WorkerIncoming --> PayloadBuf\n    Ticker -.\"|MaxTickerCount<br/>触发 Display()\"| PayloadBuf\n    \n    PayloadBuf --> NewParser\n    NewParser -->|\"detect() 成功\"| HTTPRequest\n    NewParser -->|\"detect() 成功\"| HTTPResponse\n    NewParser -->|\"detect() 成功\"| HTTP2Request\n    NewParser -->|\"detect() 成功\"| HTTP2Response\n    NewParser -->|\"无匹配\"| DefaultParser\n    \n    HTTPRequest --> OutComing\n    HTTPResponse --> OutComing\n    HTTP2Request --> OutComing\n    HTTP2Response --> OutComing\n    DefaultParser --> OutComing\n    \n    OutComing --> Serve\n    Serve --> Logger\n    Logger -.\"|类型断言\"| CollectorWriter\n    \n    DestroyConn --> Serve\n    Serve -.\"|destroyWorkers()\"| WorkerQueue\n```\n\n**来源：** [pkg/event_processor/processor.go:30-63](), [pkg/event_processor/processor.go:66-89](), [pkg/event_processor/iworker.go:70-89](), [pkg/event_processor/iworker.go:262-306](), [pkg/event_processor/iparser.go:85-115]()\n\n---\n\n## 事件流\n\n事件通过不同的阶段遍历流程：摄入、路由、聚合、解析和输出。\n\n**事件在流程中的流动**\n\n```mermaid\nsequenceDiagram\n    participant eBPF as eBPF Perf/Ring Buffer\n    participant Module as 模块读取器<br/>(MOpenSSLProbe)\n    participant EP as EventProcessor\n    participant WQ as workerQueue<br/>map[string]IWorker\n    participant EW as eventWorker\n    participant Parser as IParser<br/>(HTTPRequest/etc)\n    participant Logger as io.Writer\n    \n    Note over eBPF: 由 uprobe/kprobe/TC<br/>程序生成的事件\n    \n    eBPF->>Module: 从 perf/ring buffer 读取\n    Module->>Module: event.Decode(payload)\n    Module->>EP: processor.Write(IEventStruct)\n    EP->>EP: incoming <- event (chan)\n    \n    Note over EP: Serve() 循环 select\n    EP->>EP: case event := <-incoming\n    EP->>EP: dispatch(event)\n    EP->>EP: uuid := event.GetUUID()\n    EP->>WQ: found, worker := getWorkerByUUID(uuid)\n    \n    alt Worker 存在\n        WQ-->>EP: found=true, worker\n        EP->>WQ: worker.Get() (引用计数)\n    else Worker 不存在\n        EP->>EW: NewEventWorker(uuid, ep)\n        EW->>EW: init(uuid, processor)\n        EW->>EW: go Run() (新协程)\n        EP->>WQ: addWorkerByUUID(worker)\n        WQ-->>EP: worker\n    end\n    \n    EP->>EW: worker.Write(event)\n    EP->>WQ: worker.Put() (释放引用)\n    EW->>EW: incoming <- event (chan)\n    \n    Note over EW: Run() 循环 select\n    EW->>EW: case e := <-incoming\n    EW->>EW: writeEvent(e)\n    EW->>EW: payload.Write(e.Payload())\n    EW->>EW: tickerCount = 0\n    \n    Note over EW: 1 秒内无新事件<br/>(10 个 tick × 100ms)\n    EW->>EW: case <-ticker.C\n    EW->>EW: tickerCount++\n    EW->>EW: if tickerCount > MaxTickerCount\n    EW->>EW: Display()\n    EW->>EW: parserEvents()\n    \n    alt 解析器未初始化 (LifeCycleStateSock)\n        EW->>Parser: NewParser(payload.Bytes())\n        Parser->>Parser: 循环遍历解析器注册表\n        Parser->>Parser: parser.detect(payload)\n        Parser-->>EW: 返回 HTTPRequest 或 Default\n        EW->>EW: ew.parser = newParser\n    end\n    \n    EW->>Parser: parser.Write(payload.Bytes())\n    Parser->>Parser: 在内部缓冲区累积\n    EW->>Parser: parser.Display()\n    Parser->>Parser: 格式化输出 (DumpRequest/DumpResponse)\n    Parser-->>EW: []byte 格式化后\n    \n    alt logger 是 CollectorWriter\n        EW->>EW: 使用元数据格式化 (PID, Comm, Tuple)\n    else logger 是其他 io.Writer\n        EW->>EW: 编码为 protobuf LogEntry\n    end\n    \n    EW->>EP: outComing <- []byte (chan)\n    \n    Note over EP: Serve() 循环 select\n    EP->>EP: case s := <-outComing\n    EP->>Logger: logger.Write(s)\n```\n\n**来源：** [pkg/event_processor/processor.go:65-109](), [pkg/event_processor/iworker.go:91-136](), [pkg/event_processor/iworker.go:154-162](), [pkg/event_processor/iworker.go:262-306](), [pkg/event_processor/iworker.go:175-228](), [pkg/event_processor/iparser.go:85-115]()\n\n---\n\n## EventProcessor：中央调度器\n\n`EventProcessor` 管理全局事件路由系统并维护所有活动 worker 的生命周期。\n\n### 结构和通道\n\n| 字段 | 类型 | 目的 |\n|-------|------|---------|\n| `incoming` | `chan event.IEventStruct` | 接收来自模块的事件（容量：1024） |\n| `outComing` | `chan []byte` | 将格式化的输出发送到 logger（容量：1024） |\n| `destroyConn` | `chan uint64` | 通过 socket 地址信号连接销毁 |\n| `workerQueue` | `map[string]IWorker` | 将 UUID 映射到活动 worker（容量：1024） |\n| `closeChan` | `chan bool` | 向 `Serve()` 循环发送关闭信号 |\n| `errChan` | `chan error` | 报告调度错误（容量：16） |\n| `logger` | `io.Writer` | 输出目标（控制台或文件） |\n\n**来源：** [pkg/event_processor/processor.go:30-50]()\n\n### 核心方法\n\n**`Serve()` 方法 - 主事件循环**\n\n`Serve()` 方法持续运行，使用 `select` 语句处理四种通道类型：\n\n```mermaid\nflowchart TD\n    Start[\"EventProcessor.Serve()\"]\n    Select[\"在 4 个通道上 select\"]\n    \n    Start --> Loop[\"for { }\"]\n    Loop --> Select\n    \n    Select -->|\"case eventStruct := <-incoming\"| DispatchCall[\"err = ep.dispatch(eventStruct)\"]\n    Select -->|\"case destroyUUID := <-destroyConn\"| DestroyCall[\"ep.destroyWorkers(destroyUUID)\"]\n    Select -->|\"case s := <-outComing\"| WriteCall[\"_, _ = ep.GetLogger().Write(s)\"]\n    Select -->|\"case _ = <-closeChan\"| CloseCall[\"ep.clearAllWorkers()<br/>return nil\"]\n    \n    DispatchCall --> ErrorCheck{\"err != nil?\"}\n    ErrorCheck -->|是| ErrorChan[\"select errChan <- err<br/>或 default（丢弃）\"]\n    ErrorCheck -->|否| Loop\n    ErrorChan --> Loop\n    \n    DestroyCall --> Loop\n    WriteCall --> Loop\n    CloseCall --> Return[\"返回给调用者\"]\n    \n    subgraph \"dispatch(eventStruct) 详细信息\"\n        D1[\"uuid := e.GetUUID()\"]\n        D2[\"found, eWorker := ep.getWorkerByUUID(uuid)\"]\n        D3{\"found?\"}\n        D4[\"eWorker = NewEventWorker(uuid, ep)\"]\n        D5[\"ep.addWorkerByUUID(eWorker)\"]\n        D6[\"err := eWorker.Write(e)\"]\n        D7[\"eWorker.Put()\"]\n        \n        D1 --> D2\n        D2 --> D3\n        D3 -->|否| D4\n        D4 --> D5\n        D5 --> D6\n        D3 -->|是| D6\n        D6 --> D7\n    end\n    \n    subgraph \"destroyWorkers(destroyUUID) 详细信息\"\n        Dst1[\"ep.Lock()\"]\n        Dst2[\"for _, ew := range workerQueue\"]\n        Dst3{\"destroyUUID == ew.GetDestroyUUID()?\"}\n        Dst4[\"ew.CloseEventWorker()<br/>break\"]\n        Dst5[\"ep.Unlock()\"]\n        \n        Dst1 --> Dst2\n        Dst2 --> Dst3\n        Dst3 -->|是| Dst4\n        Dst3 -->|否| Dst2\n        Dst4 --> Dst5\n    end\n```\n\n**关键行为：**\n- **非阻塞错误报告**：如果 `errChan` 已满，通过 `default` case 丢弃错误\n- **socket 销毁时的 worker 清理**：`destroyWorkers()` 通过 `DestroyUUID`（socket 地址）匹配\n- **优雅关闭**：`closeChan` 信号清除所有 worker 并从 `Serve()` 返回\n\n**来源：** [pkg/event_processor/processor.go:66-89](), [pkg/event_processor/processor.go:91-109](), [pkg/event_processor/processor.go:115-128]()\n\n**`dispatch(e event.IEventStruct)` - 将事件路由到合适的 worker：**\n\n1. 通过 `e.GetUUID()` 从事件中提取 UUID\n2. 在 `workerQueue` 中查找现有 worker\n3. 如果未找到，通过 `NewEventWorker(uuid, ep)` 创建新的 `eventWorker`\n4. 调用 `worker.Write(e)` 将事件入队\n5. 通过 `worker.Put()` 释放 worker 引用\n\n**来源：** [pkg/event_processor/processor.go:91-109]()\n\n**Worker 生命周期方法：**\n\n- `getWorkerByUUID(uuid string)` - 带引用计数的线程安全查找\n- `addWorkerByUUID(worker IWorker)` - 线程安全插入\n- `delWorkerByUUID(worker IWorker)` - 由 worker 调用以自我销毁\n- `destroyWorkers(destroyUUID uint64)` - 通知基于 socket 的 worker 关闭\n\n**来源：** [pkg/event_processor/processor.go:130-155]()\n\n---\n\n## eventWorker：每连接聚合器\n\n每个 `eventWorker` 聚合单个逻辑连接或数据流的事件，由唯一的 UUID 标识。Worker 作为独立的协程运行，具有内部状态机。\n\n### UUID 格式和生命周期状态\n\nWorker 基于 UUID 格式支持两种生命周期模型：\n\n| 生命周期状态 | UUID 格式 | 示例 | 销毁触发器 |\n|----------------|-------------|---------|---------------------|\n| `LifeCycleStateDefault` | `{Pid}_{Tid}_{Comm}_{Fd}_{DataType}` | `1234_1234_curl_3_0` | 10 个 tick 超时（1 秒空闲） |\n| `LifeCycleStateSock` | `sock:{Pid}_{Tid}_{Comm}_{Fd}_{DataType}_{Tuple}_{Sock}` | `sock:1234_1234_curl_3_0_1.2.3.4:80-5.6.7.8:443_140234567890` | 通过 `CloseEventWorker()` 的外部信号 |\n\n**来源：** [pkg/event_processor/iworker.go:57-63](), [pkg/event_processor/iworker.go:100-123]()\n\n### 结构和状态\n\n```mermaid\ngraph TB\n    subgraph \"eventWorker 字段\"\n        UUID[\"UUID string<br/>连接标识符\"]\n        DestroyUUID[\"DestroyUUID uint64<br/>用于生命周期的 socket 地址\"]\n        State[\"ewLifeCycleState<br/>Default 或 Sock\"]\n        \n        Incoming[\"incoming chan<br/>IEventStruct<br/>容量：1024\"]\n        OutComing[\"outComing chan<br/>[]byte<br/>与 EventProcessor 共享\"]\n        \n        Payload[\"payload *bytes.Buffer<br/>累积的数据\"]\n        Parser[\"parser IParser<br/>协议处理器\"]\n        \n        Ticker[\"ticker *time.Ticker<br/>100ms 间隔\"]\n        TickerCount[\"tickerCount uint8<br/>0-10 范围\"]\n        \n        CloseChan[\"closeChan chan struct{}<br/>关闭信号\"]\n        Used[\"used atomic.Bool<br/>引用计数\"]\n    end\n    \n    UUID --> State\n    State -.决定.-> DestroyUUID\n    \n    Incoming --> Payload\n    Payload --> Parser\n    Parser --> OutComing\n    \n    Ticker --> TickerCount\n    TickerCount -.触发.-> Parser\n    \n    CloseChan -.外部信号.-> State\n```\n\n**来源：** [pkg/event_processor/iworker.go:70-89]()\n\n### Run 循环和生命周期\n\n`Run()` 方法实现 worker 的事件循环，具有三个 select case 和依赖生命周期的超时处理：\n\n```mermaid\nstateDiagram-v2\n    [*] --> Init: \"NewEventWorker(uuid, ep)<br/>go ew.Run()\"\n    \n    Init --> SelectLoop: \"tickerRestartFlag = false\"\n    \n    SelectLoop --> TickerCase: \"case <-ew.ticker.C\"\n    SelectLoop --> IncomingCase: \"case e := <-ew.incoming\"\n    SelectLoop --> CloseCase: \"case <-ew.closeChan\"\n    \n    TickerCase --> IncrementCount: \"ew.tickerCount++\"\n    IncrementCount --> CheckThreshold: \"tickerCount > MaxTickerCount (10)?\"\n    \n    CheckThreshold --> CheckLifecycle: \"是\"\n    CheckThreshold --> SelectLoop: \"否\"\n    \n    CheckLifecycle --> SocketLifecycle: \"ew.ewLifeCycleState == LifeCycleStateSock\"\n    CheckLifecycle --> DefaultLifecycle: \"ew.ewLifeCycleState == LifeCycleStateDefault\"\n    \n    SocketLifecycle --> DrainAndCloseSock: \"ew.drainAndClose()\"\n    DrainAndCloseSock --> ResetCount: \"ew.tickerCount = 0\"\n    ResetCount --> SetRestartFlag: \"tickerRestartFlag = true\"\n    SetRestartFlag --> SelectLoop: \"continue（继续运行）\"\n    \n    DefaultLifecycle --> DeleteWorker: \"ew.processor.delWorkerByUUID(ew)\"\n    DeleteWorker --> DrainAndCloseFinal: \"ew.drainAndClose()\"\n    DrainAndCloseFinal --> [*]: \"return（协程退出）\"\n    \n    IncomingCase --> CheckRestart: \"tickerRestartFlag?\"\n    CheckRestart --> RestartTicker: \"是：ew.ticker = time.NewTicker(100ms)\"\n    CheckRestart --> WriteEventCall: \"否\"\n    RestartTicker --> ClearFlag: \"tickerRestartFlag = false\"\n    ClearFlag --> WriteEventCall: \"ew.tickerCount = 0\"\n    WriteEventCall --> WriteEvent: \"ew.writeEvent(e)\"\n    WriteEvent --> SelectLoop\n    \n    CloseCase --> DeleteWorkerClose: \"ew.processor.delWorkerByUUID(ew)\"\n    DeleteWorkerClose --> DrainAndCloseFinal\n    \n    note right of SocketLifecycle\n        Socket 生命周期 worker（UUID 以 \"sock:\" 开头）\n        持续运行直到显式调用 CloseEventWorker()\n    end note\n    \n    note right of DefaultLifecycle\n        默认 worker（UUID：Pid_Tid_Comm_Fd）\n        在 1 秒空闲后自我销毁（10 × 100ms）\n    end note\n```\n\n**关键时间详情：**\n- **Ticker 间隔**：每个 tick `100ms` ([pkg/event_processor/iworker.go:126]())\n- **超时阈值**：`MaxTickerCount = 10` tick = 1 秒空闲 ([pkg/event_processor/iworker.go:52]())\n- **Ticker 重启**：Socket worker 在 `drainAndClose()` 后重新创建 ticker 以避免陈旧的 ticker 通道 ([pkg/event_processor/iworker.go:293-296]())\n\n**生命周期状态确定：**\n- UUID 格式在 `uuidParse()` 中解析 ([pkg/event_processor/iworker.go:100-123]())\n- 如果 UUID 以 `\"sock:\"` 开头并以有效的 socket 地址结尾：`LifeCycleStateSock`\n- 否则：`LifeCycleStateDefault`\n\n**来源：** [pkg/event_processor/iworker.go:262-306](), [pkg/event_processor/iworker.go:51-63](), [pkg/event_processor/iworker.go:100-123]()\n\n### 事件聚合和显示\n\n**`writeEvent(e event.IEventStruct)` - 累积有效负载数据：**\n\n1. 检查状态是否为 `ProcessStateInit`（防止处理过程中的写入）\n2. 如果 `truncateSize > 0` 且有效负载超过限制，应用截断\n3. 存储 `originEvent` 以获取元数据\n4. 将 `e.Payload()` 附加到内部 `bytes.Buffer`\n\n**来源：** [pkg/event_processor/iworker.go:230-245]()\n\n**`Display()` - 触发解析和输出：**\n\n1. 检查有效负载是否有数据（`payload.Len() > 0`）\n2. 调用 `parserEvents()` 处理累积的缓冲区\n3. 如果 `processor.isHex` 为 true，应用十六进制转储\n4. 使用元数据格式化输出（PID、Comm、Src/Dst IP:Port）\n5. 作为 `[]byte` 或 `Protobuf` 写入 `outComing` 通道\n6. 重置解析器、有效负载缓冲区和状态\n\n**来源：** [pkg/event_processor/iworker.go:175-228]()\n\n**`drainAndClose()` - 确保干净关闭：**\n\n循环直到 `incoming` 通道为空且没有外部例程持有引用（`IfUsed() == false`）。这可以防止在销毁 worker 时另一个例程试图向其写入时发生数据丢失。\n\n**来源：** [pkg/event_processor/iworker.go:308-337]()\n\n---\n\n## 协议检测和解析\n\n解析器子系统自动从原始有效负载字节识别协议并应用适当的格式化。\n\n### IParser 接口\n\n```mermaid\ngraph TB\n    subgraph \"IParser 方法\"\n        Init[\"Init()<br/>初始化缓冲区\"]\n        Detect[\"detect([]byte) error<br/>协议识别\"]\n        Write[\"Write([]byte) (int, error)<br/>累积数据\"]\n        IsDone[\"IsDone() bool<br/>检查完成\"]\n        Display[\"Display() []byte<br/>格式化输出\"]\n        Reset[\"Reset()<br/>准备重用\"]\n        ParserType[\"ParserType() ParserType<br/>获取解析器 ID\"]\n    end\n    \n    subgraph \"ParserType 枚举\"\n        PT0[\"ParserTypeNull = 0\"]\n        PT1[\"ParserTypeHttpRequest = 1\"]\n        PT2[\"ParserTypeHttp2Request = 2\"]\n        PT3[\"ParserTypeHttpResponse = 3\"]\n        PT4[\"ParserTypeHttp2Response = 4\"]\n        PT5[\"ParserTypeWebSocket = 5\"]\n    end\n    \n    Init -.序列 1.-> Detect\n    Detect -.序列 2.-> Write\n    Write -.序列 3.-> IsDone\n    IsDone -.序列 4.-> Display\n    Display -.序列 5.-> Reset\n```\n\n**来源：** [pkg/event_processor/iparser.go:49-60]()\n\n### 解析器注册和选择\n\n**全局解析器注册表**\n\n解析器在包初始化期间注册自己：\n\n```go\n// 在 pkg/event_processor/iparser.go 中\nvar parsers = make(map[string]IParser)\n\nfunc Register(p IParser) {\n    if p == nil {\n        panic(\"Register Parser is nil\")\n    }\n    name := p.Name()\n    if _, dup := parsers[name]; dup {\n        panic(fmt.Sprintf(\"Register called twice for Parser %s\", name))\n    }\n    parsers[name] = p\n}\n\n// 在每个解析器文件的 init() 中\nfunc init() {\n    hr := &HTTPRequest{}\n    hr.Init()\n    Register(hr)\n}\n```\n\n**来源：** [pkg/event_processor/iparser.go:62-73](), [pkg/event_processor/http_request.go:159-163](), [pkg/event_processor/http_response.go:177-181]()\n\n**`NewParser(payload []byte)` - 协议检测算法**\n\n```mermaid\nflowchart TD\n    Entry[\"NewParser(payload []byte)\"]\n    CheckEmpty{\"len(payload) > 0?\"}\n    \n    CheckEmpty -->|否| CreateDefault[\"newParser = new(DefaultParser)\"]\n    CreateDefault --> InitDefault[\"newParser.Init()\"]\n    InitDefault --> ReturnParser[\"return newParser\"]\n    \n    CheckEmpty -->|是| GetRegistry[\"parsers := GetAllModules()\"]\n    GetRegistry --> InitVars[\"var newParser IParser\"]\n    InitVars --> LoopStart[\"for _, parser := range parsers\"]\n    \n    LoopStart --> CallDetect[\"err := parser.detect(payload)\"]\n    CallDetect --> CheckError{\"err == nil?\"}\n    \n    CheckError -->|否| NextIter[\"continue 到下一个解析器\"]\n    NextIter --> LoopStart\n    \n    CheckError -->|是| SwitchType[\"switch parser.ParserType()\"]\n    \n    SwitchType -->|\"ParserTypeHttpRequest\"| NewHTTPReq[\"newParser = new(HTTPRequest)\"]\n    SwitchType -->|\"ParserTypeHttpResponse\"| NewHTTPResp[\"newParser = new(HTTPResponse)\"]\n    SwitchType -->|\"ParserTypeHttp2Request\"| NewHTTP2Req[\"newParser = new(HTTP2Request)\"]\n    SwitchType -->|\"ParserTypeHttp2Response\"| NewHTTP2Resp[\"newParser = new(HTTP2Response)\"]\n    SwitchType -->|\"default\"| NewDefault[\"newParser = new(DefaultParser)\"]\n    \n    NewHTTPReq --> Break[\"break（退出循环）\"]\n    NewHTTPResp --> Break\n    NewHTTP2Req --> Break\n    NewHTTP2Resp --> Break\n    NewDefault --> Break\n    \n    Break --> CheckNil{\"newParser == nil?\"}\n    NextIter -.\"|未找到匹配\"| CheckNil\n    \n    CheckNil -->|是| FallbackDefault[\"newParser = new(DefaultParser)\"]\n    CheckNil -->|否| InitNew[\"newParser.Init()\"]\n    FallbackDefault --> InitNew\n    \n    InitNew --> ReturnParser\n```\n\n**检测顺序**：解析器按 map 迭代顺序测试（非确定性）。每个解析器的 `detect()` 方法都使用有效负载调用。第一个成功检测的获胜。\n\n**示例检测方法：**\n- `HTTPRequest.detect()`：调用 `http.ReadRequest()` ([pkg/event_processor/http_request.go:83-92]())\n- `HTTPResponse.detect()`：调用 `http.ReadResponse()` ([pkg/event_processor/http_response.go:94-102]())\n- `DefaultParser.detect()`：始终返回 `nil`（匹配所有内容）([pkg/event_processor/iparser.go:136-138]())\n\n**来源：** [pkg/event_processor/iparser.go:85-115](), [pkg/event_processor/iparser.go:136-138]()\n\n### HTTP/1.1 请求解析器\n\n`HTTPRequest` 解析器利用 Go 的标准 `net/http` 包：\n\n**结构：**\n```go\ntype HTTPRequest struct {\n    request    *http.Request   // 解析的 HTTP 请求\n    packerType PacketType      // PacketTypeNull 或 PacketTypeGzip\n    isDone     bool            // 完成标志（目前未使用）\n    isInit     bool            // 第一次 Write() 调用后为 true\n    reader     *bytes.Buffer   // 原始字节的累加器\n    bufReader  *bufio.Reader   // reader 上的缓冲读取器\n}\n```\n\n**来源：** [pkg/event_processor/http_request.go:28-35]()\n\n**协议检测**\n\n`detect()` 方法尝试 HTTP 解析：\n\n```go\nfunc (hr *HTTPRequest) detect(payload []byte) error {\n    rd := bytes.NewReader(payload)\n    buf := bufio.NewReader(rd)\n    _, err := http.ReadRequest(buf)\n    if err != nil {\n        return err\n    }\n    return nil\n}\n```\n\n成功表示有效的 HTTP/1.1 请求格式。**来源：** [pkg/event_processor/http_request.go:83-92]()\n\n**处理生命周期**\n\n| 阶段 | 方法 | 操作 | 关键行 |\n|-------|--------|-----------|-----------|\n| 初始化 | `Init()` | 创建 `bytes.Buffer` 和 `bufio.Reader` | [pkg/event_processor/http_request.go:37-40]() |\n| 第一次写入 | `Write(b)` (isInit=false) | 写入缓冲区，调用 `http.ReadRequest()`，存储结果，设置 `isInit=true` | [pkg/event_processor/http_request.go:56-67]() |\n| 后续写入 | `Write(b)` (isInit=true) | 将额外的 body 数据附加到缓冲区 | [pkg/event_processor/http_request.go:71-78]() |\n| 输出 | `Display()` | 读取 body，如果存在则解压 gzip，调用 `httputil.DumpRequest(false)` | [pkg/event_processor/http_request.go:105-157]() |\n| 清理 | `Reset()` | 设置 `isDone=false`，`isInit=false`，重置缓冲区 | [pkg/event_processor/http_request.go:98-103]() |\n\n**Gzip 解压缩**\n\n如果存在 `Content-Encoding: gzip` 头：\n1. 通过 `io.ReadAll(hr.request.Body)` 读取原始 body\n2. 创建 `gzip.NewReader(bytes.NewReader(rawData))`\n3. 解压缩：`rawData, err = io.ReadAll(reader)`\n4. 设置 `hr.packerType = PacketTypeGzip`\n\n**来源：** [pkg/event_processor/http_request.go:123-142]()\n\n**HTTP/2.0 检测**\n\n如果 `hr.request.Proto == \"HTTP/2.0\"`，返回原始字节而不处理。HTTP/2 需要专门的帧处理。**来源：** [pkg/event_processor/http_request.go:106-108]()\n\n### HTTP/1.1 响应解析器\n\n类似于请求解析器，但使用 `http.ReadResponse()`：\n\n**关键差异：**\n- 处理分块响应（负的 `ContentLength`）\n- 当 body 不完整时记录截断的响应\n- 支持 HTTP/2.0 检测（返回原始字节而不处理）\n\n**来源：** [pkg/event_processor/http_response.go:28-37](), [pkg/event_processor/http_response.go:58-92](), [pkg/event_processor/http_response.go:115-175]()\n\n### HTTP/2 解析器\n\nHTTP/2 解析器已定义，但实现详细信息在未提供的单独文件中。它们处理：\n- HPACK 头压缩/解压缩\n- 二进制帧格式\n- 流多路复用\n\n**来源：** 在 [pkg/event_processor/iparser.go:96-99]() 中引用\n\n### DefaultParser\n\n未识别协议的回退解析器：\n\n- 在 `bytes.Buffer` 中累积所有字节\n- 在 `Display()` 上，检查第一个字节是否为可打印的 ASCII（32-126）\n- 如果非 ASCII，通过 `hex.Dump()` 输出十六进制转储\n- 如果是 ASCII，输出为字符串（通过 `CToGoString()` 进行 C 风格的 null 终止）\n\n**来源：** [pkg/event_processor/iparser.go:117-166]()\n\n---\n\n## 事件类型和结构\n\n所有事件都实现 `IEventStruct` 接口，从而在流程中实现多态处理。\n\n### IEventStruct 接口\n\n```mermaid\nclassDiagram\n    class IEventStruct {\n        <<interface>>\n        +Decode(payload []byte) error\n        +Payload() []byte\n        +PayloadLen() int\n        +String() string\n        +StringHex() string\n        +Clone() IEventStruct\n        +EventType() Type\n        +GetUUID() string\n        +Base() Base\n        +ToProtobufEvent() *pb.Event\n    }\n    \n    class Base {\n        +Timestamp int64\n        +UUID string\n        +SrcIP string\n        +SrcPort uint32\n        +DstIP string\n        +DstPort uint32\n        +PID int64\n        +PName string\n        +Type uint32\n    }\n    \n    class SSLDataEvent {\n        +DataType int64\n        +Timestamp uint64\n        +Pid uint32\n        +Tid uint32\n        +Data [16384]byte\n        +DataLen int32\n        +Comm [16]byte\n        +Fd uint32\n        +Version int32\n        +Tuple string\n        +Sock uint64\n    }\n    \n    class ConnDataEvent {\n        +Saddr [16]byte\n        +Daddr [16]byte\n        +Comm [16]byte\n        +Sock uint64\n        +Pid uint32\n        +Tid uint32\n        +Fd uint32\n        +Family uint16\n        +Sport uint16\n        +Dport uint16\n        +IsDestroy uint8\n        +Tuple string\n    }\n    \n    class MasterSecretEvent {\n        +Version int32\n        +ClientRandom [32]byte\n        +MasterKey [48]byte\n        +CipherId uint32\n        +EarlyTrafficSecret [64]byte\n        +HandshakeSecret [64]byte\n        +ClientAppTrafficSecret [64]byte\n        +ServerAppTrafficSecret [64]byte\n        +ExporterMasterSecret [64]byte\n    }\n    \n    class BashEvent {\n        +BashType uint32\n        +Pid uint32\n        +Uid uint32\n        +Line [256]uint8\n        +ReturnValue uint32\n        +Comm [16]byte\n    }\n    \n    class MysqldEvent {\n        +Pid uint64\n        +Timestamp uint64\n        +Query [256]uint8\n        +Alllen uint64\n        +Len uint64\n        +Comm [16]uint8\n        +Retval int8\n    }\n    \n    IEventStruct <|.. SSLDataEvent\n    IEventStruct <|.. ConnDataEvent\n    IEventStruct <|.. MasterSecretEvent\n    IEventStruct <|.. BashEvent\n    IEventStruct <|.. MysqldEvent\n    \n    SSLDataEvent --> Base\n    ConnDataEvent --> Base\n```\n\n**来源：** [user/event/ievent.go:26-52]()\n\n### 事件类型分类\n\n事件按其处理目标分类：\n\n```mermaid\ngraph TB\n    subgraph \"Type 枚举\"\n        T0[\"TypeOutput = 0<br/>直接到 logger\"]\n        T1[\"TypeModuleData = 1<br/>模块特定处理\"]\n        T2[\"TypeEventProcessor = 2<br/>协议解析\"]\n    end\n    \n    subgraph \"TypeOutput 事件\"\n        Bash[\"BashEvent<br/>Shell 命令\"]\n        Mysqld[\"MysqldEvent<br/>SQL 查询\"]\n        Postgres[\"PostgresEvent<br/>SQL 查询\"]\n    end\n    \n    subgraph \"TypeModuleData 事件\"\n        MasterSecret[\"MasterSecretEvent<br/>TLS 密钥\"]\n        TcSkb[\"TcSkbEvent<br/>网络数据包\"]\n        Conn[\"ConnDataEvent<br/>连接元数据\"]\n    end\n    \n    subgraph \"TypeEventProcessor 事件\"\n        SSL[\"SSLDataEvent<br/>TLS 明文\"]\n        Gnutls[\"GnutlsDataEvent<br/>GnuTLS 明文\"]\n        Nspr[\"NsprDataEvent<br/>NSS/NSPR 明文\"]\n    end\n    \n    T0 --> Bash\n    T0 --> Mysqld\n    T0 --> Postgres\n    \n    T1 --> MasterSecret\n    T1 --> TcSkb\n    T1 --> Conn\n    \n    T2 --> SSL\n    T2 --> Gnutls\n    T2 --> Nspr\n```\n\n**来源：** [user/event/ievent.go:26-37](), [user/event/event_openssl.go:77-92](), [user/event/event_bash.go:37-47](), [user/event/event_masterkey.go:37-55]()\n\n### SSLDataEvent 结构\n\nOpenSSL/BoringSSL 捕获的主要事件类型：\n\n**字段：**\n- **DataType**：0（ProbeEntry/接收）或 1（ProbeRet/发送）\n- **Timestamp**：解码为 Unix 纳秒的内核时间\n- **Pid/Tid/Comm**：进程标识\n- **Data**：有效负载缓冲区（最大 16384 字节）\n- **DataLen**：实际数据长度\n- **Fd**：文件描述符\n- **Version**：TLS 版本常量（0x0303 = TLS 1.2 等）\n- **Tuple**：网络 5 元组字符串（`srcip:port-dstip:port`）\n- **Sock**：Socket 指针地址（用于生命周期跟踪）\n\n**UUID 格式：**\n- 默认：`{Pid}_{Tid}_{Comm}_{Fd}_{DataType}`\n- Socket 生命周期：`sock:{Pid}_{Tid}_{Comm}_{Fd}_{DataType}_{Tuple}_{Sock}`\n\n**来源：** [user/event/event_openssl.go:77-92](), [user/event/event_openssl.go:138-141]()\n\n### ConnDataEvent 结构\n\n用于 socket 跟踪的连接生命周期事件：\n\n**目的：** 在创建或销毁 socket 时提供网络 5 元组信息，通过 socket 地址与 `SSLDataEvent` 进行关联。\n\n**字段：**\n- **Saddr/Daddr**：源/目标 IP（IPv6 为 16 字节）\n- **Sport/Dport**：源/目标端口\n- **Family**：`AF_INET`（2）或 `AF_INET6`（10）\n- **Sock**：Socket 指针（与 `SSLDataEvent.Sock` 匹配）\n- **IsDestroy**：如果连接正在销毁则为 1，如果创建则为 0\n\n**Tuple 生成：** 格式化为 `ip:port-ip:port`，IPv6 使用括号表示法。\n\n**来源：** [user/event/event_openssl.go:272-310]()\n\n---\n\n## 输出路由\n\n`eventWorker.Display()` 方法使用类型断言根据 logger 类型路由格式化的输出。\n\n### 输出决策流程\n\n```mermaid\nflowchart TD\n    DisplayCall[\"eventWorker.Display()\"]\n    CheckLen{\"payload.Len() <= 0?\"}\n    \n    DisplayCall --> CheckLen\n    CheckLen -->|是| Return[\"return nil<br/>（无输出）\"]\n    \n    CheckLen -->|否| ParseEvents[\"b := ew.parserEvents()\"]\n    ParseEvents --> CheckEmpty{\"len(b) <= 0?\"}\n    CheckEmpty -->|是| ResetState[\"重置 parser、payload、state<br/>return nil\"]\n    \n    CheckEmpty -->|否| CheckHex{\"ew.processor.isHex?\"}\n    CheckHex -->|是| HexDump[\"b = []byte(hex.Dump(b))\"]\n    CheckHex -->|否| TypeAssert[\"_, ok := ew.processor.logger.(event.CollectorWriter)\"]\n    HexDump --> TypeAssert\n    \n    TypeAssert --> Branch{\"ok == true?\"}\n    \n    Branch -->|是| FormatText[\"构建文本格式：<br/>eb := ew.originEvent.Base()<br/>eb.Type = parser.ParserType()<br/>eb.UUID = ew.uuidOutput\"]\n    FormatText --> FprintfCall[\"fmt.Fprintf(&buf,<br/>'PID:%d, Comm:%s, Src:%s:%d, Dest:%s:%d,\\\\n%s',<br/>eb.PID, eb.PName, eb.SrcIP, eb.SrcPort,<br/>eb.DstIP, eb.DstPort, b)\"]\n    FprintfCall --> WriteChanText[\"ew.writeToChan(buf.Bytes())\"]\n    \n    Branch -->|否| FormatProto[\"构建 protobuf：<br/>le := new(pb.LogEntry)<br/>le.LogType = LOG_TYPE_EVENT\"]\n    FormatProto --> ConvertEvent[\"ep := ew.originEvent.ToProtobufEvent()<br/>ep.Uuid = ew.uuidOutput<br/>ep.Type = parser.ParserType()<br/>ep.Payload = b<br/>ep.Length = len(b)\"]\n    ConvertEvent --> SetPayload[\"le.Payload = &pb.LogEntry_EventPayload{<br/>EventPayload: ep}\"]\n    SetPayload --> MarshalProto[\"encodedData, err := proto.Marshal(le)\"]\n    MarshalProto --> WriteChanProto[\"ew.writeToChan(encodedData)\"]\n    \n    WriteChanText --> DeferReset[\"defer: parser.Reset()<br/>payload.Reset()<br/>status = ProcessStateInit\"]\n    WriteChanProto --> DeferReset\n    ResetState --> Return\n    DeferReset --> Return\n```\n\n**类型断言逻辑：**\n\n```go\n_, ok := ew.processor.logger.(event.CollectorWriter)\nif ok {\n    // 文本模式：使用元数据格式化\n} else {\n    // Protobuf 模式：序列化为 pb.LogEntry\n}\n```\n\n**来源：** [pkg/event_processor/iworker.go:175-228](), [pkg/event_processor/iworker.go:198-212](), [pkg/event_processor/iworker.go:213-227]()\n\n**CollectorWriter 类型：**\n\n```go\ntype CollectorWriter struct {\n    logger *zerolog.Logger\n}\n\nfunc (e CollectorWriter) Write(p []byte) (n int, err error) {\n    return e.logger.Write(p)\n}\n```\n\n当配置了使用 `zerolog` 的结构化日志时使用。**来源：** [user/event/ievent.go:54-70]()\n\n### 输出格式示例\n\n**文本模式（CollectorWriter）：**\n```\nPID:1234, Comm:curl, Src:192.168.1.10:54321, Dest:93.184.216.34:443,\nGET / HTTP/1.1\nHost: example.com\nUser-Agent: curl/7.81.0\nAccept: */*\n```\n\n**Protobuf 模式：**\n```protobuf\nmessage LogEntry {\n  LogType log_type = 1;  // LOG_TYPE_EVENT\n  oneof payload {\n    Event event_payload = 2;\n  }\n}\n\nmessage Event {\n  int64 timestamp = 1;\n  string uuid = 2;\n  int64 pid = 3;\n  string pname = 4;\n  string src_ip = 5;\n  uint32 src_port = 6;\n  string dst_ip = 7;\n  uint32 dst_port = 8;\n  uint32 type = 9;\n  uint32 length = 10;\n  bytes payload = 11;\n}\n```\n\n**来源：** [pkg/event_processor/iworker.go:198-227](), [user/event/event_openssl.go:237-266]()\n\n---\n\n## 性能特征\n\n流程设计用于高吞吐量的事件处理和有界的内存使用。\n\n### 缓冲区容量和限制\n\n| 组件 | 缓冲区类型 | 容量 | 目的 |\n|-----------|-------------|----------|---------|\n| EventProcessor.incoming | 缓冲通道 | 1024 个事件 | 从模块接收事件 |\n| EventProcessor.outComing | 缓冲通道 | 1024 条消息 | 格式化输出到 logger |\n| EventProcessor.destroyConn | 缓冲通道 | 1024 个信号 | 连接销毁信号 |\n| EventProcessor.errChan | 缓冲通道 | 16 个错误 | 错误报告 |\n| eventWorker.incoming | 缓冲通道 | 1024 个事件 | 每个 worker 的事件队列 |\n| eventWorker.payload | bytes.Buffer | 无界* | 有效负载累积 |\n\n*受 `truncateSize` 配置参数限制。\n\n**来源：** [pkg/event_processor/processor.go:25-28](), [pkg/event_processor/iworker.go:51-54]()\n\n### 背压处理\n\n流程使用带有 `select` + `default` 的非阻塞通道写入来防止停顿：\n\n**EventProcessor.Write() - 模块到处理器**\n\n```go\nfunc (ep *EventProcessor) Write(e event.IEventStruct) {\n    if ep.isClosed {\n        return\n    }\n    select {\n    case ep.incoming <- e:\n        return\n    default:\n        // 队列已满：静默丢弃事件\n    }\n}\n```\n\n**来源：** [pkg/event_processor/processor.go:165-175]()\n\n**eventWorker.Write() - 处理器到 Worker**\n\n```go\nfunc (ew *eventWorker) Write(e event.IEventStruct) error {\n    var err error\n    select {\n    case ew.incoming <- e:\n    default:\n        err = ErrEventWorkerIncomingFull\n    }\n    return err\n}\n```\n\n当 worker 队列已满（容量：1024）时返回 `ErrEventWorkerIncomingFull`。错误被传播到 `EventProcessor.errChan` 但不会阻塞。**来源：** [pkg/event_processor/iworker.go:154-162](), [pkg/event_processor/iworker.go:66]()\n\n**eventWorker.writeToChan() - Worker 到处理器输出**\n\n```go\nfunc (ew *eventWorker) writeToChan(b []byte) error {\n    var err error\n    select {\n    case ew.outComing <- b:\n    default:\n        err = ErrEventWorkerOutcomingFull\n    }\n    return err\n}\n```\n\n当处理器输出队列已满（容量：1024）时返回 `ErrEventWorkerOutcomingFull`。**来源：** [pkg/event_processor/iworker.go:164-172](), [pkg/event_processor/iworker.go:67]()\n\n**理由**：非阻塞操作可防止阻塞 eBPF 事件读取器（这会导致内核空间环形缓冲区溢出）。在监控场景中，在极端负载下丢弃少量事件是可以接受的。\n\n### 截断行为\n\n如果 `EventProcessor.truncateSize > 0`：\n- Worker 在每次写入前检查有效负载大小\n- 如果 `payload.Len() >= truncateSize`，截断到确切大小\n- 日志消息：`\"Events truncated, size: %d bytes\\n\"`\n- 防止长期存在的连接进行大传输时内存无限增长\n\n**来源：** [pkg/event_processor/iworker.go:236-242]()\n\n---\n\n## 线程安全和同步\n\n流程采用多种同步机制来确保并发访问下的正确性。\n\n### EventProcessor 锁定\n\n所有 `workerQueue` 操作都受 `sync.Mutex` 保护：\n\n```mermaid\ngraph TB\n    subgraph \"线程安全操作\"\n        Get[\"getWorkerByUUID()\"]\n        Add[\"addWorkerByUUID()\"]\n        Del[\"delWorkerByUUID()\"]\n        Destroy[\"destroyWorkers()\"]\n        Clear[\"clearAllWorkers()\"]\n    end\n    \n    subgraph \"锁定范围\"\n        Lock[\"Lock()\"]\n        MapOp[\"workerQueue 访问\"]\n        RefCount[\"worker.Get() 用于引用计数\"]\n        Unlock[\"Unlock()\"]\n    end\n    \n    Get --> Lock\n    Add --> Lock\n    Del --> Lock\n    Destroy --> Lock\n    Clear --> Lock\n    \n    Lock --> MapOp\n    MapOp --> RefCount\n    RefCount --> Unlock\n```\n\n**来源：** [pkg/event_processor/processor.go:130-161]()\n\n### Worker 引用计数\n\n`eventWorker.used` 是一个跟踪外部引用的 `atomic.Bool`：\n\n**Get/Put 模式：**\n```go\n// 在 EventProcessor.dispatch() 中\nworker.Get()      // 原子设置 used = true\ndefer worker.Put() // 原子设置 used = false\n\n// 在 eventWorker.drainAndClose() 中\nfor {\n    if ew.IfUsed() {\n        time.Sleep(10 * time.Millisecond)\n        continue  // 等待 Put()\n    }\n    ew.Close()\n    return\n}\n```\n\n**目的：** 防止 worker 在 `dispatch()` 正在向其写入时被销毁。使用带有 10ms 睡眠的忙等待来确保在最终清理之前释放引用。\n\n**来源：** [pkg/event_processor/iworker.go:346-360](), [pkg/event_processor/iworker.go:308-337]()\n\n### 基于通道的信号\n\nSocket 生命周期 worker 使用 `closeChan` 进行干净关闭：\n\n```go\ncloseChan chan struct{}  // 默认生命周期为 nil，socket 生命周期已初始化\ncloseOnce sync.Once      // 确保 close() 只调用一次\n\nfunc (ew *eventWorker) CloseEventWorker() {\n    if ew.closeChan != nil {\n        ew.closeOnce.Do(func() {\n            close(ew.closeChan)\n        })\n    }\n}\n```\n\n**模式：** 关闭通道同时向所有读取器发出信号。`sync.Once` 防止双重关闭导致的 panic。\n\n**来源：** [pkg/event_processor/iworker.go:86-88](), [pkg/event_processor/iworker.go:142-148]()\n\n---\n\n## 总结\n\n事件处理流程通过三阶段架构将原始 eBPF 事件转换为协议感知的格式化输出：\n\n1. **EventProcessor** 将传入事件路由到基于 UUID 键的 worker\n2. **eventWorker** 实例累积有效负载并管理连接生命周期\n3. **IParser** 实现检测协议并格式化输出\n\n关键设计原则：\n- **非阻塞操作**：完整的通道丢弃事件而不是停顿\n- **自动生命周期管理**：Worker 在空闲期或外部信号后自我销毁\n- **协议无关核心**：解析器注册系统支持任意协议处理器\n- **线程安全访问**：互斥锁保护的 map 和原子引用计数防止竞争\n\n流程支持输出到控制台、文件、PCAP、keylog 和 Protobuf 流，从而能够与外部分析工具集成。\n\n**来源：** [pkg/event_processor/processor.go:1-216](), [pkg/event_processor/iworker.go:1-366](), [pkg/event_processor/iparser.go:1-167]()"
          },
          {
            "page_plan": {
              "id": "2.3",
              "title": "配置系统"
            },
            "content": "# 配置系统\n\n配置系统管理 eCapture 各个捕获模块的模块特定设置、运行时参数、库发现和过滤机制。它提供了一个统一的 `IConfig` 接口，由基础配置和模块特定配置共同实现，使所有模块（OpenSSL、Go TLS、GnuTLS、NSPR、Bash、MySQL、PostgreSQL、Zsh）都能一致地处理参数。\n\n配置系统支持：\n- **进程和用户过滤**：基于 PID/UID 的目标定位，传递给 eBPF 程序\n- **运行时更新**：通过 HTTP API 动态更改配置，无需重启\n- **平台检测**：自动发现 Linux 和 Android 平台的库\n- **输出模式**：文本、PCAP、密钥日志格式选择\n- **eBPF 参数**：BTF 模式、映射大小、字节码选择\n\n关于模块生命周期和初始化，请参见[模块系统与生命周期](#2.4)。关于编译时配置，请参见[构建系统](#5.1)。\n\n## 配置流程概览\n\n配置系统从 CLI 标志开始，经过验证后传递到 eBPF 程序常量：\n\n```mermaid\ngraph TB\n    subgraph \"CLI 层\"\n        Flags[\"CLI 标志<br/>cobra.Command<br/>--pid, --uid, --btf\"]\n        GlobalConf[\"globalConf<br/>BaseConfig<br/>root.go:134\"]\n        ModConfig[\"模块配置<br/>OpensslConfig, GoTLSConfig 等\"]\n    end\n    \n    subgraph \"配置应用\"\n        SetMod[\"setModConfig()<br/>root.go:157-175<br/>复制 global → module\"]\n        CheckMethod[\"config.Check()<br/>验证与设置\"]\n    end\n    \n    subgraph \"模块初始化\"\n        ModInit[\"module.Init()<br/>context, logger, config\"]\n        ConstEditor[\"constantEditor()<br/>probe_openssl.go:361-387<br/>target_pid, target_uid\"]\n    end\n    \n    subgraph \"eBPF 程序\"\n        BPFConst[\"eBPF 常量<br/>target_pid, target_uid<br/>编译到字节码中\"]\n        Maps[\"eBPF 映射<br/>PerCpuMapSize<br/>事件缓冲区\"]\n    end\n    \n    subgraph \"运行时更新\"\n        HTTPServer[\"HTTP 服务器<br/>localhost:28256<br/>root.go:313-322\"]\n        ReloadChan[\"reRloadConfig chan<br/>root.go:310\"]\n        ModReload[\"模块重载<br/>root.go:392-396\"]\n    end\n    \n    Flags --> GlobalConf\n    GlobalConf --> SetMod\n    SetMod --> ModConfig\n    ModConfig --> CheckMethod\n    CheckMethod --> ModInit\n    ModInit --> ConstEditor\n    ConstEditor --> BPFConst\n    ModConfig --> Maps\n    \n    HTTPServer --> ReloadChan\n    ReloadChan --> ModReload\n    ModReload --> CheckMethod\n```\n\n**来源：** [cli/cmd/root.go:134-175](), [user/module/probe_openssl.go:361-387](), [cli/cmd/root.go:310-396]()\n\n## IConfig 接口\n\n`IConfig` 接口定义了所有配置实现必须满足的契约：\n\n```mermaid\ngraph TB\n    subgraph \"IConfig 接口方法\"\n        Validation[\"Check() error<br/>验证配置\"]\n        Getters[\"获取方法<br/>GetPid(), GetUid()<br/>GetHex(), GetBTF()<br/>GetDebug(), GetPerCpuMapSize()\"]\n        Setters[\"设置方法<br/>SetPid(), SetUid()<br/>SetHex(), SetBTF()<br/>SetDebug(), SetPerCpuMapSize()\"]\n        Output[\"输出配置<br/>GetAddrType(), SetAddrType()<br/>GetEventCollectorAddr()\"]\n        Serialization[\"Bytes() []byte<br/>JSON 序列化\"]\n    end\n    \n    subgraph \"实现\"\n        BaseConfig[\"BaseConfig<br/>iconfig.go:96-212\"]\n        OpensslConfig[\"OpensslConfig\"]\n        GoTLSConfig[\"GoTLSConfig\"]\n        BashConfig[\"BashConfig\"]\n        MysqldConfig[\"MysqldConfig\"]\n        PostgresConfig[\"PostgresConfig\"]\n        GnutlsConfig[\"GnutlsConfig\"]\n        NsprConfig[\"NsprConfig\"]\n        ZshConfig[\"ZshConfig\"]\n    end\n    \n    Validation --> BaseConfig\n    Getters --> BaseConfig\n    Setters --> BaseConfig\n    Output --> BaseConfig\n    Serialization --> BaseConfig\n    \n    BaseConfig --> OpensslConfig\n    BaseConfig --> GoTLSConfig\n    BaseConfig --> BashConfig\n    BaseConfig --> MysqldConfig\n    BaseConfig --> PostgresConfig\n    BaseConfig --> GnutlsConfig\n    BaseConfig --> NsprConfig\n    BaseConfig --> ZshConfig\n```\n\n**来源：** [user/config/iconfig.go:24-70](), [user/config/iconfig.go:96-212]()\n\n### IConfig 方法分类\n\n| 类别 | 方法 | 用途 |\n|------|------|------|\n| **验证** | `Check() error` | 在模块启动前验证配置设置 |\n| **进程过滤** | `GetPid()`, `SetPid()`, `GetUid()`, `SetUid()` | 针对特定进程或用户 |\n| **eBPF 控制** | `GetBTF()`, `SetBTF()`, `GetPerCpuMapSize()`, `SetPerCpuMapSize()` | 控制 eBPF 字节码和映射配置 |\n| **输出控制** | `GetHex()`, `SetHex()`, `GetTruncateSize()`, `SetTruncateSize()` | 控制输出格式 |\n| **调试** | `GetDebug()`, `SetDebug()` | 启用详细日志 |\n| **序列化** | `Bytes() []byte` | 将配置序列化为 JSON，用于运行时更新 |\n\n**来源：** [user/config/iconfig.go:24-70]()\n\n## BaseConfig 结构\n\n`BaseConfig` 实现了 `IConfig` 接口，并被所有模块特定配置嵌入：\n\n| 字段 | 类型 | 默认值 | 用途 |\n|------|------|--------|------|\n| `Pid` | `uint64` | `0` | 目标进程 ID（0 = 所有进程）|\n| `Uid` | `uint64` | `0` | 目标用户 ID（0 = 所有用户）|\n| `PerCpuMapSize` | `int` | `1024 * PAGESIZE` | 每个 CPU 的 eBPF 映射大小（字节）|\n| `IsHex` | `bool` | `false` | 以十六进制格式输出数据 |\n| `Debug` | `bool` | `false` | 启用调试日志 |\n| `BtfMode` | `uint8` | `0` | BTF 模式：0=自动，1=core，2=non-core |\n| `ByteCodeFileMode` | `uint8` | `0` | 字节码选择：0=全部，1=core，2=non-core |\n| `TruncateSize` | `uint64` | `0` | 截断捕获数据（0 = 不截断）|\n| `LoggerAddr` | `string` | `\"\"` | 日志输出地址（文件/tcp/ws）|\n| `EventCollectorAddr` | `string` | `\"\"` | 事件收集器地址 |\n| `Listen` | `string` | `\"localhost:28256\"` | HTTP API 监听地址 |\n\n**来源：** [user/config/iconfig.go:96-112](), [cli/cmd/root.go:134-154]()\n\n## 进程和用户过滤\n\neCapture 支持按进程 ID（PID）或用户 ID（UID）过滤捕获。这些过滤器在初始化期间作为常量传递给 eBPF 程序：\n\n### 过滤器配置流程\n\n```mermaid\ngraph LR\n    subgraph \"CLI 标志\"\n        PidFlag[\"--pid=3423<br/>root.go:144\"]\n        UidFlag[\"--uid=1000<br/>root.go:145\"]\n    end\n    \n    subgraph \"配置应用\"\n        SetPid[\"modConf.SetPid()<br/>root.go:158\"]\n        SetUid[\"modConf.SetUid()<br/>root.go:159\"]\n    end\n    \n    subgraph \"eBPF 常量注入\"\n        Editor[\"constantEditor()<br/>probe_openssl.go:361-387\"]\n        TargetPid[\"target_pid 常量<br/>第 364 行\"]\n        TargetUid[\"target_uid 常量<br/>第 369 行\"]\n    end\n    \n    subgraph \"eBPF 程序\"\n        BPFCheck[\"if target_pid > 0<br/>检查当前 PID\"]\n        BPFFilter[\"过滤事件<br/>在内核空间\"]\n    end\n    \n    PidFlag --> SetPid\n    UidFlag --> SetUid\n    SetPid --> Editor\n    SetUid --> Editor\n    Editor --> TargetPid\n    Editor --> TargetUid\n    TargetPid --> BPFCheck\n    TargetUid --> BPFCheck\n    BPFCheck --> BPFFilter\n```\n\n**来源：** [cli/cmd/root.go:144-145](), [cli/cmd/root.go:157-159](), [user/module/probe_openssl.go:361-387]()\n\n### 常量编辑器实现\n\n`constantEditor()` 方法在加载前将配置值注入 eBPF 字节码：\n\n```go\n// 来自 probe_openssl.go:361-387\nfunc (m *MOpenSSLProbe) constantEditor() []manager.ConstantEditor {\n    editor := []manager.ConstantEditor{\n        {\n            Name:  \"target_pid\",\n            Value: uint64(m.conf.GetPid()),\n        },\n        {\n            Name:  \"target_uid\",\n            Value: uint64(m.conf.GetUid()),\n        },\n    }\n    // 为简洁起见，省略日志记录\n    return editor\n}\n```\n\n当 `target_pid` 为 0 时，eBPF 程序捕获所有进程。当设置为特定 PID 时，仅捕获该进程的事件。`target_uid` 也采用相同的逻辑。\n\n**注意：** 在内核版本 < 5.2 的系统上，由于缺少 eBPF 功能，进程过滤可能无法正常工作。这在 [user/module/imodule.go:140-149]() 中被检测到。\n\n**来源：** [user/module/probe_openssl.go:361-387](), [user/module/imodule.go:140-149]()\n\n## 通过 HTTP API 进行运行时配置更新\n\neCapture 提供了一个 HTTP API，用于在运行时更新配置而无需重启捕获进程：\n\n### HTTP API 架构\n\n```mermaid\ngraph TB\n    subgraph \"HTTP 服务器\"\n        Listen[\"http.ListenAndServe()<br/>localhost:28256<br/>root.go:313-322\"]\n        Handler[\"HttpServer.Run()<br/>接收配置更新\"]\n    end\n    \n    subgraph \"配置通道\"\n        ReloadChan[\"reRloadConfig chan<br/>root.go:310<br/>缓冲通道\"]\n    end\n    \n    subgraph \"模块生命周期\"\n        RunLoop[\"模块运行循环<br/>root.go:368-396\"]\n        Signal[\"select case<br/>stopper vs reRloadConfig\"]\n        Stop[\"mod.Close()<br/>停止当前模块\"]\n        Reload[\"goto reload<br/>使用新配置重启\"]\n    end\n    \n    Listen --> Handler\n    Handler --> ReloadChan\n    ReloadChan --> RunLoop\n    RunLoop --> Signal\n    Signal --> Stop\n    Stop --> Reload\n```\n\n**来源：** [cli/cmd/root.go:310-322](), [cli/cmd/root.go:368-396]()\n\n### 重载流程\n\n1. **HTTP 请求**：客户端向 `http://localhost:28256` 发送新配置\n2. **通道发送**：HTTP 处理程序解析 JSON 并发送到 `reRloadConfig` 通道\n3. **接收信号**：主运行循环从通道接收新配置\n4. **停止模块**：调用当前模块的 `Close()` 方法\n5. **重载**：控制跳转到 `reload` 标签，使用新配置重新初始化模块\n6. **重启**：模块使用更新后的配置启动\n\n配置使用 `IConfig` 的 `Bytes()` 方法进行序列化：\n\n```go\n// 来自 iconfig.go:205-211\nfunc (c *BaseConfig) Bytes() []byte {\n    b, e := json.Marshal(c)\n    if e != nil {\n        return []byte{}\n    }\n    return b\n}\n```\n\n这使得可以动态更新 PID 过滤器、UID 过滤器、调试模式和其他运行时可配置的设置，而无需停止捕获。\n\n**来源：** [cli/cmd/root.go:368-396](), [user/config/iconfig.go:205-211]()\n\n## 模块特定配置\n\n每个捕获模块都有一个特定的配置结构，该结构嵌入了 `BaseConfig`：\n\n| 模块 | 配置类型 | CLI 变量 | 关键字段 |\n|------|----------|----------|----------|\n| OpenSSL/BoringSSL | `OpensslConfig` | `oc` (tls.go:26) | `Openssl`, `Model`, `KeylogFile`, `PcapFile`, `Ifname`, `SslVersion`, `CGroupPath` |\n| Go TLS | `GoTLSConfig` | `goc` (gotls.go:26) | `Path`, `Model`, `KeylogFile`, `PcapFile`, `Ifname` |\n| GnuTLS | `GnutlsConfig` | `gc` (gnutls.go:29) | `Gnutls`, `Model`, `KeylogFile`, `PcapFile`, `Ifname`, `SslVersion` |\n| NSPR/NSS | `NsprConfig` | `nc` (nspr.go:27) | `Nsprpath` |\n| Bash | `BashConfig` | `bc` (bash.go:24) | `Bashpath`, `Readline`, `ErrNo` |\n| MySQL | `MysqldConfig` | `myc` (mysqld.go:27) | `Mysqldpath`, `Offset`, `FuncName` |\n| PostgreSQL | `PostgresConfig` | `pgc` (postgres.go:27) | `PostgresPath`, `FuncName` |\n| Zsh | `ZshConfig` | `zc` (zsh.go:27) | `Zshpath`, `ErrNo` |\n\n**来源：** [cli/cmd/tls.go:26](), [cli/cmd/gotls.go:26](), [cli/cmd/gnutls.go:29](), [cli/cmd/nspr.go:27](), [cli/cmd/bash.go:24](), [cli/cmd/mysqld.go:27](), [cli/cmd/postgres.go:27](), [cli/cmd/zsh.go:27]()\n\n## Go TLS 配置\n\n`GoTLSConfig` 对 Go 应用程序进行二进制分析，以提取符号地址和函数偏移量，用于 uprobe 附加：\n\n### 二进制分析流程\n\nGo 二进制文件需要符号解析以定位特定的 TLS 函数进行 uprobe 附加。配置执行 ELF 分析和符号表解析：\n\n```mermaid\ngraph TD\n    Check[\"Check() 方法<br/>config_gotls.go:102-190\"]\n    PathCheck[\"os.Stat(Path)<br/>验证二进制文件存在\"]\n    ElfOpen[\"elf.Open(path)<br/>解析 ELF 头\"]\n    BuildInfo[\"buildinfo.ReadFile()<br/>提取 Go 构建信息\"]\n    ArchCheck[\"架构验证<br/>runtime.GOARCH 匹配\"]\n    \n    subgraph \"PIE 模式检测\"\n        PIECheck[\"检查 buildmode=pie<br/>BuildInfo.Settings\"]\n        SymTabRead[\"ReadTable()<br/>解析 .gopclntab 部分\"]\n        MagicFind[\"查找魔数<br/>版本特定字节\"]\n    end\n    \n    subgraph \"符号解析\"\n        WriteAddr[\"findPieSymbolAddr()<br/>GoTlsWriteFunc<br/>writeRecordLocked\"]\n        MasterAddr[\"findPieSymbolAddr()<br/>GoTlsMasterSecretFunc<br/>writeKeyLog\"]\n        RetOffsets[\"findRetOffsetsPie()<br/>GoTlsReadFunc<br/>返回偏移量\"]\n    end\n    \n    Check --> PathCheck\n    PathCheck --> ElfOpen\n    ElfOpen --> BuildInfo\n    BuildInfo --> ArchCheck\n    ArchCheck --> PIECheck\n    PIECheck --> SymTabRead\n    SymTabRead --> MagicFind\n    MagicFind --> WriteAddr\n    WriteAddr --> MasterAddr\n    MasterAddr --> RetOffsets\n```\n\n**来源：** [user/config/config_gotls.go:102-190](), [user/config/config_gotls.go:281-325](), [user/config/config_gotls.go:327-357]()\n\n### 符号地址解析\n\nGo 配置解析特定函数地址以进行 uprobe 附加：\n\n| 函数 | 常量 | 用途 |\n|------|------|------|\n| `crypto/tls.(*Conn).Read` | `GoTlsReadFunc` | TLS 读取拦截 |\n| `crypto/tls.(*Conn).writeRecordLocked` | `GoTlsWriteFunc` | TLS 写入拦截 |\n| `crypto/tls.(*Config).writeKeyLog` | `GoTlsMasterSecretFunc` | 主密钥提取 |\n\n```mermaid\ngraph LR\n    subgraph \"函数符号\"\n        ReadFunc[\"GoTlsReadFunc<br/>crypto/tls.(*Conn).Read\"]\n        WriteFunc[\"GoTlsWriteFunc<br/>writeRecordLocked\"]\n        MasterFunc[\"GoTlsMasterSecretFunc<br/>writeKeyLog\"]\n    end\n    \n    subgraph \"地址解析\"\n        ReadAddrs[\"ReadTlsAddrs[]<br/>返回指令偏移量\"]\n        WriteAddr[\"GoTlsWriteAddr<br/>函数入口点\"]\n        MasterAddr[\"GoTlsMasterSecretAddr<br/>密钥日志函数\"]\n    end\n    \n    ReadFunc --> ReadAddrs\n    WriteFunc --> WriteAddr\n    MasterFunc --> MasterAddr\n```\n\n**来源：** [user/config/config_gotls.go:31-35](), [user/config/config_gotls.go:88-91](), [user/config/config_gotls.go:168-182]()\n\n## OpenSSL/BoringSSL 配置\n\n`OpensslConfig` 处理 OpenSSL 和 BoringSSL 库的库发现、版本检测和捕获模式配置：\n\n### 库发现流程\n\n如果未指定路径，OpenSSL 配置会执行自动库检测：\n\n```mermaid\ngraph TD\n    Check[\"Check() 方法<br/>config_openssl.go:74-111\"]\n    UserPath[\"--libssl 标志<br/>用户指定路径\"]\n    AutoDetect[\"自动检测<br/>checkOpenssl()\"]\n    \n    subgraph \"Linux 检测\"\n        DynLibDirs[\"GetDynLibDirs()<br/>系统库路径<br/>/lib, /usr/lib 等\"]\n        LibSearch[\"搜索:<br/>libssl.so.3<br/>libssl.so.1.1<br/>libssl.so.1.0\"]\n        PathFound[\"设置 Openssl 路径<br/>ElfType = ElfTypeSo\"]\n    end\n    \n    subgraph \"Android 检测\"  \n        IsAndroid[\"IsAndroid = true<br/>构建标签检查\"]\n        AndroidPath[\"DefaultOpensslPath<br/>/apex/com.android.conscrypt/<br/>lib64/libssl.so\"]\n        AndroidVer[\"解析 build.prop<br/>ro.build.version.release<br/>用于版本映射\"]\n    end\n    \n    Check --> UserPath\n    Check --> AutoDetect\n    UserPath --> PathFound\n    AutoDetect --> DynLibDirs\n    DynLibDirs --> LibSearch\n    LibSearch --> PathFound\n    \n    Check --> IsAndroid\n    IsAndroid --> AndroidPath\n    AndroidPath --> AndroidVer\n    AndroidVer --> PathFound\n```\n\n**来源：** [user/config/config_openssl.go:74-111](), [user/config/config_openssl_linux.go:38-67](), [user/config/config_openssl_androidgki.go:34-71]()\n\n### 平台特定路径\n\n| 平台 | 默认库路径 | 接口 |\n|------|-----------|------|\n| Linux | `/usr/lib/x86_64-linux-gnu/libssl.so.3` | `eth0` |\n| Android | `/apex/com.android.conscrypt/lib64/libssl.so` | `wlan0` |\n\n**来源：** [user/config/config_openssl_linux.go:28-36](), [user/config/config_openssl_androidgki.go:26-32]()\n\n## 捕获模式选择\n\nTLS/SSL 模块支持 `IConfig` 常量中定义的三种捕获模式：\n\n### 捕获模式类型\n\n| 模式常量 | CLI 值 | 用途 | 输出 |\n|---------|--------|------|------|\n| `TlsCaptureModelText` | `\"text\"` (默认) | 明文捕获，带 HTTP/HTTP2 解析 | 控制台或文件输出 |\n| `TlsCaptureModelKey` / `TlsCaptureModelKeylog` | `\"key\"` 或 `\"keylog\"` | 仅提取主密钥 | SSLKEYLOGFILE 格式 |\n| `TlsCaptureModelPcap` / `TlsCaptureModelPcapng` | `\"pcap\"` 或 `\"pcapng\"` | 完整数据包捕获，带加密密钥 | PCAP-NG 文件 |\n\n**来源：** [user/config/iconfig.go:73-79]()\n\n### 模式选择和验证\n\n```mermaid\ngraph TD\n    ModelFlag[\"--model 标志<br/>tls.go:53, gotls.go:45\"]\n    CheckModel[\"checkModel() 方法\"]\n    \n    subgraph \"模式常量\"\n        Text[\"TlsCaptureModelText<br/>iconfig.go:74\"]\n        Key[\"TlsCaptureModelKey<br/>TlsCaptureModelKeylog<br/>iconfig.go:77-78\"]\n        Pcap[\"TlsCaptureModelPcap<br/>TlsCaptureModelPcapng<br/>iconfig.go:75-76\"]\n    end\n    \n    subgraph \"模式特定验证\"\n        TextValid[\"文本模式:<br/>默认，无要求\"]\n        KeyValid[\"Key/Keylog 模式:<br/>设置 KeylogFile 路径<br/>默认: ecapture_*_key.log\"]\n        PcapValid[\"Pcap 模式:<br/>需要 --ifname<br/>设置 PcapFile 路径<br/>启用 TC 捕获\"]\n    end\n    \n    subgraph \"模块行为\"\n        TextSetup[\"setupManagersText()<br/>probe_openssl.go:293\"]\n        KeySetup[\"setupManagersKeylog()<br/>probe_openssl.go:289\"]\n        PcapSetup[\"setupManagersPcap()<br/>probe_openssl.go:291\"]\n    end\n    \n    ModelFlag --> CheckModel\n    CheckModel --> Text\n    CheckModel --> Key\n    CheckModel --> Pcap\n    \n    Text --> TextValid\n    Key --> KeyValid\n    Pcap --> PcapValid\n    \n    TextValid --> TextSetup\n    KeyValid --> KeySetup\n    PcapValid --> PcapSetup\n```\n\n**来源：** [user/config/iconfig.go:73-79](), [cli/cmd/tls.go:53](), [cli/cmd/gotls.go:45](), [user/module/probe_openssl.go:287-296]()\n\n## BTF 模式配置\n\neCapture 支持 CO-RE（一次编译 - 到处运行）和非 CO-RE eBPF 字节码。BTF 模式决定加载哪个字节码变体：\n\n### BTF 模式选择\n\n```mermaid\ngraph TD\n    BtfFlag[\"--btf 标志<br/>root.go:141<br/>0=自动, 1=core, 2=non-core\"]\n    \n    subgraph \"自动检测\"\n        AutoMode[\"BTFModeAutoDetect = 0<br/>iconfig.go:83\"]\n        ContainerCheck[\"IsContainer()<br/>检查容器化环境\"]\n        BTFCheck[\"IsEnableBTF()<br/>检查 /sys/kernel/btf/vmlinux\"]\n        SetCore[\"isCoreUsed = true<br/>imodule.go:185\"]\n        SetNonCore[\"isCoreUsed = false<br/>imodule.go:162\"]\n    end\n    \n    subgraph \"手动模式\"\n        CoreMode[\"BTFModeCore = 1<br/>iconfig.go:84<br/>强制 CO-RE\"]\n        NonCoreMode[\"BTFModeNonCore = 2<br/>iconfig.go:85<br/>强制 non-CO-RE\"]\n    end\n    \n    subgraph \"字节码选择\"\n        GetName[\"geteBPFName()<br/>imodule.go:191-214\"]\n        CoreFile[\"*_core.o<br/>启用 BTF 的字节码\"]\n        NonCoreFile[\"*_noncore.o<br/>内核特定字节码\"]\n    end\n    \n    BtfFlag --> AutoMode\n    BtfFlag --> CoreMode\n    BtfFlag --> NonCoreMode\n    \n    AutoMode --> ContainerCheck\n    ContainerCheck --> BTFCheck\n    BTFCheck --> SetCore\n    BTFCheck --> SetNonCore\n    \n    CoreMode --> SetCore\n    NonCoreMode --> SetNonCore\n    \n    SetCore --> GetName\n    SetNonCore --> GetName\n    GetName --> CoreFile\n    GetName --> NonCoreFile\n```\n\n**来源：** [cli/cmd/root.go:141](), [user/config/iconfig.go:82-86](), [user/module/imodule.go:154-214]()\n\n### BTF 模式影响\n\n| 模式 | 字节码文件 | 要求 | 优势 |\n|------|-----------|------|------|\n| **CO-RE** (`_core.o`) | 启用 BTF | 支持 BTF 的内核（5.2+）| 单个字节码适用于所有内核版本 |\n| **Non-CO-RE** (`_noncore.o`) | 内核特定 | 编译时匹配内核头文件 | 适用于没有 BTF 的旧内核 |\n\n系统会根据内核功能自动选择适当的字节码，除非使用 `--btf` 标志覆盖。\n\n**来源：** [user/module/imodule.go:191-214](), [user/module/imodule.go:173-190]()\n\n## 配置序列化\n\n所有配置都实现了 `Bytes()` 方法进行 JSON 序列化，以支持配置导出和运行时更新：\n\n```go\n// 来自 iconfig.go:205-211\nfunc (c *BaseConfig) Bytes() []byte {\n    b, e := json.Marshal(c)\n    if e != nil {\n        return []byte{}\n    }\n    return b\n}\n```\n\n此序列化用于：\n- **HTTP API**：以 JSON 形式接收配置更新\n- **日志记录**：使用 `logger.Info().RawJSON(\"config\", modConfig.Bytes())` 记录当前配置\n- **调试**：检查活动配置\n\n配置 JSON 示例：\n```json\n{\n  \"pid\": 3423,\n  \"uid\": 1000,\n  \"debug\": true,\n  \"is_hex\": false,\n  \"btf_mode\": 0,\n  \"per_cpu_map_size\": 4194304,\n  \"truncate_size\": 1024\n}\n```\n\n**来源：** [user/config/iconfig.go:205-211](), [cli/cmd/root.go:394]()"
          },
          {
            "page_plan": {
              "id": "2.4",
              "title": "模块系统与生命周期"
            },
            "content": "# 模块系统与生命周期\n\n本文档解释了 eCapture 中的模块系统架构，包括 `IModule` 接口约定、模块注册模式，以及从初始化到关闭的完整生命周期。模块系统提供了一个可插拔的架构，每种捕获类型（OpenSSL、GoTLS、Bash、MySQL 等）都实现了一个通用接口，同时保持专门的行为。\n\n有关模块如何配置自身的详细信息，请参见页面 **2.3 配置系统**。有关模块内 eBPF 程序加载的信息，请参见页面 **2.1 eBPF 引擎**。有关捕获后的事件处理，请参见页面 **2.2 事件处理流程**。\n\n## IModule 接口约定\n\n`IModule` 接口定义了所有捕获模块必须实现的标准约定。该接口在整个系统中实现多态模块处理，允许 CLI 命令和 HTTP API 通过工厂模式统一实例化和管理不同的捕获类型。\n\n**核心接口定义**\n\n| 方法 | 用途 | 调用者 |\n|--------|---------|-----------|\n| `Init(context.Context, *zerolog.Logger, config.IConfig, io.Writer)` | 使用上下文、日志器、配置和事件写入器初始化模块 | 启动前的 CLI/HTTP 处理器 |\n| `Name()` | 返回模块名称（例如 \"openssl\"、\"gotls\"） | 日志记录和标识 |\n| `Run()` | 启动事件处理流程 | 初始化完成后的 CLI |\n| `Start()` | 加载并附加 eBPF 程序 | 内部由 `Module.Run()` 调用 |\n| `Stop()` | 优雅地停止捕获 | 信号处理器 |\n| `Close()` | 释放所有资源 | 关闭序列 |\n| `SetChild(IModule)` | 为父子模式注册具体实现 | `Init()` 阶段 |\n| `Events()` | 返回用于事件读取的 eBPF 映射列表 | 事件读取器设置 |\n| `DecodeFun(*ebpf.Map)` | 获取特定 eBPF 映射的解码器 | 事件解码 |\n| `Decode(*ebpf.Map, []byte)` | 将原始字节解码为事件结构 | 事件处理 |\n| `Dispatcher(event.IEventStruct)` | 处理已解码的事件 | 事件路由 |\n\n该接口在整个系统中实现多态处理，允许 CLI 命令和 HTTP API 通过工厂模式统一实例化和管理不同的捕获类型。\n\n**来源：** [user/module/imodule.go:47-75](), [user/module/probe_openssl.go:83-106]()\n\n```mermaid\nclassDiagram\n    class IModule {\n        <<interface>>\n        +Init(context, logger, config, writer) error\n        +Name() string\n        +Run() error\n        +Start() error\n        +Stop() error\n        +Close() error\n        +SetChild(module)\n        +Decode(map, bytes) IEventStruct\n        +Events() []*ebpf.Map\n        +DecodeFun(map) IEventStruct\n        +Dispatcher(event)\n    }\n    \n    class Module {\n        -isClosed atomic.Bool\n        -ctx context.Context\n        -logger *zerolog.Logger\n        -eventCollector io.Writer\n        -child IModule\n        -name string\n        -mType string\n        -conf config.IConfig\n        -processor *EventProcessor\n        -isKernelLess5_2 bool\n        -isCoreUsed bool\n        -errChan chan error\n        +Init()\n        +Run()\n        +Close()\n        +Decode()\n        +Dispatcher()\n        -autoDetectBTF()\n        -geteBPFName()\n        -readEvents()\n        -perfEventReader()\n        -ringbufEventReader()\n    }\n    \n    class MOpenSSLProbe {\n        +MTCProbe\n        -bpfManager *manager.Manager\n        -eventFuncMaps map\n        -eventMaps []*ebpf.Map\n        -pidConns map\n        -sock2pidFd map\n        -keylogger *os.File\n        -masterKeys map\n        -sslVersionBpfMap map\n        +Init()\n        +Start()\n        +Close()\n        +Events()\n        +DecodeFun()\n        +Dispatcher()\n        +AddConn()\n        +GetConn()\n        +DelConn()\n    }\n    \n    class MGoTLSProbe {\n        +Module\n        +Start()\n        +Events()\n    }\n    \n    class MBashProbe {\n        +Module\n        +Start()\n        +Events()\n    }\n    \n    IModule <|.. Module : 实现\n    Module <|-- MOpenSSLProbe : 嵌入\n    Module <|-- MGoTLSProbe : 嵌入\n    Module <|-- MBashProbe : 嵌入\n    \n    Module o-- IModule : child 引用\n```\n\n**图表：IModule 接口层次结构**\n\n父子模式允许基础 `Module` 结构体提供通用功能（BTF 检测、事件读取、上下文管理），同时通过 `child` 字段将模块特定操作（eBPF 程序设置、事件解码）委托给具体实现。\n\n**来源：** [user/module/imodule.go:83-108](), [user/module/probe_openssl.go:83-106]()\n\n## 模块注册与工厂模式\n\neCapture 使用工厂模式进行模块实例化，基于 CLI 命令实现动态模块加载。每个模块在包初始化期间使用 Go 的 `init()` 机制注册一个工厂函数。\n\n**注册实现**\n\n每个模块文件都包含一个注册工厂的 `init()` 函数：\n\n```go\n// 来自 probe_openssl.go 的示例\nfunc init() {\n    RegisteFunc(NewOpenSSLProbe)\n}\n\nfunc NewOpenSSLProbe() IModule {\n    mod := &MOpenSSLProbe{}\n    mod.name = ModuleNameOpenssl\n    mod.mType = ProbeTypeUprobe\n    return mod\n}\n```\n\n`RegisteFunc()` 函数将这些工厂存储在一个以模块名称为键的全局注册表映射中。当 CLI 命令执行时，它调用 `GetModuleFunc(moduleName)` 来检索工厂并实例化模块。\n\n```mermaid\ngraph TB\n    subgraph init[\"包初始化（Go init）\"]\n        InitOpenSSL[\"probe_openssl.go init()\"]\n        InitGoTLS[\"probe_gotls.go init()\"]\n        InitBash[\"probe_bash.go init()\"]\n        InitMysqld[\"probe_mysqld.go init()\"]\n    end\n    \n    subgraph registry[\"模块注册表\"]\n        RegisteFunc[\"RegisteFunc(factory)\"]\n        Registry[\"moduleRegistry\\nmap[string]GetModuleFunc\"]\n    end\n    \n    subgraph cli[\"CLI 命令执行\"]\n        CobraCmd[\"cobra.Command.Run\"]\n        RunModule[\"runModule(modName, config)\"]\n        GetModFunc[\"GetModuleFunc(modName)\"]\n    end\n    \n    subgraph instantiation[\"模块实例化\"]\n        Factory[\"factory() IModule\"]\n        Concrete[\"具体模块\\n（例如 MOpenSSLProbe）\"]\n        Init[\"mod.Init(ctx, logger, config, ecw)\"]\n        Run[\"mod.Run()\"]\n    end\n    \n    InitOpenSSL --> RegisteFunc\n    InitGoTLS --> RegisteFunc\n    InitBash --> RegisteFunc\n    InitMysqld --> RegisteFunc\n    \n    RegisteFunc --> Registry\n    \n    CobraCmd --> RunModule\n    RunModule --> GetModFunc\n    GetModFunc --> Registry\n    Registry --> Factory\n    Factory --> Concrete\n    Concrete --> Init\n    Init --> Run\n```\n\n**图表：模块注册与工厂模式流程**\n\n**来源：** [user/module/probe_openssl.go:777-786](), [user/module/imodule.go:47-75]()\n\n**模块名称常量**\n\n每个模块由一个用于注册表查找的唯一字符串常量标识：\n\n| 模块名称 | 常量 | 目标 |\n|-------------|----------|--------|\n| `ModuleNameOpenssl` | \"openssl\" | OpenSSL/BoringSSL |\n| `ModuleNameGotls` | \"gotls\" | Go crypto/tls |\n| `ModuleNameGnutls` | \"gnutls\" | GnuTLS |\n| `ModuleNameNspr` | \"nspr\" | NSS/NSPR |\n| `ModuleNameBash` | \"bash\" | Bash shell |\n| `ModuleNameZsh` | \"zsh\" | Zsh shell |\n| `ModuleNameMysqld` | \"mysqld\" | MySQL 服务器 |\n| `ModuleNamePostgres` | \"postgres\" | PostgreSQL |\n\n**CLI 到模块的映射**\n\n`cli/cmd/` 中的 CLI 层为每个模块包含一个 cobra 命令文件。每个命令文件使用适当的模块名称常量和配置对象调用 `runModule()`：\n\n| CLI 命令 | 模块名称常量 | 配置类型 | 源文件 |\n|-------------|---------------------|-------------|-------------|\n| `ecapture tls` | `ModuleNameOpenssl` | `OpensslConfig` | cli/cmd/tls.go |\n| `ecapture gotls` | `ModuleNameGotls` | `GoTLSConfig` | cli/cmd/gotls.go |\n| `ecapture gnutls` | `ModuleNameGnutls` | `GnutlsConfig` | cli/cmd/gnutls.go |\n| `ecapture bash` | `ModuleNameBash` | `BashConfig` | cli/cmd/bash.go |\n| `ecapture zsh` | `ModuleNameZsh` | `ZshConfig` | cli/cmd/zsh.go |\n| `ecapture mysqld` | `ModuleNameMysqld` | `MysqldConfig` | cli/cmd/mysqld.go |\n| `ecapture postgres` | `ModuleNamePostgres` | `PostgresConfig` | cli/cmd/postgres.go |\n\n[cli/cmd/root.go:249-403]() 中的 `runModule()` 函数协调完整的模块生命周期：配置设置、日志器初始化、通过工厂实例化模块、初始化、执行和清理。\n\n**来源：** [cli/cmd/root.go:249-403]()\n\n## 模块生命周期阶段\n\n模块生命周期由五个不同的阶段组成，每个阶段都有特定的职责。模块按顺序经历这些阶段，在每个转换点都有错误处理。\n\n```mermaid\nstateDiagram-v2\n    [*] --> Uninitialized\n    \n    Uninitialized --> Initialized: Init()\n    note right of Initialized\n        - 日志器设置\n        - 配置验证\n        - BTF 检测\n        - EventProcessor 创建\n        - 上下文继承\n    end note\n    \n    Initialized --> Started: Start()\n    note right of Started\n        - eBPF 字节码加载\n        - 程序附加\n        - 映射初始化\n        - 钩子注册\n    end note\n    \n    Started --> Running: Run()\n    note right of Running\n        - 事件读取器 goroutine\n        - EventProcessor 服务\n        - Perf/Ring 缓冲区读取\n        - 事件分发\n    end note\n    \n    Running --> Stopping: ctx.Done() 或信号\n    \n    Stopping --> Closed: Close()\n    note right of Closed\n        - 停止事件读取器\n        - 分离 eBPF 程序\n        - 关闭文件句柄\n        - 清理资源\n    end note\n    \n    Closed --> [*]\n    \n    Initialized --> Error: Init() 失败\n    Started --> Error: Start() 失败\n    Running --> Error: errChan 接收错误\n    Error --> [*]\n```\n\n**图表：模块生命周期状态机**\n\n**来源：** [cli/cmd/root.go:336-397](), [user/module/imodule.go:110-171]()\n\n### 初始化阶段（Init）\n\n`Init()` 方法为执行准备模块。这是模块接收其依赖项并执行环境检测的地方。\n\n**初始化职责：**\n\n1. **上下文继承**：存储父上下文以进行取消传播\n2. **日志器配置**：设置 `zerolog.Logger` 实例进行模块特定的日志记录\n3. **配置存储**：保存 `IConfig` 引用以便运行时参数访问\n4. **BTF 模式检测**：确定是使用 CO-RE（支持 BTF）还是非 CO-RE 字节码\n5. **内核版本检查**：检测内核版本是否 < 5.2（影响过滤能力和字节码选择）\n6. **EventProcessor 创建**：初始化 `event_processor.EventProcessor` 用于事件聚合和格式化\n7. **输出格式选择**：根据 `eventCollector` 类型选择文本或 protobuf 编码\n8. **错误通道设置**：创建缓冲的 `errChan` 用于错误传播\n9. **关闭标志初始化**：将 `isClosed` 原子标志设置为 false\n\n**基础模块 Init 实现：**\n\n[user/module/imodule.go:110-171]() 中的 `Module.Init()` 方法提供所有模块执行的通用初始化逻辑：\n\n```go\n// 上下文和核心依赖\nm.isClosed.Store(false)\nm.ctx = ctx\nm.logger = logger\nm.eventCollector = eventCollector\nm.errChan = make(chan error, 16)\n\n// BTF 模式确定（CO-RE vs 非 CO-RE）\nif conf.GetBTF() == config.BTFModeAutoDetect {\n    m.autoDetectBTF()  // 检查内核中的 BTF 支持\n} else {\n    m.isCoreUsed = (conf.GetBTF() == config.BTFModeCore)\n}\n\n// 内核版本检测用于字节码选择\nkv, err := kernel.HostVersion()\nif kv < kernel.VersionCode(5, 2, 0) {\n    m.isKernelLess5_2 = true  // 使用 *_less52.o 字节码变体\n}\n\n// 输出格式检测\nif _, ok := m.eventCollector.(event.CollectorWriter); !ok {\n    m.eventOutputType = codecTypeProtobuf\n} else {\n    m.eventOutputType = codecTypeText\n}\n\n// EventProcessor 初始化，支持截断\ntsize := conf.GetTruncateSize()\nm.processor = event_processor.NewEventProcessor(eventCollector, conf.GetHex(), tsize)\n```\n\n[user/module/imodule.go:173-190]() 中的 `autoDetectBTF()` 方法检查容器环境和内核 BTF 配置以确定 CO-RE 支持。\n\n**模块特定的 Init 扩展：**\n\n具体模块通过专门的设置扩展初始化。例如，[user/module/probe_openssl.go:109-176]() 中的 `MOpenSSLProbe.Init()` 执行 OpenSSL 特定的初始化：\n\n```go\n// 调用父初始化\nerr = m.Module.Init(ctx, logger, conf, ecw)\nif err != nil {\n    return err\n}\n\n// 将自身注册为子对象以进行委托模式\nm.Module.SetChild(m)\n\n// 初始化模块特定的数据结构\nm.eventMaps = make([]*ebpf.Map, 0, 2)\nm.eventFuncMaps = make(map[*ebpf.Map]event.IEventStruct)\nm.pidConns = make(map[uint32]map[uint32]ConnInfo)  // pid -> fd -> 连接\nm.sock2pidFd = make(map[uint64][2]uint32)          // sock -> [pid, fd]\nm.pidLocker = new(sync.Mutex)\nm.masterKeys = make(map[string]bool)                // 去重映射\nm.sslVersionBpfMap = make(map[string]string)        // 版本 -> 字节码文件\n\n// 捕获模式确定\nmodel := m.conf.(*config.OpensslConfig).Model\nswitch model {\ncase config.TlsCaptureModelKeylog, config.TlsCaptureModelKey:\n    m.keylogger, err = os.OpenFile(keylogFilename, os.O_APPEND|os.O_WRONLY|os.O_CREATE, 0o600)\n    m.eBPFProgramType = TlsCaptureModelTypeKeylog\ncase config.TlsCaptureModelPcap, config.TlsCaptureModelPcapng:\n    m.eBPFProgramType = TlsCaptureModelTypePcap\n    m.tcPacketsChan = make(chan *TcPacket, 2048)\ncase config.TlsCaptureModelText:\n    m.eBPFProgramType = TlsCaptureModelTypeText\n}\n\n// 时钟同步用于时间戳转换\nunix.ClockGettime(unix.CLOCK_MONOTONIC, &ts)\nm.startTime = uint64(ts.Nano())\nm.bootTime = uint64(time.Now().UnixNano() - ts.Nano())\n\n// 初始化 OpenSSL 偏移配置\nm.initOpensslOffset()\n```\n\n不同的模块执行不同的专门初始化：GoTLS 执行 Go 二进制分析，Bash 定位 readline 库，MySQL 检测 `dispatch_command` 函数偏移等。\n\n**来源：** [user/module/imodule.go:110-171](), [user/module/probe_openssl.go:109-176]()\n\n### 启动阶段\n\n`Start()` 方法加载并附加 eBPF 程序。这是执行模块特定钩子逻辑的地方。\n\n**启动阶段操作：**\n\n1. **管理器设置**：使用探针和映射配置 `ebpfmanager.Manager`\n2. **字节码选择**：根据版本检测选择适当的 `.o` 文件\n3. **程序加载**：解析 ELF 字节码并创建 eBPF 程序\n4. **常量编辑**：将运行时值（目标 PID、UID）注入 eBPF 常量\n5. **程序附加**：将 uprobe/kprobe/TC 钩子附加到目标函数\n6. **映射注册**：存储对 eBPF 映射的引用以进行事件读取\n\n**OpenSSL 模块启动示例：**\n\n[user/module/probe_openssl.go:284-350]() 中的 `MOpenSSLProbe.start()` 方法演示了典型的启动阶段流程：\n\n```go\n// 1. 根据捕获模式设置 eBPF 管理器\nswitch m.eBPFProgramType {\ncase TlsCaptureModelTypeKeylog:\n    err = m.setupManagersKeylog()\ncase TlsCaptureModelTypePcap:\n    err = m.setupManagersPcap()\ncase TlsCaptureModelTypeText:\n    err = m.setupManagersText()\n}\n\n// 2. 如果在 pcap 模式下应用 pcap 过滤器\nif m.eBPFProgramType == TlsCaptureModelTypePcap && pcapFilter != \"\" {\n    m.bpfManager.InstructionPatchers = prepareInsnPatchers(...)\n}\n\n// 3. 选择适当的字节码文件\nbpfFileName := m.geteBPFName(filepath.Join(\"user/bytecode\", m.sslBpfFile))\n// 结果：例如 \"user/bytecode/openssl_3_0_0_kern_core.o\"\n\n// 4. 从资产加载嵌入的字节码\nbyteBuf, err := assets.Asset(bpfFileName)\n\n// 5. 使用字节码初始化 eBPF 管理器\nerr = m.bpfManager.InitWithOptions(bytes.NewReader(byteBuf), m.bpfManagerOptions)\n\n// 6. 启动管理器（附加所有探针）\nerr = m.bpfManager.Start()\n\n// 7. 为映射注册事件解码器\nswitch m.eBPFProgramType {\ncase TlsCaptureModelTypeKeylog:\n    err = m.initDecodeFunKeylog()\ncase TlsCaptureModelTypePcap:\n    err = m.initDecodeFunPcap()\ncase TlsCaptureModelTypeText:\n    err = m.initDecodeFunText()\n}\n```\n\n[user/module/imodule.go:191-214]() 中的 `geteBPFName()` 方法通过追加后缀来选择字节码文件名：根据 BTF 支持添加 `_core.o` 或 `_noncore.o`，对于内核 < 5.2 添加 `_less52.o`。\n\n**按模式划分的管理器配置：**\n\n不同的捕获模式配置不同的 eBPF 程序和映射：\n\n| 模式 | 管理器方法 | 使用的 eBPF 映射 | TC 程序 | Uprobe |\n|------|---------------|----------------|-------------|---------|\n| Text | `setupManagersText()` | `events`（SSL 数据） | 否 | SSL_read, SSL_write |\n| Pcap | `setupManagersPcap()` | `events`, `mastersecret_events`, `skb_events` | 是（ingress/egress） | SSL_read, SSL_write, SSL_do_handshake, SSL_get_wbio |\n| Keylog | `setupManagersKeylog()` | `mastersecret_events` | 否 | SSL_do_handshake, SSL_get_wbio, SSL_in_before |\n\nPcap 模式使用附加到网络接口的 TC（流量控制）eBPF 程序来捕获数据包元数据，而 Text 和 Keylog 模式仅在 SSL 库函数上使用 uprobe。\n\n**来源：** [user/module/probe_openssl.go:284-350]()\n\n### 运行阶段\n\n`Run()` 方法启动事件处理流程，为事件读取和分发启动 goroutine。\n\n**运行阶段组件：**\n\n```mermaid\ngraph TB\n    Run[\"Module.Run()\"]\n    \n    subgraph \"Goroutine 1: 模块监控\"\n        Monitor[\"m.run()\"]\n        CtxDone[\"<-ctx.Done()\"]\n        ErrChan[\"<-errChan\"]\n    end\n    \n    subgraph \"Goroutine 2: EventProcessor\"\n        ProcessorServe[\"processor.Serve()\"]\n        WorkerPool[\"事件工作池\"]\n        Aggregation[\"事件聚合\"]\n    end\n    \n    subgraph \"Goroutine 3-N: 事件读取器\"\n        ReadEvents[\"m.readEvents()\"]\n        PerfReader[\"perfEventReader()\"]\n        RingReader[\"ringbufEventReader()\"]\n        Decode[\"Decode() 事件\"]\n        Dispatch[\"Dispatcher()\"]\n    end\n    \n    Run --> Monitor\n    Run --> ProcessorServe\n    Run --> ReadEvents\n    \n    Monitor --> CtxDone\n    Monitor --> ErrChan\n    \n    ProcessorServe --> WorkerPool\n    WorkerPool --> Aggregation\n    \n    ReadEvents --> PerfReader\n    ReadEvents --> RingReader\n    PerfReader --> Decode\n    RingReader --> Decode\n    Decode --> Dispatch\n```\n\n**图表：运行阶段 Goroutine 架构**\n\n**事件读取实现：**\n\n[user/module/imodule.go:285-306]() 中的 `readEvents()` 方法遍历 `child.Events()` 返回的映射，并根据映射类型创建适当的读取器：\n\n- **Perf 事件数组**：使用 `perf.NewReader(em, mapSize)` 配置可配置的每个 CPU 缓冲区大小 [user/module/imodule.go:308-351]()\n- **环形缓冲区**：对于内核 >= 5.8，使用 `ringbuf.NewReader(em)` [user/module/imodule.go:353-391]()\n\n每个读取器产生一个具有此事件循环的 goroutine：\n\n```go\nfor {\n    select {\n    case <-m.ctx.Done():\n        return  // 优雅关闭\n    default:\n    }\n    \n    record, err := rd.Read()  // 阻塞等待事件\n    if err != nil {\n        if errors.Is(err, perf.ErrClosed) {\n            return\n        }\n        errChan <- err\n        return\n    }\n    \n    // 将原始字节解码为类型化事件\n    evt, err := m.child.Decode(em, record.RawSample)\n    \n    // 路由到适当的处理器\n    m.Dispatcher(evt)\n}\n```\n\n缓冲区大小可通过 `--mapsize` 标志配置，默认为每个 CPU 核心 1024 KB。\n\n**错误处理：**\n\n事件读取系统实现多种错误处理策略：\n\n- **丢失样本**：Perf 事件读取器通过 `record.LostSamples` 检测缓冲区溢出并记录警告 [user/module/imodule.go:336]()\n- **读取器错误**：不可恢复的错误发送到 `errChan`，触发模块关闭 [user/module/imodule.go:331-333]()\n- **解码错误**：单个事件解码失败被记录但不会停止读取器 [user/module/imodule.go:342-345]()\n- **上下文取消**：所有读取器 goroutine 监控 `ctx.Done()` 以进行优雅关闭 [user/module/imodule.go:320-324](), [user/module/imodule.go:363-367]()\n\n[user/module/imodule.go:268-283]() 中的 `Module.run()` goroutine 监控上下文取消和错误通道，确保错误发生时正确清理。\n\n**来源：** [user/module/imodule.go:236-262](), [user/module/imodule.go:285-391](), [user/module/imodule.go:268-283]()\n\n### 停止和清理阶段\n\n`Close()` 方法执行优雅关闭，释放所有获取的资源。\n\n**清理序列：**\n\n模块清理遵循定义的关闭序列以确保正确释放资源：\n\n1. **设置关闭标志**：`m.isClosed.Store(true)` 防止新事件被分发 [user/module/imodule.go:451]()\n2. **关闭事件读取器**：停止所有 perf 事件和环形缓冲区读取器 [user/module/imodule.go:453-457]()\n3. **停止 EventProcessor**：`m.processor.Close()` 刷新挂起的事件并停止工作池 [user/module/imodule.go:458-459]()\n4. **模块特定清理**：子对象的 `Close()` 方法执行模块特定的清理（见下文）\n5. **上下文取消**：父上下文取消传播到所有 goroutine\n\n模块特定清理（OpenSSL 示例）：\n\n```go\n// 分离 eBPF 程序并卸载映射\nerr := m.bpfManager.Stop(manager.CleanAll)\n\n// 关闭文件句柄\nif m.keylogger != nil {\n    m.keylogger.Close()\n}\n\n// 调用父清理\nreturn m.Module.Close()\n```\n\n`bpfManager.Stop(manager.CleanAll)` 中的 eBPF 管理器清理分离所有 uprobe、kprobe 和 TC 程序，然后取消映射并关闭所有 eBPF 映射。\n\n**来源：** [user/module/imodule.go:450-460](), [user/module/probe_openssl.go:352-358]()\n\n## 基础模块实现\n\n`Module` 结构体提供所有捕获模块共享的通用功能，部分实现 IModule 接口，并将专门操作委托给子模块。\n\n**共享能力：**\n\n| 能力 | 实现 | 用途 |\n|------------|----------------|---------|\n| BTF 检测 | `autoDetectBTF()` | 确定 CO-RE 支持 [user/module/imodule.go:173-190]() |\n| 字节码选择 | `geteBPFName()` | 选择 _core.o vs _noncore.o 变体 [user/module/imodule.go:191-214]() |\n| 事件读取 | `perfEventReader()`, `ringbufEventReader()` | 从 eBPF 映射读取 [user/module/imodule.go:308-391]() |\n| 事件解码 | `Decode()` | 反序列化 eBPF 事件 [user/module/imodule.go:393-406]() |\n| 事件路由 | `Dispatcher()` | 按类型路由事件 [user/module/imodule.go:408-448]() |\n| 输出编码 | `output()` | 格式化为文本或 protobuf [user/module/imodule.go:461-479]() |\n| 上下文管理 | `run()` | 监控关闭信号 [user/module/imodule.go:268-283]() |\n\n**父子委托模式：**\n\n基础 `Module` 结构体嵌入通用功能，并通过 `child IModule` 字段存储对其具体实现的引用。需要模块特定逻辑的操作通过此引用委托：\n\n```mermaid\ngraph TB\n    Module[\"Module（基础）\"]\n    Child[\"child IModule\"]\n    \n    subgraph \"委托操作\"\n        Start[\"Start()\"]\n        Events[\"Events()\"]\n        DecodeFun[\"DecodeFun(map)\"]\n        Dispatcher[\"Dispatcher(event)\"]\n    end\n    \n    subgraph \"具体实现\"\n        MOpenSSL[\"MOpenSSLProbe\"]\n        MGoTLS[\"MGoTLSProbe\"]\n        MBash[\"MBashProbe\"]\n    end\n    \n    Module --> Child\n    Child -.->|委托给| Start\n    Child -.->|委托给| Events\n    Child -.->|委托给| DecodeFun\n    Child -.->|委托给| Dispatcher\n    \n    MOpenSSL -.->|实现| Child\n    MGoTLS -.->|实现| Child\n    MBash -.->|实现| Child\n```\n\n**图表：父子委托架构**\n\n[user/module/imodule.go:393-406]() 中的 `Decode()` 方法演示了委托：\n\n```go\nfunc (m *Module) Decode(em *ebpf.Map, b []byte) (event.IEventStruct, error) {\n    // 委托给子对象以获取此映射的适当解码器\n    es, found := m.child.DecodeFun(em)\n    if !found {\n        return nil, fmt.Errorf(\"找不到映射 %s 的解码器\", em.String())\n    }\n    \n    // 克隆事件结构模板并解码\n    te := es.Clone()\n    err = te.Decode(b)\n    return te, err\n}\n```\n\n**使用 SetChild 初始化：**\n\n具体模块必须在初始化期间将自己注册为子对象：\n\n```go\nfunc (m *MOpenSSLProbe) Init(ctx context.Context, logger *zerolog.Logger, \n                             conf config.IConfig, ecw io.Writer) error {\n    // 调用父 Init\n    err := m.Module.Init(ctx, logger, conf, ecw)\n    if err != nil {\n        return err\n    }\n    \n    // 将自身注册为子对象以进行委托\n    m.Module.SetChild(m)\n    \n    // 模块特定初始化继续...\n}\n```\n\n这种模式允许基础 `Module` 提供基础设施（BTF 检测、事件读取、上下文管理），同时将捕获特定逻辑委托给专门的实现。\n\n**来源：** [user/module/imodule.go:83-108](), [user/module/imodule.go:216-218](), [user/module/imodule.go:393-406](), [user/module/probe_openssl.go:109-116]()\n\n## 模块配置集成\n\n模块通过 `IConfig` 接口接收配置，允许运行时行为定制。每种模块类型都有相应的配置结构。\n\n**配置到模块的映射：**\n\n| 模块 | 配置类型 | CLI 命令 | 关键标志 |\n|--------|-------------|-------------|-----------|\n| MOpenSSLProbe | `OpensslConfig` | `tls` | `--libssl`, `--model`, `--pcapfile` |\n| MGoTLSProbe | `GoTLSConfig` | `gotls` | `--elfpath`, `--model` |\n| MGnuTLSProbe | `GnutlsConfig` | `gnutls` | `--gnutls`, `--ssl_version` |\n| MBashProbe | `BashConfig` | `bash` | `--bash`, `--errnumber` |\n| MMysqldProbe | `MysqldConfig` | `mysqld` | `--mysqld`, `--offset` |\n| MPostgresProbe | `PostgresConfig` | `postgres` | `--postgres` |\n\n**全局配置应用：**\n\n[cli/cmd/root.go:156-175]() 将全局设置应用于模块配置：\n\n```\nfunc setModConfig(globalConf config.BaseConfig, modConf config.IConfig) {\n    modConf.SetPid(globalConf.Pid)\n    modConf.SetUid(globalConf.Uid)\n    modConf.SetDebug(globalConf.Debug)\n    modConf.SetHex(globalConf.IsHex)\n    modConf.SetBTF(globalConf.BtfMode)\n    modConf.SetPerCpuMapSize(globalConf.PerCpuMapSize)\n    modConf.SetTruncateSize(globalConf.TruncateSize)\n    ...\n}\n```\n\n**运行时配置更新：**\n\nHTTP 服务器（在 [cli/cmd/root.go:313-322]() 中启动）默认监听 `localhost:28256` 并支持运行时配置重新加载。[cli/cmd/root.go:349-396]() 中的重新加载机制遵循此序列：\n\n```go\nreload:\n    // 初始化并启动模块\n    mod := modFunc()\n    err = mod.Init(ctx, &logger, modConfig, ecw)\n    err = mod.Run()\n    \n    // 等待信号\n    select {\n    case <-stopper:          // SIGINT 或 SIGTERM\n        isReload = false\n    case rc := <-reRloadConfig:  // HTTP POST /config\n        isReload = true\n        modConfig = rc\n    }\n    \n    // 清理当前实例\n    err = mod.Close()\n    \n    // 如果配置已更改则重新加载\n    if isReload {\n        goto reload  // 使用新配置重新启动\n    }\n```\n\n当 HTTP API 接收到配置更新时，它在 `reRloadConfig` 通道上发送新的 `IConfig`。主循环关闭当前模块实例并跳回到 `reload`，使用更新的设置重新初始化模块。这使得无需重启 eCapture 进程即可动态更改过滤器、输出模式和其他参数。\n\n**来源：** [cli/cmd/root.go:156-175](), [cli/cmd/root.go:313-322](), [cli/cmd/root.go:349-396](), [user/config/iconfig.go:24-70]()\n\n## 事件分发和处理\n\n`Dispatcher()` 方法根据事件类型将已解码的事件路由到适当的处理器。这实现了三向路由策略。\n\n```mermaid\ngraph TD\n    Dispatch[\"Dispatcher(IEventStruct)\"]\n    \n    CheckClosed{\"isClosed.Load()\"}\n    CheckHex{\"conf.GetHex() && event.EventType() in [TypeEventProcessor, TypeOutput]\"}\n    \n    TypeSwitch{\"event.EventType()\"}\n    \n    TypeOutput[\"TypeOutput\"]\n    TypeProcessor[\"TypeEventProcessor\"]\n    TypeModuleData[\"TypeModuleData\"]\n    \n    HexOutput[\"StringHex() → eventCollector\"]\n    TextOutput[\"output() → 编码 → eventCollector\"]\n    ProcessorWrite[\"processor.Write(event)\"]\n    ChildDispatch[\"child.Dispatcher(event)\"]\n    \n    Dispatch --> CheckClosed\n    CheckClosed -->|true| Return[\"返回（模块正在关闭）\"]\n    CheckClosed -->|false| CheckHex\n    \n    CheckHex -->|true| HexOutput\n    CheckHex -->|false| TypeSwitch\n    \n    TypeSwitch --> TypeOutput\n    TypeSwitch --> TypeProcessor\n    TypeSwitch --> TypeModuleData\n    \n    TypeOutput --> TextOutput\n    TypeProcessor --> ProcessorWrite\n    TypeModuleData --> ChildDispatch\n```\n\n**图表：事件分发路由逻辑**\n\n**事件类型类别：**\n\n[user/module/imodule.go:408-448]() 按类型路由事件：\n\n- **`TypeOutput`**：准备显示的最终格式化事件 → `eventCollector.Write()`\n- **`TypeEventProcessor`**：需要聚合/解析的事件 → `processor.Write()`\n- **`TypeModuleData`**：模块特定数据（连接、主密钥） → `child.Dispatcher()`\n\n**模块特定分发示例：**\n\n[user/module/probe_openssl.go:733-754]() 中的 `MOpenSSLProbe.Dispatcher()` 方法处理 TLS 捕获的模块特定事件类型：\n\n```go\nfunc (m *MOpenSSLProbe) Dispatcher(eventStruct event.IEventStruct) {\n    switch ev := eventStruct.(type) {\n    case *event.ConnDataEvent:\n        // 连接生命周期跟踪\n        if ev.IsDestroy == 0 {\n            m.AddConn(ev.Pid, ev.Fd, ev.Tuple, ev.Sock)\n        } else {\n            m.DelConn(ev.Sock)\n        }\n    \n    case *event.MasterSecretEvent:\n        // TLS 主密钥（OpenSSL）\n        m.saveMasterSecret(ev)  // 写入 keylog 文件或 PCAP DSB\n    \n    case *event.MasterSecretBSSLEvent:\n        // TLS 主密钥（BoringSSL 变体）\n        m.saveMasterSecretBSSL(ev)\n    \n    case *event.TcSkbEvent:\n        // 来自 TC 钩子的网络数据包\n        err := m.dumpTcSkb(ev)  // 写入 PCAP 文件\n    \n    case *event.SSLDataEvent:\n        // 明文 SSL 数据\n        m.dumpSslData(ev)  // 发送到 EventProcessor\n    }\n}\n```\n\n模块维护有状态跟踪：\n- **连接映射**：`pidConns` 将 `[pid][fd] -> ConnInfo{tuple, sock}` 映射，用于将 SSL 数据关联到网络连接 [user/module/probe_openssl.go:91-94]()\n- **主密钥**：`masterKeys` 映射通过客户端随机数去重主密钥 [user/module/probe_openssl.go:98]()\n- **文件句柄**：`keylogger` 文件用于写入 SSLKEYLOGFILE 格式 [user/module/probe_openssl.go:96-97]()\n\n[user/module/probe_openssl.go:756-775]() 中的 `dumpSslData()` 方法查找连接信息并在发送到 `EventProcessor` 之前丰富 `SSLDataEvent`。\n\n**来源：** [user/module/imodule.go:408-448](), [user/module/probe_openssl.go:733-754](), [user/module/probe_openssl.go:756-775](), [user/module/probe_openssl.go:91-98]()\n\n## 完整的系统集成流程\n\n此图显示模块如何从 CLI 调用到事件输出与更广泛的 eCapture 系统集成。\n\n```mermaid\nsequenceDiagram\n    participant CLI as \"cobra.Command\"\n    participant Root as \"runModule()\"\n    participant Factory as \"GetModuleFunc()\"\n    participant Module as \"IModule（具体）\"\n    participant eBPF as \"ebpfmanager\"\n    participant Reader as \"事件读取器\"\n    participant Processor as \"EventProcessor\"\n    participant Output as \"io.Writer\"\n    \n    CLI->>Root: 执行命令\n    Root->>Root: setModConfig()\n    Root->>Root: initLogger()\n    Root->>Factory: GetModuleFunc(modName)\n    Factory-->>Root: modFunc()\n    Root->>Module: modFunc() 创建实例\n    \n    Note over Root,Module: 初始化阶段\n    Root->>Module: Init(ctx, logger, config, ecw)\n    Module->>Module: autoDetectBTF()\n    Module->>Module: 创建 EventProcessor\n    Module-->>Root: nil（成功）\n    \n    Note over Root,Module: 启动阶段\n    Root->>Module: Run()\n    Module->>Module: child.Start()\n    Module->>eBPF: bpfManager.InitWithOptions(bytecode)\n    Module->>eBPF: bpfManager.Start()\n    eBPF-->>Module: 程序已附加\n    \n    Note over Module,Output: 运行阶段\n    par 事件读取\n        Module->>Reader: perfEventReader(em)\n        Reader->>Reader: rd.Read() [循环]\n        Reader->>Module: Decode(em, bytes)\n        Reader->>Module: Dispatcher(event)\n    and EventProcessor\n        Module->>Processor: processor.Serve()\n        Processor->>Processor: 工作池运行\n    end\n    \n    Note over Module,Output: 分发阶段\n    Module->>Module: Dispatcher(event)\n    alt TypeOutput\n        Module->>Output: output() → Write()\n    else TypeEventProcessor\n        Module->>Processor: Write(event)\n        Processor->>Processor: 聚合/解析\n        Processor->>Output: Write(格式化)\n    else TypeModuleData\n        Module->>Module: child.Dispatcher(event)\n        Module->>Module: 保存到缓存/文件\n    end\n    \n    Note over CLI,Output: 清理阶段\n    CLI->>Root: 接收到信号\n    Root->>Module: Close()\n    Module->>Reader: 关闭所有读取器\n    Module->>Processor: Close()\n    Module->>eBPF: bpfManager.Stop()\n    Module-->>Root: nil（清理完成）\n```\n\n**图表：完整的模块集成序列**\n\n**来源：** [cli/cmd/root.go:249-403](), [user/module/imodule.go:236-262]()\n\n## 模块列表和能力\n\n下表总结了所有可用模块及其关键特征：\n\n| 模块 | 名称常量 | 主要目标 | eBPF 钩子 | 钩取的关键函数 | 事件类型 | 输出模式 |\n|--------|---------------|----------------|------------|----------------------|-------------|--------------|\n| MOpenSSLProbe | `openssl` | libssl.so, libcrypto.so | Uprobe, TC（pcap 模式） | SSL_read, SSL_write, SSL_do_handshake, SSL_get_wbio, SSL_in_before | SSLDataEvent, MasterSecretEvent, MasterSecretBSSLEvent, TcSkbEvent, ConnDataEvent | Text, PCAP, Keylog |\n| MGoTLSProbe | `gotls` | 使用 crypto/tls 的 Go 二进制文件 | Uprobe, TC（pcap 模式）, Kprobe（connect） | crypto/tls.(*Conn).Read, crypto/tls.(*Conn).Write, crypto/tls.(*clientHandshakeStateTLS13).handshake | TlsDataEvent, MasterSecretEvent, TcSkbEvent | Text, PCAP, Keylog |\n| MGnuTLSProbe | `gnutls` | libgnutls.so | Uprobe, TC（pcap/keylog 模式） | gnutls_record_recv, gnutls_record_send, gnutls_handshake | SSLDataEvent, MasterSecretEvent | Text, PCAP, Keylog |\n| MNSPRProbe | `nspr` | libnspr4.so（Firefox、Chrome） | Uprobe | PR_Read, PR_Write, PR_Send, PR_Recv | NsprDataEvent | Text |\n| MBashProbe | `bash` | /bin/bash | Uprobe | readline, bash_execute_command | BashEvent | Text |\n| MZshProbe | `zsh` | /bin/zsh | Uprobe | zleread, execcmd | ZshEvent | Text |\n| MMysqldProbe | `mysqld` | mysqld 二进制文件 | Uprobe | dispatch_command | MysqldEvent | Text |\n| MPostgresProbe | `postgres` | postgres 二进制文件 | Uprobe | exec_simple_query | PostgresEvent | Text |\n\n每个模块检测适当的库或二进制文件路径，解析符号地址，并在关键点附加 eBPF 程序以拦截数据。有关特定模块的详细信息，请参见页面 **3 捕获模块**。\n\n**来源：** [user/module/probe_openssl.go:777-786](), [user/module/imodule.go:47-75]()"
          },
          {
            "page_plan": {
              "id": "2.5",
              "title": "版本检测与字节码选择"
            },
            "content": "# 版本检测与字节码选择\n\n## 目的与范围\n\n版本检测与字节码选择系统使 eCapture 能够在运行时自动识别 SSL/TLS 库版本并选择兼容的 eBPF 字节码。这消除了大多数情况下手动指定版本的需要。该系统通过 ELF 解析、版本映射和回退策略处理超过 20 种不同的 OpenSSL/BoringSSL 变体。\n\n本页记录了 `MOpenSSLProbe` 版本检测机制、`sslVersionBpfMap` 映射结构以及 `detectOpenssl()` / `autoDetectBytecode()` 选择算法。\n\n相关章节：[eBPF 引擎](#2.1) 介绍字节码加载，[模块系统与生命周期](#2.4) 介绍初始化流程，[构建系统](#5.1) 介绍字节码编译。\n\n## 系统概述\n\neCapture 维护 22 个 OpenSSL/BoringSSL eBPF 字节码变体（包括 CO-RE 和 non-CO-RE 版本共 44 个文件）以支持：\n- **OpenSSL**：1.0.2a - 3.5.4（跨版本系列的 21 个变体）\n- **BoringSSL**：Android 12-16 和非 Android 版本（5 个变体）\n\n每个版本都有独特的内部结构偏移量，需要特定版本的字节码。`MOpenSSLProbe` 结构体通过三个核心函数管理此选择：\n- `detectOpenssl()`：解析 ELF `.rodata` 段获取版本字符串\n- `getSslBpfFile()`：将检测到的版本映射到字节码文件\n- `autoDetectBytecode()`：当无法精确匹配时应用回退策略\n\n**来源：** [variables.mk:189-228](), [user/module/probe_openssl_lib.go:30-42](), [user/module/probe_openssl.go:100-106]()\n\n## 版本检测架构\n\n**高层检测流程**\n\n```mermaid\nflowchart TB\n    Start[\"MOpenSSLProbe.start()\"]\n    \n    subgraph Detection[\"detectOpenssl(soPath)\"]\n        OpenFile[\"os.OpenFile(soPath)\"]\n        NewELF[\"elf.NewFile(f)\"]\n        CheckMachine[\"r.FileHeader.Machine<br/>EM_X86_64 或 EM_AARCH64\"]\n        GetSection[\"r.Section('.rodata')\"]\n        ReadLoop[\"读取 1MB 块<br/>30 字节重叠\"]\n        RegexMatch[\"rex.Find(buf)<br/>模式：OpenSSL\\s\\d\\.\\d\\.[0-9a-z]+\"]\n        ReturnVer[\"返回 versionKeyLower<br/>例如：'openssl 3.0.12'\"]\n    end\n    \n    subgraph Selection[\"getSslBpfFile(soPath, sslVersion)\"]\n        MapLookup[\"m.sslVersionBpfMap[sslVersion]\"]\n        Found{\"找到？\"}\n        CallDetect[\"m.detectOpenssl(soPath)\"]\n        CheckErr{\"err == ErrProbeOpensslVerNotFound?\"}\n        TryLibcrypto[\"尝试 libcrypto.so.3<br/>getImpNeeded(soPath)\"]\n        AutoDetect[\"m.autoDetectBytecode()\"]\n        SetBpfFile[\"m.sslBpfFile = bpfFile\"]\n    end\n    \n    subgraph Fallback[\"autoDetectBytecode(ver, soPath, isAndroid)\"]\n        IsAndroid{\"isAndroid?\"}\n        AndroidDefault[\"使用 AndroidDefaultFilename<br/>boringssl_a_13_kern.o\"]\n        Downgrade[\"downgradeOpensslVersion(ver)\"]\n        IsDowngrade{\"isDowngrade?\"}\n        CheckLibssl3{\"包含 'libssl.so.3'?\"}\n        Use30[\"LinuxDefaultFilename30<br/>openssl_3_0_0_kern.o\"]\n        Use111[\"LinuxDefaultFilename111<br/>openssl_1_1_1j_kern.o\"]\n    end\n    \n    Start --> Selection\n    Selection --> MapLookup\n    MapLookup --> Found\n    Found -->|否| CallDetect\n    CallDetect --> CheckErr\n    CheckErr -->|是| TryLibcrypto\n    CheckErr -->|否| MapLookup\n    TryLibcrypto --> MapLookup\n    Found -->|所有尝试后仍否| AutoDetect\n    Found -->|是| SetBpfFile\n    \n    AutoDetect --> IsAndroid\n    IsAndroid -->|是| AndroidDefault\n    IsAndroid -->|否| Downgrade\n    Downgrade --> IsDowngrade\n    IsDowngrade -->|是| SetBpfFile\n    IsDowngrade -->|否| CheckLibssl3\n    CheckLibssl3 -->|是| Use30\n    CheckLibssl3 -->|否| Use111\n    Use30 --> SetBpfFile\n    Use111 --> SetBpfFile\n    AndroidDefault --> SetBpfFile\n```\n\n**来源：** [user/module/probe_openssl.go:178-278](), [user/module/probe_openssl_lib.go:189-282](), [user/module/probe_openssl_lib.go:284-317]()\n\n## ELF 解析与版本提取\n\n`detectOpenssl()` 函数使用 ELF 解析从 SSL/TLS 共享库的 `.rodata` 段提取版本字符串。\n\n### 实现细节\n\n**函数签名：**\n```go\nfunc (m *MOpenSSLProbe) detectOpenssl(soPath string) (string, error)\n```\n\n**处理过程：**\n\n1. **打开 ELF 文件**：`elf.NewFile(f)` 位于 [user/module/probe_openssl_lib.go:194]()\n2. **架构检查**：验证 `r.FileHeader.Machine` 是 `EM_X86_64` 或 `EM_AARCH64`，位于 [user/module/probe_openssl_lib.go:199-204]()\n3. **定位 .rodata**：`r.Section(\".rodata\")` 返回包含只读数据的段，位于 [user/module/probe_openssl_lib.go:206]()\n4. **流式读取**：1MB 缓冲区，30 字节重叠（`OpenSslVersionLen = 30`），位于 [user/module/probe_openssl_lib.go:236-269]()\n5. **模式匹配**：正则表达式 `(OpenSSL\\s\\d\\.\\d\\.[0-9a-z]+)`，位于 [user/module/probe_openssl_lib.go:231]()\n6. **标准化**：`strings.ToLower(versionKey)` 返回小写版本，位于 [user/module/probe_openssl_lib.go:279]()\n\n### 边缘情况处理\n\n| 场景 | 代码位置 | 行为 |\n|------|---------|------|\n| 版本跨越缓冲区边界 | [user/module/probe_openssl_lib.go:261]() | 30 字节重叠防止分割 |\n| `.rodata` 未找到 | [user/module/probe_openssl_lib.go:208-210]() | 返回错误和消息 |\n| 无正则匹配 | [user/module/probe_openssl_lib.go:275-277]() | 返回 `ErrProbeOpensslVerNotFound` |\n| BoringSSL（无版本） | [user/module/probe_openssl.go:214-244]() | 回退到 Android 检测 |\n\n**提取示例：**\n- 输入：`\"OpenSSL 1.1.1j  16 Feb 2021\"` → 输出：`\"openssl 1.1.1j\"`\n- 输入：`\"OpenSSL 3.2.0 23 Nov 2023\"` → 输出：`\"openssl 3.2.0\"`\n- 输入：`\"BoringSSL\"` → 输出：`ErrProbeOpensslVerNotFound`\n\n**来源：** [user/module/probe_openssl_lib.go:189-282](), [user/module/probe_openssl_lib.go:30-42]()\n\n### OpenSSL 3.x 的 libcrypto.so 回退\n\n当 `detectOpenssl()` 在 `libssl.so.3` 上失败时，系统尝试解析 `libcrypto.so.3`：\n\n```mermaid\nflowchart TB\n    Detect[\"detectOpenssl(libssl.so.3)\"]\n    CheckErr{\"err == ErrProbeOpensslVerNotFound?\"}\n    CheckLib3{\"soPath 包含 'libssl.so.3'?\"}\n    GetImported[\"getImpNeeded(soPath)<br/>提取 DT_NEEDED 条目\"]\n    FindCrypto[\"在导入中搜索 'libcrypto.so'\"]\n    BuildPath[\"替换 'libssl.so.3' → 'libcrypto.so.3'\"]\n    RetryDetect[\"detectOpenssl(libcrypto.so.3)\"]\n    Success[\"在 libcrypto 中找到版本\"]\n    \n    Detect --> CheckErr\n    CheckErr -->|是| CheckLib3\n    CheckLib3 -->|是| GetImported\n    GetImported --> FindCrypto\n    FindCrypto --> BuildPath\n    BuildPath --> RetryDetect\n    RetryDetect --> Success\n```\n\n**原理：** OpenSSL 3.x 将功能分散在 `libssl.so.3` 和 `libcrypto.so.3` 中。版本字符串可能位于任一库中。`getImpNeeded()` 函数位于 [user/module/probe_openssl_lib.go:319-339]()，使用 `elf.DynString(elf.DT_NEEDED)` 查找链接的库。\n\n**来源：** [user/module/probe_openssl.go:214-244](), [user/module/probe_openssl_lib.go:319-339]()\n\n## 版本到字节码映射系统\n\n`sslVersionBpfMap` 映射（类型为 `map[string]string`）存储所有版本到字节码的关联。`initOpensslOffset()` 函数位于 [user/module/probe_openssl_lib.go:73-187]()，在 `MOpenSSLProbe.Init()` 期间填充此映射。\n\n### 映射表结构\n\n| 版本系列 | 版本范围 | 字节码文件 | 注释 |\n|---------|---------|-----------|------|\n| OpenSSL 1.0.2 | 1.0.2a - 1.0.2u | `openssl_1_0_2a_kern.o` | 所有 1.0.2 版本共享偏移量 |\n| OpenSSL 1.1.0 | 1.1.0a - 1.1.0l | `openssl_1_1_0a_kern.o` | 所有 1.1.0 版本共享偏移量 |\n| OpenSSL 1.1.1a | 仅 1.1.1a | `openssl_1_1_1a_kern.o` | 独特的偏移量组 |\n| OpenSSL 1.1.1b-c | 1.1.1b - 1.1.1c | `openssl_1_1_1b_kern.o` | 第二偏移量组 |\n| OpenSSL 1.1.1d-i | 1.1.1d - 1.1.1i | `openssl_1_1_1d_kern.o` | 第三偏移量组 |\n| OpenSSL 1.1.1j+ | 1.1.1j - 1.1.1w | `openssl_1_1_1j_kern.o` | 最常见的 1.1.1 变体 |\n| OpenSSL 3.0.x | 3.0.0 - 3.0.11, 3.0.13+ | `openssl_3_0_0_kern.o` | 3.0 系列默认版本 |\n| OpenSSL 3.0.12 | 仅 3.0.12 | `openssl_3_0_12_kern.o` | 具有独特偏移量的特殊情况 |\n| OpenSSL 3.1.x | 3.1.0 - 3.1.8 | `openssl_3_1_0_kern.o` | 与 3.0 系列共享基础 |\n| OpenSSL 3.2.0-2 | 3.2.0 - 3.2.2 | `openssl_3_2_0_kern.o` | 早期 3.2 系列 |\n| OpenSSL 3.2.3 | 仅 3.2.3 | `openssl_3_2_3_kern.o` | 结构变化 |\n| OpenSSL 3.2.5 | 仅 3.2.5 | `openssl_3_2_4_kern.o` | 额外变化 |\n| OpenSSL 3.3.0-1 | 3.3.0 - 3.3.1 | `openssl_3_3_0_kern.o` | 早期 3.3 系列 |\n| OpenSSL 3.3.2 | 仅 3.3.2 | `openssl_3_3_2_kern.o` | 中期系列变化 |\n| OpenSSL 3.3.3-4 | 3.3.3 - 3.3.4 | `openssl_3_3_3_kern.o` | 最新 3.3 系列 |\n| OpenSSL 3.4.0 | 仅 3.4.0 | `openssl_3_4_0_kern.o` | 初始 3.4 发布 |\n| OpenSSL 3.4.1+ | 3.4.1 - 3.4.2 | `openssl_3_4_1_kern.o` | 更新的 3.4 系列 |\n| OpenSSL 3.5.x | 3.5.0 - 3.5.4 | `openssl_3_5_0_kern.o` | 最新支持版本 |\n| BoringSSL A12-13 | Android 12-13 | `boringssl_a_13_kern.o` | Google 的分支 |\n| BoringSSL A14 | Android 14 | `boringssl_a_14_kern.o` | 更新的结构 |\n| BoringSSL A15 | Android 15 | `boringssl_a_15_kern.o` | 最新 Android |\n| BoringSSL A16 | Android 16 | `boringssl_a_16_kern.o` | 即将推出的 Android |\n| BoringSSL NA | 非 Android | `boringssl_na_kern.o` | 通用 BoringSSL |\n\n### 映射结构与初始化\n\n**数据结构：**\n```go\nm.sslVersionBpfMap = map[string]string{\n    \"openssl 1.1.1j\": \"openssl_1_1_1j_kern.o\",\n    \"openssl 3.0.12\": \"openssl_3_0_12_kern.o\",\n    \"boringssl_a_13\": \"boringssl_a_13_kern.o\",\n    // ... 100+ 条目\n}\n```\n\n**初始化模式：**\n\n```mermaid\nflowchart TB\n    Init[\"initOpensslOffset()\"]\n    \n    subgraph StaticEntries[\"静态默认条目\"]\n        E1[\"LinuxDefaultFilename102<br/>→ openssl_1_0_2a_kern.o\"]\n        E2[\"LinuxDefaultFilename110<br/>→ openssl_1_1_0a_kern.o\"]\n        E3[\"LinuxDefaultFilename111<br/>→ openssl_1_1_1j_kern.o\"]\n        E4[\"LinuxDefaultFilename30<br/>→ openssl_3_0_0_kern.o\"]\n        E5[\"AndroidDefaultFilename<br/>→ boringssl_a_13_kern.o\"]\n        E6[\"'boringssl 1.1.1'<br/>→ boringssl_a_13_kern.o\"]\n    end\n    \n    subgraph LoopGenerated[\"循环生成的条目\"]\n        L1[\"循环：ch='j' 到 MaxSupportedOpenSSL111Version='w'<br/>openssl 1.1.1{ch} → openssl_1_1_1j_kern.o\"]\n        L2[\"循环：ch=0 到 MaxSupportedOpenSSL30Version=17<br/>openssl 3.0.{ch} → openssl_3_0_0_kern.o\"]\n        L3[\"循环：ch=0 到 MaxSupportedOpenSSL31Version=8<br/>openssl 3.1.{ch} → openssl_3_1_0_kern.o\"]\n        L4[\"多个循环用于 3.2、3.3、3.4、3.5\"]\n    end\n    \n    subgraph Overrides[\"特殊覆盖条目\"]\n        O1[\"SupportedOpenSSL30Version12=12<br/>openssl 3.0.12 → openssl_3_0_12_kern.o\"]\n        O2[\"SupportedOpenSSL32Version3=3<br/>openssl 3.2.3 → openssl_3_2_3_kern.o\"]\n        O3[\"SupportedOpenSSL32Version4=5<br/>openssl 3.2.5 → openssl_3_2_4_kern.o\"]\n    end\n    \n    Init --> StaticEntries\n    StaticEntries --> LoopGenerated\n    LoopGenerated --> Overrides\n```\n\n**关键常量：** 所有版本限制定义在 [user/module/probe_openssl_lib.go:44-62]()\n- `MaxSupportedOpenSSL111Version = 'w'`\n- `MaxSupportedOpenSSL30Version = 17`\n- `MaxSupportedOpenSSL35Version = 4`\n\n**来源：** [user/module/probe_openssl_lib.go:73-187](), [user/module/probe_openssl_lib.go:44-62]()\n\n## 降级版本选择算法\n\n当 `sslVersionBpfMap` 查找失败时，`downgradeOpensslVersion()` 位于 [user/module/probe_openssl_lib.go:341-369]() 实现渐进式前缀匹配以找到最新的兼容旧版本。\n\n### 算法实现\n\n**函数签名：**\n```go\nfunc (m *MOpenSSLProbe) downgradeOpensslVersion(ver string, soPath string) (string, bool)\n// 返回值：(bpfFile, isDowngrade)\n```\n\n**截断循环：**\n\n```mermaid\nflowchart TD\n    Start[\"downgradeOpensslVersion(ver, soPath)\"]\n    Example[\"示例：ver = 'openssl 3.0.20'<br/>（不在 sslVersionBpfMap 中）\"]\n    \n    subgraph TruncateLoop[\"渐进式前缀截断\"]\n        I19[\"i=19: prefix='openssl 3.0.2'<br/>扫描映射查找匹配的键\"]\n        I18[\"i=18: prefix='openssl 3.0.'<br/>扫描映射查找匹配的键\"]\n        I17[\"i=17: prefix='openssl 3.0'<br/>扫描映射查找匹配的键\"]\n        Match[\"找到：'openssl 3.0.17'<br/>isVersionLessOrEqual() = true\"]\n    end\n    \n    subgraph Selection[\"候选选择\"]\n        Append[\"candidates.append('openssl 3.0.17')\"]\n        Sort[\"sort.Strings(candidates)<br/>按字母顺序排序\"]\n        Return[\"返回 sslVersionBpfMap[candidates[last]]<br/>= 'openssl_3_0_0_kern.o'\"]\n    end\n    \n    subgraph NoMatch[\"未找到匹配\"]\n        CheckLib[\"strings.Contains(soPath, 'libssl.so.3')\"]\n        ReturnDefault[\"返回 LinuxDefaultFilename111<br/>或 LinuxDefaultFilename30\"]\n    end\n    \n    Start --> Example\n    Example --> I19\n    I19 --> I18\n    I18 --> I17\n    I17 --> Match\n    Match --> Append\n    Append --> Sort\n    Sort --> Return\n    \n    I19 -.->|\"所有迭代后<br/>无候选\"| CheckLib\n    CheckLib --> ReturnDefault\n```\n\n**版本比较：** `isVersionLessOrEqual()` 位于 [user/module/probe_openssl_lib.go:372-422]()，按 `.` 分割版本字符串，使用 `extractVersionPart()` 位于 [user/module/probe_openssl_lib.go:425-448]() 提取数字和后缀部分，并逐组件比较。\n\n**示例：**\n- 输入：`ver = \"openssl 3.6.0\"`（不支持的未来版本）\n- 循环找到：`[\"openssl 3.5.0\", \"openssl 3.5.1\", \"openssl 3.5.4\"]`\n- 排序后返回：`sslVersionBpfMap[\"openssl 3.5.4\"]` = `\"openssl_3_5_0_kern.o\"`\n\n**来源：** [user/module/probe_openssl_lib.go:341-369](), [user/module/probe_openssl_lib.go:372-422]()\n\n## 默认回退行为\n\n当检测和降级都失败时，`autoDetectBytecode()` 位于 [user/module/probe_openssl_lib.go:284-317]() 应用平台特定的默认值。\n\n### 回退决策树\n\n```mermaid\nflowchart TD\n    Entry[\"autoDetectBytecode(ver, soPath, isAndroid)\"]\n    \n    subgraph AndroidPath[\"Android 平台\"]\n        IsAndroid{\"isAndroid == true?\"}\n        HasAndroidVer{\"androidVer 标志已设置？\"}\n        BuildKey[\"bpfFileKey = fmt.Sprintf('boringssl_a_%s', androidVer)\"]\n        LookupSpecific[\"m.sslVersionBpfMap[bpfFileKey]\"]\n        FoundSpecific{\"找到？\"}\n        UseSpecific[\"返回特定的 BoringSSL 变体\"]\n        UseAndroidDefault[\"返回 m.sslVersionBpfMap[AndroidDefaultFilename]<br/>'boringssl_a_13_kern.o'\"]\n    end\n    \n    subgraph LinuxPath[\"Linux 平台\"]\n        TryDowngrade[\"isDowngrade = m.downgradeOpensslVersion(ver, soPath)\"]\n        DowngradeOK{\"isDowngrade == true?\"}\n        CheckLib3{\"strings.Contains(soPath, 'libssl.so.3')?\"}\n        Use30[\"conf.SslVersion = LinuxDefaultFilename30<br/>返回 'openssl_3_0_0_kern.o'\"]\n        Use111[\"conf.SslVersion = LinuxDefaultFilename111<br/>返回 'openssl_1_1_1j_kern.o'\"]\n    end\n    \n    Entry --> IsAndroid\n    IsAndroid -->|是| HasAndroidVer\n    HasAndroidVer -->|是| BuildKey\n    BuildKey --> LookupSpecific\n    LookupSpecific --> FoundSpecific\n    FoundSpecific -->|是| UseSpecific\n    FoundSpecific -->|否| UseAndroidDefault\n    HasAndroidVer -->|否| UseAndroidDefault\n    \n    IsAndroid -->|否| TryDowngrade\n    TryDowngrade --> DowngradeOK\n    DowngradeOK -->|是| UseSpecific\n    DowngradeOK -->|否| CheckLib3\n    CheckLib3 -->|是| Use30\n    CheckLib3 -->|否| Use111\n```\n\n**默认常量：**\n- `LinuxDefaultFilename30 = \"linux_default_3_0\"` → `\"openssl_3_0_0_kern.o\"`\n- `LinuxDefaultFilename111 = \"linux_default_1_1_1\"` → `\"openssl_1_1_1j_kern.o\"`\n- `AndroidDefaultFilename = \"android_default\"` → `\"boringssl_a_13_kern.o\"`\n\n定义在 [user/module/probe_openssl_lib.go:30-40]()\n\n**来源：** [user/module/probe_openssl_lib.go:284-317](), [user/module/probe_openssl_lib.go:30-40](), [user/module/probe_openssl_lib.go:361-368]()\n\n## CO-RE 与 Non-CO-RE 字节码选择\n\n版本到字节码映射后，`geteBPFName()` 函数位于 [user/module/imodule.go:191-214]() 根据 BTF 可用性和用户配置附加 `_core.o` 或 `_noncore.o` 后缀。\n\n### 选择标准\n\n| 标准 | CO-RE 模式 | Non-CO-RE 模式 |\n|------|-----------|---------------|\n| 内核 BTF 支持 | `CONFIG_DEBUG_INFO_BTF=y` | 不需要 |\n| 最低内核版本 | 5.2+ (x86_64), 5.5+ (aarch64) | 4.18+ (x86_64), 5.5+ (aarch64) |\n| 字节码后缀 | `_core.o` | `_noncore.o` |\n| 重定位 | 通过 libbpf 在运行时 | 通过内核头在编译时 |\n| 可移植性 | 跨内核版本工作 | 绑定到特定内核 |\n\n### BTF 模式检测与后缀附加\n\n```mermaid\nflowchart TB\n    Start[\"Module.Init()\"]\n    \n    subgraph BTFDetection[\"BTF 模式选择\"]\n        CheckMode{\"conf.GetBTF()\"}\n        AutoDetect[\"BTFModeAutoDetect=0\"]\n        ManualCore[\"BTFModeCore=1\"]\n        ManualNonCore[\"BTFModeNonCore=2\"]\n        \n        CallAutoDetect[\"m.autoDetectBTF()\"]\n        CheckContainer[\"ebpfenv.IsContainer()\"]\n        CheckBTFFile[\"ebpfenv.IsEnableBTF()<br/>检查 /sys/kernel/btf/vmlinux\"]\n        SetCore[\"m.isCoreUsed = true\"]\n        SetNonCore[\"m.isCoreUsed = false\"]\n    end\n    \n    subgraph BytecodeSelection[\"geteBPFName(filename)\"]\n        CheckByteCodeMode{\"conf.GetByteCodeFileMode()\"}\n        CheckCoreUsed{\"m.isCoreUsed?\"}\n        AppendCore[\"替换 '.o' → '_core.o'\"]\n        AppendNonCore[\"替换 '.o' → '_noncore.o'\"]\n        CheckKernel{\"m.isKernelLess5_2?\"}\n        AppendLess52[\"替换 '.o' → '_less52.o'\"]\n        FinalName[\"返回修改后的文件名\"]\n    end\n    \n    Start --> CheckMode\n    CheckMode -->|0| AutoDetect\n    CheckMode -->|1| ManualCore\n    CheckMode -->|2| ManualNonCore\n    \n    AutoDetect --> CallAutoDetect\n    CallAutoDetect --> CheckContainer\n    CheckContainer --> CheckBTFFile\n    CheckBTFFile -->|已启用| SetCore\n    CheckBTFFile -->|已禁用| SetNonCore\n    \n    ManualCore --> SetCore\n    ManualNonCore --> SetNonCore\n    \n    SetCore --> BytecodeSelection\n    SetNonCore --> BytecodeSelection\n    \n    BytecodeSelection --> CheckByteCodeMode\n    CheckByteCodeMode -->|ByteCodeFileCore=1| AppendCore\n    CheckByteCodeMode -->|ByteCodeFileNonCore=2| AppendNonCore\n    CheckByteCodeMode -->|ByteCodeFileAll=0| CheckCoreUsed\n    CheckCoreUsed -->|true| AppendCore\n    CheckCoreUsed -->|false| AppendNonCore\n    AppendCore --> CheckKernel\n    AppendNonCore --> CheckKernel\n    CheckKernel -->|true| AppendLess52\n    CheckKernel -->|false| FinalName\n    AppendLess52 --> FinalName\n```\n\n**BTF 检测：** `IsEnableBTF()` 检查 `/sys/kernel/btf/vmlinux` 是否存在，位于 [pkg/util/ebpf/ebpf.go]()\n\n**转换示例：**\n- 输入：`\"openssl_3_0_0_kern.o\"`，CO-RE 模式，内核 5.10\n  - 输出：`\"openssl_3_0_0_kern_core.o\"`\n- 输入：`\"openssl_3_0_0_kern.o\"`，non-CO-RE 模式，内核 4.18\n  - 输出：`\"openssl_3_0_0_kern_noncore_less52.o\"`\n\n**来源：** [user/module/imodule.go:191-214](), [user/module/imodule.go:154-169](), [user/module/imodule.go:173-190]()\n\n## 字节码加载与验证\n\n选择后，`MOpenSSLProbe.start()` 通过 `ebpfmanager` 库加载并验证字节码。\n\n### 加载序列\n\n```mermaid\nsequenceDiagram\n    participant Start as MOpenSSLProbe.start()\n    participant Get as getSslBpfFile()\n    participant Assets as assets.Asset()\n    participant Manager as bpfManager\n    participant Verify as Verifier\n    \n    Start->>Get: getSslBpfFile(soPath, sslVersion)\n    Get->>Get: detectOpenssl() / autoDetectBytecode()\n    Get-->>Start: m.sslBpfFile 已设置（例如：\"openssl_3_0_0_kern.o\"）\n    \n    Start->>Start: bpfFileName = geteBPFName(m.sslBpfFile)<br/>→ \"openssl_3_0_0_kern_core.o\"\n    Start->>Assets: assets.Asset(bpfFileName)\n    Assets-->>Start: byteBuf []byte\n    \n    Start->>Manager: bpfManager.InitWithOptions(byteBuf, options)\n    Manager->>Manager: 解析 ELF 段\n    Manager->>Manager: 应用 CO-RE 重定位\n    Manager->>Verify: 内核验证器检查\n    Verify-->>Manager: VerifierError 或成功\n    Manager-->>Start: Manager 已初始化\n    \n    Start->>Manager: bpfManager.Start()\n    Manager->>Manager: 附加 uprobe 钩子\n    Manager->>Manager: 附加 TC 钩子（如果 PCAP 模式）\n    Manager-->>Start: 程序已附加\n```\n\n**关键函数：**\n- `assets.Asset()`：从 Go 二进制文件检索嵌入的字节码，位于 [user/module/probe_openssl.go:313]()\n- `InitWithOptions()`：解析字节码并应用重定位，位于 [user/module/probe_openssl.go:320]()\n- `Start()`：将 eBPF 程序附加到内核，位于 [user/module/probe_openssl.go:329]()\n\n**来源：** [user/module/probe_openssl.go:284-350](), [user/module/probe_openssl.go:178-278]()\n\n### 错误处理策略\n\n| 错误条件 | 恢复操作 | 日志消息 |\n|---------|---------|---------|\n| `.rodata` 中未找到版本 | 根据库名使用默认 | `\"OpenSSL/BoringSSL version not found, used default version\"` |\n| 字节码文件未找到 | 致命错误，退出 | `\"BPF bytecode file is not matched\"` |\n| Uprobe 附加失败 | 记录警告，继续 | `\"attach uprobe failed\"` |\n| 符号未找到 | 跳过该钩子 | `\"symbol not found, ignored\"` |\n\n**来源：** [user/module/probe_openssl_lib.go:189-282](), [user/module/probe_openssl_lib.go:284-317]()\n\n## 版本支持矩阵\n\n此表总结了完整的版本支持情况：\n\n| 库 | 最低版本 | 最高版本 | 总变体数 | 注释 |\n|----|---------|---------|---------|------|\n| OpenSSL 1.0.2 | 1.0.2a | 1.0.2u | 1 | 传统支持 |\n| OpenSSL 1.1.0 | 1.1.0a | 1.1.0l | 1 | 传统支持 |\n| OpenSSL 1.1.1 | 1.1.1a | 1.1.1w | 4 | 生产中最常见 |\n| OpenSSL 3.0 | 3.0.0 | 3.0.17 | 2 | Ubuntu 22.04+ 默认 |\n| OpenSSL 3.1 | 3.1.0 | 3.1.8 | 1 | 与 3.0 共享基础 |\n| OpenSSL 3.2 | 3.2.0 | 3.2.5 | 3 | 多次结构变化 |\n| OpenSSL 3.3 | 3.3.0 | 3.3.4 | 3 | 最新稳定版 |\n| OpenSSL 3.4 | 3.4.0 | 3.4.2 | 2 | 最近发布 |\n| OpenSSL 3.5 | 3.5.0 | 3.5.4 | 1 | 最新支持版本 |\n| BoringSSL Android | 12 | 16 | 4 | 每个 Android 版本 |\n| BoringSSL | 非 Android | N/A | 1 | 通用变体 |\n\n**总字节码文件数：** 22 个 SSL/TLS 变体 × 2 种模式（CO-RE + non-CO-RE）= 仅 OpenSSL/BoringSSL 就有 **44 个字节码文件**\n\n**来源：** [user/module/probe_openssl_lib.go:44-62](), [variables.mk:189-228](), [CHANGELOG.md:14-23]()\n\n## 配置选项\n\n用户可以通过 `OpensslConfig` 结构体中的 CLI 标志覆盖自动检测：\n\n| 标志 | 配置字段 | 类型 | 目的 |\n|-----|---------|------|------|\n| `--ssl_version` | `SslVersion` | `string` | 强制指定版本，绕过检测 |\n| `--libssl` | `ElfPath` | `string` | 指定库路径 |\n| `--android_ver` | `AndroidVer` | `string` | Android 版本（12-16） |\n| `-b, --btf` | `BtfMode` | `uint8` | BTF 模式：0=自动，1=core，2=non-core |\n\n**命令示例：**\n\n```bash\n# 手动版本覆盖\nsudo ecapture tls --ssl_version=\"openssl 3.2.3\" --libssl=/usr/local/lib/libssl.so.3\n\n# Android 设备（强制 BoringSSL A14）\nadb shell \"ecapture tls --android_ver=14\"\n\n# 强制 non-CO-RE 模式\nsudo ecapture tls -b 2\n\n# 强制 CO-RE 模式（需要 BTF）\nsudo ecapture tls -b 1\n```\n\n**版本覆盖逻辑：** 当设置 `--ssl_version` 时，`getSslBpfFile()` 位于 [user/module/probe_openssl.go:198-204]() 首先检查 `sslVersionBpfMap[sslVersion]`，完全跳过 ELF 检测。\n\n**来源：** [user/config/openssl.go](), [user/module/probe_openssl.go:178-278]()\n\n## 日志与诊断\n\n版本检测系统在多个阶段提供详细的日志记录：\n\n### 日志消息类别\n\n| 阶段 | 日志级别 | 示例消息 | 解释 |\n|------|---------|---------|------|\n| 检测成功 | INFO | `\"Openssl Version=openssl 3.0.12\"` | 找到精确版本 |\n| 默认回退 | WARN | `\"OpenSSL/BoringSSL version not found, used default version OpenSSL Version=linux_default_3_0\"` | 使用通用默认 |\n| 应用降级 | ERROR | `\"OpenSSL Version=openssl 3.6.0, used downgrade version openssl 3.5.4\"` | 更新版本，使用最接近的旧版本 |\n| 字节码匹配 | INFO | `\"BPF bytecode file is matched. bpfFileName=openssl_3_0_0_kern_core.o\"` | 字节码选择完成 |\n| BTF 模式 | INFO | `\"BTF bytecode mode: CORE. btfMode=0\"` | 已启用 CO-RE |\n\n### 故障排除指南\n\n**问题：** `\"OpenSSL/BoringSSL version not found\"`\n\n**解决方案：**\n1. 检查 `.rodata` 段是否存在：`readelf -S /path/to/libssl.so | grep rodata`\n2. 手动指定版本：`--ssl_version=\"openssl x.x.x\"`\n3. 对于 BoringSSL，使用：`--ssl_version=\"boringssl_a_13\"`\n\n**问题：** `\"BPF bytecode file is not matched\"`\n\n**解决方案：**\n1. 验证字节码文件存在：`ls user/bytecode/*.o`\n2. 检查构建是否完成：`make`\n3. 尝试强制版本：`--ssl_version`\n\n**问题：** 捕获工作但数据乱码\n\n**原因：** 版本/偏移量不匹配\n\n**解决方案：**\n1. 启用调试模式：`ecapture tls --debug`\n2. 尝试相邻版本：`--ssl_version=\"openssl 3.0.11\"` vs `\"openssl 3.0.13\"`\n3. 检查库版本：`openssl version` 或 `strings /lib/libssl.so.3 | grep \"OpenSSL\"`\n\n**来源：** [user/module/probe_openssl_lib.go:300-316](), [README.md:89-101]()"
          },
          {
            "page_plan": {
              "id": "2.6",
              "title": "网络连接跟踪"
            },
            "content": "# 网络连接跟踪\n\n## 目的与范围\n\n本文档解释了 eCapture 的网络连接跟踪系统，该系统将捕获的网络数据包与生成它们的进程关联起来。该系统通过维护网络四元组（协议、源/目标 IP/端口）与进程标识符（PID、UID、文件描述符）之间的双向映射，使得数据包级捕获（通过 TC eBPF 程序）能够与 SSL/TLS 明文数据（通过 uprobe 钩子）相关联。\n\n有关整体 eBPF 架构的信息，请参阅 [eBPF 引擎](#2.1)。有关 SSL/TLS 捕获和主密钥提取的详细信息，请参阅 [TLS/SSL 模块](#3.1)。有关 PCAP 输出集成，请参阅 [PCAP 集成](#4.2)。\n\n---\n\n## 概述\n\neCapture 中的网络连接跟踪主要服务于两个功能：\n\n1. **网络数据包的进程归属**：当 TC（流量控制）程序在网络层捕获数据包时，它们需要确定是哪个进程发送/接收了该数据包，以应用过滤器并丰富元数据。\n\n2. **明文数据的连接上下文**：当 uprobe 钩子捕获 SSL/TLS 明文数据时，它们需要将数据与网络连接元组关联，以便进行 PCAP 重建和协议解析。\n\n跟踪系统结合使用：\n- **内核空间**：在 `tcp_sendmsg`/`udp_sendmsg` 上的 kprobe 填充共享 eBPF 映射表\n- **内核空间**：TC 分类器查询映射表以将数据包归属到进程\n- **用户空间**：维护 SSL/TLS 文件描述符到套接字的连接状态跟踪\n\n来源：[kern/tc.h:1-398]()，[user/module/probe_openssl.go:78-481]()\n\n---\n\n## 架构概览\n\n```mermaid\ngraph TB\n    subgraph \"应用层\"\n        APP[\"应用进程<br/>(OpenSSL/Go TLS/等)\"]\n    end\n    \n    subgraph \"系统调用层\"\n        SSL_WRITE[\"SSL_write()<br/>SSL_read()\"]\n        TCP_SEND[\"tcp_sendmsg()<br/>udp_sendmsg()\"]\n    end\n    \n    subgraph \"内核 eBPF 层\"\n        KPROBE[\"Kprobe 钩子<br/>tcp_sendmsg<br/>udp_sendmsg\"]\n        UPROBE[\"Uprobe 钩子<br/>SSL 函数\"]\n        TC[\"TC 分类器<br/>egress_cls_func<br/>ingress_cls_func\"]\n        \n        NET_MAP[\"network_map<br/>BPF_MAP_TYPE_LRU_HASH<br/>net_id_t → net_ctx_t\"]\n    end\n    \n    subgraph \"用户空间跟踪\"\n        CONN_INFO[\"连接状态<br/>pidConns<br/>sock2pidFd\"]\n        CONN_EVENT[\"ConnDataEvent<br/>添加/销毁信号\"]\n    end\n    \n    subgraph \"数据流\"\n        PKT[\"数据包捕获<br/>带 PID/UID\"]\n        SSL_DATA[\"SSL 数据事件<br/>带 tuple/sock\"]\n    end\n    \n    APP --> SSL_WRITE\n    APP --> TCP_SEND\n    \n    SSL_WRITE --> UPROBE\n    TCP_SEND --> KPROBE\n    \n    KPROBE -->|\"插入\"| NET_MAP\n    NET_MAP -->|\"查找\"| TC\n    \n    TC --> PKT\n    UPROBE --> CONN_EVENT\n    CONN_EVENT --> CONN_INFO\n    \n    UPROBE --> SSL_DATA\n    CONN_INFO -->|\"丰富\"| SSL_DATA\n    \n    style NET_MAP fill:#f9f9f9,stroke:#333,stroke-width:2px\n    style CONN_INFO fill:#f9f9f9,stroke:#333,stroke-width:2px\n```\n\n**图表**：网络连接跟踪架构\n\n该图展示了双层跟踪系统。当连接建立时，kprobe 填充内核 `network_map`，允许 TC 程序归属数据包。另外，用户空间维护连接状态，以便用网络元组丰富 SSL/TLS 数据事件。\n\n来源：[kern/tc.h:57-77]()，[kern/tc.h:290-397]()，[user/module/probe_openssl.go:78-106]()\n\n---\n\n## 内核空间连接跟踪\n\n### 网络标识结构\n\n内核使用支持 IPv4 和 IPv6 的四元组标识符来跟踪连接：\n\n```mermaid\ngraph LR\n    subgraph \"struct net_id_t\"\n        PROTO[\"protocol<br/>(IPPROTO_TCP/UDP)\"]\n        SRC_PORT[\"src_port\"]\n        DST_PORT[\"dst_port\"]\n        \n        subgraph \"IPv4 字段\"\n            SRC_IP4[\"src_ip4\"]\n            DST_IP4[\"dst_ip4\"]\n        end\n        \n        subgraph \"IPv6 字段\"\n            SRC_IP6[\"src_ip6[4]\"]\n            DST_IP6[\"dst_ip6[4]\"]\n        end\n    end\n    \n    PROTO --> SRC_PORT\n    SRC_PORT --> DST_PORT\n    DST_PORT --> SRC_IP4\n    DST_PORT --> SRC_IP6\n```\n\n**图表**：网络标识结构（四元组）\n\n`net_id_t` 结构 [kern/tc.h:39-47]() 作为 eBPF 映射表的键。它包含 IPv4 和 IPv6 地址的字段，根据地址族只填充相关字段。\n\n| 字段 | 类型 | 描述 |\n|-------|------|-------------|\n| `protocol` | `u32` | IPPROTO_TCP (6) 或 IPPROTO_UDP (17) |\n| `src_port` | `u32` | 源端口号（主机字节序） |\n| `dst_port` | `u32` | 目标端口号（主机字节序） |\n| `src_ip4` | `u32` | 源 IPv4 地址 |\n| `dst_ip4` | `u32` | 目标 IPv4 地址 |\n| `src_ip6[4]` | `u32[4]` | 源 IPv6 地址（128 位） |\n| `dst_ip6[4]` | `u32[4]` | 目标 IPv6 地址（128 位） |\n\n来源：[kern/tc.h:39-47]()\n\n### 进程上下文结构\n\n每个连接都与进程上下文信息相关联：\n\n```mermaid\ngraph LR\n    subgraph \"struct net_ctx_t\"\n        PID[\"pid<br/>(进程 ID)\"]\n        UID[\"uid<br/>(用户 ID)\"]\n        COMM[\"comm[16]<br/>(命令名称)\"]\n    end\n    \n    PID --> UID\n    UID --> COMM\n```\n\n**图表**：进程上下文结构\n\n`net_ctx_t` 结构 [kern/tc.h:49-54]() 存储进程信息，稍后由 TC 程序用于过滤和归属。\n\n来源：[kern/tc.h:49-54]()\n\n### 基于 Kprobe 的连接注册\n\n系统钩住 `tcp_sendmsg` 和 `udp_sendmsg` 内核函数以捕获连接建立：\n\n```mermaid\nsequenceDiagram\n    participant App as 应用程序\n    participant Kernel as 内核 (tcp_sendmsg)\n    participant Kprobe as tcp_sendmsg Kprobe\n    participant NetMap as network_map\n\n    App->>Kernel: send() 系统调用\n    Kernel->>Kprobe: 钩子触发\n    \n    Note over Kprobe: 提取 sock 结构\n    Kprobe->>Kprobe: 读取 sk_family (AF_INET/AF_INET6)\n    Kprobe->>Kprobe: 从 sock 读取源/目标 IP 和端口\n    Kprobe->>Kprobe: 从当前任务获取 PID/UID\n    \n    Note over Kprobe: 构建 net_id_t 键\n    Note over Kprobe: 构建 net_ctx_t 值\n    \n    Kprobe->>NetMap: bpf_map_update_elem()\n    Note over NetMap: 存储 conn_id → net_ctx\n    \n    Kprobe-->>Kernel: 返回\n    Kernel-->>App: 继续执行\n```\n\n**图表**：Kprobe 连接注册序列\n\nkprobe 实现 [kern/tc.h:290-347]() 执行以下步骤：\n\n1. **提取进程上下文**：从 `bpf_get_current_pid_tgid()` 获取 PID，从 `bpf_get_current_uid_gid()` 获取 UID\n2. **读取套接字结构**：提取 `struct sock *` 参数并使用 `bpf_probe_read()` 读取网络字段\n3. **确定地址族**：检查 `sk->__sk_common.skc_family` 是否为 AF_INET (2) 或 AF_INET6 (10)\n4. **提取连接元组**：\n   - 本地端口：`sk->__sk_common.skc_num`（已经是主机字节序）\n   - 远程端口：`sk->__sk_common.skc_dport`（需要 `bpf_ntohs()`）\n   - 本地 IP：`skc_rcv_saddr` (IPv4) 或 `skc_v6_rcv_saddr` (IPv6)\n   - 远程 IP：`skc_daddr` (IPv4) 或 `skc_v6_daddr` (IPv6)\n5. **更新 eBPF 映射表**：使用 BPF_ANY 标志将映射插入 `network_map`\n\n重要的实现细节：\n\n- **kprobe 中无 PID/UID 过滤**：与其他 eBPF 程序不同，kprobe 不按 target_pid/target_uid 过滤 [kern/tc.h:296-302]()。这确保跟踪所有连接，允许 TC 程序稍后执行过滤。\n- **LRU 驱逐**：映射类型 `BPF_MAP_TYPE_LRU_HASH` [kern/tc.h:73]() 在满时自动驱逐最近最少使用的条目（最大 10240 条）。\n- **单独的 UDP 处理程序**：`udp_sendmsg` kprobe [kern/tc.h:349-397]() 使用相同的逻辑，但设置 `protocol = IPPROTO_UDP`。\n\n来源：[kern/tc.h:290-347]()，[kern/tc.h:349-397]()\n\n### 基于 TC 的数据包捕获和归属\n\n流量控制（TC）eBPF 分类器在入口和出口点捕获数据包：\n\n```mermaid\ngraph TB\n    subgraph \"数据包到达\"\n        PKT_IN[\"网络数据包\"]\n    end\n    \n    subgraph \"TC 分类器逻辑\"\n        PARSE_L2[\"解析以太网<br/>检查 ETH_P_IP/ETH_P_IPV6\"]\n        PARSE_L3[\"解析 IP 头<br/>提取协议\"]\n        PARSE_L4[\"解析 TCP/UDP 头<br/>提取端口\"]\n        \n        BUILD_KEY[\"构建 net_id_t 键\"]\n        LOOKUP[\"查找 network_map\"]\n        \n        FOUND{\"找到<br/>条目？\"}\n        SWAP[\"尝试反向查找<br/>(交换源/目标)\"]\n        FILTER[\"应用 PID/UID 过滤器\"]\n        \n        EVENT[\"构建 skb_data_event_t\"]\n        OUTPUT[\"bpf_perf_event_output()\"]\n    end\n    \n    PKT_IN --> PARSE_L2\n    PARSE_L2 -->|\"有效\"| PARSE_L3\n    PARSE_L3 -->|\"TCP/UDP/ICMP\"| PARSE_L4\n    PARSE_L4 --> BUILD_KEY\n    \n    BUILD_KEY --> LOOKUP\n    LOOKUP --> FOUND\n    FOUND -->|\"否\"| SWAP\n    SWAP --> LOOKUP\n    FOUND -->|\"是\"| FILTER\n    FILTER -->|\"通过\"| EVENT\n    EVENT --> OUTPUT\n    \n    PARSE_L2 -->|\"无效\"| DROP[\"返回 TC_ACT_OK\"]\n    PARSE_L3 -->|\"无效\"| DROP\n    FILTER -->|\"失败\"| DROP\n```\n\n**图表**：TC 数据包捕获和归属流程\n\n`capture_packets()` 函数 [kern/tc.h:135-276]() 实现了数据包捕获逻辑：\n\n**步骤 1：数据包解析**\n- 验证数据包长度：至少为 `sizeof(ethhdr) + sizeof(iphdr)` [kern/tc.h:141-144]()\n- 解析以太网头以确定 IPv4 还是 IPv6 [kern/tc.h:156-236]()\n- 使用 `skb_revalidate_data()` [kern/tc.h:102-119]() 确保在访问头之前有足够的数据\n- 提取协议（TCP/UDP/ICMP）和连接元组\n\n**步骤 2：连接查找**\n- 从数据包头构建 `net_id_t` 键\n- 调用 `bpf_map_lookup_elem(&network_map, &conn_id)` [kern/tc.h:188-198]()\n- 如果未找到，交换源/目标字段并重试（处理双向流量）\n\n**步骤 3：进程过滤**\n- 如果找到连接，则检查 `target_pid` 和 `target_uid` 常量 [kern/tc.h:243-250]()\n- 这些过滤器仅在内核 >= 5.2 上有效（KERNEL_LESS_5_2 检查）\n\n**步骤 4：事件生成**\n- 创建包含时间戳、PID、命令、数据包长度、接口索引的 `skb_data_event_t` [kern/tc.h:30-37]()\n- 使用 `bpf_perf_event_output()` [kern/tc.h:271]() 将最小事件数据（36 字节）加上数据包数据发送到用户空间\n\n**可选：PCAP 过滤**\nTC 程序通过 `filter_pcap_l2()` 函数 [kern/tc.h:128-132]() 支持运行时 PCAP 过滤器注入。这被实现为一个桩函数 `filter_pcap_ebpf_l2()` [kern/tc.h:122-126]()，在加载时由指令修补器替换 [user/module/probe_openssl.go:303-306]()。\n\n来源：[kern/tc.h:135-276]()，[kern/tc.h:279-288]()\n\n### 映射配置\n\n网络跟踪映射定义为：\n\n```c\nstruct {\n    __uint(type, BPF_MAP_TYPE_LRU_HASH);\n    __type(key, struct net_id_t);\n    __type(value, struct net_ctx_t);\n    __uint(max_entries, 10240);\n} network_map SEC(\".maps\");\n```\n\n| 参数 | 值 | 原因 |\n|-----------|-------|-----------|\n| 类型 | `BPF_MAP_TYPE_LRU_HASH` | 自动驱逐旧条目防止内存耗尽 |\n| 最大条目数 | 10,240 | 在内存使用和并发连接容量之间取得平衡 |\n| 键大小 | 56 字节 | `net_id_t` 结构（协议 + 端口 + IP） |\n| 值大小 | 20 字节 | `net_ctx_t` 结构（pid + uid + comm） |\n\n来源：[kern/tc.h:72-77]()\n\n---\n\n## 用户空间连接跟踪\n\n### 连接状态管理\n\nOpenSSL 探针在用户空间维护额外的连接状态，以将 SSL/TLS 操作与网络连接关联：\n\n```mermaid\ngraph TB\n    subgraph \"MOpenSSLProbe 状态\"\n        PID_CONNS[\"pidConns<br/>map[pid]map[fd]ConnInfo\"]\n        SOCK_MAP[\"sock2pidFd<br/>map[sock][pid,fd]\"]\n        LOCKER[\"pidLocker<br/>(sync.Mutex)\"]\n    end\n    \n    subgraph \"ConnInfo 结构\"\n        TUPLE[\"tuple: string<br/>(例如 192.168.1.1:443-10.0.0.1:54321)\"]\n        SOCK[\"sock: uint64<br/>(内核套接字指针)\"]\n    end\n    \n    PID_CONNS -->|\"包含\"| TUPLE\n    PID_CONNS -->|\"包含\"| SOCK\n    SOCK_MAP -->|\"反向查找\"| PID_CONNS\n    LOCKER -.->|\"保护\"| PID_CONNS\n    LOCKER -.->|\"保护\"| SOCK_MAP\n```\n\n**图表**：用户空间连接状态结构\n\n用户空间跟踪系统 [user/module/probe_openssl.go:78-106]() 维护两个同步的映射表：\n\n**1. 主映射表：`pidConns`**\n- 类型：`map[uint32]map[uint32]ConnInfo`\n- 结构：PID → 文件描述符 → 连接信息\n- 目的：为 SSL 操作按进程和文件描述符快速查找\n\n**2. 反向映射表：`sock2pidFd`**\n- 类型：`map[uint64][2]uint32`\n- 结构：套接字指针 → [PID, FD]\n- 目的：当内核通知套接字销毁时启用连接清理\n\n**连接信息字段：**\n- `tuple`：人类可读的连接字符串（格式：\"src_ip:src_port-dst_ip:dst_port\"）\n- `sock`：内核套接字指针（用于一致性检查）\n\n来源：[user/module/probe_openssl.go:78-106]()\n\n### 连接生命周期操作\n\n```mermaid\nstateDiagram-v2\n    [*] --> Established: AddConn(pid,fd,tuple,sock)\n    \n    Established --> Active: GetConn(pid,fd)\n    Active --> Established: 返回 ConnInfo\n    \n    Established --> Delayed: DelConn(sock)\n    Delayed --> Destroyed: 3 秒延迟\n    \n    Destroyed --> [*]: DestroyConn(sock)\n    \n    note right of Delayed\n        延迟销毁允许事件处理器\n        合并待处理的事件\n    end note\n```\n\n**图表**：连接生命周期状态机\n\n#### AddConn：连接注册\n\n```mermaid\nsequenceDiagram\n    participant eBPF as eBPF 程序\n    participant Dispatcher as Dispatcher()\n    participant AddConn as AddConn()\n    participant Maps as 连接映射表\n\n    eBPF->>Dispatcher: ConnDataEvent(IsDestroy=0)\n    Dispatcher->>AddConn: (pid, fd, tuple, sock)\n    \n    Note over AddConn: 锁定 pidLocker\n    AddConn->>Maps: 获取/创建 pidConns[pid]\n    AddConn->>Maps: 设置 pidConns[pid][fd] = ConnInfo\n    AddConn->>Maps: 设置 sock2pidFd[sock] = [pid,fd]\n    Note over AddConn: 解锁 pidLocker\n    \n    AddConn-->>Dispatcher: 成功\n```\n\n**图表**：AddConn 序列\n\n`AddConn()` 方法 [user/module/probe_openssl.go:398-416]() 在检测到新连接时被调用：\n\n1. **验证**：如果 `fd <= 0` 则拒绝 [user/module/probe_openssl.go:399-402]()\n2. **获取锁**：使用互斥锁防止并发修改 [user/module/probe_openssl.go:404]()\n3. **映射初始化**：如果不存在则为 PID 创建嵌套映射 [user/module/probe_openssl.go:406-409]()\n4. **存储连接**：添加带有元组和套接字指针的 `ConnInfo` [user/module/probe_openssl.go:410-411]()\n5. **反向映射**：存储 socket → [pid, fd] 以便清理 [user/module/probe_openssl.go:413]()\n\n来源：[user/module/probe_openssl.go:398-416]()\n\n#### GetConn：连接检索\n\n`GetConn()` 方法 [user/module/probe_openssl.go:464-480]() 为 SSL/TLS 数据事件检索连接信息：\n\n1. **快速验证**：如果 `fd <= 0` 则返回 nil [user/module/probe_openssl.go:465-467]()\n2. **锁定查找**：在互斥锁保护下访问映射表 [user/module/probe_openssl.go:469-470]()\n3. **两级查找**：首先查找 PID 的映射，然后查找 FD 的连接 [user/module/probe_openssl.go:471-479]()\n\n此方法由 `dumpSslData()` [user/module/probe_openssl.go:762]() 调用，以使用网络元组信息丰富 SSL 数据事件。\n\n来源：[user/module/probe_openssl.go:464-480]()，[user/module/probe_openssl.go:756-775]()\n\n#### DelConn：延迟销毁\n\n```mermaid\nsequenceDiagram\n    participant eBPF as eBPF 程序\n    participant Dispatcher as Dispatcher()\n    participant DelConn as DelConn()\n    participant Timer as time.AfterFunc\n    participant DestroyConn as DestroyConn()\n\n    eBPF->>Dispatcher: ConnDataEvent(IsDestroy=1)\n    Dispatcher->>DelConn: (sock)\n    \n    Note over DelConn: 安排延迟清理\n    DelConn->>Timer: 3 秒后\n    DelConn-->>Dispatcher: 立即返回\n    \n    Note over Timer: 等待 3 秒...\n    \n    Timer->>DestroyConn: 执行清理\n    Note over DestroyConn: 从映射表中移除\n```\n\n**图表**：延迟连接销毁\n\n`DelConn()` 方法 [user/module/probe_openssl.go:455-462]() 实现延迟清理：\n\n- **3 秒延迟**：使用 `time.AfterFunc()` 延迟实际销毁 [user/module/probe_openssl.go:459]()\n- **原因**：延迟必须超过事件处理器的合并间隔 [user/module/probe_openssl.go:456-458]()。这确保在删除连接状态之前处理所有待处理的事件。\n\n来源：[user/module/probe_openssl.go:455-462]()\n\n#### DestroyConn：实际清理\n\n`DestroyConn()` 方法 [user/module/probe_openssl.go:418-452]() 执行实际清理：\n\n1. **通知处理器**：向事件处理器发送信号以刷新连接数据 [user/module/probe_openssl.go:423-424]()\n2. **反向查找**：使用 `sock2pidFd` 查找 [pid, fd] [user/module/probe_openssl.go:426-429]()\n3. **一致性检查**：在删除前验证套接字指针匹配 [user/module/probe_openssl.go:441-445]()（防止竞态条件）\n4. **清理映射表**：从 `pidConns` 中移除，如果为空则可能删除整个 PID 映射 [user/module/probe_openssl.go:446-449]()\n\n来源：[user/module/probe_openssl.go:418-452]()\n\n---\n\n## 与 SSL/TLS 数据捕获的集成\n\n### 丰富 SSL 数据事件\n\n当 uprobe 钩子捕获 SSL/TLS 明文数据时，连接跟踪系统使用网络上下文丰富事件：\n\n```mermaid\nsequenceDiagram\n    participant Uprobe as SSL_write Uprobe\n    participant Dispatcher as Dispatcher()\n    participant DumpSslData as dumpSslData()\n    participant GetConn as GetConn()\n    participant Processor as 事件处理器\n\n    Uprobe->>Dispatcher: SSLDataEvent(pid, fd, data)\n    Dispatcher->>DumpSslData: 处理事件\n    \n    DumpSslData->>GetConn: (pid, fd)\n    \n    alt 找到连接\n        GetConn-->>DumpSslData: ConnInfo{tuple, sock}\n        Note over DumpSslData: 设置 event.Tuple<br/>设置 event.Sock\n    else 未找到连接\n        Note over DumpSslData: 设置 tuple = \"0.0.0.0:0-0.0.0.0:0\"<br/>设置 sock = 0\n    end\n    \n    DumpSslData->>Processor: 写入丰富的事件\n```\n\n**图表**：SSL 数据事件丰富流程\n\n`dumpSslData()` 方法 [user/module/probe_openssl.go:756-775]() 执行丰富操作：\n\n1. **验证**：检查 FD 是否有效以及 BIO 类型是否合适 [user/module/probe_openssl.go:758-761]()\n2. **连接查找**：调用 `GetConn(pid, fd)` [user/module/probe_openssl.go:762]()\n3. **后备处理**：如果未找到连接，使用默认元组 `\"0.0.0.0:0-0.0.0.0:0\"` [user/module/probe_openssl.go:763-766]()\n4. **事件丰富**：在事件上设置 `tuple` 和 `sock` 字段 [user/module/probe_openssl.go:769-770]()\n5. **转发到处理器**：将丰富的事件发送到事件处理器 [user/module/probe_openssl.go:774]()\n\n**默认元组常量：**\n常量 `DefaultTuple = \"0.0.0.0:0-0.0.0.0:0\"` [user/module/probe_openssl.go:43]() 在连接信息不可用时使用，通常用于：\n- 内存 BIO 操作（无网络套接字）\n- eCapture 启动前建立的连接\n- 文件描述符不匹配\n\n来源：[user/module/probe_openssl.go:756-775]()，[user/module/probe_openssl.go:42-43]()\n\n### 连接事件分发\n\n分发器将连接相关事件路由到适当的处理程序：\n\n```mermaid\ngraph TB\n    DISPATCHER[\"Dispatcher()<br/>event.IEventStruct\"]\n    \n    TYPE_CHECK{\"事件<br/>类型？\"}\n    \n    CONN_DATA[\"ConnDataEvent\"]\n    MASTER_SECRET[\"MasterSecretEvent\"]\n    TC_SKB[\"TcSkbEvent\"]\n    SSL_DATA[\"SSLDataEvent\"]\n    \n    CHECK_DESTROY{\"IsDestroy<br/>== 0？\"}\n    \n    ADD_CONN[\"AddConn()\"]\n    DEL_CONN[\"DelConn()\"]\n    \n    SAVE_MASTER[\"saveMasterSecret()\"]\n    DUMP_TC[\"dumpTcSkb()\"]\n    DUMP_SSL[\"dumpSslData()\"]\n    \n    DISPATCHER --> TYPE_CHECK\n    \n    TYPE_CHECK -->|\"ConnDataEvent\"| CONN_DATA\n    TYPE_CHECK -->|\"MasterSecretEvent\"| MASTER_SECRET\n    TYPE_CHECK -->|\"TcSkbEvent\"| TC_SKB\n    TYPE_CHECK -->|\"SSLDataEvent\"| SSL_DATA\n    \n    CONN_DATA --> CHECK_DESTROY\n    CHECK_DESTROY -->|\"是\"| ADD_CONN\n    CHECK_DESTROY -->|\"否\"| DEL_CONN\n    \n    MASTER_SECRET --> SAVE_MASTER\n    TC_SKB --> DUMP_TC\n    SSL_DATA --> DUMP_SSL\n```\n\n**图表**：事件分发器路由\n\n`Dispatcher()` 方法 [user/module/probe_openssl.go:733-754]() 使用类型开关来路由事件：\n\n- **ConnDataEvent**：来自 TC 或套接字操作的连接生命周期事件\n  - `IsDestroy == 0`：新连接 → `AddConn()` [user/module/probe_openssl.go:738]()\n  - `IsDestroy != 0`：关闭连接 → `DelConn()` [user/module/probe_openssl.go:740]()\n- **MasterSecretEvent**：TLS 主密钥 → `saveMasterSecret()` [user/module/probe_openssl.go:743]()\n- **TcSkbEvent**：TC 数据包捕获 → `dumpTcSkb()` [user/module/probe_openssl.go:747]()\n- **SSLDataEvent**：SSL/TLS 明文数据 → `dumpSslData()` [user/module/probe_openssl.go:752]()\n\n来源：[user/module/probe_openssl.go:733-754]()\n\n---\n\n## PCAP 模式集成\n\n在 PCAP 模式下，连接跟踪系统启用数据包级重建：\n\n```mermaid\ngraph TB\n    subgraph \"TC 层\"\n        TC_CAPTURE[\"TC 数据包捕获\"]\n        NET_MAP_LOOKUP[\"network_map 查找\"]\n        TC_EVENT[\"TcSkbEvent<br/>(带 PID/tuple)\"]\n    end\n    \n    subgraph \"SSL 层\"\n        SSL_CAPTURE[\"SSL Uprobe 捕获\"]\n        CONN_LOOKUP[\"GetConn(pid, fd)\"]\n        SSL_EVENT[\"SSLDataEvent<br/>(带 tuple/sock)\"]\n    end\n    \n    subgraph \"用户空间处理\"\n        TC_HANDLER[\"dumpTcSkb()\"]\n        SSL_HANDLER[\"dumpSslData()\"]\n        \n        PCAP_WRITER[\"PCAP-NG 写入器\"]\n        DSB_WRITER[\"DSB 块写入器<br/>(解密密钥)\"]\n    end\n    \n    TC_CAPTURE --> NET_MAP_LOOKUP\n    NET_MAP_LOOKUP --> TC_EVENT\n    TC_EVENT --> TC_HANDLER\n    \n    SSL_CAPTURE --> CONN_LOOKUP\n    CONN_LOOKUP --> SSL_EVENT\n    SSL_EVENT --> SSL_HANDLER\n    \n    TC_HANDLER --> PCAP_WRITER\n    SSL_HANDLER --> DSB_WRITER\n    DSB_WRITER --> PCAP_WRITER\n```\n\n**图表**：PCAP 模式连接跟踪集成\n\n在 PCAP 模式（`TlsCaptureModelTypePcap`）下，系统：\n\n1. **捕获网络数据包**：TC 程序捕获带有进程归属的原始数据包\n2. **捕获 TLS 密钥**：Uprobe 钩子提取带有连接元组的主密钥\n3. **通过元组关联**：两个数据流都写入同一个 PCAP-NG 文件，允许 Wireshark 通过匹配数据包头中的元组与 DSB（解密密钥块）记录中的密钥来解密 TLS 流量\n\n连接元组作为以下内容之间的关联键：\n- 加密网络数据包（来自 TC 层）\n- TLS 主密钥（来自 SSL/TLS 层）\n\n有关详细的 PCAP 输出格式，请参阅 [PCAP 集成](#4.2)。\n\n来源：[user/module/probe_openssl.go:137-154]()\n\n---\n\n## 性能考虑\n\n### 映射大小和驱逐\n\n`network_map` 使用 LRU（最近最少使用）驱逐，最多 10,240 个条目：\n\n| 场景 | 映射行为 | 影响 |\n|----------|-------------|--------|\n| 低连接数 | 所有连接被跟踪 | 所有数据包完全归属 |\n| 高连接流失 | 旧连接被驱逐 | 最近的连接优先 |\n| 映射已满 | LRU 条目被替换 | 可能会失去空闲连接的归属 |\n\n**缓解措施**：LRU 策略确保活跃连接保留在映射表中，而最近未发送数据包的空闲连接是驱逐的候选者。\n\n来源：[kern/tc.h:72-77]()\n\n### 锁竞争\n\n用户空间连接状态使用单个互斥锁（`pidLocker`）保护两个映射表 [user/module/probe_openssl.go:94]()：\n\n**锁点：**\n- `AddConn()`：在映射插入期间持有 [user/module/probe_openssl.go:404]()\n- `GetConn()`：在映射查找期间持有 [user/module/probe_openssl.go:469]()\n- `DestroyConn()`：在映射清理期间持有 [user/module/probe_openssl.go:419]()\n\n**优化机会**：当前实现使用全局锁。高并发场景可能受益于：\n- 按 PID 锁（分片）\n- 读写锁（许多查找，少量修改）\n- 无锁并发映射\n\n然而，对于典型工作负载，竞争很小，因为大多数操作快速完成（简单的映射操作）。\n\n来源：[user/module/probe_openssl.go:404]()，[user/module/probe_openssl.go:419]()，[user/module/probe_openssl.go:469]()\n\n### 延迟销毁原因\n\n`DelConn()` 中的 3 秒延迟 [user/module/probe_openssl.go:459]() 有特定目的：\n\n**问题**：事件可能无序到达或在 eBPF perf/ring 缓冲区中缓冲\n**解决方案**：在关闭后短暂保持连接状态活动，以确保所有事件都被丰富\n**权衡**：增加内存使用（短期）与数据完整性\n\n选择延迟是为了超过事件处理器的合并间隔，确保连接状态对引用它的所有事件都可用。\n\n来源：[user/module/probe_openssl.go:455-462]()\n\n---\n\n## 限制和边界情况\n\n### 内核版本约束\n\nTC 程序中的进程过滤仅在内核 >= 5.2 上有效：\n\n```c\n#ifndef KERNEL_LESS_5_2\n    if (target_pid != 0 && target_pid != net_ctx->pid) {\n        return TC_ACT_OK;\n    }\n    if (target_uid != 0 && target_uid != net_ctx->uid) {\n        return TC_ACT_OK;\n    }\n#endif\n```\n\n在旧内核上，TC 程序捕获所有数据包，无论 PID/UID 过滤器如何 [kern/tc.h:147-150]()，[kern/tc.h:243-250]()。\n\n来源：[kern/tc.h:243-250]()\n\n### 连接元组匹配\n\n双向查找 [kern/tc.h:188-198]() 处理两个方向的数据包：\n\n1. 首先使用数据包的 (src, dst) 查找\n2. 如果未找到，交换并使用 (dst, src) 查找\n\n**边界情况**：ICMP 数据包没有端口号，因此元组对于多连接场景可能不明确。\n\n来源：[kern/tc.h:188-198]()，[kern/tc.h:226-235]()\n\n### 竞态条件\n\n**套接字重用**：如果内核在关闭和新分配之间重用套接字指针，`DestroyConn()` 中的一致性检查 [user/module/probe_openssl.go:441-445]() 可防止错误删除：\n\n```go\nif connInfo.sock != sock {\n    m.logger.Debug().Msg(\"DestroyConn skip\")\n    return\n}\n```\n\n这确保只销毁确切的连接实例，而不是恰好使用相同套接字指针的新连接。\n\n来源：[user/module/probe_openssl.go:441-445]()\n\n### 缺失连接状态\n\n当 `GetConn()` 返回 nil 时，`dumpSslData()` 使用默认元组 [user/module/probe_openssl.go:763-766]()：\n\n**原因：**\n- 没有网络套接字的 BIO 操作（内存 BIO、文件 BIO）\n- eCapture 附加之前建立的连接\n- 文件描述符在事件之间关闭/重用\n\n**影响：**\n- PCAP 重建不可能（没有关联的元组）\n- 文本模式输出仍然有效（显示默认元组）\n- 事件处理器仍然可以通过 sock 字段合并事件\n\n来源：[user/module/probe_openssl.go:763-766]()\n\n---\n\n## 总结\n\neCapture 中的网络连接跟踪系统实现了复杂的多层关联机制：\n\n**内核空间：**\n- `tcp_sendmsg`/`udp_sendmsg` 上的 kprobe 填充连接映射表\n- TC 分类器查询映射表以进行数据包归属\n- LRU 驱逐以 10K 连接限制管理内存\n\n**用户空间：**\n- 双向映射表（pid/fd → conn，sock → pid/fd）实现快速查找\n- 延迟清理（3 秒）防止过早删除状态\n- 连接丰富将 SSL/TLS 数据与网络元组关联\n\n**关键设计原则：**\n1. **关注点分离**：内核跟踪网络，用户空间跟踪 SSL/TLS\n2. **双向查找**：支持数据包→进程和 fd→连接流程\n3. **优雅降级**：缺失的连接使用默认元组\n4. **性能优化**：LRU 驱逐、最小锁定、有针对性的过滤\n\n这种架构使 eCapture 能够通过关联加密的网络数据包与明文应用数据和解密密钥来提供 TLS 流量的完整可见性。\n\n来源：[kern/tc.h:1-398]()，[user/module/probe_openssl.go:1-787]()"
          },
          {
            "page_plan": {
              "id": "3",
              "title": "捕获模块"
            },
            "content": "# 捕获模块\n\n## 目的与范围\n\n本页面提供 eCapture 捕获模块系统的概述，该系统为不同的协议、库和应用程序实现了专门的数据捕获能力。每个模块针对特定的技术（OpenSSL、GnuTLS、Go TLS、Bash、MySQL 等），并实现通用接口以集成到 eCapture 的事件处理流程中。\n\n有关特定模块类型的详细信息，请参阅：\n- TLS/SSL 捕获实现：[TLS/SSL 模块](#3.1)\n- Shell 和数据库审计：[系统审计模块](#3.2)\n- 网络数据包捕获机制：[TC 网络数据包捕获](#3.3)\n- 模块接口和生命周期管理：[模块系统与生命周期](#2.4)\n\n## 模块系统概述\n\neCapture 的模块化架构允许通过统一的接口从不同来源捕获数据。每个模块负责：\n\n1. **目标检测**：定位要检测的适当二进制文件或共享库\n2. **eBPF 程序管理**：加载和附加特定版本的 eBPF 字节码\n3. **事件处理**：解码和格式化捕获的数据\n4. **输出生成**：以 text、pcap 或 keylog 格式生成数据\n\n该系统目前实现了 **8 个捕获模块**，每个模块都通过 CLI 子命令注册，并可通过模块注册表访问。\n\n来源：[README.md:152-161](), [cli/cmd/tls.go:29-48](), [cli/cmd/gotls.go:29-40]()\n\n## 模块注册表与架构\n\n```mermaid\ngraph TB\n    subgraph \"CLI 层\"\n        rootCmd[\"rootCmd<br/>(cobra.Command)\"]\n        tlsCmd[\"opensslCmd<br/>'tls' 子命令\"]\n        gotlsCmd[\"gotlsCmd<br/>'gotls' 子命令\"]\n        gnutlsCmd[\"gnutlsCmd<br/>'gnutls' 子命令\"]\n        nssCmd[\"nssCmd<br/>'nspr' 子命令\"]\n        bashCmd[\"bashCmd<br/>'bash' 子命令\"]\n        zshCmd[\"zshCmd<br/>'zsh' 子命令\"]\n        mysqldCmd[\"mysqldCmd<br/>'mysqld' 子命令\"]\n        postgresCmd[\"postgresCmd<br/>'postgres' 子命令\"]\n    end\n    \n    subgraph \"配置层\"\n        oc[\"OpensslConfig<br/>oc 变量\"]\n        goc[\"GoTLSConfig<br/>goc 变量\"]\n        gc[\"GnutlsConfig<br/>gc 变量\"]\n        nc[\"NsprConfig<br/>nc 变量\"]\n        bc[\"BashConfig<br/>bc 变量\"]\n        zc[\"ZshConfig<br/>zc 变量\"]\n        myc[\"MysqldConfig<br/>myc 变量\"]\n        pgc[\"PostgresConfig<br/>pgc 变量\"]\n    end\n    \n    subgraph \"模块层\"\n        modOpenssl[\"ModuleNameOpenssl<br/>常量\"]\n        modGotls[\"ModuleNameGotls<br/>常量\"]\n        modGnutls[\"ModuleNameGnutls<br/>常量\"]\n        modNspr[\"ModuleNameNspr<br/>常量\"]\n        modBash[\"ModuleNameBash<br/>常量\"]\n        modZsh[\"ModuleNameZsh<br/>常量\"]\n        modMysqld[\"ModuleNameMysqld<br/>常量\"]\n        modPostgres[\"ModuleNamePostgres<br/>常量\"]\n    end\n    \n    subgraph \"执行层\"\n        runModule[\"runModule()<br/>函数\"]\n    end\n    \n    rootCmd --> tlsCmd\n    rootCmd --> gotlsCmd\n    rootCmd --> gnutlsCmd\n    rootCmd --> nssCmd\n    rootCmd --> bashCmd\n    rootCmd --> zshCmd\n    rootCmd --> mysqldCmd\n    rootCmd --> postgresCmd\n    \n    tlsCmd --> oc\n    gotlsCmd --> goc\n    gnutlsCmd --> gc\n    nssCmd --> nc\n    bashCmd --> bc\n    zshCmd --> zc\n    mysqldCmd --> myc\n    postgresCmd --> pgc\n    \n    oc --> modOpenssl\n    goc --> modGotls\n    gc --> modGnutls\n    nc --> modNspr\n    bc --> modBash\n    zc --> modZsh\n    myc --> modMysqld\n    pgc --> modPostgres\n    \n    modOpenssl --> runModule\n    modGotls --> runModule\n    modGnutls --> runModule\n    modNspr --> runModule\n    modBash --> runModule\n    modZsh --> runModule\n    modMysqld --> runModule\n    modPostgres --> runModule\n```\n\n**模块注册架构**：每个模块都注册为一个 Cobra CLI 子命令，带有自己的配置对象。当被调用时，命令函数使用模块名称常量和配置调用 `runModule()`，通过模块注册表实例化相应的模块实现。\n\n来源：[cli/cmd/tls.go:26-67](), [cli/cmd/gotls.go:26-58](), [cli/cmd/bash.go:24-55](), [cli/cmd/mysqld.go:27-49](), [cli/cmd/postgres.go:27-45](), [cli/cmd/nspr.go:27-51](), [cli/cmd/gnutls.go:29-64](), [cli/cmd/zsh.go:27-57]()\n\n## 模块分类\n\neCapture 的 8 个模块根据捕获目标和技术分为三个功能类别：\n\n### TLS/SSL 加密库\n\n这些模块拦截加密函数，在加密前或解密后捕获明文数据：\n\n| 模块 | CLI 命令 | 目标库 | 支持版本 | 主要用途 |\n|--------|-------------|----------------|-------------------|------------------|\n| **OpenSSL** | `tls`, `openssl` | libssl.so | 1.0.x, 1.1.x, 3.0.x+ | 通用 TLS/HTTPS 捕获 |\n| **BoringSSL** | `tls` | libssl.so | Android 12-16 | Android HTTPS 捕获 |\n| **Go TLS** | `gotls`, `tlsgo` | 内置 crypto/tls | 所有 Go 版本 | Go 应用程序捕获 |\n| **GnuTLS** | `gnutls`, `gnu` | libgnutls.so | 3.x | 替代 TLS 库 |\n| **NSPR/NSS** | `nspr`, `nss` | libnspr4.so | 所有版本 | Firefox/Thunderbird |\n\n来源：[README.md:152-161](), [README_CN.md:128-138](), [cli/cmd/tls.go:29-33](), [cli/cmd/gotls.go:29-33](), [cli/cmd/gnutls.go:32-36](), [cli/cmd/nspr.go:30-34]()\n\n### 系统审计与命令捕获\n\n这些模块挂钩到命令解释器和数据库服务器进行安全审计：\n\n| 模块 | CLI 命令 | 目标二进制 | 钩子点 | 审计能力 |\n|--------|-------------|---------------|-------------|------------------|\n| **Bash** | `bash` | /bin/bash | readline 库 | 命令输入/输出 |\n| **Zsh** | `zsh` | /bin/zsh | readline 函数 | 命令执行 |\n| **MySQL** | `mysqld` | /usr/sbin/mysqld | dispatch_command | SQL 查询日志 |\n| **PostgreSQL** | `postgres` | /usr/bin/postgres | 查询执行 | SQL 审计 |\n\n来源：[README.md:152-161](), [cli/cmd/bash.go:27-32](), [cli/cmd/zsh.go:30-35](), [cli/cmd/mysqld.go:30-36](), [cli/cmd/postgres.go:30-33]()\n\n### 网络数据包捕获\n\n网络级捕获通过流量控制（TC）eBPF 分类器集成到 TLS/SSL 模块中。详见 [TC 网络数据包捕获](#3.3)。\n\n## 详细模块描述\n\n```mermaid\ngraph LR\n    subgraph \"TLS/SSL 模块\"\n        direction TB\n        M1[\"MOpenSSLProbe\"]\n        M1_desc[\"钩子：SSL_read/SSL_write<br/>SSL_do_handshake<br/>主密钥提取\"]\n        \n        M2[\"MGoTLSProbe\"]\n        M2_desc[\"钩子：crypto/tls.Conn.Read<br/>crypto/tls.Conn.Write<br/>PIE 二进制支持\"]\n        \n        M3[\"MGnuTLSProbe\"]\n        M3_desc[\"钩子：gnutls_record_recv<br/>gnutls_record_send<br/>早期密钥支持\"]\n        \n        M4[\"MNSPRProbe\"]\n        M4_desc[\"钩子：PR_Read/PR_Write<br/>NSS/Firefox 加密\"]\n        \n        M1 -.-> M1_desc\n        M2 -.-> M2_desc\n        M3 -.-> M3_desc\n        M4 -.-> M4_desc\n    end\n    \n    subgraph \"系统审计模块\"\n        direction TB\n        M5[\"MBashProbe\"]\n        M5_desc[\"钩子：readline()<br/>命令行输入<br/>返回值过滤\"]\n        \n        M6[\"MZshProbe\"]\n        M6_desc[\"钩子：zsh readline<br/>Zsh 命令捕获\"]\n        \n        M7[\"MMysqldProbe\"]\n        M7_desc[\"钩子：dispatch_command()<br/>MySQL 5.6/5.7/8.0<br/>MariaDB 10.5+\"]\n        \n        M8[\"MPostgresProbe\"]\n        M8_desc[\"钩子：exec_simple_query<br/>PostgreSQL 10+\"]\n        \n        M5 -.-> M5_desc\n        M6 -.-> M6_desc\n        M7 -.-> M7_desc\n        M8 -.-> M8_desc\n    end\n```\n\n**模块实现细节**：每个模块实现为一个单独的结构体，嵌入通用功能并实现模块特定的钩子点和事件处理逻辑。\n\n### OpenSSL/BoringSSL 模块\n\n`tls` 命令针对 OpenSSL 和 BoringSSL 库，提供最全面的 TLS 捕获能力。它支持：\n\n- **版本检测**：自动检测 OpenSSL 1.0.2 到 3.5.x 以及 Android BoringSSL A12-A16\n- **三种捕获模式**：\n  - `text`：直接明文捕获，支持 HTTP/HTTP2 解析\n  - `pcap`/`pcapng`：网络数据包捕获，嵌入解密密钥\n  - `keylog`/`key`：TLS 主密钥提取，用于外部解密\n- **钩子点**：`SSL_read`、`SSL_write`、`SSL_do_handshake`、`SSL_get_wbio`、`SSL_in_before`\n- **连接跟踪**：通过 TC 和 kprobe 钩子进行 4 元组网络跟踪\n\n来源：[cli/cmd/tls.go:29-48](), [README.md:163-253](), [CHANGELOG.md:14-24]()\n\n### Go TLS 模块\n\n`gotls` 命令从使用标准 `crypto/tls` 包的 Go 应用程序捕获明文：\n\n- **二进制分析**：解析 Go 二进制元数据以定位 TLS 函数\n- **PIE 支持**：处理位置无关可执行文件，动态计算偏移量\n- **ABI 兼容性**：支持基于寄存器和基于栈的调用约定\n- **捕获模式**：与 OpenSSL 相同的三种模式（text、pcap、keylog）\n\n来源：[cli/cmd/gotls.go:29-40](), [README.md:254-276](), [CHANGELOG.md:21-29]()\n\n### GnuTLS 模块\n\n`gnutls` 命令针对 wget 和其他应用程序使用的 GnuTLS 库：\n\n- **钩子点**：`gnutls_record_recv`、`gnutls_record_send`\n- **版本支持**：GnuTLS 3.x，支持自动版本检测\n- **早期密钥支持**：捕获 TLS 1.3 早期密钥，用于 0-RTT 解密\n- **捕获模式**：text、pcap、keylog\n\n来源：[cli/cmd/gnutls.go:32-45](), [CHANGELOG.md:126-127]()\n\n### NSPR/NSS 模块\n\n`nspr` 命令捕获来自 Firefox、Thunderbird 和其他 Mozilla 应用程序的流量：\n\n- **目标**：NSS 使用的 NSPR（Netscape Portable Runtime）库\n- **钩子点**：`PR_Read`、`PR_Write` 函数\n- **应用程序支持**：Firefox 浏览器、Thunderbird 电子邮件客户端\n\n来源：[cli/cmd/nspr.go:30-40](), [README.md:158]()\n\n### Bash 模块\n\n`bash` 命令为 Bash shell 提供命令行审计：\n\n- **钩子点**：libreadline 中的 `readline()` 函数\n- **捕获数据**：执行前的命令输入，执行后的返回值\n- **过滤**：可选的 errno 过滤，仅捕获失败的命令\n- **自动检测**：从 `$SHELL` 环境变量自动定位 bash 二进制文件\n\n命令用法：\n```\necapture bash [--bash=/bin/bash] [--errnumber=N]\n```\n\n来源：[cli/cmd/bash.go:27-55](), [README.md:153]()\n\n### Zsh 模块\n\n`zsh` 命令为 Zsh shell 提供类似的审计功能：\n\n- **钩子点**：Zsh 特定的 readline 实现\n- **功能**：命令捕获、返回值跟踪、errno 过滤\n- **平台支持**：仅限 Linux（通过构建标签从 Android 构建中排除）\n\n来源：[cli/cmd/zsh.go:30-57](), [README.md:154](), [CHANGELOG.md:369]()\n\n### MySQL 模块\n\n`mysqld` 命令从 MySQL 和 MariaDB 服务器捕获 SQL 查询：\n\n- **版本支持**：MySQL 5.6、5.7、8.0 以及 MariaDB 10.5+\n- **钩子点**：特定版本偏移量处的 `dispatch_command()` 函数\n- **捕获数据**：完整的 SQL 查询文本，带时间戳和连接信息\n- **偏移量支持**：为自定义构建手动指定偏移量\n\n命令用法：\n```\necapture mysqld [--mysqld=/usr/sbin/mysqld] [--funcname=dispatch_command]\n```\n\n来源：[cli/cmd/mysqld.go:30-49](), [README.md:157]()\n\n### PostgreSQL 模块\n\n`postgres` 命令为 PostgreSQL 数据库提供查询审计：\n\n- **版本支持**：PostgreSQL 10 及更新版本\n- **钩子点**：查询执行函数\n- **函数自定义**：允许为不同构建指定自定义函数名称\n\n来源：[cli/cmd/postgres.go:30-45](), [README.md:159]()\n\n## 通用模块功能\n\n所有捕获模块通过 eCapture 框架共享一组通用能力：\n\n### 配置接口\n\n每个模块实现一个 `IConfig` 接口，带有通用参数：\n\n| 参数 | 标志 | 描述 | 默认值 |\n|-----------|------|-------------|---------|\n| PID 过滤 | `--pid` | 针对特定进程 ID | 所有进程 |\n| UID 过滤 | `--uid` | 针对特定用户 ID | 所有用户 |\n| 输出文件 | `-l`, `--logaddr` | 将事件保存到文件 | stdout |\n| 十六进制模式 | `--hex` | 以十六进制显示数据 | false |\n| BTF 模式 | `--btf` | 指定 BTF 字节码模式 | 自动检测 |\n| 映射大小 | `--mapsize` | eBPF 映射大小（KB） | 5120 |\n\n来源：[cli/cmd/tls.go:50-58](), [cli/cmd/gotls.go:42-48]()\n\n### 输出模式\n\nTLS/SSL 模块支持三种由 `-m`/`--model` 标志控制的输出模式：\n\n1. **文本模式**（`-m text`）：直接明文输出，支持 HTTP/HTTP2 解析\n2. **PCAP 模式**（`-m pcap`）：网络数据包捕获，嵌入解密密钥\n3. **Keylog 模式**（`-m keylog`）：仅提取 TLS 主密钥\n\n详细信息请参阅 [输出格式](#4)。\n\n来源：[cli/cmd/tls.go:53](), [cli/cmd/gotls.go:45](), [README.md:171-253]()\n\n### 网络集成\n\nTLS/SSL 模块可以附加 TC（流量控制）eBPF 分类器以进行网络数据包捕获：\n\n- **接口选择**：`-i`/`--ifname` 指定网络接口\n- **PCAP 过滤器**：可选的 BPF 过滤器表达式（例如 `tcp port 443`）\n- **连接映射**：通过 kprobe 钩子将网络流映射到进程\n\n来源：[cli/cmd/tls.go:56](), [README.md:180-229]()\n\n## 模块选择与调用\n\n```mermaid\nsequenceDiagram\n    participant User as \"用户\"\n    participant CLI as \"Cobra CLI\"\n    participant Cmd as \"命令函数\"\n    participant Run as \"runModule()\"\n    participant Registry as \"模块注册表\"\n    participant Module as \"IModule 实现\"\n    participant eBPF as \"eBPF 管理器\"\n    \n    User->>CLI: ecapture tls -m pcap -i eth0\n    CLI->>Cmd: opensslCmd.RunE()\n    Cmd->>Cmd: 解析参数到 OpensslConfig\n    Cmd->>Run: runModule(ModuleNameOpenssl, oc)\n    Run->>Registry: GetModuleFunc(ModuleNameOpenssl)\n    Registry->>Module: NewOpenSSLProbe(oc)\n    Module->>Module: Init()\n    Module->>eBPF: 加载字节码，附加探针\n    Module->>Module: Start()\n    Module->>Module: Run() - 事件循环\n    Note over Module: 捕获和处理事件\n    User->>Module: Ctrl+C 信号\n    Module->>Module: Close()\n    Module->>eBPF: 分离探针\n    Module-->>User: 清理完成\n```\n\n**模块调用流程**：CLI 框架将子命令路由到各自的处理函数，这些函数创建模块特定的配置并调用 `runModule()` 来实例化和执行相应的模块实现。\n\n模块选择过程：\n\n1. **CLI 解析**：用户调用子命令（例如 `ecapture tls`）\n2. **配置创建**：命令处理程序创建模块特定的配置对象\n3. **模块实例化**：`runModule()` 通过名称常量查找模块\n4. **生命周期执行**：模块经历 Init → Start → Run → Close 阶段\n5. **事件处理**：模块处理事件直到被中断\n\n来源：[cli/cmd/tls.go:62-67](), [cli/cmd/gotls.go:52-58](), [main.go:1-11]()\n\n## 模块构建配置\n\n模块可以根据平台和功能要求有条件地编译：\n\n- **构建标签**：`//go:build !androidgki` 从 Android 内核构建中排除模块\n- **平台特定**：某些模块（bash、gnutls、nspr、mysqld、postgres、zsh）仅限 Linux\n- **通用模块**：OpenSSL 和 GoTLS 模块支持 Linux 和 Android\n\nAndroid 排除的模块：\n- GnuTLS: [cli/cmd/gnutls.go:1-2]()\n- NSPR/NSS: [cli/cmd/nspr.go:1-2]()\n- MySQL: [cli/cmd/mysqld.go:1-2]()\n- PostgreSQL: [cli/cmd/postgres.go:1-2]()\n- Zsh: [cli/cmd/zsh.go:1-2]()\n\n来源：[cli/cmd/gnutls.go:1-2](), [cli/cmd/nspr.go:1-2](), [cli/cmd/mysqld.go:1-2](), [cli/cmd/postgres.go:1-2](), [cli/cmd/zsh.go:1-2]()\n\n## 版本历史与演进\n\n变更日志中记录的最近模块增强：\n\n- **v1.5.0**：OpenSSL 3.5.4 支持、Android 16 BoringSSL、HTTP/2 解析器改进\n- **v1.4.0**：WebSocket 事件转发、OpenSSL 版本降级逻辑\n- **v1.3.0**：GnuTLS 早期密钥支持、keylog 改进\n- **v1.2.0**：事件工作器双重生命周期管理\n- **v1.0.0**：稳定版本，支持多协议\n- **v0.9.0**：Zsh 命令捕获、连接清理改进\n- **v0.7.0**：模块拆分（OpenSSL/GnuTLS/NSPR 分离）、引入 keylog 模式\n\n来源：[CHANGELOG.md:11-757]()"
          },
          {
            "page_plan": {
              "id": "3.1",
              "title": "TLS/SSL 模块"
            },
            "content": "# TLS/SSL 模块\n\n## 目的与范围\n\n本文档概述了 eCapture 的 TLS/SSL 捕获模块，这些模块能够在无需 CA 证书或修改 SSL/TLS 库的情况下捕获加密网络流量的明文。TLS/SSL 模块集合支持多个加密库，包括 OpenSSL、BoringSSL、GnuTLS 和 NSS/NSPR，提供三种不同的捕获模式：文本输出、PCAP 数据包捕获和密钥日志生成。\n\n有关特定模块的详细实现，请参阅：\n- OpenSSL/BoringSSL 实现：[OpenSSL 模块](#3.1.1)\n- Go TLS 实现：[Go TLS 模块](#3.1.2)\n- GnuTLS 和 NSS 实现：[GnuTLS 与 NSS 模块](#3.1.3)\n- 主密钥提取机制：[主密钥提取](#3.1.4)\n\n有关网络数据包捕获的详细信息，请参阅 [TC 网络数据包捕获](#3.3)。\n\n---\n\n## 支持的 TLS/SSL 库\n\neCapture 通过专用模块支持多种 TLS/SSL 库实现。每个模块使用 eBPF uprobe 拦截加密库函数并提取明文数据或主密钥。\n\n| 模块名称 | 支持的库 | 版本覆盖范围 | 平台支持 |\n|-------------|-------------------|------------------|------------------|\n| `tls` | OpenSSL, LibreSSL, BoringSSL | OpenSSL 1.0.2 - 3.5.x<br/>BoringSSL Android 12-16 | Linux x86_64/aarch64<br/>Android |\n| `gotls` | Go crypto/tls | Go 1.8+ (所有版本) | Linux x86_64/aarch64 |\n| `gnutls` | GnuTLS | 3.x 系列 | Linux x86_64/aarch64 |\n| `nss` | NSS/NSPR (Firefox, Chrome) | NSS 3.x 系列 | Linux x86_64/aarch64 |\n\n**来源：** [README.md:38-42](), [CHANGELOG.md:202-204](), [cli/cmd/root.go:152-161]()\n\n---\n\n## 捕获模式\n\n所有 TLS/SSL 模块都支持三种操作模式，用于确定捕获数据的处理和输出方式。通过 `-m` 命令行标志选择模式。\n\n### 捕获模式对比\n\n```mermaid\ngraph TB\n    subgraph \"输入：加密的 TLS 流量\"\n        APP[\"使用 OpenSSL/GnuTLS/NSS<br/>的应用程序\"]\n    end\n    \n    subgraph \"eCapture TLS 模块\"\n        UPROBE[\"eBPF Uprobes<br/>SSL_read/SSL_write<br/>SSL_do_handshake\"]\n        DETECT[\"版本检测<br/>字节码选择\"]\n        \n        APP --> UPROBE\n        UPROBE --> DETECT\n    end\n    \n    subgraph \"捕获模式选择\"\n        TEXT[\"文本模式<br/>-m text\"]\n        PCAP[\"PCAP 模式<br/>-m pcap\"]\n        KEYLOG[\"密钥日志模式<br/>-m keylog\"]\n        \n        DETECT --> TEXT\n        DETECT --> PCAP\n        DETECT --> KEYLOG\n    end\n    \n    subgraph \"输出格式\"\n        TEXT_OUT[\"控制台/文件<br/>HTTP/HTTP2 解析<br/>直接明文\"]\n        PCAP_OUT[\"PCAP-NG 文件<br/>网络数据包<br/>+ DSB 密钥块\"]\n        KEYLOG_OUT[\"SSLKEYLOGFILE<br/>主密钥<br/>CLIENT_RANDOM 格式\"]\n        \n        TEXT --> TEXT_OUT\n        PCAP --> PCAP_OUT\n        KEYLOG --> KEYLOG_OUT\n    end\n    \n    subgraph \"使用场景\"\n        TEXT_OUT --> UC1[\"实时监控<br/>安全分析\"]\n        PCAP_OUT --> UC2[\"Wireshark 分析<br/>网络调试\"]\n        KEYLOG_OUT --> UC3[\"离线解密<br/>tshark 集成\"]\n    end\n```\n\n**来源：** [user/module/probe_openssl.go:58-76](), [user/config/iconfig.go:73-79](), [README.md:171-252]()\n\n### 模式配置类型\n\n捕获模式由 `TlsCaptureModelType` 枚举表示：\n\n```go\ntype TlsCaptureModelType uint8\n\nconst (\n    TlsCaptureModelTypePcap   TlsCaptureModelType = iota  // PCAP-NG 格式\n    TlsCaptureModelTypeText                                // 文本输出\n    TlsCaptureModelTypeKeylog                             // 密钥日志格式\n)\n```\n\n**模式选择逻辑：**\n\n1. **文本模式**（`-m text` 或默认）：捕获明文数据并直接输出到控制台或文件。支持 HTTP/1.x 和 HTTP/2 协议解析以实现结构化输出。\n\n2. **PCAP 模式**（`-m pcap` 或 `-m pcapng`）：以 PCAP-NG 格式捕获带有明文载荷和主密钥的网络数据包。需要 `-i`（网络接口）和 `--pcapfile` 参数。支持与 Wireshark 兼容的解密密钥块（DSB），可实现自动解密。\n\n3. **密钥日志模式**（`-m keylog` 或 `-m key`）：仅捕获 TLS 主密钥，格式为与 Wireshark 和 tshark 兼容的 `SSLKEYLOGFILE`。需要 `--keylogfile` 参数（默认值：`ecapture_masterkey.log`）。\n\n**来源：** [user/module/probe_openssl.go:128-154](), [README_CN.md:150-220]()\n\n---\n\n## 架构概览\n\n### 模块初始化与配置流程\n\n```mermaid\ngraph TB\n    CLI[\"CLI 入口<br/>cobra.Command<br/>cli/cmd/root.go\"]\n    \n    subgraph \"配置层\"\n        BASE_CONF[\"BaseConfig<br/>user/config/iconfig.go<br/>Pid, Uid, BTF Mode\"]\n        MOD_CONF[\"OpensslConfig<br/>TlsCaptureModel<br/>PcapFile, KeylogFile\"]\n    end\n    \n    subgraph \"模块工厂\"\n        FACTORY[\"GetModuleFunc()<br/>user/module/imodule.go\"]\n        NEW_OPENSSL[\"NewOpenSSLProbe()<br/>user/module/probe_openssl.go:781\"]\n        NEW_GOTLS[\"NewGoTLSProbe()\"]\n        NEW_GNUTLS[\"NewGnuTLSProbe()\"]\n    end\n    \n    subgraph \"模块实例：MOpenSSLProbe\"\n        INIT[\"Init()<br/>line 109-176\"]\n        VERSION_DETECT[\"getSslBpfFile()<br/>line 178-278<br/>版本检测\"]\n        BYTECODE_SELECT[\"字节码选择<br/>sslVersionBpfMap\"]\n        SETUP[\"setupManagers*()<br/>Text/Pcap/Keylog\"]\n    end\n    \n    subgraph \"运行时组件\"\n        EBPF_MGR[\"ebpfmanager<br/>bpfManager\"]\n        EVENT_PROC[\"EventProcessor<br/>event_processor\"]\n        CONN_TRACK[\"连接跟踪<br/>pidConns, sock2pidFd\"]\n    end\n    \n    CLI --> BASE_CONF\n    CLI --> MOD_CONF\n    BASE_CONF --> FACTORY\n    MOD_CONF --> FACTORY\n    \n    FACTORY --> NEW_OPENSSL\n    FACTORY --> NEW_GOTLS\n    FACTORY --> NEW_GNUTLS\n    \n    NEW_OPENSSL --> INIT\n    INIT --> VERSION_DETECT\n    VERSION_DETECT --> BYTECODE_SELECT\n    BYTECODE_SELECT --> SETUP\n    \n    SETUP --> EBPF_MGR\n    SETUP --> EVENT_PROC\n    SETUP --> CONN_TRACK\n```\n\n**来源：** [cli/cmd/root.go:249-403](), [user/module/probe_openssl.go:109-176](), [user/module/imodule.go:47-75]()\n\n### TLS 模块状态管理\n\n`MOpenSSLProbe` 结构体维护 TLS 捕获操作的关键状态：\n\n**关键数据结构：**\n\n| 字段 | 类型 | 用途 |\n|-------|------|---------|\n| `pidConns` | `map[uint32]map[uint32]ConnInfo` | 通过 PID 和文件描述符跟踪连接 |\n| `sock2pidFd` | `map[uint64][2]uint32` | 从套接字到 PID/FD 的反向查找，用于清理 |\n| `masterKeys` | `map[string]bool` | 通过客户端随机数去重主密钥 |\n| `eBPFProgramType` | `TlsCaptureModelType` | 活动捕获模式（Text/Pcap/Keylog） |\n| `sslVersionBpfMap` | `map[string]string` | 将 SSL 版本映射到 eBPF 字节码文件 |\n| `isBoringSSL` | `bool` | 指示是否检测到 BoringSSL 库 |\n\n**连接跟踪操作：**\n\n- `AddConn(pid, fd, tuple, sock)`：从 TC hook 或 connect 系统调用注册新连接\n- `GetConn(pid, fd)`：检索用于数据事件关联的连接元组\n- `DelConn(sock)`：在 3 秒延迟后安排连接清理\n- `DestroyConn(sock)`：立即从跟踪映射中删除连接\n\n**来源：** [user/module/probe_openssl.go:83-106](), [user/module/probe_openssl.go:398-481]()\n\n---\n\n## 版本检测与字节码选择\n\neCapture 自动检测 SSL/TLS 库版本并选择适当的 eBPF 字节码来处理特定于版本的结构布局。\n\n### 版本检测流程\n\n```mermaid\nflowchart TD\n    START[\"开始捕获<br/>tls/gotls/gnutls/nss\"]\n    \n    DETECT_LIB[\"检测库路径<br/>/etc/ld.so.conf<br/>--libssl 标志\"]\n    \n    PARSE_ELF[\"解析 ELF 二进制<br/>detectOpenssl()<br/>probe_openssl.go:line 207\"]\n    \n    CHECK_VER{\"是否找到<br/>版本字符串？\"}\n    \n    TRY_CRYPTO[\"尝试 libcrypto.so<br/>如果是 libssl.so.3<br/>getImpNeeded()\"]\n    \n    MAP_LOOKUP[\"在 sslVersionBpfMap 中查找<br/>map[version]bytecode\"]\n    \n    FOUND{\"字节码<br/>是否存在？\"}\n    \n    AUTO_DETECT[\"autoDetectBytecode()<br/>按顺序尝试版本<br/>line 273\"]\n    \n    DEFAULT[\"使用默认版本<br/>linux_default_3_0\"]\n    \n    LOAD_BPF[\"加载 eBPF 字节码<br/>assets.Asset(filename)\"]\n    \n    INIT_MANAGER[\"初始化 bpfManager<br/>InitWithOptions()\"]\n    \n    START --> DETECT_LIB\n    DETECT_LIB --> PARSE_ELF\n    PARSE_ELF --> CHECK_VER\n    \n    CHECK_VER -->|否| TRY_CRYPTO\n    CHECK_VER -->|是| MAP_LOOKUP\n    TRY_CRYPTO --> MAP_LOOKUP\n    \n    MAP_LOOKUP --> FOUND\n    FOUND -->|是| LOAD_BPF\n    FOUND -->|否| AUTO_DETECT\n    AUTO_DETECT --> DEFAULT\n    DEFAULT --> LOAD_BPF\n    \n    LOAD_BPF --> INIT_MANAGER\n```\n\n**来源：** [user/module/probe_openssl.go:178-278](), [user/module/probe_openssl.go:280-350]()\n\n### 字节码命名约定\n\neBPF 字节码文件按照特定模式命名，该模式编码了版本、内核兼容性和 CO-RE 模式：\n\n**模式：** `<library>_<version>_kern[_core|_noncore][_less52].o`\n\n**示例：**\n- `openssl_3_0_0_kern_core.o` - OpenSSL 3.0.x，CO-RE 模式，内核 ≥5.2\n- `openssl_1_1_1_kern_noncore.o` - OpenSSL 1.1.x，非 CO-RE，内核 ≥5.2\n- `boringssl_a_14_kern_core_less52.o` - BoringSSL Android 14，CO-RE，内核 <5.2\n\n**版本映射初始化：**\n\n`initOpensslOffset()` 方法填充 `sslVersionBpfMap`，包含如下映射：\n\n```\n\"openssl 1.1.1a\" -> \"openssl_1_1_1_kern.o\"\n\"openssl 3.0.0\"  -> \"openssl_3_0_0_kern.o\"\n\"boringssl\"      -> \"boringssl_a_13_kern.o\"\n```\n\n**来源：** [user/module/imodule.go:191-214](), [CHANGELOG.md:14-24]()\n\n---\n\n## 模块变体\n\n### OpenSSL/BoringSSL 模块（`tls`）\n\n**主要实现：** [user/module/probe_openssl.go]() 中的 `MOpenSSLProbe`\n\n**支持的版本：**\n- OpenSSL：1.0.2 到 3.5.x\n- BoringSSL：Android 12 (A12) 到 Android 16 (A16)\n- LibreSSL：兼容版本\n\n**关键 Hook 点：**\n- `SSL_read` / `SSL_write` - 数据捕获\n- `SSL_do_handshake` - 主密钥提取（OpenSSL）\n- `SSL_get_wbio` - Bio/FD 关联\n- `SSL_in_before` / `SSL_state` - 握手状态（依赖版本）\n\n**BoringSSL 特性：**\n- 使用 `SSL_get_session` 进行主密钥提取\n- 通过 `--androidver` 标志进行 Android 版本检测\n- 针对 Android 12-16 变体的特殊偏移量处理\n\n**来源：** [user/module/probe_openssl.go:83-106](), [CHANGELOG.md:305-309](), [README.md:163-169]()\n\n### Go TLS 模块（`gotls`）\n\n**主要实现：** `MGoTLSProbe`（在提供的文件中未包含）\n\n**功能：**\n- Go 二进制分析以获取 TLS 结构偏移量\n- PIE（位置无关可执行文件）支持\n- 寄存器与栈 ABI 检测\n- 自动 `crypto/tls` 版本兼容性\n\n**Hook 策略：**\n- `crypto/tls.(*Conn).Read` / `Write` 用于数据\n- `crypto/tls.(*Conn).handshakeContext` 用于密钥\n- 从 Go 调试信息计算结构偏移量\n\n**限制：**\n- 需要调试符号或已知的 Go 版本\n- 对于剥离的二进制文件可能需要 `--elfpath` 参数\n\n**来源：** [README.md:254-276](), [cli/cmd/root.go:156]()\n\n### GnuTLS 模块（`gnutls`）\n\n**支持状态：** 自 v1.3.0 起完全支持捕获，包括密钥日志模式\n\n**Hook 函数：**\n- `gnutls_record_send` / `gnutls_record_recv` - 数据捕获\n- `gnutls_handshake` - 主密钥提取\n- TLS 1.3 的早期密钥支持\n\n**输出模式：** 文本、PCAP、密钥日志（v1.3.0 中添加）\n\n**来源：** [README.md:155](), [CHANGELOG.md:126-127]()\n\n### NSS/NSPR 模块（`nss`）\n\n**目标应用程序：**\n- Firefox 浏览器\n- Chrome/Chromium（使用 NSS 构建时）\n- 使用 NSS 加密库的应用程序\n\n**Hook 函数：**\n- `PR_Read` / `PR_Write`（NSPR 层）\n- `SSL_ImportFD` - 会话初始化\n- NSS 特定的握手函数\n\n**注意事项：**\n- 可能需要特殊处理 `libnss3.so` 路径检测\n- 在某些平台上，Chrome 可能使用 BoringSSL 而非 NSS\n\n**来源：** [README.md:158](), [CHANGELOG.md:402]()\n\n---\n\n## 关键功能\n\n### 1. 主密钥提取\n\n所有 TLS/SSL 模块都为 TLS 1.2 和 TLS 1.3 协议提取主密钥：\n\n**TLS 1.2：**\n- 客户端随机数（32 字节）\n- 主密钥（48 字节）\n- 输出格式：`CLIENT_RANDOM <random> <master_key>`\n\n**TLS 1.3：**\n- 客户端随机数（32 字节）\n- 握手密钥\n- 客户端/服务器握手流量密钥\n- 客户端/服务器应用流量密钥\n- 导出器密钥\n- 使用 SHA256/SHA384 的 HKDF 派生\n\n**密钥存储：**\n- 通过以客户端随机数为键的 `masterKeys` 映射进行去重\n- 格式与 `SSLKEYLOGFILE` 环境变量兼容\n- 可与 Wireshark 的\"Pre-Master-Secret log filename\"设置一起使用\n\n**来源：** [user/module/probe_openssl.go:482-642](), [README.md:234-247]()\n\n### 2. 协议解析\n\n**文本模式 HTTP 支持：**\n\n模块包含内置的 HTTP/1.x 和 HTTP/2 协议解析器：\n\n- HTTP/1.x：请求/响应解析，包括头部和正文\n- HTTP/2：帧解析，包括 HEADERS、DATA、SETTINGS、PING\n- HTTP/2 的 HPACK 头部解压缩\n- 自动内容类型检测和显示\n\n**来源：** [CHANGELOG.md:487](), [cli/cmd/root.go:152]()\n\n### 3. 多架构支持\n\n**支持的平台：**\n- Linux x86_64：内核 4.18+\n- Linux aarch64：内核 5.5+\n- Android x86_64：Android 12+\n- Android aarch64：Android 12+\n\n**交叉编译：**\n- 单个二进制文件中的双模式字节码（CO-RE 和非 CO-RE）\n- 自动 BTF 检测和模式选择\n- 内核版本特定的字节码变体（<5.2）\n\n**来源：** [README.md:14-16](), [CHANGELOG.md:553-561]()\n\n### 4. 过滤与定向\n\n**进程过滤：**\n- `--pid` 标志：针对特定进程 ID\n- `--uid` 标志：针对特定用户 ID\n- 默认：捕获所有进程/用户\n\n**网络过滤（PCAP 模式）：**\n- PCAP 过滤表达式支持（tcpdump 语法）\n- 示例：`tcp port 443`\n- 通过 TC eBPF 程序指令修补应用\n\n**来源：** [user/module/probe_openssl.go:361-387](), [README.md:183-184]()\n\n### 5. 连接生命周期跟踪\n\n**4 元组生成：**\n\n模块使用 4 元组信息跟踪网络连接：\n- 源 IP:端口\n- 目标 IP:端口\n- IPv4 和 IPv6 支持\n\n**跟踪机制：**\n1. TC hook 捕获数据包并生成 4 元组\n2. 对 `tcp_sendmsg` / `__sys_connect` 的 Kprobe 将套接字与 PID/FD 关联\n3. SSL 数据事件通过 `pidConns` 映射与元组关联\n4. 在套接字销毁或进程退出时清理连接\n\n**延迟清理：**\n- 通过 `time.AfterFunc()` 延迟 3 秒以处理竞态条件\n- 防止在事件传输中过早删除\n- 与 EventProcessor 合并间隔协调\n\n**来源：** [user/module/probe_openssl.go:398-462](), [CHANGELOG.md:306-309]()\n\n---\n\n## 配置参数\n\n### 通用 TLS 模块标志\n\n| 标志 | 类型 | 默认值 | 描述 |\n|------|------|---------|-------------|\n| `-m, --model` | string | `text` | 捕获模式：text/pcap/pcapng/keylog/key |\n| `--libssl` | string | 自动检测 | SSL 库路径或静态链接的二进制文件 |\n| `--pcapfile` | string | `ecapture_openssl.pcapng` | PCAP 输出文件（pcap 模式） |\n| `--keylogfile` | string | `ecapture_masterkey.log` | 密钥日志输出文件（keylog 模式） |\n| `-i, --ifname` | string | - | 网络接口（pcap 模式，必需） |\n| `--pid` | uint64 | 0 | 目标进程 ID（0 = 全部） |\n| `--uid` | uint64 | 0 | 目标用户 ID（0 = 全部） |\n| `-b, --btf` | uint8 | 0 | BTF 模式：0=自动，1=core，2=non-core |\n\n### Android 特定标志\n\n| 标志 | 类型 | 描述 |\n|------|------|-------------|\n| `--android` | bool | 启用 Android/BoringSSL 模式 |\n| `--androidver` | string | Android 版本（12-16）用于字节码选择 |\n\n**来源：** [user/config/iconfig.go:73-93](), [cli/cmd/root.go:140-152]()\n\n---\n\n## 输出示例\n\n### 文本模式输出\n\n```\nUUID:233479_233479_curl_5_1_39.156.66.10:443, Name:HTTPRequest, Type:1, Length:73\nGET / HTTP/1.1\nHost: baidu.com\nAccept: */*\nUser-Agent: curl/7.81.0\n```\n\n**UUID 格式：** `<pid>_<tid>_<comm>_<fd>_<direction>_<tuple>`\n\n**来源：** [README_CN.md:103-125]()\n\n### PCAP 模式输出\n\n- 文件格式：PCAP-NG\n- 包含：带有明文载荷的网络数据包\n- 解密密钥块（DSB）：嵌入的主密钥\n- 兼容：Wireshark、tshark、tcpdump\n\n**来源：** [README.md:187-232]()\n\n### 密钥日志模式输出\n\n```\nCLIENT_RANDOM 5a6f2b3c... 1d8e9f0a...\nCLIENT_HANDSHAKE_TRAFFIC_SECRET 5a6f2b3c... 8c7d6e5f...\nSERVER_HANDSHAKE_TRAFFIC_SECRET 5a6f2b3c... 3b2a1c0d...\nCLIENT_TRAFFIC_SECRET_0 5a6f2b3c... f9e8d7c6...\nSERVER_TRAFFIC_SECRET_0 5a6f2b3c... b5a49382...\nEXPORTER_SECRET 5a6f2b3c... 71625348...\n```\n\n**与 tshark 一起使用：**\n```bash\ntshark -o tls.keylog_file:ecapture_masterkey.log -Y http -T fields -e http.file_data -f \"port 443\" -i eth0\n```\n\n**来源：** [README.md:239-247](), [user/module/probe_openssl.go:492-554]()"
          },
          {
            "page_plan": {
              "id": "3.1.1",
              "title": "OpenSSL 模块"
            },
            "content": "# OpenSSL 模块\n\nOpenSSL 模块从使用 OpenSSL 或 BoringSSL 库的应用程序中捕获 SSL/TLS 明文流量和主密钥。它支持多种捕获模式（文本、pcap、keylog），并处理 TLS 1.2 和 TLS 1.3 协议，覆盖广泛的库版本范围。\n\n有关其他 TLS/SSL 模块的信息，请参见 Go TLS 模块 [3.1.2](#3.1.2) 和 GnuTLS/NSS 模块 [3.1.3](#3.1.3)。有关主密钥提取技术的详细信息，请参见 [3.1.4](#3.1.4)。\n\n---\n\n## 架构概述\n\nOpenSSL 模块由三个主要子系统组成：版本检测和字节码选择、用于数据捕获的 eBPF 探针，以及用于输出生成的用户空间处理。\n\n### 核心组件\n\n```mermaid\ngraph TB\n    subgraph \"模块初始化\"\n        INIT[MOpenSSLProbe.Init]\n        CONFIG[OpensslConfig]\n        DETECT[detectOpenssl]\n        SELECT[getSslBpfFile]\n    end\n    \n    subgraph \"版本到字节码映射\"\n        VMAP[sslVersionBpfMap]\n        BYTECODE[\"字节码选择<br/>openssl_X_X_X_kern.o<br/>boringssl_a_XX_kern.o\"]\n    end\n    \n    subgraph \"eBPF 探针\"\n        HOOKS[\"函数钩子<br/>SSL_write/SSL_read<br/>SSL_do_handshake<br/>SSL_get_wbio\"]\n        MASTERKEY[\"主密钥钩子<br/>probe_ssl_master_key\"]\n        TC[\"TC 钩子<br/>数据包捕获\"]\n    end\n    \n    subgraph \"数据结构\"\n        PIDCONNS[\"pidConns<br/>map[pid]map[fd]ConnInfo\"]\n        SOCK2PID[\"sock2pidFd<br/>map[sock][pid,fd]\"]\n        MASTERKEYS[\"masterKeys<br/>去重映射\"]\n    end\n    \n    subgraph \"输出处理\"\n        TEXT[\"文本模式<br/>dumpSslData\"]\n        PCAP[\"PCAP 模式<br/>dumpTcSkb\"]\n        KEYLOG[\"Keylog 模式<br/>saveMasterSecret\"]\n    end\n    \n    INIT --> CONFIG\n    INIT --> DETECT\n    DETECT --> VMAP\n    VMAP --> SELECT\n    SELECT --> BYTECODE\n    \n    BYTECODE --> HOOKS\n    BYTECODE --> MASTERKEY\n    BYTECODE --> TC\n    \n    HOOKS --> PIDCONNS\n    TC --> SOCK2PID\n    MASTERKEY --> MASTERKEYS\n    \n    PIDCONNS --> TEXT\n    PIDCONNS --> PCAP\n    MASTERKEYS --> KEYLOG\n    MASTERKEYS --> PCAP\n    \n    style VMAP fill:#f9f9f9\n    style BYTECODE fill:#f9f9f9\n    style PIDCONNS fill:#f9f9f9\n```\n\n**MOpenSSLProbe 结构**: 主模块结构体 `MOpenSSLProbe` 嵌入了 `MTCProbe`（用于基于 TC 的数据包捕获），并维护几个关键的数据结构用于连接跟踪和密钥管理。\n\n来源：[user/module/probe_openssl.go:83-106]()\n\n---\n\n## 支持的库版本\n\n该模块通过版本特定的字节码变体支持广泛的 OpenSSL 和 BoringSSL 版本。\n\n### 版本支持矩阵\n\n| 库 | 版本范围 | 字节码文件 | 备注 |\n|---------|--------------|----------------|-------|\n| OpenSSL | 1.0.2a-1.0.2u | `openssl_1_0_2a_kern.o` | 需要 `SSL_state` 钩子 |\n| OpenSSL | 1.1.0a-1.1.0l | `openssl_1_1_0a_kern.o` | 标准钩子 |\n| OpenSSL | 1.1.1a-1.1.1w | `openssl_1_1_1{a,b,d,j}_kern.o` | 四个偏移量组 |\n| OpenSSL | 3.0.0-3.0.17 | `openssl_3_0_{0,12}_kern.o` | 3.0.12 有独特的偏移量 |\n| OpenSSL | 3.1.0-3.1.8 | `openssl_3_1_0_kern.o` | 与 3.0 共享偏移量 |\n| OpenSSL | 3.2.0-3.2.5 | `openssl_3_2_{0,3,4}_kern.o` | 三个偏移量变体 |\n| OpenSSL | 3.3.0-3.3.4 | `openssl_3_3_{0,2,3}_kern.o` | 三个偏移量变体 |\n| OpenSSL | 3.4.0-3.4.2 | `openssl_3_4_{0,1}_kern.o` | 两个偏移量变体 |\n| OpenSSL | 3.5.0-3.5.4 | `openssl_3_5_0_kern.o` | 最新支持版本 |\n| BoringSSL | Android 12-16 | `boringssl_a_{13,14,15,16}_kern.o` | Android 特定 |\n| BoringSSL | 非 Android | `boringssl_na_kern.o` | 通用 BoringSSL |\n\n版本映射在 `initOpensslOffset()` 中初始化，该函数用版本到字节码的映射填充 `sslVersionBpfMap`。\n\n来源：[user/module/probe_openssl_lib.go:73-187](), [variables.mk:190-213]()\n\n---\n\n## 版本检测机制\n\n版本检测是一个关键阶段，它决定了加载哪个 eBPF 字节码以正确处理结构体偏移量。\n\n### 检测流程\n\n```mermaid\nflowchart TD\n    START[\"开始: getSslBpfFile<br/>soPath, sslVersion\"]\n    \n    CHECK_PARAM{\"sslVersion<br/>参数已设置?\"}\n    USE_PARAM[\"使用提供的版本<br/>在 sslVersionBpfMap 中查找\"]\n    \n    DETECT[\"detectOpenssl(soPath)<br/>解析 ELF .rodata 节\"]\n    \n    REGEX[\"正则匹配:<br/>'OpenSSL \\\\d\\\\.\\\\d\\\\.[0-9a-z]+'\"]\n    \n    FOUND{\"找到版本<br/>字符串?\"}\n    \n    ANDROID{\"isAndroid<br/>标志?\"}\n    \n    ANDROID_VER[\"使用 androidVer 参数<br/>boringssl_a_{ver}\"]\n    DEFAULT_ANDROID[\"默认: boringssl_a_13\"]\n    \n    DOWNGRADE[\"downgradeOpensslVersion<br/>查找最接近的匹配\"]\n    \n    DEFAULT_LINUX[\"基于 soPath 的默认值:<br/>libssl.so.3 → openssl_3_0_0<br/>其他 → openssl_1_1_1j\"]\n    \n    ADJUST_HOOKS[\"调整 masterHookFuncs<br/>OpenSSL 1.0.x: SSL_state<br/>BoringSSL: 特定钩子\"]\n    \n    RETURN[\"返回字节码文件名\"]\n    \n    START --> CHECK_PARAM\n    CHECK_PARAM -->|是| USE_PARAM\n    CHECK_PARAM -->|否| DETECT\n    \n    USE_PARAM --> ADJUST_HOOKS\n    \n    DETECT --> REGEX\n    REGEX --> FOUND\n    \n    FOUND -->|是| ANDROID\n    FOUND -->|否| ANDROID\n    \n    ANDROID -->|是, 有 androidVer| ANDROID_VER\n    ANDROID -->|是, 无 androidVer| DEFAULT_ANDROID\n    ANDROID -->|否| DOWNGRADE\n    \n    ANDROID_VER --> ADJUST_HOOKS\n    DEFAULT_ANDROID --> ADJUST_HOOKS\n    \n    DOWNGRADE -->|找到匹配| ADJUST_HOOKS\n    DOWNGRADE -->|未找到匹配| DEFAULT_LINUX\n    DEFAULT_LINUX --> ADJUST_HOOKS\n    \n    ADJUST_HOOKS --> RETURN\n```\n\n**ELF 解析**: `detectOpenssl()` 函数将共享库作为 ELF 文件打开，并在 `.rodata` 节中使用正则表达式模式 `(OpenSSL\\s\\d\\.\\d\\.[0-9a-z]+)` 搜索 OpenSSL 版本字符串。\n\n**回退策略**: 当版本检测失败时，模块依次尝试：\n1. 如果 `libssl.so.3` 不包含版本信息，检查 `libcrypto.so.3`\n2. 如果设置了 `isAndroid` 标志，使用 Android 特定的字节码\n3. 应用 `downgradeOpensslVersion()` 查找最接近的匹配版本\n4. 根据库路径回退到默认字节码\n\n**特殊情况**:\n- OpenSSL 1.0.x 需要使用 `SSL_state` 钩子而不是 `SSL_in_before`（一个宏）\n- OpenSSL 3.0.12 的偏移量与 3.0.0-3.0.11 和 3.0.13-3.0.17 不同\n- BoringSSL 版本通常是 \"1.1.1\"，但需要 Android 版本特定的字节码\n\n来源：[user/module/probe_openssl.go:179-278](), [user/module/probe_openssl_lib.go:189-282](), [user/module/probe_openssl_lib.go:284-369]()\n\n---\n\n## 钩子点和 eBPF 探针\n\n该模块将 uprobes 附加到战略性的 SSL/TLS 库函数上，以拦截明文数据和主密钥。\n\n### 主要钩子函数\n\n```mermaid\ngraph TB\n    subgraph \"SSL/TLS 函数\"\n        SSL_WRITE[\"SSL_write<br/>捕获出站数据\"]\n        SSL_READ[\"SSL_read<br/>捕获入站数据\"]\n        SSL_HANDSHAKE[\"SSL_do_handshake<br/>跟踪握手状态\"]\n        SSL_WBIO[\"SSL_get_wbio<br/>提取文件描述符\"]\n    end\n    \n    subgraph \"主密钥函数\"\n        SSL_STATE[\"SSL_in_before / SSL_state<br/>主密钥提取点\"]\n        BORING_HOOK[\"tls13_advance_key_schedule<br/>BoringSSL 特定\"]\n    end\n    \n    subgraph \"eBPF 程序\"\n        DATA_PROBE[\"uprobe/uprobe_ssl_write<br/>uprobe/uprobe_ssl_read<br/>提取明文\"]\n        KEY_PROBE[\"uprobe/SSL_write_key<br/>probe_ssl_master_key<br/>提取密钥\"]\n    end\n    \n    subgraph \"捕获的数据\"\n        PLAINTEXT[\"SSLDataEvent<br/>pid, fd, data, length\"]\n        KEYS[\"MasterSecretEvent<br/>MasterSecretBSSLEvent<br/>client_random, secrets\"]\n    end\n    \n    SSL_WRITE --> DATA_PROBE\n    SSL_READ --> DATA_PROBE\n    SSL_HANDSHAKE --> DATA_PROBE\n    SSL_WBIO --> DATA_PROBE\n    \n    SSL_STATE --> KEY_PROBE\n    BORING_HOOK --> KEY_PROBE\n    \n    DATA_PROBE --> PLAINTEXT\n    KEY_PROBE --> KEYS\n    \n    style DATA_PROBE fill:#e8f5e9\n    style KEY_PROBE fill:#fff3e0\n```\n\n**数据捕获钩子**: `SSL_write` 和 `SSL_read` 上的探针在加密前和解密后捕获明文数据。`SSL_get_wbio` 钩子提取底层套接字文件描述符用于连接跟踪。\n\n**主密钥钩子**: 主密钥提取的钩子点因库而异：\n- **OpenSSL 1.1.0+**: `SSL_in_before` 函数\n- **OpenSSL 1.0.x**: `SSL_state` 函数（因为 `SSL_in_before` 是一个宏）\n- **BoringSSL**: `tls13_advance_key_schedule` 函数\n\n主密钥钩子函数列表在 `masterHookFuncs` 数组中配置，并在初始化期间根据检测到的版本进行调整。\n\n来源：[user/module/probe_openssl.go:104](), [user/module/probe_openssl.go:179-196](), [kern/openssl_masterkey.h:80-257](), [kern/boringssl_masterkey.h:169-403]()\n\n---\n\n## 连接跟踪系统\n\n该模块维护进程、文件描述符和网络套接字之间的双向映射，以将捕获的数据与连接关联起来。\n\n### 连接跟踪数据结构\n\n```mermaid\ngraph TB\n    subgraph \"连接事件流\"\n        TC_HOOK[\"TC 分类器<br/>捕获数据包 + 元组\"]\n        SSL_BIO[\"SSL_get_wbio 钩子<br/>从 SSL* 提取 fd\"]\n        CONN_EVENT[\"ConnDataEvent<br/>pid, fd, tuple, sock\"]\n    end\n    \n    subgraph \"跟踪映射 (用户空间)\"\n        PIDCONNS[\"pidConns<br/>map[uint32]map[uint32]ConnInfo<br/>键: PID → FD<br/>值: {tuple, sock}\"]\n        \n        SOCK2PID[\"sock2pidFd<br/>map[uint64][2]uint32<br/>键: sock<br/>值: [pid, fd]\"]\n    end\n    \n    subgraph \"操作\"\n        ADD[\"AddConn(pid, fd, tuple, sock)<br/>双向插入\"]\n        GET[\"GetConn(pid, fd)<br/>→ *ConnInfo\"]\n        DEL[\"DelConn(sock)<br/>延迟 3 秒删除\"]\n        DESTROY[\"DestroyConn(sock)<br/>立即清理\"]\n    end\n    \n    subgraph \"数据关联\"\n        SSL_DATA[\"SSLDataEvent<br/>pid, fd, data\"]\n        LOOKUP[\"GetConn(pid, fd)\"]\n        ENRICHED[\"丰富的事件<br/>pid, fd, tuple, sock, data\"]\n    end\n    \n    TC_HOOK --> CONN_EVENT\n    SSL_BIO --> CONN_EVENT\n    \n    CONN_EVENT --> ADD\n    ADD --> PIDCONNS\n    ADD --> SOCK2PID\n    \n    SSL_DATA --> LOOKUP\n    LOOKUP --> PIDCONNS\n    PIDCONNS --> GET\n    GET --> ENRICHED\n    \n    SOCK2PID --> DEL\n    DEL --> DESTROY\n    DESTROY --> PIDCONNS\n    \n    style PIDCONNS fill:#e3f2fd\n    style SOCK2PID fill:#f3e5f5\n```\n\n**ConnInfo 结构**: 每个连接由一个 `ConnInfo` 结构体表示，包含网络 4 元组（源/目标 IP:端口）和套接字指针。\n\n**双向查找**: \n- `pidConns`: 映射 `(pid, fd)` → `ConnInfo`，用于丰富 SSL 数据事件\n- `sock2pidFd`: 映射 `sock` → `(pid, fd)`，用于套接字关闭时的连接清理\n\n**生命周期管理**:\n- **AddConn**: 当 TC 钩子或 SSL_get_wbio 捕获连接元数据时调用\n- **GetConn**: 在处理 SSL 数据时检索给定 `(pid, fd)` 对的元组\n- **DelConn**: 安排延迟删除（3 秒），以允许事件处理完成\n- **DestroyConn**: 执行实际清理，通知事件处理器\n\n`DelConn` 中的 3 秒延迟确保任何正在处理的事件在连接元数据被删除之前仍然可以被关联。\n\n来源：[user/module/probe_openssl.go:78-81](), [user/module/probe_openssl.go:91-94](), [user/module/probe_openssl.go:398-481](), [user/module/probe_openssl.go:756-775]()\n\n---\n\n## 主密钥提取\n\n主密钥使捕获的 TLS 流量能够被解密。TLS 1.2 和 TLS 1.3 之间的提取技术不同，因为密钥派生机制不同。\n\n### TLS 1.2 主密钥提取\n\n```mermaid\ngraph TB\n    ENTRY[\"probe_ssl_master_key<br/>参数: ssl_st*\"]\n    \n    CHECK_VER{\"version ==<br/>TLS1_3_VERSION?\"}\n    \n    TLS12[\"TLS 1.2 路径\"]\n    \n    GET_S3[\"获取 ssl_st->s3<br/>ssl3_state_st*\"]\n    \n    GET_CLIENT_RANDOM[\"读取 client_random<br/>从 s3 读取 32 字节\"]\n    \n    GET_SESSION[\"获取 ssl_st->session 或<br/>s3->hs->new_session<br/>ssl_session_st*\"]\n    \n    READ_MASTER_KEY[\"读取 master_key<br/>从 ssl_session_st<br/>48 字节\"]\n    \n    OUTPUT_TLS12[\"输出 MasterSecretEvent<br/>version, client_random,<br/>master_key\"]\n    \n    ENTRY --> CHECK_VER\n    CHECK_VER -->|否| TLS12\n    TLS12 --> GET_S3\n    GET_S3 --> GET_CLIENT_RANDOM\n    GET_CLIENT_RANDOM --> GET_SESSION\n    GET_SESSION --> READ_MASTER_KEY\n    READ_MASTER_KEY --> OUTPUT_TLS12\n```\n\n**TLS 1.2 结构导航** (OpenSSL):\n1. `ssl_st->s3` → `ssl3_state_st*`\n2. `ssl3_state_st->client_random`（32 字节）\n3. `ssl_st->session` → `ssl_session_st*`\n4. `ssl_session_st->master_key`（48 字节）\n\n**TLS 1.2 结构导航** (BoringSSL):\n1. `ssl_st->s3` → `bssl::SSL3_STATE*`\n2. `ssl3_state->client_random`（32 字节）\n3. `ssl3_state->hs` → `bssl::SSL_HANDSHAKE*`\n4. `ssl_handshake->new_session` 或 `ssl_st->session` → `ssl_session_st*`\n5. `ssl_session_st->secret` 和 `ssl_session_st->secret_length`\n\n握手状态被检查以确保握手已完成（BoringSSL 的 `state >= CLIENT_STATE12_SEND_CLIENT_FINISHED`）。\n\n来源：[kern/openssl_masterkey.h:82-169](), [kern/boringssl_masterkey.h:170-342](), [kern/openssl_masterkey_3.0.h:82-165]()\n\n### TLS 1.3 主密钥提取\n\nTLS 1.3 使用多个派生密钥而不是单个主密钥。提取更加复杂：\n\n```mermaid\ngraph TB\n    ENTRY[\"probe_ssl_master_key<br/>参数: ssl_st*\"]\n    \n    CHECK_VER{\"version ==<br/>TLS1_3_VERSION?\"}\n    \n    TLS13[\"TLS 1.3 路径\"]\n    \n    GET_CIPHER[\"从以下位置获取 cipher_id:<br/>ssl_session_st->cipher 或<br/>ssl_session_st->cipher_id\"]\n    \n    DETERMINE_HASH[\"确定哈希算法:<br/>TLS_AES_128_GCM_SHA256 → SHA256 (32 字节)<br/>TLS_AES_256_GCM_SHA384 → SHA384 (48 字节)<br/>TLS_CHACHA20_POLY1305_SHA256 → SHA256\"]\n    \n    READ_SECRETS[\"从 ssl_st 读取多个密钥:<br/>early_secret<br/>handshake_secret<br/>handshake_traffic_hash<br/>client_app_traffic_secret<br/>server_app_traffic_secret<br/>exporter_master_secret\"]\n    \n    DERIVE[\"派生握手密钥:<br/>client_handshake = HKDF-Expand(handshake_secret)<br/>server_handshake = HKDF-Expand(handshake_secret)\"]\n    \n    OUTPUT_TLS13[\"输出 MasterSecretEvent<br/>version, cipher_id, client_random<br/>+ 6 个派生密钥\"]\n    \n    ENTRY --> CHECK_VER\n    CHECK_VER -->|是| TLS13\n    TLS13 --> GET_CIPHER\n    GET_CIPHER --> DETERMINE_HASH\n    DETERMINE_HASH --> READ_SECRETS\n    READ_SECRETS --> DERIVE\n    DERIVE --> OUTPUT_TLS13\n```\n\n**TLS 1.3 结构导航** (OpenSSL):\n1. `ssl_st->s3->client_random`（32 字节）- OpenSSL 3.0+ 中 client_random 直接在 ssl_st 中\n2. `ssl_st->session->cipher->id` → 密码套件 ID\n3. 从 `ssl_st` 读取多个密钥（每个最多 64 字节）：\n   - `early_secret`（偏移量 `SSL_ST_EARLY_SECRET`）\n   - `handshake_secret`（偏移量 `SSL_ST_HANDSHAKE_SECRET`）\n   - `handshake_traffic_hash`（偏移量 `SSL_ST_HANDSHAKE_TRAFFIC_HASH`）\n   - `client_app_traffic_secret`（偏移量 `SSL_ST_CLIENT_APP_TRAFFIC_SECRET`）\n   - `server_app_traffic_secret`（偏移量 `SSL_ST_SERVER_APP_TRAFFIC_SECRET`）\n   - `exporter_master_secret`（偏移量 `SSL_ST_EXPORTER_MASTER_SECRET`）\n\n**TLS 1.3 结构导航** (BoringSSL):\n1. 从 `bssl::SSL3_STATE` 获取 `ssl_st->s3->client_random`\n2. `ssl_st->s3->hs->hash_len` 用于密钥长度\n3. `ssl_st->s3->hs->client_version` 用于验证 TLS 1.3\n4. 检查握手状态：`tls13_state >= CLIENT_STATE13_READ_SERVER_FINISHED`\n5. 从 `ssl_handshake` 读取私有成员密钥（计算的偏移量）：\n   - `early_traffic_secret_`（偏移量 `SSL_HANDSHAKE_EARLY_TRAFFIC_SECRET_`）\n   - `client_handshake_secret_`（偏移量 `SSL_HANDSHAKE_CLIENT_HANDSHAKE_SECRET_`）\n   - `server_handshake_secret_`（偏移量 `SSL_HANDSHAKE_SERVER_HANDSHAKE_SECRET_`）\n   - `client_traffic_secret_0_`（偏移量 `SSL_HANDSHAKE_CLIENT_TRAFFIC_SECRET_0_`）\n   - `server_traffic_secret_0_`（偏移量 `SSL_HANDSHAKE_SERVER_TRAFFIC_SECRET_0_`）\n6. 从 `ssl_st->s3` 读取：\n   - `exporter_secret`（偏移量 `BSSL__SSL3_STATE_EXPORTER_SECRET`）\n\n**HKDF 派生**: 对于 OpenSSL TLS 1.3，握手流量密钥必须在用户空间使用 HKDF-Expand-Label 派生，因为 OpenSSL 只存储基本的 `handshake_secret`。派生使用标签 \"c hs traffic\" 和 \"s hs traffic\" 以及握手摘要哈希。\n\n**BoringSSL 私有成员**: BoringSSL 将 TLS 1.3 密钥存储为 `SSL_HANDSHAKE` 结构体中的私有成员。偏移量通过在 `hash_len_` 字段之后为每个密钥添加 `SSL_MAX_MD_SIZE`（48 字节）来计算。参见 `SSL_HANDSHAKE_SECRET_` 到 `SSL_HANDSHAKE_EXPECTED_CLIENT_FINISHED_` 常量定义。\n\n来源：[kern/openssl_masterkey.h:171-257](), [kern/boringssl_masterkey.h:343-403](), [kern/openssl_masterkey_3.0.h:167-253](), [kern/boringssl_const.h:1-63](), [user/module/probe_openssl.go:518-551]()\n\n### Keylog 格式生成\n\n捕获的主密钥按照 NSS Key Log 格式（SSLKEYLOGFILE）格式化：\n\n**TLS 1.2 格式**:\n```\nCLIENT_RANDOM <client_random_hex> <master_key_hex>\n```\n\n**TLS 1.3 格式**:\n```\nCLIENT_HANDSHAKE_TRAFFIC_SECRET <client_random_hex> <secret_hex>\nSERVER_HANDSHAKE_TRAFFIC_SECRET <client_random_hex> <secret_hex>\nCLIENT_TRAFFIC_SECRET_0 <client_random_hex> <secret_hex>\nSERVER_TRAFFIC_SECRET_0 <client_random_hex> <secret_hex>\nEXPORTER_SECRET <client_random_hex> <secret_hex>\n```\n\n`client_random`（32 字节）作为去重的键——每个唯一的 client random 只写入 keylog 文件一次。`masterKeys` 映射跟踪哪些 client randoms 已被处理。\n\n来源：[user/module/probe_openssl.go:482-642](), [user/module/probe_openssl.go:98]()\n\n---\n\n## 捕获模式\n\n该模块支持三种不同的捕获模式，通过 `OpensslConfig.Model` 字段配置。\n\n### 捕获模式比较\n\n| 模式 | 输出格式 | 使用场景 | 捕获的数据 |\n|------|--------------|----------|---------------|\n| Text | 人类可读的文本 | 实时监控 | 明文 SSL 数据 + HTTP/HTTP2 解析 |\n| PCAP | PCAP-NG 文件 | 网络分析 | 原始数据包 + 带主密钥的 DSB |\n| Keylog | SSLKEYLOGFILE | 流量解密 | 仅主密钥 |\n\n### 文本模式\n\n```mermaid\nflowchart LR\n    SSL_DATA[\"SSLDataEvent<br/>来自 eBPF\"]\n    \n    GET_CONN[\"GetConn(pid, fd)<br/>→ ConnInfo\"]\n    \n    ENRICH[\"添加 tuple + sock<br/>到事件\"]\n    \n    PROCESSOR[\"事件处理器<br/>聚合 + 解析\"]\n    \n    PARSER[\"HTTP/HTTP2 解析器<br/>协议检测\"]\n    \n    OUTPUT[\"控制台或文件<br/>格式化文本\"]\n    \n    SSL_DATA --> GET_CONN\n    GET_CONN --> ENRICH\n    ENRICH --> PROCESSOR\n    PROCESSOR --> PARSER\n    PARSER --> OUTPUT\n```\n\n**文本模式流程**:\n1. uprobe 捕获的 `SSLDataEvent` 包含 `pid`、`fd`、`data`、`data_len`\n2. `dumpSslData()` 调用 `GetConn(pid, fd)` 检索连接元组\n3. 使用元组和套接字指针丰富事件\n4. 发送到事件处理器，该处理器聚合片段并检测 HTTP/HTTP2\n5. 解析的事件作为格式化文本输出\n\n文本模式是默认模式，提供对解密流量的即时可见性和自动协议解析。\n\n来源：[user/module/probe_openssl.go:756-775](), [user/module/probe_openssl.go:152-153]()\n\n### PCAP 模式\n\n```mermaid\nflowchart TB\n    TC_PROG[\"TC 分类器 eBPF<br/>捕获数据包\"]\n    \n    TC_EVENT[\"TcSkbEvent<br/>数据包数据 + 元数据\"]\n    \n    MASTER_SEC[\"主密钥事件<br/>TLS 密钥\"]\n    \n    PCAPNG[\"PCAP-NG 写入器<br/>增强的数据包块\"]\n    \n    DSB[\"解密密钥块<br/>嵌入 TLS 密钥\"]\n    \n    FILE[\"输出 .pcapng 文件<br/>Wireshark 兼容\"]\n    \n    TC_PROG --> TC_EVENT\n    TC_EVENT --> PCAPNG\n    \n    MASTER_SEC --> DSB\n    DSB --> PCAPNG\n    \n    PCAPNG --> FILE\n```\n\n**PCAP 模式特性**:\n- **数据包捕获**: TC eBPF 分类器捕获原始网络数据包（入站/出站）\n- **解密密钥块（DSB）**: 主密钥使用 DSB 格式嵌入到 PCAP-NG 文件中\n- **4 元组过滤**: 可以通过 BPF 指令按源/目标 IP/端口过滤数据包\n- **Wireshark 集成**: 生成的文件可以直接在 Wireshark 中打开进行解密\n\n`setupManagersPcap()` 函数在网络接口上配置 TC 钩子，而 `savePcapngSslKeyLog()` 将主密钥作为 DSB 记录写入。\n\nPCAP 模式非常适合离线分析和与标准网络分析工具共享捕获。\n\n来源：[user/module/probe_openssl.go:138-148](), [user/module/probe_openssl.go:288-289]()\n\n### Keylog 模式\n\n```mermaid\nflowchart LR\n    MASTER_EVENT[\"MasterSecretEvent 或<br/>MasterSecretBSSLEvent\"]\n    \n    DEDUP[\"检查 masterKeys 映射<br/>如果 client_random 存在则跳过\"]\n    \n    FORMAT[\"格式化为 NSS keylog:<br/>CLIENT_RANDOM + 密钥<br/>或 TLS 1.3 标签\"]\n    \n    WRITE[\"写入 keylog 文件<br/>追加模式\"]\n    \n    MASTER_EVENT --> DEDUP\n    DEDUP --> FORMAT\n    FORMAT --> WRITE\n```\n\n**Keylog 模式特性**:\n- **输出**: 与浏览器和工具兼容的标准 SSLKEYLOGFILE 格式\n- **去重**: 使用 `client_random` 作为键来防止重复条目\n- **TLS 版本支持**: 处理 TLS 1.2（单个主密钥）和 TLS 1.3（多个派生密钥）\n- **文件管理**: 以追加模式打开 keylog 文件，权限为 0600\n\nkeylog 文件可用于：\n- Wireshark（编辑 → 首选项 → 协议 → TLS → Pre-Master-Secret 日志文件名）\n- 浏览器，用于调试加密流量\n- 其他支持 NSS Key Log 格式的工具\n\n当只需要主密钥进行解密时，Keylog 模式是最轻量的选项。\n\n来源：[user/module/probe_openssl.go:129-136](), [user/module/probe_openssl.go:482-642](), [user/module/probe_openssl.go:288]()\n\n---\n\n## 初始化和生命周期\n\n该模块遵循标准的 IModule 生命周期，并为 SSL/TLS 拦截进行专门设置。\n\n### 模块生命周期\n\n```mermaid\nstateDiagram-v2\n    [*] --> Init\n    \n    Init --> Start\n    note right of Init\n        - 解析配置\n        - 检测 SSL 版本\n        - 选择字节码\n        - 初始化跟踪映射\n        - 设置事件处理器\n    end note\n    \n    Start --> SetupManagers\n    note right of Start\n        - setupManagersText()\n        - setupManagersPcap()  \n        - setupManagersKeylog()\n    end note\n    \n    SetupManagers --> LoadBytecode\n    note right of LoadBytecode\n        - 从 assets 获取\n        - 应用 CO-RE/non-CO-RE\n        - 使用选项初始化\n    end note\n    \n    LoadBytecode --> AttachProbes\n    note right of AttachProbes\n        - 将 uprobes 附加到 SSL 函数\n        - 设置 TC 分类器 (pcap 模式)\n        - 配置常量编辑器\n    end note\n    \n    AttachProbes --> Run\n    note right of Run\n        - 启动事件读取器\n        - 处理 eBPF 映射事件\n        - 分派到处理器\n    end note\n    \n    Run --> Processing\n    note right of Processing\n        - AddConn/GetConn\n        - saveMasterSecret\n        - dumpSslData/dumpTcSkb\n    end note\n    \n    Processing --> Close\n    note right of Close\n        - 停止 bpfManager\n        - 关闭事件处理器\n        - 关闭输出文件\n    end note\n    \n    Close --> [*]\n```\n\n**初始化步骤**（`Init`）:\n1. 调用基础 `Module.Init()` 进行通用设置\n2. 初始化连接跟踪映射（`pidConns`、`sock2pidFd`、`masterKeys`）\n3. 从配置确定捕获模式\n4. 打开输出文件（keylog 或 PCAP）\n5. 调用 `initOpensslOffset()` 填充版本到字节码映射\n6. 调用 `getSslBpfFile()` 检测版本并选择字节码\n7. 根据检测到的库设置 `masterHookFuncs`（OpenSSL 与 BoringSSL）\n\n**启动阶段**:\n- 根据 `eBPFProgramType` 调用适当的设置函数\n- 使用探针和映射配置 `ebpfmanager`\n- 应用常量编辑器进行 PID/UID 过滤\n- 从嵌入的 assets 加载字节码\n- 初始化 eBPF 映射的解码函数\n\n**运行时处理**:\n- 事件读取器持续轮询 eBPF 映射（perf 数组或 ring 缓冲区）\n- 事件通过 `Dispatcher()` 分派到适当的处理器\n- 通过 `AddConn`、`GetConn`、`DelConn` 操作管理连接生命周期\n\n**清理**（`Close`）:\n- 使用 `CleanAll` 标志停止 `bpfManager`\n- 关闭事件处理器\n- 关闭 keylog 文件（如果打开）\n- 调用基础 `Module.Close()`\n\n来源：[user/module/probe_openssl.go:109-176](), [user/module/probe_openssl.go:280-350](), [user/module/probe_openssl.go:352-358](), [user/module/probe_openssl.go:733-754]()\n\n---\n\n## 配置\n\nOpenSSL 模块通过 `OpensslConfig` 结构体进行配置。\n\n### 配置参数\n\n| 参数 | 类型 | 用途 | 默认值 |\n|-----------|------|---------|---------|\n| `Pid` | uint64 | 目标进程 ID（0 = 全部） | 0 |\n| `Uid` | uint64 | 目标用户 ID（0 = 全部） | 0 |\n| `Model` | string | 捕获模式：text/pcap/keylog | text |\n| `KeylogFile` | string | keylog 输出文件路径 | - |\n| `PcapFile` | string | PCAP 输出文件路径 | - |\n| `PcapFilter` | string | 数据包捕获的 BPF 过滤器 | \"\" |\n| `SslVersion` | string | 手动版本覆盖 | \"\" |\n| `IsAndroid` | bool | Android 环境标志 | false |\n| `AndroidVer` | string | Android API 级别（13-16） | \"\" |\n| `CGroupPath` | string | 用于过滤的 cgroup 路径 | \"\" |\n| `BtfMode` | uint8 | BTF 模式：0=自动，1=core，2=non-core | 0 |\n\n**手动版本覆盖**: 设置 `SslVersion` 会绕过自动检测。在版本检测可能不可靠的 Android 上很有用。示例：\n- `--ssl_version='boringssl_a_13'` 用于 Android 12\n- `--ssl_version='openssl 3.0.0'` 用于特定的 OpenSSL 版本\n\n**PCAP 过滤器**: 使用 PCAP 模式时，`PcapFilter` 对捕获的数据包应用 BPF 过滤。过滤器被编译成应用于 TC 分类器的 eBPF 指令补丁。\n\n来源：[user/config/iconfig.go:73-79](), [cli/cmd/root.go:157-175]()\n\n---\n\n## 与事件处理的集成\n\nOpenSSL 模块将事件分派到中央事件处理系统进行聚合、解析和输出。\n\n### 事件类型和处理器\n\n```mermaid\ngraph TB\n    subgraph \"事件源\"\n        SSL_DATA[\"SSLDataEvent<br/>TypeEventProcessor\"]\n        MASTER_SEC[\"MasterSecretEvent<br/>MasterSecretBSSLEvent<br/>TypeModuleData\"]\n        CONN[\"ConnDataEvent<br/>TypeModuleData\"]\n        TC[\"TcSkbEvent<br/>TypeModuleData\"]\n    end\n    \n    subgraph \"分派器逻辑\"\n        CHECK_TYPE{\"事件<br/>类型?\"}\n        CHECK_HEX{\"十六进制模式<br/>已启用?\"}\n    end\n    \n    subgraph \"处理器\"\n        HEX_OUTPUT[\"直接十六进制输出\"]\n        PROCESSOR[\"事件处理器<br/>聚合 + 解析\"]\n        MODULE_HANDLER[\"模块特定处理器<br/>AddConn/saveMasterSecret/dumpTcSkb\"]\n    end\n    \n    subgraph \"输出\"\n        CONSOLE[\"控制台/文件输出\"]\n        PCAPNG[\"PCAP-NG 文件\"]\n        KEYLOG[\"Keylog 文件\"]\n    end\n    \n    SSL_DATA --> CHECK_TYPE\n    MASTER_SEC --> CHECK_TYPE\n    CONN --> CHECK_TYPE\n    TC --> CHECK_TYPE\n    \n    CHECK_TYPE -->|TypeOutput| CHECK_HEX\n    CHECK_TYPE -->|TypeEventProcessor| CHECK_HEX\n    CHECK_TYPE -->|TypeModuleData| MODULE_HANDLER\n    \n    CHECK_HEX -->|是| HEX_OUTPUT\n    CHECK_HEX -->|否 TypeOutput| CONSOLE\n    CHECK_HEX -->|否 TypeEventProcessor| PROCESSOR\n    \n    HEX_OUTPUT --> CONSOLE\n    PROCESSOR --> CONSOLE\n    \n    MODULE_HANDLER -->|ConnDataEvent| AddConn\n    MODULE_HANDLER -->|MasterSecret*| saveMasterSecret\n    MODULE_HANDLER -->|TcSkbEvent| dumpTcSkb\n    \n    AddConn[AddConn]\n    saveMasterSecret[saveMasterSecret]\n    dumpTcSkb[dumpTcSkb]\n    \n    saveMasterSecret --> KEYLOG\n    saveMasterSecret --> PCAPNG\n    dumpTcSkb --> PCAPNG\n```\n\n**事件类型路由**:\n- `TypeEventProcessor`: SSL 数据事件发送到事件处理器进行聚合和 HTTP 解析\n- `TypeModuleData`: 模块内部事件（连接、主密钥、数据包）由模块处理\n- `TypeOutput`: 预格式化的输出事件直接发送到输出写入器\n\n**模块特定处理器**:\n- `ConnDataEvent`: 根据 `IsDestroy` 标志调用 `AddConn()` 或 `DelConn()`\n- `MasterSecretEvent`/`MasterSecretBSSLEvent`: 调用 `saveMasterSecret()` 或 `saveMasterSecretBSSL()`\n- `TcSkbEvent`: 调用 `dumpTcSkb()` 将数据包写入 PCAP-NG\n- `SSLDataEvent`: 调用 `dumpSslData()` 丰富并转发到处理器\n\n`Dispatcher()` 方法实现此路由逻辑，检查 `isClosed` 标志以防止在关闭后处理事件。\n\n来源：[user/module/probe_openssl.go:733-754](), [user/module/imodule.go:408-448]()\n\n---\n\n## 结构体偏移量计算\n\n捕获主密钥需要从内部 SSL/TLS 库结构体中读取。由于这些结构体因版本而异，精确的偏移量计算至关重要。\n\n### 偏移量计算方法\n\n**1. 自动偏移量生成**（BoringSSL）:\n\n`boringssl-offset.c` 实用程序使用 C 的 `offsetof()` 宏在编译时计算结构体成员偏移量：\n\n```c\n#define X(struct_name, field_name) \\\n    format(#struct_name, #field_name, offsetof(struct struct_name, field_name));\n\nSSL_STRUCT_OFFSETS\n```\n\n这生成头文件常量，如：\n```c\n#define SSL_ST_S3 0x18\n#define BSSL__SSL3_STATE_HS 0x30\n#define SSL_SESSION_ST_SECRET 0x48\n```\n\n**2. 手动偏移量映射**（OpenSSL）:\n\n对于 OpenSSL，偏移量是针对每个主要版本手动确定的，方法是：\n- 分析 OpenSSL 源代码结构定义\n- 验证次要版本更新之间的偏移量\n- 创建版本特定的头文件（例如，`openssl_1_1_1j_offset.h`）\n\n**3. 私有成员处理**（BoringSSL TLS 1.3）:\n\nBoringSSL 将 TLS 1.3 密钥存储为 `SSL_HANDSHAKE` 中的私有成员。由于 `offsetof()` 无法访问私有成员，偏移量通过以下方式计算：\n- 找到最后一个公共成员（`max_version`）\n- 添加大小和内存对齐\n- 计算每个密钥字段的累积偏移量\n\n`boringssl_const.h` 中的示例计算：\n```c\n// max_version 位于偏移量 30，sizeof(uint16_t) = 2\n// 内存对齐到 8 字节边界\n#define SSL_HANDSHAKE_HASH_LEN_ roundup(30+2, 8)  // = 32\n#define SSL_HANDSHAKE_SECRET_ (32 + 8)  // hash_len_ 是 size_t (8 字节)\n#define SSL_HANDSHAKE_EARLY_TRAFFIC_SECRET_ (40 + 48*1)\n#define SSL_HANDSHAKE_CLIENT_HANDSHAKE_SECRET_ (40 + 48*2)\n// ... 每个密钥相隔 SSL_MAX_MD_SIZE (48 字节)\n```\n\n**版本特定挑战**:\n- OpenSSL 3.0+ 将 `client_random` 直接移到 `ssl_st` 结构体中\n- OpenSSL 3.0.12 的偏移量与其他 3.0.x 版本不同\n- Android BoringSSL 在 API 级别之间改变偏移量\n\n来源：[utils/boringssl-offset.c:1-79](), [kern/boringssl_const.h:1-63](), [user/module/probe_openssl_lib.go:73-187]()\n\n---\n\n## 性能考虑\n\n**连接跟踪开销**: 双向映射（`pidConns`、`sock2pidFd`）使用互斥锁保证线程安全。连接仅在套接字事件时添加/删除，而不是每个数据包，从而最小化锁争用。\n\n**事件缓冲区大小**: 每个 CPU 的映射大小（默认 1024 * PAGE_SIZE）影响在丢弃之前可以缓冲多少事件。通过 `--mapsize` 标志增加以适应高吞吐量场景。\n\n**延迟连接清理**: `DelConn()` 中的 3 秒延迟防止在事件处理器仍在处理事件时过早删除连接元数据。这以内存换取正确性。\n\n**主密钥去重**: `masterKeys` 映射防止向 keylog 文件写入重复条目。每个条目由 `client_random` 十六进制字符串索引，确保 O(1) 查找。\n\n**PCAP 模式开销**: 基于 TC 的数据包捕获的开销低于传统的 libpcap，因为它完全在内核空间中运行。但是，它捕获接口上的所有数据包，除非过滤，否则可能包括非 SSL 流量。\n\n来源：[user/module/probe_openssl.go:94](), [user/module/probe_openssl.go:98](), [user/module/probe_openssl.go:454-462](), [cli/cmd/root.go:143]()\n\n---\n\n## 错误处理和回退\n\n**版本检测失败**: 当 `detectOpenssl()` 未能找到版本字符串时：\n1. 尝试从 `libcrypto.so.3` 而不是 `libssl.so.3` 读取\n2. 应用 `downgradeOpensslVersion()` 查找最接近的匹配版本\n3. 根据库路径模式回退到默认字节码\n4. 记录警告并建议手动指定版本\n\n**字节码选择失败**: 如果没有字节码匹配检测到的版本，模块使用保守的默认值：\n- `openssl_1_1_1j_kern.o` 用于通用 Linux OpenSSL\n- `openssl_3_0_0_kern.o` 用于 `libssl.so.3`\n- `boringssl_a_13_kern.o` 用于 Android\n\n**主密钥提取错误**: eBPF 探针包含广泛的错误检查和调试日志。如果读取字段失败，探针通常会提前返回，而不是发送部分/损坏的数据。常见的失败场景：\n- 握手尚未完成（状态检查防止过早捕获）\n- 会话结构的空指针（回退会话检索逻辑）\n- 无效的内存地址（bpf_probe_read_user 返回错误）\n\n**连接跟踪错误**: 当 `GetConn()` 未能找到连接时（例如，SSL 数据事件在 TC 事件之前到达）：\n- 事件仍然使用默认元组 `\"0.0.0.0:0-0.0.0.0:0\"` 处理\n- 记录以用于调试\n- 不阻止 SSL 数据捕获\n\n来源：[user/module/probe_openssl_lib.go:206-278](), [user/module/probe_openssl_lib.go:284-317](), [user/module/probe_openssl.go:756-775]()"
          },
          {
            "page_plan": {
              "id": "3.1.2",
              "title": "Go TLS 模块"
            },
            "content": "# Go TLS 模块\n\n## 目的与范围\n\nGo TLS 模块从使用 Go 编程语言编译的应用程序中捕获明文 TLS/SSL 流量和加密密钥。与挂钩动态库函数的 OpenSSL 模块（参见 [OpenSSL 模块](#3.1.1)）不同，此模块通过解析 Go 应用程序的 ELF 结构和符号表，直接插桩 Go 二进制文件的 crypto/tls 包函数。\n\n此模块解决了 Go 二进制文件的独特挑战：静态链接的 TLS 实现、不断演变的应用程序二进制接口（ABI）约定（基于寄存器与基于栈）、位置无关可执行文件（PIE）构建模式，以及特定版本的符号表格式。有关通用 TLS 捕获概念和主密钥提取技术，请参见 [主密钥提取](#3.1.4)。\n\n**主要功能：**\n- 无需库注入即可捕获 Go 应用程序的明文 TLS 数据\n- 提取 TLS 主密钥用于流量解密\n- 支持基于寄存器的 ABI（Go 1.17+）和基于栈的 ABI（Go <1.17）\n- 处理 PIE 和非 PIE Go 二进制文件\n- 三种输出模式：文本、密钥日志和 pcap（参见 [输出格式](#4)）\n\n---\n\n## 架构概览\n\nGo TLS 模块遵循三阶段初始化和执行模式，与基于库的模块不同：\n\n```mermaid\ngraph TB\n    subgraph \"阶段 1: 二进制分析\"\n        ELF[\"ELF 文件读取器<br/>(config_gotls.go)\"]\n        BUILDINFO[\"buildinfo.ReadFile()<br/>提取 Go 版本<br/>构建设置\"]\n        SYMTAB[\"符号表解析器<br/>ReadTable()<br/>.gopclntab 节\"]\n        PIE_DETECT[\"PIE 检测<br/>-buildmode=pie\"]\n    end\n    \n    subgraph \"阶段 2: 函数定位\"\n        ABI_SELECT[\"ABI 选择<br/>Go >= 1.17: 寄存器<br/>Go < 1.17: 栈\"]\n        OFFSET_CALC[\"偏移量计算器<br/>findRetOffsets()<br/>findPieSymbolAddr()\"]\n        HOOK_ADDRS[\"挂钩地址<br/>writeRecordLocked<br/>Read (多个 RET)<br/>writeKeyLog\"]\n    end\n    \n    subgraph \"阶段 3: eBPF 附加\"\n        UPROBE_MGR[\"Uprobe 管理器<br/>ebpfmanager\"]\n        REG_PROG[\"寄存器 ABI 程序<br/>gotls_write_register<br/>gotls_read_register<br/>gotls_mastersecret_register\"]\n        STACK_PROG[\"栈 ABI 程序<br/>gotls_write_stack<br/>gotls_read_stack<br/>gotls_mastersecret_stack\"]\n        ARG_EXTRACT[\"参数提取<br/>go_argument.h<br/>go_get_argument()\"]\n    end\n    \n    subgraph \"运行时捕获\"\n        DATA_EVENT[\"go_tls_event<br/>明文数据<br/>读/写类型\"]\n        SECRET_EVENT[\"mastersecret_gotls_t<br/>标签 + ClientRandom<br/>+ Secret\"]\n        TC_EVENT[\"TcSkbEvent<br/>(仅 pcap 模式)\"]\n    end\n    \n    ELF --> BUILDINFO\n    ELF --> SYMTAB\n    BUILDINFO --> PIE_DETECT\n    BUILDINFO --> ABI_SELECT\n    SYMTAB --> OFFSET_CALC\n    PIE_DETECT --> OFFSET_CALC\n    ABI_SELECT --> OFFSET_CALC\n    OFFSET_CALC --> HOOK_ADDRS\n    HOOK_ADDRS --> UPROBE_MGR\n    ABI_SELECT --> REG_PROG\n    ABI_SELECT --> STACK_PROG\n    REG_PROG --> ARG_EXTRACT\n    STACK_PROG --> ARG_EXTRACT\n    UPROBE_MGR --> DATA_EVENT\n    UPROBE_MGR --> SECRET_EVENT\n    UPROBE_MGR --> TC_EVENT\n    \n    style BUILDINFO fill:#f9f9f9\n    style ABI_SELECT fill:#f9f9f9\n    style ARG_EXTRACT fill:#f9f9f9\n```\n\n**来源：** [user/module/probe_gotls.go:58-122](), [user/config/config_gotls.go:95-190]()\n\n---\n\n## Go 二进制分析与 ABI 检测\n\n### ELF 结构解析\n\n模块首先使用 Go 的 `debug/buildinfo` 和 `debug/elf` 包从目标 Go 二进制文件中提取元数据：\n\n```mermaid\nflowchart TD\n    START[\"GoTLSConfig.Check()\"]\n    READ_BUILD[\"buildinfo.ReadFile()<br/>提取 BuildInfo\"]\n    OPEN_ELF[\"elf.Open()<br/>解析 ELF 头\"]\n    ARCH_CHECK[\"架构检查<br/>EM_X86_64 → amd64<br/>EM_AARCH64 → arm64\"]\n    PIE_CHECK{\"检查 BuildSettings<br/>-buildmode=pie?\"}\n    READ_SYMTAB[\"ReadTable()<br/>解析 .gopclntab\"]\n    FIND_FUNCS[\"查找函数地址<br/>findPieSymbolAddr()\"]\n    FIND_OFFSETS_PIE[\"findRetOffsetsPie()<br/>解码指令\"]\n    FIND_OFFSETS_NOPIE[\"findRetOffsets()<br/>搜索符号表\"]\n    VALIDATE[\"验证挂钩点<br/>设置地址\"]\n    \n    START --> READ_BUILD\n    READ_BUILD --> OPEN_ELF\n    OPEN_ELF --> ARCH_CHECK\n    ARCH_CHECK --> PIE_CHECK\n    PIE_CHECK -->|是| READ_SYMTAB\n    PIE_CHECK -->|否| FIND_OFFSETS_NOPIE\n    READ_SYMTAB --> FIND_FUNCS\n    FIND_FUNCS --> FIND_OFFSETS_PIE\n    FIND_OFFSETS_NOPIE --> VALIDATE\n    FIND_OFFSETS_PIE --> VALIDATE\n```\n\n**关键数据结构：**\n\n| 字段 | 类型 | 用途 |\n|-------|------|---------|\n| `Buildinfo` | `*buildinfo.BuildInfo` | Go 版本、构建设置、模块信息 |\n| `goElf` | `*elf.File` | ELF 文件句柄，用于访问节/符号 |\n| `goSymTab` | `*gosym.Table` | PIE 二进制文件的符号表 |\n| `IsPieBuildMode` | `bool` | 指示 PIE 编译 |\n| `ReadTlsAddrs` | `[]int` | Read uretprobe 的多个 RET 指令偏移量 |\n| `GoTlsWriteAddr` | `uint64` | writeRecordLocked 函数地址 |\n| `GoTlsMasterSecretAddr` | `uint64` | Config.writeKeyLog 函数地址 |\n\n**来源：** [user/config/config_gotls.go:102-190]()\n\n### PIE 二进制文件的符号表解析\n\nPIE 二进制文件需要特殊处理，因为符号未标记且经过重定位。模块使用魔数匹配定位 `.gopclntab` 节（或 PIE 的 `.data.rel.ro.gopclntab`）：\n\n```mermaid\ngraph LR\n    SECTIONS[\"ELF 节\"]\n    PCLNTAB[\".gopclntab<br/>.data.rel.ro.gopclntab<br/>.data.rel.ro\"]\n    MAGIC[\"魔数<br/>0xFFFFFFFA (Go 1.16)<br/>0xFFFFFFF0 (Go 1.18)<br/>0xFFFFFFF1 (Go 1.20)\"]\n    INDEX[\"bytes.Index()<br/>在数据中查找魔数\"]\n    LINETAB[\"gosym.NewLineTable()<br/>PC 到行映射\"]\n    SYMTAB[\"gosym.NewTable()<br/>函数符号\"]\n    LOOKUP[\"LookupFunc()<br/>解析地址\"]\n    \n    SECTIONS --> PCLNTAB\n    PCLNTAB --> MAGIC\n    MAGIC --> INDEX\n    INDEX --> LINETAB\n    LINETAB --> SYMTAB\n    SYMTAB --> LOOKUP\n```\n\n魔数因 Go 版本而异，以适应程序计数器行表格式的变化：\n\n| Go 版本 | 魔数 | 十六进制值 |\n|------------|--------------|-----------|\n| < 1.16 | `go12magic` | `0xFFFFFFFB` |\n| 1.16-1.17 | `go116magic` | `0xFFFFFFFA` |\n| 1.18-1.19 | `go118magic` | `0xFFFFFFF0` |\n| ≥ 1.20 | `go120magic` | `0xFFFFFFF1` |\n\n**来源：** [user/config/config_gotls.go:46-69](), [user/config/config_gotls.go:281-325]()\n\n### ABI 版本检测\n\nGo 1.17 引入了基于寄存器的调用约定，从根本上改变了函数参数的传递方式。模块通过比较 Go 版本来检测这一点：\n\n```mermaid\ngraph TD\n    VERSION[\"提取 Go 版本<br/>proc.ExtraceGoVersion()\"]\n    COMPARE{\"版本 >= 1.17?\"}\n    REG_ABI[\"isRegisterABI = true<br/>使用基于寄存器的参数提取\"]\n    STACK_ABI[\"isRegisterABI = false<br/>使用基于栈的参数提取\"]\n    SELECT_PROG{\"选择 eBPF 程序\"}\n    REG_PROGS[\"gotls_write_register<br/>gotls_read_register<br/>gotls_mastersecret_register\"]\n    STACK_PROGS[\"gotls_write_stack<br/>gotls_read_stack<br/>gotls_mastersecret_stack\"]\n    \n    VERSION --> COMPARE\n    COMPARE -->|是| REG_ABI\n    COMPARE -->|否| STACK_ABI\n    REG_ABI --> SELECT_PROG\n    STACK_ABI --> SELECT_PROG\n    SELECT_PROG --> REG_PROGS\n    SELECT_PROG --> STACK_PROGS\n```\n\n**来源：** [user/module/probe_gotls.go:71-79](), [user/module/probe_gotls_text.go:37-47]()\n\n---\n\n## 挂钩点与函数偏移量\n\n### 目标函数\n\n模块挂钩 `crypto/tls` 包中的三个关键函数：\n\n| 函数 | 常量 | 用途 | 挂钩类型 |\n|----------|----------|---------|-----------|\n| `(*Conn).writeRecordLocked` | `GoTlsWriteFunc` | 写入 TLS 记录（明文数据） | Uprobe（入口） |\n| `(*Conn).Read` | `GoTlsReadFunc` | 读取 TLS 记录（明文数据） | Uretprobe（返回） |\n| `(*Config).writeKeyLog` | `GoTlsMasterSecretFunc` | 为密钥日志文件记录 TLS 密钥 | Uprobe（入口） |\n\n**来源：** [user/config/config_gotls.go:31-35]()\n\n### RET 指令偏移量计算\n\n对于 `Read` 函数 uretprobe，模块必须找到所有 RET 指令偏移量，因为用户空间的 uretprobe 被实现为 RET 指令上的 uprobe。PIE 与非 PIE 二进制文件的处理过程不同：\n\n```mermaid\ngraph TB\n    subgraph \"非 PIE: findRetOffsets()\"\n        SYMBOL1[\"搜索 .symtab<br/>按名称查找符号\"]\n        SECTION1[\"获取 symbol.Section<br/>提取代码字节\"]\n        DECODE1[\"decodeInstruction()<br/>查找 RET 偏移量\"]\n        ADJUST1[\"调整 PT_LOAD<br/>段偏移量\"]\n    end\n    \n    subgraph \"PIE: findRetOffsetsPie()\"\n        SYMTAB[\"goSymTab.LookupFunc()<br/>获取函数入口/结束\"]\n        ADDR[\"从符号表获取<br/>函数地址\"]\n        PROG[\"查找 PT_LOAD 段<br/>读取函数字节\"]\n        DECODE2[\"decodeInstruction()<br/>查找 RET 偏移量\"]\n        ADJUST2[\"计算绝对<br/>地址\"]\n    end\n    \n    START{\"IsPieBuildMode?\"}\n    RESULT[\"ReadTlsAddrs []int<br/>RET 地址列表\"]\n    \n    START -->|否| SYMBOL1\n    START -->|是| SYMTAB\n    SYMBOL1 --> SECTION1\n    SECTION1 --> DECODE1\n    DECODE1 --> ADJUST1\n    ADJUST1 --> RESULT\n    SYMTAB --> ADDR\n    ADDR --> PROG\n    PROG --> DECODE2\n    DECODE2 --> ADJUST2\n    ADJUST2 --> RESULT\n```\n\n`decodeInstruction()` 函数是特定于架构的，搜索 RET 操作码（x86-64 上的 0xC3，ARM64 上的特定模式）。\n\n**来源：** [user/config/config_gotls.go:196-262](), [user/config/config_gotls.go:327-357]()\n\n---\n\n## eBPF 程序与参数提取\n\n### 基于寄存器与基于栈的 ABI 参数访问\n\n核心挑战是提取函数参数，这在不同 ABI 之间有根本差异：\n\n```mermaid\ngraph TB\n    subgraph \"基于寄存器的 ABI (Go >= 1.17)\"\n        REG_PARAMS[\"x86-64 寄存器:<br/>AX, BX, CX, DI, SI, R8, R9, R10<br/><br/>ARM64 寄存器:<br/>X0-X7\"]\n        REG_MACRO[\"GO_PARAMx() 宏<br/>go_argument.h\"]\n        REG_READ[\"直接寄存器读取<br/>BPF_CORE_READ(ctx, reg)\"]\n    end\n    \n    subgraph \"基于栈的 ABI (Go < 1.17)\"\n        STACK_PTR[\"栈指针 (SP)<br/>PT_REGS_SP(ctx)\"]\n        STACK_OFFSET[\"计算偏移量<br/>SP + (index * 8)\"]\n        STACK_READ[\"bpf_probe_read()<br/>从栈读取\"]\n    end\n    \n    FUNC_CALL[\"go_get_argument(ctx, is_register_abi, index)\"]\n    SWITCH{\"is_register_abi?\"}\n    \n    FUNC_CALL --> SWITCH\n    SWITCH -->|true| REG_PARAMS\n    SWITCH -->|false| STACK_PTR\n    REG_PARAMS --> REG_MACRO\n    REG_MACRO --> REG_READ\n    STACK_PTR --> STACK_OFFSET\n    STACK_OFFSET --> STACK_READ\n```\n\n**x86-64 寄存器映射：**\n\n| 参数索引 | 寄存器（寄存器 ABI） | 栈偏移量（栈 ABI） |\n|----------------|------------------------|-------------------------|\n| 1 | RAX | SP + 8 |\n| 2 | RBX | SP + 16 |\n| 3 | RCX | SP + 24 |\n| 4 | RDI | SP + 32 |\n| 5 | RSI | SP + 40 |\n| 6 | R8 | SP + 48 |\n| 7 | R9 | SP + 56 |\n| 8 | R10 | SP + 64 |\n\n**来源：** [kern/go_argument.h:74-108]()\n\n### 写入捕获（gotls_write）\n\n`writeRecordLocked` 函数签名为：\n```go\nfunc (c *Conn) writeRecordLocked(typ recordType, data []byte) (int, error)\n```\n\neBPF 程序提取：\n- 参数 2：`recordType`（uint8）- 必须是 `recordTypeApplicationData`（23）\n- 参数 3：`data` 指针（字节切片数组指针）\n- 参数 4：`len`（int）- 数据长度\n\n```mermaid\nsequenceDiagram\n    participant App as \"Go 应用程序\"\n    participant Uprobe as \"gotls_write_*\"\n    participant Helper as \"go_get_argument()\"\n    participant Map as \"events map\"\n    \n    App->>Uprobe: writeRecordLocked(conn, 23, []byte, len)\n    Uprobe->>Helper: get_argument(ctx, is_register_abi, 2)\n    Helper-->>Uprobe: record_type = 23\n    Uprobe->>Uprobe: 检查是否为 ApplicationData\n    Uprobe->>Helper: get_argument(ctx, is_register_abi, 3)\n    Helper-->>Uprobe: data 指针\n    Uprobe->>Helper: get_argument(ctx, is_register_abi, 4)\n    Helper-->>Uprobe: 长度\n    Uprobe->>Uprobe: bpf_probe_read_user(&event.data, len, ptr)\n    Uprobe->>Map: bpf_perf_event_output(event)\n```\n\n**事件结构：**\n\n```c\nstruct go_tls_event {\n    u64 ts_ns;              // 时间戳\n    u32 pid;                // 进程 ID\n    u32 tid;                // 线程 ID\n    s32 data_len;           // 数据长度\n    u8 event_type;          // 0=写入, 1=读取\n    char comm[TASK_COMM_LEN]; // 进程名称\n    char data[MAX_DATA_SIZE_OPENSSL]; // 明文数据\n};\n```\n\n**来源：** [kern/gotls_kern.c:89-123](), [kern/gotls_kern.c:31-39]()\n\n### 读取捕获（gotls_read）\n\n`Read` 函数签名为：\n```go\nfunc (c *Conn) Read(b []byte) (int, error)\n```\n\n这使用 **uretprobe** 在读取完成后捕获数据。挑战在于在返回时，即使对于寄存器 ABI，参数也在栈上：\n\n```mermaid\ngraph TB\n    URETPROBE[\"RET 指令上的 Uretprobe\"]\n    STACK_READ[\"始终使用栈读取<br/>调用期间参数被压栈\"]\n    ARG1[\"参数 2: 字节切片指针<br/>go_get_argument(ctx, false, 2)\"]\n    RET_VAL{\"返回值位置\"}\n    REG_RET[\"寄存器 ABI:<br/>返回在寄存器中<br/>go_get_argument(ctx, true, 1)\"]\n    STACK_RET[\"栈 ABI:<br/>返回在 SP+40<br/>go_get_argument(ctx, false, 5)\"]\n    READ_DATA[\"bpf_probe_read_user()<br/>复制数据到事件\"]\n    OUTPUT[\"发送事件\"]\n    \n    URETPROBE --> STACK_READ\n    STACK_READ --> ARG1\n    ARG1 --> RET_VAL\n    RET_VAL -->|is_register_abi=true| REG_RET\n    RET_VAL -->|is_register_abi=false| STACK_RET\n    REG_RET --> READ_DATA\n    STACK_RET --> READ_DATA\n    READ_DATA --> OUTPUT\n```\n\n**来源：** [kern/gotls_kern.c:137-179]()\n\n### 主密钥捕获（gotls_mastersecret）\n\n`writeKeyLog` 函数签名为：\n```go\nfunc (c *Config) writeKeyLog(label string, clientRandom, secret []byte) error\n```\n\nGo 切片表示为三字结构：`{指针, len, cap}`。eBPF 程序提取：\n\n| 参数 | 索引 | 内容 |\n|----------|-------|---------|\n| label (string) | 2 | 标签指针 |\n| label.len | 3 | 标签长度 |\n| clientRandom ([]byte) | 4 | 客户端随机数指针 |\n| clientRandom.len | 5 | 客户端随机数长度 |\n| clientRandom.cap | 6 | （跳过） |\n| secret ([]byte) | 7 | 密钥指针 |\n| secret.len | 8 | 密钥长度 |\n\n```c\nstruct mastersecret_gotls_t {\n    u8 label[MASTER_SECRET_KEY_LEN];           // \"CLIENT_RANDOM\" 等\n    u8 labellen;\n    u8 client_random[EVP_MAX_MD_SIZE];         // 32 字节\n    u8 client_random_len;\n    u8 secret_[EVP_MAX_MD_SIZE];               // TLS 密钥\n    u8 secret_len;\n};\n```\n\n**来源：** [kern/gotls_kern.c:194-267](), [kern/gotls_kern.c:41-48]()\n\n---\n\n## 捕获模式\n\n模块支持三种捕获模式，每种模式都有不同的 eBPF 程序配置：\n\n### 文本模式\n\n捕获明文数据以进行即时控制台输出或日志记录。\n\n**设置：**\n- 挂钩：`writeRecordLocked`（uprobe）、`Read`（多个 uretprobe）\n- 映射：`events`（用于 `go_tls_event` 的性能数组）\n- 无 TC 程序\n\n```mermaid\ngraph LR\n    WRITE[\"writeRecordLocked<br/>uprobe\"]\n    READ[\"Read<br/>uretprobes (多个 RET)\"]\n    EVENTS[\"events map<br/>PERF_EVENT_ARRAY\"]\n    USERSPACE[\"事件处理器<br/>GoTLSEvent\"]\n    OUTPUT[\"文本输出<br/>HTTP/HTTP2 解析\"]\n    \n    WRITE --> EVENTS\n    READ --> EVENTS\n    EVENTS --> USERSPACE\n    USERSPACE --> OUTPUT\n```\n\n**来源：** [user/module/probe_gotls_text.go:31-118](), [user/module/probe_gotls_text.go:120-135]()\n\n### 密钥日志模式\n\n捕获 TLS 主密钥，用于使用外部工具（Wireshark 等）进行解密。\n\n**设置：**\n- 挂钩：仅 `writeKeyLog`（uprobe）\n- 映射：`mastersecret_go_events`（用于 `mastersecret_gotls_t` 的性能数组）\n- 输出：SSLKEYLOGFILE 格式\n\n```mermaid\ngraph LR\n    KEYLOG[\"writeKeyLog<br/>uprobe\"]\n    SECRETS[\"mastersecret_go_events<br/>PERF_EVENT_ARRAY\"]\n    USERSPACE[\"事件处理器<br/>MasterSecretGotlsEvent\"]\n    DEDUP[\"去重<br/>masterSecrets map\"]\n    FILE[\"写入密钥日志文件<br/>Label ClientRandom Secret\"]\n    \n    KEYLOG --> SECRETS\n    SECRETS --> USERSPACE\n    USERSPACE --> DEDUP\n    DEDUP --> FILE\n```\n\n主密钥使用键 `{label}-{clientRandom}` 进行去重，以防止同一 TLS 会话出现重复条目。\n\n**来源：** [user/module/probe_gotls_keylog.go:31-122](), [user/module/probe_gotls.go:236-275]()\n\n### PCAP 模式\n\n捕获明文数据和网络数据包以进行完整的流量重建。\n\n**设置：**\n- 挂钩：`writeKeyLog`（uprobe）、TC ingress/egress 分类器\n- 映射：`mastersecret_go_events`、`packet_events`、连接跟踪映射\n- 输出：带有 DSB（解密密钥块）的 PCAP-NG\n\n```mermaid\ngraph TB\n    KEYLOG[\"writeKeyLog<br/>uprobe\"]\n    TC_IN[\"TC Ingress<br/>capture_packets\"]\n    TC_OUT[\"TC Egress<br/>capture_packets\"]\n    SECRET_MAP[\"mastersecret_go_events\"]\n    PACKET_MAP[\"packet_events\"]\n    \n    PROCESSOR[\"事件处理器\"]\n    DSB[\"DSB 块<br/>嵌入密钥\"]\n    PACKETS[\"数据包块<br/>网络数据\"]\n    PCAPNG[\"PCAP-NG 写入器<br/>save.pcapng\"]\n    \n    KEYLOG --> SECRET_MAP\n    TC_IN --> PACKET_MAP\n    TC_OUT --> PACKET_MAP\n    SECRET_MAP --> PROCESSOR\n    PACKET_MAP --> PROCESSOR\n    PROCESSOR --> DSB\n    PROCESSOR --> PACKETS\n    DSB --> PCAPNG\n    PACKETS --> PCAPNG\n```\n\nTC 分类器使用连接跟踪（参见 [网络连接跟踪](#2.6)）将数据包与进程关联。\n\n**来源：** [user/module/probe_gotls_pcap.go]()\n\n---\n\n## 配置与命令行界面\n\n### 配置结构\n\n`GoTLSConfig` 结构集中了所有模块设置：\n\n```mermaid\nclassDiagram\n    class GoTLSConfig {\n        +BaseConfig\n        +string Path\n        +string PcapFile\n        +string KeylogFile\n        +string Model\n        +string Ifname\n        +string PcapFilter\n        +bool IsPieBuildMode\n        +bool isRegisterABI\n        +buildinfo.BuildInfo Buildinfo\n        +[]int ReadTlsAddrs\n        +uint64 GoTlsWriteAddr\n        +uint64 GoTlsMasterSecretAddr\n        +Check() error\n        +ReadTable() gosym.Table\n        +findRetOffsets() []int\n        +findPieSymbolAddr() uint64\n    }\n    \n    class BaseConfig {\n        +uint64 Pid\n        +uint64 Uid\n        +uint64 PerCpuMapSize\n        +string LogFile\n        +bool IsHex\n        +int BTFMode\n    }\n    \n    GoTLSConfig --|> BaseConfig\n```\n\n**来源：** [user/config/config_gotls.go:76-93]()\n\n### 命令行界面命令\n\n`gotls` 子命令提供用户界面：\n\n```bash\n# 基本文本捕获\necapture gotls --elfpath=/path/to/go_binary\n\n# 带过滤的密钥日志模式\necapture gotls -m keylog -k /tmp/keys.log --elfpath=/path/to/go_binary --pid=1234\n\n# 带网络接口的 PCAP 模式\necapture gotls -m pcap -w capture.pcapng -i eth0 --elfpath=/path/to/go_binary tcp port 443\n```\n\n**标志映射：**\n\n| 标志 | 配置字段 | 默认值 | 用途 |\n|------|--------------|---------|---------|\n| `-e, --elfpath` | `Path` | （必需） | Go 二进制文件路径 |\n| `-m, --model` | `Model` | `text` | 捕获模式：text/pcap/keylog |\n| `-w, --pcapfile` | `PcapFile` | `ecapture_gotls.pcapng` | PCAP 输出文件 |\n| `-k, --keylogfile` | `KeylogFile` | `ecapture_gotls_key.log` | 密钥日志输出文件 |\n| `-i, --ifname` | `Ifname` | （pcap 必需） | 网络接口 |\n| `--pid` | `Pid` | 0（全部） | 目标进程 ID |\n\n**来源：** [cli/cmd/gotls.go:26-58]()\n\n---\n\n## 事件处理与输出\n\n### 事件分发器\n\n`Dispatcher` 方法根据类型路由事件：\n\n```mermaid\nflowchart TD\n    EVENT[\"接收到 eventStruct\"]\n    TYPE_CHECK{\"事件类型?\"}\n    MASTER[\"MasterSecretGotlsEvent\"]\n    TCSKB[\"TcSkbEvent\"]\n    GOTLS[\"GoTLSEvent\"]\n    \n    SAVE_MASTER[\"saveMasterSecret()<br/>写入密钥日志/DSB\"]\n    DUMP_TC[\"dumpTcSkb()<br/>写入 PCAP\"]\n    PARSE_HTTP[\"HTTP/HTTP2 解析器<br/>格式化输出\"]\n    \n    EVENT --> TYPE_CHECK\n    TYPE_CHECK --> MASTER\n    TYPE_CHECK --> TCSKB\n    TYPE_CHECK --> GOTLS\n    MASTER --> SAVE_MASTER\n    TCSKB --> DUMP_TC\n    GOTLS --> PARSE_HTTP\n```\n\n**来源：** [user/module/probe_gotls.go:277-288]()\n\n### 主密钥去重\n\n主密钥进行去重以防止多次写入相同的密钥：\n\n```go\n// 键格式：\"LABEL-CLIENTRANDOM\"\n// 例如，\"CLIENT_RANDOM-6a7b8c9d...\"\nk := fmt.Sprintf(\"%s-%02x\", label, clientRandom)\n\n_, exists := g.masterSecrets[k]\nif exists {\n    return // 跳过重复\n}\ng.masterSecrets[k] = true\n```\n\n这确保了重复的 TLS 握手（例如，带有会话恢复的 HTTP/2）不会产生冗余的密钥日志条目。\n\n**来源：** [user/module/probe_gotls.go:242-248]()\n\n---\n\n## 构建系统集成\n\n该模块与 eCapture 的双路径 eBPF 编译集成：\n\n```mermaid\ngraph TB\n    SOURCE[\"kern/gotls_kern.c\"]\n    HEADER[\"kern/go_argument.h<br/>kern/ecapture.h\"]\n    \n    CORE[\"CO-RE 路径<br/>clang -target bpf<br/>-D__TARGET_ARCH_xxx\"]\n    NONCORE[\"非 CO-RE 路径<br/>clang + 内核头文件\"]\n    \n    CORE_OBJ[\"gotls_kern_core.o\"]\n    NONCORE_OBJ[\"gotls_kern_noncore.o\"]\n    \n    BINDATA[\"go-bindata<br/>嵌入字节码\"]\n    ASSETS[\"assets/ebpf_probe.go\"]\n    \n    SOURCE --> CORE\n    SOURCE --> NONCORE\n    HEADER --> CORE\n    HEADER --> NONCORE\n    CORE --> CORE_OBJ\n    NONCORE --> NONCORE_OBJ\n    CORE_OBJ --> BINDATA\n    NONCORE_OBJ --> BINDATA\n    BINDATA --> ASSETS\n```\n\n模块在运行时通过 `geteBPFName()` 根据内核 BTF 支持选择字节码。\n\n**来源：** 有关全面的构建系统文档，请参见 [构建系统](#5.1)。\n\n---\n\n## 错误处理与边缘情况\n\n### 常见失败场景\n\n| 问题 | 检测 | 缓解措施 |\n|-------|-----------|-----------|\n| 不是 Go 二进制文件 | `buildinfo.ReadFile()` 失败 | 返回 `ErrNotGoCompiledBin` |\n| 架构不匹配 | `runtime.GOARCH != goElfArch` | 返回架构错误 |\n| 剥离的 PIE 二进制文件 | 未找到符号表 | 返回 `ErrorSymbolNotFoundFromTable` |\n| 未找到 RET 指令 | `decodeInstruction()` 返回空 | 返回 `ErrorNoRetFound` |\n| 未找到函数 | `LookupFunc()` 返回 nil | 返回 `ErrorNoFuncFoundFromSymTabFun` |\n\n**来源：** [user/config/config_gotls.go:37-44](), [user/module/probe_gotls.go:40]()\n\n### PIE 二进制文件挑战\n\nPIE 二进制文件带来了独特的挑战：\n1. **重定位符号**：地址是相对的，需要运行时计算\n2. **隐藏节**：`.gopclntab` 可能在 `.data.rel.ro` 中未标记\n3. **魔数搜索**：必须扫描节数据以查找 pclntab 签名\n4. **地址转换**：必须考虑 `PT_LOAD` 段虚拟地址\n\n模块通过直接解析符号表并使用 `gosym.Table.LookupFunc()` 进行地址解析来处理这些问题。\n\n**来源：** [user/config/config_gotls.go:281-325](), [user/config/config_gotls.go:327-357]()\n\n---\n\n## 总结\n\nGo TLS 模块展示了针对 Go 独特运行时特性量身定制的复杂二进制插桩技术。通过解析 ELF 结构、检测 ABI 约定和挂钩 crypto/tls 函数，它可以在无需源代码修改或动态库注入的情况下捕获 TLS 流量。该模块对传统的基于栈的和现代的基于寄存器的 ABI 的支持确保了从 Go 1.0 到当前版本的兼容性。\n\n有关使用动态库的相关 TLS 捕获技术，请参见 OpenSSL 模块（[OpenSSL 模块](#3.1.1)）。有关适用于两个模块的主密钥提取详细信息，请参见 [主密钥提取](#3.1.4)。"
          },
          {
            "page_plan": {
              "id": "3.1.3",
              "title": "GnuTLS 与 NSS 模块"
            },
            "content": "# GnuTLS 与 NSS 模块\n\n## 目的与范围\n\n本文档描述 eCapture 中的 GnuTLS 和 NSS/NSPR 捕获模块。这些模块为使用 GnuTLS 和 NSS/NSPR 加密库的应用程序提供 TLS/SSL 明文捕获功能，与 OpenSSL 模块（参见 [OpenSSL 模块](#3.1.1)）和 GoTLS 模块（参见 [Go TLS 模块](#3.1.2)）形成互补。两个模块都使用 eBPF uprobe 来拦截各自库中的读/写函数，在加密前和解密后提取明文数据。\n\nGnuTLS 模块针对使用 GnuTLS 库构建的应用程序（通常由 wget、curl 变体和其他 GNU 工具使用），而 NSS/NSPR 模块针对使用 Mozilla 的网络安全服务（NSS）和 Netscape 可移植运行时（NSPR）库的应用程序，最著名的是 Firefox 和 Thunderbird。\n\n有关所有模块的 TLS 主密钥提取信息，请参见[主密钥提取](#3.1.4)。有关输出格式详细信息，请参见[输出格式](#4)。\n\n---\n\n## 模块架构\n\n两个模块都遵循 eCapture 的标准模块模式，实现 `IModule` 接口（参见[模块系统与生命周期](#2.4)）。它们与 OpenSSL 模块共享相似的架构模式，但针对不同的库函数签名。\n\n```mermaid\ngraph TB\n    subgraph \"CLI 层\"\n        GNUTLS_CMD[\"gnutlsCmd<br/>cobra.Command<br/>别名: 'gnu'\"]\n        NSPR_CMD[\"nssCmd<br/>cobra.Command<br/>别名: 'nspr','nss'\"]\n    end\n    \n    subgraph \"配置层\"\n        GNUTLS_CONFIG[\"GnutlsConfig<br/>--gnutls: 库路径<br/>--ssl_version<br/>--model: text/pcap/keylog\"]\n        NSPR_CONFIG[\"NsprConfig<br/>--nspr: 库路径\"]\n    end\n    \n    subgraph \"模块实现\"\n        GNUTLS_MOD[\"MGnuTLSProbe<br/>ModuleNameGnutls<br/>IModule 实现\"]\n        NSPR_MOD[\"MNSPRProbe<br/>ModuleNameNspr<br/>IModule 实现\"]\n    end\n    \n    subgraph \"eBPF 程序\"\n        GNUTLS_KERN[\"gnutls_kern.c<br/>gnutls_record_send<br/>gnutls_record_recv\"]\n        NSPR_KERN[\"nspr_kern.c<br/>PR_Write/PR_Read<br/>uprobe/uretprobe\"]\n    end\n    \n    subgraph \"eBPF 映射表\"\n        NSPR_EVENTS[\"nspr_events<br/>BPF_MAP_TYPE_PERF_EVENT_ARRAY\"]\n        NSPR_READ_MAP[\"active_ssl_read_args_map<br/>BPF_MAP_TYPE_HASH\"]\n        NSPR_WRITE_MAP[\"active_ssl_write_args_map<br/>BPF_MAP_TYPE_HASH\"]\n        DATA_HEAP[\"data_buffer_heap<br/>BPF_MAP_TYPE_PERCPU_ARRAY\"]\n    end\n    \n    subgraph \"事件结构\"\n        SSL_EVENT[\"ssl_data_event_t<br/>type: kSSLRead/kSSLWrite<br/>timestamp_ns<br/>pid/tid<br/>data[MAX_DATA_SIZE_OPENSSL]<br/>data_len<br/>comm\"]\n    end\n    \n    GNUTLS_CMD --> GNUTLS_CONFIG\n    NSPR_CMD --> NSPR_CONFIG\n    GNUTLS_CONFIG --> GNUTLS_MOD\n    NSPR_CONFIG --> NSPR_MOD\n    \n    GNUTLS_MOD --> GNUTLS_KERN\n    NSPR_MOD --> NSPR_KERN\n    \n    NSPR_KERN --> NSPR_EVENTS\n    NSPR_KERN --> NSPR_READ_MAP\n    NSPR_KERN --> NSPR_WRITE_MAP\n    NSPR_KERN --> DATA_HEAP\n    \n    NSPR_EVENTS --> SSL_EVENT\n    \n    style GNUTLS_CMD fill:#f9f9f9\n    style NSPR_CMD fill:#f9f9f9\n    style GNUTLS_KERN fill:#e8e8e8\n    style NSPR_KERN fill:#e8e8e8\n    style SSL_EVENT fill:#f0f0f0\n```\n\n**模块架构概览**：两个模块都集成到 eCapture 的 CLI 和模块系统中。GnuTLS 模块提供更全面的配置选项，包括捕获模式（text/pcap/keylog），而 NSPR 模块则专注于文本捕获。两者都使用 eBPF uprobe 来拦截库 I/O 函数，并使用性能事件数组将数据流式传输到用户空间。\n\n**来源**：[cli/cmd/gnutls.go:1-65](), [cli/cmd/nspr.go:1-52](), [kern/nspr_kern.c:1-218]()\n\n---\n\n## 目标库\n\n### GnuTLS\n\nGnuTLS 是 TLS、SSL 和 DTLS 协议的自由软件实现。它提供了用于安全通信的高级 API，常用于：\n\n- **GNU wget**：网络下载器\n- **curl（GnuTLS 变体）**：命令行 HTTP 客户端\n- **各种 GNU 工具**：需要安全网络的应用程序\n\n该模块针对核心 I/O 函数：\n- `gnutls_record_send()`：发送加密数据\n- `gnutls_record_recv()`：接收并解密数据\n\n### NSS/NSPR\n\n网络安全服务（NSS）和 Netscape 可移植运行时（NSPR）是 Mozilla 开发的加密库：\n\n- **NSS**：提供加密操作、证书处理和 SSL/TLS\n- **NSPR**：提供 I/O、线程和其他系统操作的平台抽象\n\n主要应用程序：\n- **Mozilla Firefox**：网络浏览器\n- **Mozilla Thunderbird**：电子邮件客户端\n- **Chrome/Chromium（旧版本）**：网络浏览器\n- **各种基于 Mozilla 的应用程序**\n\n该模块针对 NSPR I/O 函数：\n- `PR_Write()`：向文件描述符写入数据\n- `PR_Read()`：从文件描述符读取数据\n\n**来源**：[cli/cmd/gnutls.go:35-36](), [cli/cmd/nspr.go:33-34](), [kern/nspr_kern.c:110-113]()\n\n---\n\n## NSPR/NSS 模块实现\n\nNSPR 模块展示了 eCapture 对特定库的 TLS 捕获方法。该实现使用 uprobe 入口/退出对在入口时捕获缓冲区指针，在返回时提取数据。\n\n### 钩子点与数据流\n\n```mermaid\ngraph TB\n    subgraph \"应用程序空间\"\n        APP[\"Firefox/Thunderbird<br/>应用程序\"]\n        NSPR_LIB[\"libnspr44.so<br/>NSPR 库\"]\n    end\n    \n    subgraph \"内核 eBPF - 入口探针\"\n        PR_WRITE_ENTRY[\"probe_entry_SSL_write<br/>SEC('uprobe/PR_Write')<br/>PT_REGS_PARM2: buf 指针\"]\n        PR_READ_ENTRY[\"probe_entry_SSL_read<br/>SEC('uprobe/PR_Read')<br/>PT_REGS_PARM2: buf 指针\"]\n    end\n    \n    subgraph \"内核 eBPF - 状态存储\"\n        WRITE_MAP[\"active_ssl_write_args_map<br/>key: pid_tgid<br/>value: buf*\"]\n        READ_MAP[\"active_ssl_read_args_map<br/>key: pid_tgid<br/>value: buf*\"]\n    end\n    \n    subgraph \"内核 eBPF - 返回探针\"\n        PR_WRITE_RET[\"probe_ret_SSL_write<br/>SEC('uretprobe/PR_Write')<br/>PT_REGS_RC: 返回值\"]\n        PR_READ_RET[\"probe_ret_SSL_read<br/>SEC('uretprobe/PR_Read')<br/>PT_REGS_RC: 返回值\"]\n    end\n    \n    subgraph \"内核 eBPF - 处理\"\n        PROCESS_DATA[\"process_SSL_data()<br/>create_ssl_data_event()<br/>bpf_probe_read_user()<br/>bpf_perf_event_output()\"]\n    end\n    \n    subgraph \"eBPF 映射表输出\"\n        PERF_ARRAY[\"nspr_events<br/>BPF_MAP_TYPE_PERF_EVENT_ARRAY\"]\n    end\n    \n    subgraph \"用户空间\"\n        EVENT_READER[\"事件读取器<br/>perfEventReader\"]\n        MODULE[\"MNSPRProbe<br/>模块处理\"]\n    end\n    \n    APP -->|\"PR_Write(fd, buf, len)\"| NSPR_LIB\n    APP -->|\"PR_Read(fd, buf, len)\"| NSPR_LIB\n    \n    NSPR_LIB -->|\"入口钩子\"| PR_WRITE_ENTRY\n    NSPR_LIB -->|\"入口钩子\"| PR_READ_ENTRY\n    \n    PR_WRITE_ENTRY -->|\"存储 buf*\"| WRITE_MAP\n    PR_READ_ENTRY -->|\"存储 buf*\"| READ_MAP\n    \n    NSPR_LIB -->|\"返回钩子\"| PR_WRITE_RET\n    NSPR_LIB -->|\"返回钩子\"| PR_READ_RET\n    \n    PR_WRITE_RET -->|\"查找 buf*\"| WRITE_MAP\n    PR_READ_RET -->|\"查找 buf*\"| READ_MAP\n    \n    PR_WRITE_RET --> PROCESS_DATA\n    PR_READ_RET --> PROCESS_DATA\n    \n    PROCESS_DATA -->|\"ssl_data_event_t\"| PERF_ARRAY\n    \n    PERF_ARRAY --> EVENT_READER\n    EVENT_READER --> MODULE\n```\n\n**NSPR 钩子实现**：该模块使用两阶段方法。入口探针（`probe_entry_SSL_write`、`probe_entry_SSL_read`）捕获缓冲区指针并将它们存储在以线程 ID 为键的哈希映射中。返回探针（`probe_ret_SSL_write`、`probe_ret_SSL_read`）检索存储的指针，检查返回值是否成功，并使用 `process_SSL_data()` 提取明文并发出事件。这种模式确保仅在成功的 I/O 操作后捕获缓冲区内容。\n\n**来源**：[kern/nspr_kern.c:114-217]()\n\n### 事件结构\n\nNSPR 模块对读和写操作使用统一的事件结构：\n\n| 字段 | 类型 | 描述 |\n|-------|------|-------------|\n| `type` | `enum ssl_data_event_type` | `kSSLRead` (0) 或 `kSSLWrite` (1) |\n| `timestamp_ns` | `u64` | 来自 `bpf_ktime_get_ns()` 的事件时间戳 |\n| `pid` | `u32` | 进程 ID（`pid_tgid` 的高 32 位） |\n| `tid` | `u32` | 线程 ID（`pid_tgid` 的低 32 位） |\n| `data` | `char[MAX_DATA_SIZE_OPENSSL]` | 捕获的明文数据 |\n| `data_len` | `s32` | 实际数据长度（最大为 `MAX_DATA_SIZE_OPENSSL`） |\n| `comm` | `char[TASK_COMM_LEN]` | 来自 `bpf_get_current_comm()` 的进程命令名 |\n\n**来源**：[kern/nspr_kern.c:19-27]()\n\n### eBPF 映射表配置\n\nNSPR 模块使用四个 eBPF 映射表：\n\n```mermaid\ngraph LR\n    subgraph \"输出映射表\"\n        EVENTS[\"nspr_events<br/>BPF_MAP_TYPE_PERF_EVENT_ARRAY<br/>max_entries: 1024\"]\n    end\n    \n    subgraph \"状态管理映射表\"\n        READ_ARGS[\"active_ssl_read_args_map<br/>BPF_MAP_TYPE_HASH<br/>key: u64 (tid)<br/>value: const char*<br/>max_entries: 1024\"]\n        \n        WRITE_ARGS[\"active_ssl_write_args_map<br/>BPF_MAP_TYPE_HASH<br/>key: u64 (tid)<br/>value: const char*<br/>max_entries: 1024\"]\n    end\n    \n    subgraph \"每 CPU 暂存空间\"\n        HEAP[\"data_buffer_heap<br/>BPF_MAP_TYPE_PERCPU_ARRAY<br/>key: u32 (总是 0)<br/>value: ssl_data_event_t<br/>max_entries: 1\"]\n    end\n    \n    WRITE_ARGS -.->|\"uprobe 存储\"| WRITE_ARGS\n    READ_ARGS -.->|\"uprobe 存储\"| READ_ARGS\n    WRITE_ARGS -.->|\"uretprobe 读取\"| EVENTS\n    READ_ARGS -.->|\"uretprobe 读取\"| EVENTS\n    HEAP -.->|\"避免栈限制\"| EVENTS\n```\n\n**eBPF 映射表设计**：`data_buffer_heap` 使用 `BPF_MAP_TYPE_PERCPU_ARRAY` 来规避 eBPF 的 512 字节栈限制。每个 CPU 获得自己的 `ssl_data_event_t` 实例用于事件构造。`active_ssl_*_args_map` 哈希映射在 uprobe 入口和返回之间提供临时存储，使用线程 ID 作为键来处理并发操作。\n\n**来源**：[kern/nspr_kern.c:29-62]()\n\n---\n\n## GnuTLS 模块实现\n\nGnuTLS 模块遵循与 NSPR 类似的架构模式，但针对不同的库函数并提供更全面的捕获模式。\n\n### 库检测与版本处理\n\nGnuTLS CLI 命令通过 `--ssl_version` 标志支持特定于版本的行为：\n\n```bash\necapture gnutls --ssl_version=3.7.9\n```\n\n这允许模块适应不同的 GnuTLS API 版本和结构布局。如果未指定路径，该模块会自动搜索 `libgnutls.so`。\n\n**来源**：[cli/cmd/gnutls.go:54]()\n\n### 捕获模式\n\nGnuTLS 模块通过 `--model` 标志支持三种捕获模式：\n\n| 模式 | 描述 | 输出 |\n|------|-------------|--------|\n| `text` | 直接明文捕获 | 控制台/日志文件，带 HTTP/HTTP2 解析 |\n| `pcap`/`pcapng` | 网络数据包捕获（含明文） | 与 Wireshark 兼容的 PCAP-NG 文件 |\n| `key`/`keylog` | TLS 主密钥 | 用于解密的 SSLKEYLOGFILE 格式 |\n\n**来源**：[cli/cmd/gnutls.go:50-53]()\n\n### CLI 使用示例\n\n```mermaid\ngraph TB\n    subgraph \"基本文本捕获\"\n        CMD1[\"ecapture gnutls<br/>--hex --pid=3423\"]\n        OUT1[\"十六进制格式<br/>明文输出\"]\n        CMD1 --> OUT1\n    end\n    \n    subgraph \"密钥日志模式\"\n        CMD2[\"ecapture gnutls<br/>-m keylog<br/>-k ecapture_gnutls_key.log<br/>--ssl_version=3.7.9\"]\n        OUT2[\"TLS 主密钥<br/>SSLKEYLOGFILE 格式\"]\n        CMD2 --> OUT2\n    end\n    \n    subgraph \"PCAP 模式（带 TC）\"\n        CMD3[\"ecapture gnutls<br/>-m pcap<br/>--pcapfile save.pcapng<br/>-i eth0<br/>--gnutls=/lib/x86_64-linux-gnu/libgnutls.so<br/>tcp port 443\"]\n        OUT3[\"PCAP-NG 文件<br/>网络数据包 + 明文<br/>应用 BPF 过滤器\"]\n        CMD3 --> OUT3\n    end\n    \n    subgraph \"目标捕获\"\n        CMD4[\"ecapture gnutls<br/>-l save.log<br/>--pid=3423\"]\n        OUT4[\"特定进程<br/>日志文件\"]\n        CMD4 --> OUT4\n    end\n```\n\n**GnuTLS CLI 模式**：该命令支持灵活的定向（按 PID/UID）、自定义库路径、基于 TC 的数据包捕获的网络接口附加，以及 PCAP 模式的 BPF 过滤器表达式。密钥日志模式支持使用 Wireshark 等标准工具对捕获的流量进行离线解密。\n\n**来源**：[cli/cmd/gnutls.go:36-43]()\n\n---\n\n## 过滤与定向\n\n两个模块都在 eBPF 级别实现 PID 和 UID 过滤，以实现高效的事件处理：\n\n```c\n#ifndef KERNEL_LESS_5_2\n    // if target_ppid is 0 then we target all pids\n    if (target_pid != 0 && target_pid != pid) {\n        return 0;\n    }\n    if (target_uid != 0 && target_uid != uid) {\n        return 0;\n    }\n#endif\n```\n\n这种过滤模式出现在所有钩子函数中，在捕获任何数据之前在内核空间中操作，最大限度地减少性能开销。条件编译（`#ifndef KERNEL_LESS_5_2`）表明用于过滤的全局变量仅在 5.2+ 版本的内核中可用。\n\n**来源**：[kern/nspr_kern.c:122-130](), [kern/nspr_kern.c:147-153](), [kern/nspr_kern.c:177-185](), [kern/nspr_kern.c:200-208]()\n\n---\n\n## 数据捕获实现\n\n### 缓冲区大小管理\n\n两个模块都使用具有按位掩码的大小限制缓冲区以确保安全：\n\n```c\n// NSPR 模块数据捕获\nevent->data_len = (len < MAX_DATA_SIZE_OPENSSL ? \n                   (len & (MAX_DATA_SIZE_OPENSSL - 1)) : \n                   MAX_DATA_SIZE_OPENSSL);\nbpf_probe_read_user(event->data, event->data_len, buf);\n```\n\n按位与操作 `(len & (MAX_DATA_SIZE_OPENSSL - 1))` 确保即使由于验证器限制导致比较失败，大小也不会超过缓冲区。这种模式在 eCapture 的 eBPF 程序中很常见，用于 eBPF 验证器合规性。\n\n**来源**：[kern/nspr_kern.c:100-101]()\n\n### 事件创建与输出\n\nNSPR 模块使用辅助函数从每 CPU 暂存空间创建事件：\n\n```c\nstatic __inline struct ssl_data_event_t* create_ssl_data_event(u64 current_pid_tgid) {\n    u32 kZero = 0;\n    struct ssl_data_event_t* event = bpf_map_lookup_elem(&data_buffer_heap, &kZero);\n    if (event == NULL) {\n        return NULL;\n    }\n    \n    const u32 kMask32b = 0xffffffff;\n    event->timestamp_ns = bpf_ktime_get_ns();\n    event->pid = current_pid_tgid >> 32;\n    event->tid = current_pid_tgid & kMask32b;\n    return event;\n}\n```\n\n此函数通过使用每 CPU 数组映射来避免栈分配，规避 512 字节 eBPF 栈限制。然后通过 `bpf_perf_event_output()` 将事件输出到 `nspr_events` 性能数组。\n\n**来源**：[kern/nspr_kern.c:68-80](), [kern/nspr_kern.c:103]()\n\n---\n\n## 与事件处理流程的集成\n\n两个模块都与 eCapture 的事件处理系统集成（参见[事件处理流程](#2.2)）：\n\n```mermaid\ngraph LR\n    subgraph \"eBPF 空间\"\n        KERN[\"nspr_kern.c 或<br/>gnutls_kern.c<br/>bpf_perf_event_output()\"]\n        MAP[\"nspr_events 或<br/>gnutls_events<br/>性能事件数组\"]\n        KERN --> MAP\n    end\n    \n    subgraph \"用户空间 - 模块\"\n        READER[\"perfEventReader<br/>从性能数组读取\"]\n        WORKER[\"事件工作器<br/>IWorker 接口<br/>连接跟踪\"]\n        PARSER[\"协议解析器<br/>IParser 接口<br/>HTTP/HTTP2\"]\n        MAP --> READER\n        READER --> WORKER\n        WORKER --> PARSER\n    end\n    \n    subgraph \"输出层\"\n        TEXT[\"文本输出<br/>控制台/文件<br/>十六进制格式化\"]\n        PCAP[\"PCAP 写入器<br/>gopacket 序列化<br/>密钥的 DSB\"]\n        KEYLOG[\"密钥日志写入器<br/>SSLKEYLOGFILE 格式\"]\n        PARSER --> TEXT\n        PARSER --> PCAP\n        PARSER --> KEYLOG\n    end\n```\n\n**事件处理集成**：事件从 eBPF 程序通过性能数组流向模块的事件读取器。工作器层管理连接状态和生命周期，而解析器解码协议数据（HTTP/HTTP2）。输出处理器根据所选模式（text/pcap/keylog）格式化数据。\n\n**来源**：[cli/cmd/gnutls.go:50-53](), [cli/cmd/nspr.go:34-39]()\n\n---\n\n## 与其他 TLS 模块的比较\n\n下表比较了 GnuTLS 和 NSS 模块与其他 TLS 捕获模块：\n\n| 功能 | OpenSSL | GoTLS | GnuTLS | NSS/NSPR |\n|---------|---------|-------|--------|----------|\n| **主要目标** | OpenSSL/BoringSSL 应用 | Go TLS 应用 | GNU 工具 | Mozilla 应用 |\n| **钩子函数** | SSL_read/SSL_write | crypto/tls.Conn.Read/Write | gnutls_record_recv/send | PR_Read/PR_Write |\n| **版本检测** | 广泛（1.0.x-3.5.x） | Go 版本 + ABI | 可选 | 可选 |\n| **主密钥提取** | 是（TLS 1.2/1.3） | 是 | 是 | 受限 |\n| **PCAP 模式** | 是（带 TC） | 是（带 TC） | 是（带 TC） | 受限 |\n| **密钥日志格式** | 是 | 是 | 是 | 否 |\n| **Android 支持** | 是（BoringSSL） | 否 | 否 | 否 |\n| **CLI 复杂度** | 高 | 中 | 中 | 低 |\n\n**模块比较**：由于版本碎片化较少，GnuTLS 和 NSS 模块提供了比 OpenSSL 更简单的实现。NSS 模块是最小的，专注于基本文本捕获。GnuTLS 提供了一个折中方案，支持密钥日志和 PCAP，但不需要 OpenSSL 所需的大量特定于版本的字节码变体。\n\n**来源**：[cli/cmd/tls.go:1-68](), [cli/cmd/gotls.go:1-59](), [cli/cmd/gnutls.go:1-65](), [cli/cmd/nspr.go:1-52]()\n\n---\n\n## 构建系统集成\n\n两个模块都根据平台有条件地编译：\n\n```go\n//go:build !androidgki\n// +build !androidgki\n```\n\n此构建标记将 GnuTLS 和 NSS 模块从 Android 构建中排除，因为这些库通常在 Android 平台上不可用。OpenSSL/BoringSSL 模块处理 Android 的 TLS 需求。\n\n模块与 eCapture 的构建系统集成：\n- **eBPF 编译**：通过 Makefile 编译 `kern/gnutls_kern.c` 和 `kern/nspr_kern.c`\n- **CO-RE 支持**：两者都支持启用 BTF 的内核以实现可移植性\n- **非 CO-RE 回退**：为旧系统提供基于内核头文件的编译\n- **资源嵌入**：通过 go-bindata 将字节码嵌入到最终二进制文件中\n\n**来源**：[cli/cmd/gnutls.go:1-2](), [cli/cmd/nspr.go:1-2]()\n\n---\n\n## 使用示例\n\n### 捕获 Firefox 流量（NSS）\n\n```bash\n# 带十六进制输出的基本捕获\necapture nspr --hex --pid=$(pgrep firefox)\n\n# 保存到日志文件\necapture nspr -l firefox_capture.log --pid=$(pgrep firefox)\n\n# 手动指定 NSPR 库路径\necapture nspr --nspr=/usr/lib/x86_64-linux-gnu/libnspr4.so\n```\n\n### 捕获 wget 流量（GnuTLS）\n\n```bash\n# 文本模式（自动库检测）\necapture gnutls\n\n# PCAP 模式（带网络接口和 BPF 过滤器）\necapture gnutls -m pcap --pcapfile wget_traffic.pcapng -i eth0 \\\n  --gnutls=/lib/x86_64-linux-gnu/libgnutls.so.30 \\\n  tcp port 443\n\n# 密钥日志模式（用于离线解密）\necapture gnutls -m keylog -k gnutls_keys.log --ssl_version=3.7.9\n\n# 按 PID 定向捕获\necapture gnutls --pid=$(pgrep wget) -l wget_output.log\n```\n\n### 高级过滤\n\n```bash\n# 仅捕获特定用户的流量\necapture gnutls --uid=1000\n\n# 带复杂 BPF 过滤器的 PCAP\necapture gnutls -m pcap -w capture.pcapng -i wlan0 \\\n  \"host 192.168.1.100 and tcp port 443\"\n```\n\n**来源**：[cli/cmd/nspr.go:35-39](), [cli/cmd/gnutls.go:36-43]()\n\n---\n\n## 限制与注意事项\n\n### NSS/NSPR 模块限制\n\n1. **无 PCAP 模式**：与 GnuTLS 不同，NSPR 模块不支持 PCAP 输出模式\n2. **无密钥日志支持**：未实现主密钥提取\n3. **有限配置**：与其他 TLS 模块相比，CLI 选项较少\n4. **NSPR 特定**：仅通过 PR_Read/PR_Write 捕获数据，不捕获 NSS 的更高级别函数\n\n### GnuTLS 模块限制\n\n1. **版本敏感性**：某些 GnuTLS 版本可能具有不同的结构布局\n2. **采用率有限**：使用 GnuTLS 的应用程序比使用 OpenSSL 的少\n3. **主密钥提取复杂性**：TLS 1.3 密钥需要特定于版本的偏移量\n\n### 一般注意事项\n\n- **库检测**：如果库位于非标准路径，自动检测可能会失败\n- **性能开销**：从繁忙的应用程序（如 Firefox）捕获所有流量可能会生成大量数据\n- **内核版本**：某些功能需要内核 5.2+ 以支持全局变量\n- **BTF 要求**：CO-RE 模式需要带有 BTF 支持的内核\n\n**来源**：[cli/cmd/nspr.go:43-45](), [cli/cmd/gnutls.go:47-55](), [kern/nspr_kern.c:122-130]()\n\n---\n\n## 相关模块\n\n要在不同应用程序和库之间实现全面的 TLS 捕获覆盖：\n\n- **[OpenSSL 模块](#3.1.1)**：OpenSSL/BoringSSL 应用程序的主要模块\n- **[Go TLS 模块](#3.1.2)**：使用 crypto/tls 的 Go 应用程序的专用模块\n- **[主密钥提取](#3.1.4)**：深入探讨 TLS 密钥材料提取\n- **[TC 网络数据包捕获](#3.3)**：带进程归属的网络级数据包捕获\n\nGnuTLS 和 NSS 模块将 eCapture 的覆盖范围扩展到 OpenSSL 生态系统之外的应用程序，实现跨多样化应用程序栈的全面 TLS 可观测性。"
          },
          {
            "page_plan": {
              "id": "3.1.4",
              "title": "主密钥提取"
            },
            "content": "# 主密钥提取\n\n本文档描述了 eCapture 从 OpenSSL 和 BoringSSL 库中提取 TLS 主密钥和流量密钥的机制。这些密钥使得在无需证书私钥的情况下解密捕获的 TLS 流量成为可能。\n\n关于通用 TLS 捕获架构的信息，请参阅 [OpenSSL 模块](#3.1.1)。关于密钥日志文件生成和 PCAP 集成的信息，请参阅 [TLS 密钥日志](#4.3) 和 [PCAP 集成](#4.2)。\n\n## 概述\n\n主密钥提取通过附加到 SSL/TLS 库函数的 eBPF uprobes 来操作。eCapture 拦截加密握手以捕获：\n\n- **TLS 1.2**: 握手期间派生的单个主密钥\n- **TLS 1.3**: 多个流量密钥（握手密钥、客户端/服务器流量密钥、导出器密钥）\n\n提取的密钥以 SSLKEYLOGFILE 格式导出，供 Wireshark 和其他解密工具使用。\n\n来源：[user/module/probe_openssl.go:482-575](), [kern/openssl_masterkey.h:25-39](), [kern/boringssl_masterkey.h:37-56]()\n\n## TLS 版本差异\n\n### TLS 1.2 密钥提取\n\nTLS 1.2 使用从预主密钥和客户端/服务器随机值派生的单个 48 字节 `master_key`。此主密钥在会话期间保持不变。\n\n```mermaid\ngraph LR\n    subgraph \"TLS 1.2 结构导航\"\n        SSL_ST[\"ssl_st\"]\n        SESSION[\"ssl_session_st\"]\n        MASTER[\"master_key[48]\"]\n        CLIENT_RND[\"client_random[32]\"]\n        \n        SSL_ST -->|\"SSL_ST_SESSION\"| SESSION\n        SSL_ST -->|\"SSL_ST_S3\"| S3[\"ssl3_state_st\"]\n        S3 -->|\"SSL3_STATE_ST_CLIENT_RANDOM\"| CLIENT_RND\n        SESSION -->|\"SSL_SESSION_ST_MASTER_KEY\"| MASTER\n    end\n```\n\n**TLS 1.2 提取过程：**\n1. 读取 `ssl_st->version` 以验证 TLS 版本\n2. 导航到 `ssl_st->s3->client_random` 获取 32 字节随机值\n3. 导航到 `ssl_st->session->master_key` 获取 48 字节主密钥\n4. 格式化为：`CLIENT_RANDOM <client_random> <master_key>`\n\n来源：[kern/openssl_masterkey.h:151-168](), [kern/boringssl_masterkey.h:288-342]()\n\n### TLS 1.3 密钥提取\n\nTLS 1.3 用多个不同阶段的派生密钥替换了单个主密钥：\n\n| 密钥类型 | 用途 | 大小 |\n|------------|---------|------|\n| `early_secret` | 早期数据（0-RTT） | 32 或 48 字节 |\n| `handshake_secret` | 握手加密 | 32 或 48 字节 |\n| `client_handshake_secret` | 从 handshake_secret 派生 | 32 或 48 字节 |\n| `server_handshake_secret` | 从 handshake_secret 派生 | 32 或 48 字节 |\n| `client_app_traffic_secret` | 客户端应用数据 | 32 或 48 字节 |\n| `server_app_traffic_secret` | 服务器应用数据 | 32 或 48 字节 |\n| `exporter_master_secret` | 密钥导出器 | 32 或 48 字节 |\n\n密钥长度取决于密码套件（基于 SHA256 的为 32 字节，基于 SHA384 的为 48 字节）。\n\n来源：[kern/openssl_masterkey.h:171-256](), [kern/boringssl_masterkey.h:344-402](), [user/module/probe_openssl.go:502-551]()\n\n## OpenSSL 与 BoringSSL 提取对比\n\n### OpenSSL 结构布局\n\nOpenSSL 直接在 `ssl_st` 结构中以固定偏移量存储 TLS 1.3 密钥：\n\n```mermaid\ngraph TB\n    subgraph \"OpenSSL ssl_st 结构\"\n        SSL_ST[\"ssl_st\"]\n        VERSION[\"version\"]\n        SESSION[\"session*\"]\n        S3[\"s3*\"]\n        EARLY[\"early_secret[64]\"]\n        HS[\"handshake_secret[64]\"]\n        HTH[\"handshake_traffic_hash[64]\"]\n        CATS[\"client_app_traffic_secret[64]\"]\n        SATS[\"server_app_traffic_secret[64]\"]\n        EMS[\"exporter_master_secret[64]\"]\n        \n        SSL_ST --> VERSION\n        SSL_ST --> SESSION\n        SSL_ST --> S3\n        SSL_ST --> EARLY\n        SSL_ST --> HS\n        SSL_ST --> HTH\n        SSL_ST --> CATS\n        SSL_ST --> SATS\n        SSL_ST --> EMS\n    end\n```\n\n**OpenSSL 偏移量宏**（特定版本）：\n- `SSL_ST_VERSION`: 版本字段偏移量\n- `SSL_ST_SESSION`: 会话指针偏移量\n- `SSL_ST_EARLY_SECRET`: 早期密钥偏移量（TLS 1.3）\n- `SSL_ST_HANDSHAKE_SECRET`: 握手密钥偏移量\n- `SSL_ST_CLIENT_APP_TRAFFIC_SECRET`: 客户端流量密钥偏移量\n- `SSL_ST_SERVER_APP_TRAFFIC_SECRET`: 服务器流量密钥偏移量\n- `SSL_ST_EXPORTER_MASTER_SECRET`: 导出器密钥偏移量\n\n来源：[kern/openssl_masterkey.h:80-257](), [kern/openssl_masterkey_3.0.h:80-253]()\n\n### BoringSSL 结构布局\n\nBoringSSL 将 TLS 1.3 密钥存储在 `SSL_HANDSHAKE` 结构中（通过 `ssl_st->s3->hs` 访问），一些密钥标记为 `private`，需要手动计算偏移量：\n\n```mermaid\ngraph TB\n    subgraph \"BoringSSL 结构层次\"\n        SSL_ST[\"ssl_st\"]\n        S3[\"ssl3_state_st (s3)\"]\n        HS[\"SSL_HANDSHAKE (hs)\"]\n        NEW_SESSION[\"new_session*\"]\n        \n        SSL_ST -->|\"SSL_ST_S3\"| S3\n        S3 -->|\"BSSL__SSL3_STATE_HS\"| HS\n        S3 -->|\"BSSL__SSL3_STATE_EXPORTER_SECRET\"| EXPORT_SEC[\"exporter_secret[64]\"]\n        HS -->|\"BSSL__SSL_HANDSHAKE_NEW_SESSION\"| NEW_SESSION\n        HS -->|\"SSL_HANDSHAKE_HASH_LEN_\"| HASH_LEN[\"hash_len_\"]\n        HS -->|\"私有字段\"| SECRETS[\"secret_, early_traffic_secret_,<br/>client_handshake_secret_,<br/>server_handshake_secret_,<br/>client_traffic_secret_0_,<br/>server_traffic_secret_0_\"]\n    end\n```\n\n**私有字段偏移量计算：**\n\nBoringSSL 的 `SSL_HANDSHAKE` 结构包含无法通过标准 `offsetof()` 访问的私有字段。偏移量手动计算：\n\n```c\n// max_version 是最后一个公共字段（uint16_t，偏移量 30）\n// 内存对齐到 8 字节后：偏移量 32\n// hash_len_（size_t）：偏移量 32\n// secret_ 起始位置：32 + sizeof(size_t) = 40\n#define SSL_HANDSHAKE_HASH_LEN_ roundup(BSSL__SSL_HANDSHAKE_MAX_VERSION+2,8)\n#define SSL_HANDSHAKE_SECRET_ SSL_HANDSHAKE_HASH_LEN_+8\n#define SSL_HANDSHAKE_EARLY_TRAFFIC_SECRET_ SSL_HANDSHAKE_SECRET_+SSL_MAX_MD_SIZE*1\n#define SSL_HANDSHAKE_CLIENT_HANDSHAKE_SECRET_ SSL_HANDSHAKE_SECRET_+SSL_MAX_MD_SIZE*2\n// ... 以此类推\n```\n\n来源：[kern/boringssl_const.h:28-60](), [kern/boringssl_masterkey.h:90-98](), [utils/boringssl-offset.c:23-78]()\n\n## eBPF 钩子点\n\nOpenSSL 和 BoringSSL 提取使用相同的钩子点策略：\n\n**Uprobe 函数：** `SSL_write_key`（符号名称，实际函数因版本而异）\n\neBPF 程序 `probe_ssl_master_key` 作为 uprobe 附加到 SSL/TLS 库函数。实际的钩子函数由版本检测确定（参见 [版本检测与字节码选择](#2.5)）：\n\n| 钩子函数 | 库 | 用途 |\n|--------------|---------|---------|\n| `SSL_write` | OpenSSL/BoringSSL | 在写入期间捕获密钥的主钩子点 |\n| `SSL_do_handshake` | OpenSSL/BoringSSL | 握手完成钩子 |\n| `SSL_get_wbio` | BoringSSL | 用于连接跟踪的 BIO 检索 |\n| `SSL_in_before` | OpenSSL 1.1.0+ | 握手状态检查 |\n| `SSL_state` | OpenSSL 1.0.x | 替代握手状态（旧版本） |\n\n主钩子函数在 [user/module/probe_openssl_masterkey.go:13-21]() 中配置：\n\n```go\nvar masterKeyHookFuncs = []string{\n    \"SSL_write\",\n    \"SSL_read\",\n    \"SSL_do_handshake\",\n}\n```\n\n来源：[kern/openssl_masterkey.h:81-82](), [kern/boringssl_masterkey.h:169-170](), [user/module/probe_openssl.go:104](), [user/module/probe_openssl.go:179-195]()\n\n## 提取流程\n\n### 完整提取管道\n\n```mermaid\nflowchart TD\n    subgraph \"内核空间 - eBPF\"\n        UPROBE[\"uprobe: probe_ssl_master_key\"]\n        SSL_PTR[\"从 PT_REGS_PARM1 读取 ssl_st*\"]\n        VER_CHECK[\"检查 TLS 版本<br/>(ssl_st->version)\"]\n        \n        TLS12[\"TLS 1.2 提取\"]\n        TLS13[\"TLS 1.3 提取\"]\n        \n        CLIENT_RND[\"读取 client_random[32]<br/>(ssl_st->s3->client_random)\"]\n        \n        MASTER12[\"读取 master_key[48]<br/>(ssl_session_st->master_key)\"]\n        \n        SECRETS13[\"读取多个密钥:<br/>handshake_secret,<br/>client/server traffic secrets,<br/>exporter_secret\"]\n        \n        EVENT_OUT[\"bpf_perf_event_output<br/>(mastersecret_events)\"]\n    end\n    \n    subgraph \"用户空间 - Go\"\n        READ_EVENT[\"perfEventReader 读取<br/>MasterSecretEvent\"]\n        DISPATCH[\"Dispatcher 路由事件\"]\n        SAVE[\"saveMasterSecret/<br/>saveMasterSecretBSSL\"]\n        \n        NULL_CHECK[\"空密钥验证\"]\n        DEDUP[\"去重检查<br/>(masterKeys map)\"]\n        \n        FORMAT12[\"格式化 TLS 1.2:<br/>CLIENT_RANDOM <cr> <mk>\"]\n        FORMAT13[\"格式化 TLS 1.3:<br/>使用 HKDF 扩展<br/>生成多行\"]\n        \n        OUTPUT[\"写入 keylogger 文件<br/>或 PCAP DSB 块\"]\n    end\n    \n    UPROBE --> SSL_PTR\n    SSL_PTR --> VER_CHECK\n    VER_CHECK -->|\"!= TLS1_3_VERSION\"| TLS12\n    VER_CHECK -->|\"== TLS1_3_VERSION\"| TLS13\n    \n    TLS12 --> CLIENT_RND\n    TLS13 --> CLIENT_RND\n    \n    CLIENT_RND --> MASTER12\n    TLS12 --> MASTER12\n    \n    CLIENT_RND --> SECRETS13\n    TLS13 --> SECRETS13\n    \n    MASTER12 --> EVENT_OUT\n    SECRETS13 --> EVENT_OUT\n    \n    EVENT_OUT --> READ_EVENT\n    READ_EVENT --> DISPATCH\n    DISPATCH --> SAVE\n    \n    SAVE --> NULL_CHECK\n    NULL_CHECK -->|\"非空\"| DEDUP\n    NULL_CHECK -->|\"全为空\"| DISCARD[\"丢弃事件\"]\n    \n    DEDUP -->|\"新密钥\"| FORMAT12\n    DEDUP -->|\"新密钥\"| FORMAT13\n    DEDUP -->|\"重复\"| DISCARD\n    \n    FORMAT12 --> OUTPUT\n    FORMAT13 --> OUTPUT\n```\n\n来源：[kern/openssl_masterkey.h:82-257](), [kern/boringssl_masterkey.h:170-403](), [user/module/probe_openssl.go:482-642]()\n\n### 状态验证\n\neBPF 程序检查握手状态，以确保仅在协商完成后才捕获密钥：\n\n**OpenSSL：** 无显式状态检查（依赖密钥可用性）\n\n**BoringSSL TLS 1.2：**\n```c\nif (ssl3_hs_state.state < CLIENT_STATE12_SEND_CLIENT_FINISHED) {\n    return 0; // 尚未完成\n}\n```\n\n**BoringSSL TLS 1.3：**\n```c\nif (ssl3_hs_state.tls13_state < CLIENT_STATE13_READ_SERVER_FINISHED) {\n    return 0; // 尚未完成\n}\n```\n\n来源：[kern/boringssl_masterkey.h:263-292](), [kern/boringssl_masterkey.h:345-348]()\n\n## 数据结构\n\n### 内核侧事件结构\n\n**OpenSSL 事件结构：**\n\n```c\nstruct mastersecret_t {\n    s32 version;                                   // TLS 版本\n    u8 client_random[SSL3_RANDOM_SIZE];            // 32 字节\n    u8 master_key[MASTER_SECRET_MAX_LEN];          // 48 字节（TLS 1.2）\n    \n    // TLS 1.3 字段\n    u32 cipher_id;                                 // 密码套件 ID\n    u8 early_secret[EVP_MAX_MD_SIZE];              // 64 字节\n    u8 handshake_secret[EVP_MAX_MD_SIZE];          // 64 字节\n    u8 handshake_traffic_hash[EVP_MAX_MD_SIZE];    // 64 字节\n    u8 client_app_traffic_secret[EVP_MAX_MD_SIZE]; // 64 字节\n    u8 server_app_traffic_secret[EVP_MAX_MD_SIZE]; // 64 字节\n    u8 exporter_master_secret[EVP_MAX_MD_SIZE];    // 64 字节\n};\n```\n\n**BoringSSL 事件结构：**\n\n```c\nstruct mastersecret_bssl_t {\n    s32 version;                                   // TLS 版本\n    u8 client_random[SSL3_RANDOM_SIZE];            // 32 字节\n    u8 secret_[MASTER_SECRET_MAX_LEN];             // 48 字节（TLS 1.2）\n    \n    // TLS 1.3 字段\n    u32 hash_len;                                  // 哈希长度（32 或 48）\n    u8 early_traffic_secret_[EVP_MAX_MD_SIZE];    // 64 字节\n    u8 client_handshake_secret_[EVP_MAX_MD_SIZE]; // 64 字节\n    u8 server_handshake_secret_[EVP_MAX_MD_SIZE]; // 64 字节\n    u8 client_traffic_secret_0_[EVP_MAX_MD_SIZE]; // 64 字节\n    u8 server_traffic_secret_0_[EVP_MAX_MD_SIZE]; // 64 字节\n    u8 exporter_secret[EVP_MAX_MD_SIZE];          // 64 字节\n};\n```\n\n来源：[kern/openssl_masterkey.h:25-39](), [kern/boringssl_masterkey.h:37-56]()\n\n### 用户空间事件结构\n\nGo 侧在 [user/event/event_openssl.go]() 中镜像这些结构：\n\n- `MasterSecretEvent`: OpenSSL 主密钥事件\n- `MasterSecretBSSLEvent`: BoringSSL 主密钥事件\n\n两者都实现 `IEventStruct` 接口以进行统一的事件处理。\n\n来源：[user/module/probe_openssl.go:50-56]()\n\n## 主密钥处理\n\n### 用户空间处理器：saveMasterSecret\n\n`saveMasterSecret` 函数处理 OpenSSL 主密钥事件：\n\n```mermaid\nflowchart TD\n    START[\"saveMasterSecret(secretEvent)\"]\n    \n    KEY[\"生成密钥:<br/>fmt.Sprintf('%02x', client_random)\"]\n    \n    DEDUP{\"密钥存在于<br/>masterKeys map?\"}\n    \n    VER_CHECK{\"TLS 版本\"}\n    \n    TLS12_PROC[\"TLS 1.2 处理\"]\n    NULL12[\"检查 master_key != 全零\"]\n    FMT12[\"格式化: CLIENT_RANDOM <cr> <mk>\"]\n    \n    TLS13_PROC[\"TLS 1.3 处理\"]\n    CIPHER[\"根据 cipher_id<br/>确定哈希长度\"]\n    EXPAND[\"HKDF 扩展:<br/>client_handshake_secret,<br/>server_handshake_secret\"]\n    NULL13[\"验证密钥 != 全零\"]\n    FMT13[\"格式化多行:<br/>CLIENT_HANDSHAKE_TRAFFIC_SECRET,<br/>SERVER_HANDSHAKE_TRAFFIC_SECRET,<br/>CLIENT_TRAFFIC_SECRET_0,<br/>SERVER_TRAFFIC_SECRET_0,<br/>EXPORTER_SECRET\"]\n    \n    WRITE[\"写入输出\"]\n    KEYLOG[\"写入 keylogger 文件\"]\n    PCAP[\"保存到 PCAP DSB 块\"]\n    MARK[\"标记密钥已保存:<br/>masterKeys[k] = true\"]\n    \n    START --> KEY\n    KEY --> DEDUP\n    DEDUP -->|\"是\"| RETURN[\"返回（跳过重复）\"]\n    DEDUP -->|\"否\"| VER_CHECK\n    \n    VER_CHECK -->|\"TLS 1.2\"| TLS12_PROC\n    VER_CHECK -->|\"TLS 1.3\"| TLS13_PROC\n    \n    TLS12_PROC --> NULL12\n    NULL12 -->|\"有效\"| FMT12\n    NULL12 -->|\"全零\"| RETURN\n    FMT12 --> MARK\n    \n    TLS13_PROC --> CIPHER\n    CIPHER --> EXPAND\n    EXPAND --> NULL13\n    NULL13 -->|\"有效\"| FMT13\n    NULL13 -->|\"包含空值\"| RETURN\n    FMT13 --> MARK\n    \n    MARK --> WRITE\n    WRITE -->|\"TlsCaptureModelTypeKeylog\"| KEYLOG\n    WRITE -->|\"TlsCaptureModelTypePcap\"| PCAP\n    KEYLOG --> DONE[\"完成\"]\n    PCAP --> DONE\n```\n\n来源：[user/module/probe_openssl.go:482-575]()\n\n### TLS 1.3 HKDF 扩展\n\n对于 TLS 1.3，握手密钥必须使用 HKDF-Expand-Label 扩展：\n\n**密码套件哈希确定：**\n\n| 密码套件 | 哈希 | 长度 |\n|-------------|------|--------|\n| `TLS_AES_128_GCM_SHA256` | SHA256 | 32 字节 |\n| `TLS_CHACHA20_POLY1305_SHA256` | SHA256 | 32 字节 |\n| `TLS_AES_256_GCM_SHA384` | SHA384 | 48 字节 |\n\n**HKDF-Expand-Label 调用：**\n\n```go\n// 将握手密钥扩展为客户端/服务器握手密钥\nclientHandshakeSecret := hkdf.ExpandLabel(\n    secretEvent.HandshakeSecret[:length],\n    hkdf.ClientHandshakeTrafficLabel,\n    secretEvent.HandshakeTrafficHash[:length],\n    length,\n    transcript\n)\n\nserverHandshakeSecret := hkdf.ExpandLabel(\n    secretEvent.HandshakeSecret[:length],\n    hkdf.ServerHandshakeTrafficLabel,\n    secretEvent.HandshakeTrafficHash[:length],\n    length,\n    transcript\n)\n```\n\n使用的标签：\n- `ClientHandshakeTrafficLabel`: \"c hs traffic\"\n- `ServerHandshakeTrafficLabel`: \"s hs traffic\"\n\n来源：[user/module/probe_openssl.go:502-551](), [pkg/util/hkdf/hkdf.go]()\n\n### 空密钥验证\n\nTLS 1.2 和 TLS 1.3 密钥都经过验证以确保它们不是全零（这表示错误或不完整的握手）：\n\n**TLS 1.2 验证：**\n```go\nfunc (m *MOpenSSLProbe) mk12NullSecrets(hashLen int, secret []byte) bool {\n    isNull := true\n    for i := 0; i < hashLen; i++ {\n        if secret[i] != 0 {\n            isNull = false\n            break\n        }\n    }\n    return isNull\n}\n```\n\n**TLS 1.3 验证：**\n该函数检查所有五个密钥（客户端握手、客户端流量、服务器握手、服务器流量、导出器），如果任何一个保持全零则返回 `true`：\n\n```go\nfunc (m *MOpenSSLProbe) mk13NullSecrets(hashLen int,\n    ClientHandshakeSecret [64]byte,\n    ClientTrafficSecret0 [64]byte,\n    ServerHandshakeSecret [64]byte,\n    ServerTrafficSecret0 [64]byte,\n    ExporterSecret [64]byte) bool {\n    // 如果任何密钥仍为空则返回 true\n    // ...\n}\n```\n\n来源：[user/module/probe_openssl.go:652-731]()\n\n## 输出格式\n\n### SSLKEYLOGFILE 格式\n\nTLS 密钥日志的标准格式：\n\n**TLS 1.2：**\n```\nCLIENT_RANDOM <64 位十六进制 client_random> <96 位十六进制 master_key>\n```\n\n**TLS 1.3：**\n```\nCLIENT_HANDSHAKE_TRAFFIC_SECRET <64 位十六进制 client_random> <64-96 位十六进制>\nSERVER_HANDSHAKE_TRAFFIC_SECRET <64 位十六进制 client_random> <64-96 位十六进制>\nCLIENT_TRAFFIC_SECRET_0 <64 位十六进制 client_random> <64-96 位十六进制>\nSERVER_TRAFFIC_SECRET_0 <64 位十六进制 client_random> <64-96 位十六进制>\nEXPORTER_SECRET <64 位十六进制 client_random> <64-96 位十六进制>\n```\n\n### 输出模式\n\n基于 `TlsCaptureModelType` 配置：\n\n| 模式 | 实现 | 输出位置 |\n|------|---------------|-----------------|\n| `TlsCaptureModelTypeKeylog` | 通过 `m.keylogger.WriteString()` 写入文件 | 由 `--keylog` 标志指定的密钥日志文件 |\n| `TlsCaptureModelTypePcap` | 通过 `m.savePcapngSslKeyLog()` 嵌入到 PCAP-NG DSB 块 | PCAP-NG 文件内部 |\n| `TlsCaptureModelTypeText` | 无输出（不需要密钥） | N/A |\n\n来源：[user/module/probe_openssl.go:58-76](), [user/module/probe_openssl.go:558-574]()\n\n## 偏移量计算工具\n\n### BoringSSL 偏移量生成器\n\n`boringssl-offset.c` 工具通过针对 BoringSSL 头文件编译来生成 BoringSSL 结构的偏移量宏：\n\n```bash\ng++ -I include/ -I src/ ./utils/boringssl-offset.c -o off\n./off > generated_offsets.h\n```\n\n它对公共字段使用 `offsetof()` 宏：\n\n```c\n#define X(struct_name, field_name) \\\n    format(#struct_name, #field_name, offsetof(struct struct_name, field_name));\nSSL_STRUCT_OFFSETS\n#undef X\n```\n\n输出示例：\n```c\n// ssl_st->version\n#define SSL_ST_VERSION 0x10\n\n// ssl_st->session\n#define SSL_ST_SESSION 0x18\n```\n\n对于 BoringSSL 中的私有字段，需要手动计算（参见 [BoringSSL 结构布局](#boringssl-结构布局)）。\n\n来源：[utils/boringssl-offset.c:1-78](), [kern/boringssl_const.h:28-60]()\n\n## 去重策略\n\n`masterKeys` map 防止重复的主密钥输出：\n\n```go\ntype MOpenSSLProbe struct {\n    // ...\n    masterKeys map[string]bool\n}\n```\n\n**键：** `client_random` 的十六进制表示（32 字节 → 64 个十六进制字符）\n\n**值：** 布尔标志，指示密钥是否已保存\n\n当新的主密钥事件到达时：\n1. 生成键：`k := fmt.Sprintf(\"%02x\", secretEvent.ClientRandom)`\n2. 检查存在性：`_, f := m.masterKeys[k]`\n3. 如果存在，提前返回（重复）\n4. 如果是新的，处理并标记：`m.masterKeys[k] = true`\n\n这可以防止在同一连接上钩住多个 SSL/TLS 函数时出现重复条目。\n\n来源：[user/module/probe_openssl.go:98](), [user/module/probe_openssl.go:482-489](), [user/module/probe_openssl.go:500](), [user/module/probe_openssl.go:533]()"
          },
          {
            "page_plan": {
              "id": "3.2",
              "title": "系统审计模块"
            },
            "content": "# 系统审计模块\n\n## 目的与范围\n\n本文档介绍 eCapture 的系统审计功能，用于在无需修改代码的情况下捕获 shell 命令和数据库查询。系统审计模块使用 eBPF uprobe 钩住 shell 解释器（Bash、Zsh）和数据库服务器（MySQL、PostgreSQL）中的关键函数，从而实现安全审计和取证分析。\n\n关于 TLS/SSL 捕获模块（包括 OpenSSL 和 Go TLS），请参见 [TLS/SSL 模块](#3.1)。关于使用 TC 分类器进行网络数据包捕获，请参见 [TC 网络数据包捕获](#3.3)。\n\n## 概述\n\n系统审计模块提供以下实时可见性：\n- **Shell 命令**：Bash 和 Zsh 命令执行，包括命令文本和退出状态\n- **数据库查询**：MySQL 和 PostgreSQL 服务器进程执行的 SQL 查询\n\n与专注于加密网络流量的 TLS 模块不同，系统审计模块直接从进程内存中捕获应用层活动，提供：\n- 用于安全合规的命令行活动监控\n- 用于调试和性能分析的数据库查询审计\n- 通过 PID/UID 过滤进行进程和用户归属\n- 对目标应用程序零配置要求\n\n系统审计子系统由四个专用模块组成：\n\n| 模块 | 目标 | 钩子函数 | 支持版本 |\n|--------|--------|----------------|-------------------|\n| Bash | `/bin/bash` | `readline()`, `execute_command()` | 所有版本 |\n| Zsh | `/bin/zsh` | `zleread()`, `execcmd_exec()` | 所有版本 |\n| MySQL | `mysqld`/`mariadbd` | `dispatch_command()` | 5.6, 5.7, 8.0, MariaDB 10.5+ |\n| PostgreSQL | `postgres` | `exec_simple_query()` | 10+ |\n\n**来源：** [cli/cmd/bash.go:1-56](), [cli/cmd/zsh.go:1-58](), [cli/cmd/mysqld.go:1-50](), [cli/cmd/postgres.go:1-46]()\n\n## 系统审计架构\n\n```mermaid\ngraph TB\n    subgraph \"CLI 命令\"\n        BashCLI[\"bash 命令<br/>cli/cmd/bash.go\"]\n        ZshCLI[\"zsh 命令<br/>cli/cmd/zsh.go\"]\n        MysqlCLI[\"mysqld 命令<br/>cli/cmd/mysqld.go\"]\n        PgCLI[\"postgres 命令<br/>cli/cmd/postgres.go\"]\n    end\n    \n    subgraph \"配置\"\n        BashConfig[\"BashConfig<br/>--bash, --readlineso<br/>--errnumber\"]\n        ZshConfig[\"ZshConfig<br/>--zsh, --errnumber\"]\n        MysqlConfig[\"MysqldConfig<br/>--mysqld, --offset<br/>--funcname\"]\n        PgConfig[\"PostgresConfig<br/>--postgres, --funcname\"]\n    end\n    \n    subgraph \"模块层\"\n        BashModule[\"MBashProbe<br/>user/module/probe_bash.go\"]\n        ZshModule[\"MZshProbe<br/>user/module/probe_zsh.go\"]\n        MysqlModule[\"MMysqldProbe<br/>user/module/probe_mysqld.go\"]\n        PgModule[\"MPostgresProbe<br/>user/module/probe_postgres.go\"]\n    end\n    \n    subgraph \"eBPF 程序\"\n        BashKern[\"bash_kern.c<br/>uretprobe/bash_readline<br/>uretprobe/bash_retval<br/>uprobe/exec_builtin<br/>uprobe/exit_builtin\"]\n        MysqlKern[\"mysqld_kern.c<br/>uprobe/dispatch_command<br/>uretprobe/dispatch_command<br/>uprobe/dispatch_command_57<br/>uretprobe/dispatch_command_57\"]\n        PgKern[\"postgres_kern.c<br/>uprobe/exec_simple_query\"]\n    end\n    \n    subgraph \"eBPF Maps\"\n        BashMaps[\"events_t<br/>PID → event<br/>events<br/>perf array\"]\n        MysqlMaps[\"sql_hash<br/>PID → data_t<br/>events<br/>perf array\"]\n        PgMaps[\"events<br/>perf array\"]\n    end\n    \n    subgraph \"事件结构\"\n        BashEvent[\"struct event<br/>type, pid, uid<br/>line, retval, comm\"]\n        MysqlEvent[\"struct data_t<br/>pid, timestamp<br/>query, len, comm<br/>retval\"]\n        PgEvent[\"struct data_t<br/>pid, timestamp<br/>query, comm\"]\n    end\n    \n    subgraph \"输出\"\n        TextOutput[\"文本输出<br/>控制台/文件\"]\n    end\n    \n    BashCLI --> BashConfig\n    ZshCLI --> ZshConfig\n    MysqlCLI --> MysqlConfig\n    PgCLI --> PgConfig\n    \n    BashConfig --> BashModule\n    ZshConfig --> ZshModule\n    MysqlConfig --> MysqlModule\n    PgConfig --> PgModule\n    \n    BashModule --> BashKern\n    ZshModule --> BashKern\n    MysqlModule --> MysqlKern\n    PgModule --> PgKern\n    \n    BashKern --> BashMaps\n    MysqlKern --> MysqlMaps\n    PgKern --> PgMaps\n    \n    BashMaps --> BashEvent\n    MysqlMaps --> MysqlEvent\n    PgMaps --> PgEvent\n    \n    BashEvent --> TextOutput\n    MysqlEvent --> TextOutput\n    PgEvent --> TextOutput\n    \n    style BashKern fill:#e3f2fd\n    style MysqlKern fill:#fff3e0\n    style PgKern fill:#f3e5f5\n```\n\n**图示：系统审计模块架构**\n\n该架构采用分层设计，其中 CLI 命令将用户参数解析为配置对象，配置对象传递给加载和管理 eBPF 程序的模块实现。eBPF 程序使用 uprobe 拦截函数调用，在 eBPF map 中存储中间状态，并通过 perf array 将事件发送到用户空间。\n\n**来源：** [cli/cmd/bash.go:24-55](), [cli/cmd/mysqld.go:27-49](), [cli/cmd/postgres.go:27-45](), [kern/bash_kern.c:17-133](), [kern/mysqld_kern.c:19-266](), [kern/postgres_kern.c:17-61]()\n\n## Shell 命令审计\n\n### Bash 命令捕获\n\nBash 命令审计通过钩住 `readline()` 函数和相关执行函数来捕获命令文本及其退出状态。\n\n```mermaid\nsequenceDiagram\n    participant User[\"用户\"]\n    participant Bash[\"bash 进程\"]\n    participant Readline[\"readline()\"]\n    participant Execute[\"execute_command()\"]\n    participant eBPF[\"bash_kern.c\"]\n    participant Maps[\"eBPF Maps\"]\n    participant UserSpace[\"用户空间\"]\n    \n    User->>Bash: 输入命令\n    Bash->>Readline: 调用 readline()\n    \n    Note over eBPF: uretprobe/bash_readline\n    Readline-->>eBPF: 返回命令字符串\n    eBPF->>eBPF: 创建事件<br/>type=READLINE<br/>line=命令文本\n    eBPF->>Maps: 存储到 events_t[pid]\n    eBPF->>UserSpace: 通过 perf array 发送\n    \n    Bash->>Execute: 执行命令\n    Execute->>Execute: 运行命令\n    \n    Note over eBPF: uretprobe/bash_retval\n    Execute-->>eBPF: 返回退出码\n    eBPF->>Maps: 查找 events_t[pid]\n    eBPF->>eBPF: 更新事件<br/>type=RETVAL<br/>retval=退出码\n    eBPF->>UserSpace: 发送完整事件\n    eBPF->>Maps: 删除 events_t[pid]\n    \n    UserSpace->>User: 显示命令 + 退出状态\n```\n\n**图示：Bash 命令捕获流程**\n\n捕获过程使用两个 uretprobe：\n1. **uretprobe/bash_readline** [kern/bash_kern.c:42-70]() 在 `readline()` 返回时捕获命令文本\n2. **uretprobe/bash_retval** [kern/bash_kern.c:71-112]() 从命令执行中捕获退出状态\n\n两阶段捕获使用 PID 索引的 map 存储来关联命令与其结果。\n\n**来源：** [kern/bash_kern.c:42-112]()\n\n### Bash eBPF 实现\n\nBash eBPF 程序定义事件结构并使用哈希表进行状态跟踪：\n\n```c\nstruct event {\n    u32 type;              // 事件类型：READLINE 或 RETVAL\n    u32 pid;               // 进程 ID\n    u32 uid;               // 用户 ID\n    u8 line[MAX_DATA_SIZE_BASH];  // 命令文本\n    u32 retval;            // 退出状态\n    char comm[TASK_COMM_LEN];      // 进程名称\n};\n```\n\n程序使用两个 eBPF map：\n- **events** (BPF_MAP_TYPE_PERF_EVENT_ARRAY)：向用户空间输出事件 [kern/bash_kern.c:26-31]()\n- **events_t** (BPF_MAP_TYPE_HASH)：存储按 PID 索引的部分事件 [kern/bash_kern.c:33-38]()\n\n**PID/UID 过滤**：当为内核 ≥5.2 编译时（非 KERNEL_LESS_5_2），程序执行过滤：\n```c\nif (target_pid != 0 && target_pid != pid) {\n    return 0;\n}\nif (target_uid != 0 && target_uid != uid) {\n    return 0;\n}\n```\n\n这允许用户通过 CLI 标志针对特定进程或用户。\n\n**来源：** [kern/bash_kern.c:17-112]()\n\n### Bash/Zsh 退出和执行事件\n\nBash 和 Zsh 模块都在 shell 退出或执行外部命令时捕获特殊事件：\n\n```c\nstatic __always_inline int send_bash_exit_event(struct pt_regs *ctx) {\n    struct event event = {\n        .type = BASH_EVENT_TYPE_EXIT_OR_EXEC,\n        .pid = pid,\n        .uid = uid,\n    };\n    bpf_perf_event_output(ctx, &events, BPF_F_CURRENT_CPU, &event, sizeof(struct event));\n    return 0;\n}\n\nSEC(\"uprobe/exec_builtin\")\nint uprobe_exec_builtin(struct pt_regs *ctx) { return send_bash_exit_event(ctx); }\n\nSEC(\"uprobe/exit_builtin\")\nint uprobe_exit_builtin(struct pt_regs *ctx) { return send_bash_exit_event(ctx); }\n```\n\n这些探针跟踪 shell 生命周期事件，对会话监控和取证分析很有用。\n\n**来源：** [kern/bash_kern.c:114-133]()\n\n### Zsh 命令捕获\n\nZsh 审计遵循与 Bash 相同的架构，但钩住不同的函数：\n- `zleread()` 用于命令输入\n- `execcmd_exec()` 用于返回值\n\nZsh 模块重用相同的 eBPF 字节码结构 [kern/bash_kern.c]()，但通过 CLI 命令 [cli/cmd/zsh.go:30-57]() 配置不同的钩子点。\n\n**来源：** [cli/cmd/zsh.go:30-57]()\n\n## 数据库查询审计\n\n### MySQL 查询捕获\n\nMySQL 查询审计拦截 `dispatch_command()` 函数，该函数处理包括 SQL 查询在内的所有客户端命令。\n\n```mermaid\ngraph TB\n    subgraph \"MySQL 服务器进程\"\n        Client[\"MySQL 客户端<br/>连接\"]\n        Protocol[\"协议处理器\"]\n        Dispatch[\"dispatch_command()<br/>入口点\"]\n        Execute[\"查询执行<br/>引擎\"]\n    end\n    \n    subgraph \"eBPF 钩子\"\n        Entry[\"uprobe/dispatch_command<br/>或<br/>uprobe/dispatch_command_57\"]\n        Return[\"uretprobe/dispatch_command<br/>或<br/>uretprobe/dispatch_command_57\"]\n    end\n    \n    subgraph \"eBPF 状态\"\n        HashCheck[\"检查命令<br/>== COM_QUERY?\"]\n        ReadQuery[\"bpf_probe_read_user<br/>提取查询字符串\"]\n        Store[\"sql_hash[PID]<br/>存储查询 + 元数据\"]\n        Lookup[\"sql_hash[PID]<br/>检索查询\"]\n        AddRetval[\"添加返回值<br/>retval 字段\"]\n        Output[\"bpf_perf_event_output<br/>发送到用户空间\"]\n    end\n    \n    subgraph \"用户空间\"\n        Parser[\"事件解析器\"]\n        Logger[\"文本日志记录器\"]\n    end\n    \n    Client --> Protocol\n    Protocol --> Dispatch\n    \n    Dispatch -.->|\"entry probe\"| Entry\n    Entry --> HashCheck\n    HashCheck -->|\"是\"| ReadQuery\n    HashCheck -->|\"否\"| Skip[\"跳过\"]\n    ReadQuery --> Store\n    \n    Dispatch --> Execute\n    Execute --> ExecReturn[\"返回\"]\n    \n    ExecReturn -.->|\"return probe\"| Return\n    Return --> Lookup\n    Lookup --> AddRetval\n    AddRetval --> Output\n    \n    Output --> Parser\n    Parser --> Logger\n    \n    style Entry fill:#fff3e0\n    style Return fill:#fff3e0\n    style Store fill:#e3f2fd\n```\n\n**图示：MySQL 查询捕获流程**\n\n捕获使用版本特定的探针函数：\n- **MySQL 5.6**: `dispatch_command(enum command, THD *thd, char *packet, uint length)` [kern/mysqld_kern.c:43-99]()\n- **MySQL 5.7+/8.0**: `dispatch_command(THD *thd, const COM_DATA *com_data, enum command)` [kern/mysqld_kern.c:186-226]()\n\n**来源：** [kern/mysqld_kern.c:43-266]()\n\n### MySQL 版本特定处理\n\nMySQL 模块处理两种不同的函数签名：\n\n**MySQL 5.6 签名：**\n```c\nSEC(\"uprobe/dispatch_command\")\nint mysql56_query(struct pt_regs *ctx) {\n    u64 command = (u64)PT_REGS_PARM1(ctx);  // enum_server_command\n    if (command != COM_QUERY) {\n        return 0;  // 仅捕获 SQL 查询 (COM_QUERY = 0x03)\n    }\n    \n    u64 len = (u64)PT_REGS_PARM4(ctx);\n    bpf_probe_read_user(&data.query, len, (void *)PT_REGS_PARM3(ctx));\n}\n```\n\n**MySQL 5.7+/8.0 签名：**\n```c\nSEC(\"upr obe/dispatch_command_57\")\nint mysql57_query(struct pt_regs *ctx) {\n    u64 command = (u64)PT_REGS_PARM3(ctx);  // enum_server_command 移动了位置\n    if (command != COM_QUERY) {\n        return 0;\n    }\n    \n    void *st = (void *)PT_REGS_PARM2(ctx);  // COM_DATA 结构指针\n    struct COM_QUERY_DATA query;\n    bpf_probe_read_user(&query, sizeof(query), st);\n    bpf_probe_read_user(&data.query, sizeof(data.query), query.query);\n}\n```\n\nCOM_DATA 结构布局在版本之间发生了变化 [kern/mysqld_kern.c:173-178]()。\n\n**来源：** [kern/mysqld_kern.c:43-266]()\n\n### MySQL 事件结构\n\nMySQL 事件结构捕获全面的查询信息：\n\n```c\nstruct data_t {\n    u64 pid;        // 进程 ID\n    u64 timestamp;  // 捕获时间戳\n    char query[MAX_DATA_SIZE_MYSQL];  // SQL 查询文本\n    u64 alllen;     // 原始查询长度\n    u64 len;        // 捕获长度（如果 > MAX 则截断）\n    char comm[TASK_COMM_LEN];  // 进程名称\n    s8 retval;      // dispatch_command 返回值\n};\n```\n\n`retval` 字段指示查询执行状态：\n- **MySQL 5.6**: `DISPATCH_COMMAND_SUCCESS=0`, `DISPATCH_COMMAND_CLOSE_CONNECTION=1`, `DISPATCH_COMMAND_WOULDBLOCK=2`\n- **MySQL 5.7**: 成功为 `0`，连接关闭为 `1`，内部使用 `DISPATCH_COMMAND_V57_FAILED=-2`\n\n**来源：** [kern/mysqld_kern.c:19-27](), [kern/mysqld_kern.c:101-141](), [kern/mysqld_kern.c:233-266]()\n\n### PostgreSQL 查询捕获\n\nPostgreSQL 审计更简单，钩住处理文本查询的单个函数：\n\n```mermaid\nsequenceDiagram\n    participant Client[\"psql/应用程序\"]\n    participant Server[\"postgres 进程\"]\n    participant ExecFunc[\"exec_simple_query()\"]\n    participant eBPF[\"postgres_kern.c\"]\n    participant UserSpace[\"用户空间\"]\n    \n    Client->>Server: 发送 SQL 查询\n    Server->>ExecFunc: exec_simple_query(query_string)\n    \n    Note over eBPF: uprobe/exec_simple_query\n    ExecFunc->>eBPF: 函数入口\n    eBPF->>eBPF: PT_REGS_PARM1(ctx)<br/>= query_string 指针\n    eBPF->>eBPF: bpf_probe_read_user<br/>读取查询文本\n    eBPF->>eBPF: 创建 data_t 事件<br/>pid, timestamp, query, comm\n    eBPF->>UserSpace: bpf_perf_event_output\n    \n    ExecFunc->>Server: 执行查询\n    Server->>Client: 返回结果\n    \n    UserSpace->>UserSpace: 解析事件\n    UserSpace->>UserSpace: 显示查询\n```\n\n**图示：PostgreSQL 查询捕获流程**\n\nPostgreSQL 实现很简单，因为 `exec_simple_query()` 在版本 10+ 中统一处理基于文本的查询。\n\n**来源：** [kern/postgres_kern.c:35-60]()\n\n### PostgreSQL eBPF 实现\n\nPostgreSQL eBPF 程序是数据库模块中最简单的：\n\n```c\nstruct data_t {\n    u64 pid;\n    u64 timestamp;\n    char query[MAX_DATA_SIZE_POSTGRES];\n    char comm[TASK_COMM_LEN];\n};\n\nSEC(\"uprobe/exec_simple_query\")\nint postgres_query(struct pt_regs *ctx) {\n    // PID/UID 过滤\n    \n    struct data_t data = {};\n    data.pid = pid;\n    data.timestamp = bpf_ktime_get_ns();\n    \n    char *sql_string = (char *)PT_REGS_PARM1(ctx);\n    bpf_get_current_comm(&data.comm, sizeof(data.comm));\n    bpf_probe_read_user(&data.query, sizeof(data.query), sql_string);\n    bpf_perf_event_output(ctx, &events, BPF_F_CURRENT_CPU, &data, sizeof(data));\n    return 0;\n}\n```\n\n与 MySQL 不同，PostgreSQL 不需要返回值跟踪或多个版本特定的钩子。\n\n**来源：** [kern/postgres_kern.c:17-60]()\n\n## CLI 使用与配置\n\n### Shell 命令审计 CLI\n\n**Bash 命令：**\n```bash\n# 基本用法\necapture bash\n\n# 指定 bash 二进制路径\necapture bash --bash=/bin/bash\n\n# 指定 readline 库路径\necapture bash --readlineso=/lib/x86_64-linux-gnu/libreadline.so.8\n\n# 按退出码过滤（例如，仅失败的命令）\necapture bash -e 1\n\n# PID/UID 过滤（通用标志）\necapture bash --pid=1234 --uid=1000\n```\n\n**Zsh 命令：**\n```bash\necapture zsh\necapture zsh --zsh=/bin/zsh -e 0  # 仅成功的命令\n```\n\n`--errnumber` 标志按退出状态过滤事件：\n- `-e 0`：仅显示成功的命令\n- `-e 1`：仅显示失败的命令\n- `-e 128`（默认）：显示所有命令\n\n**来源：** [cli/cmd/bash.go:27-55](), [cli/cmd/zsh.go:30-57]()\n\n### 数据库审计 CLI\n\n**MySQL 命令：**\n```bash\n# 基本用法\necapture mysqld\n\n# 指定 mysqld 二进制文件\necapture mysqld --mysqld=/usr/sbin/mysqld\n\n# MariaDB\necapture mysqld --mysqld=/usr/sbin/mariadbd\n\n# 手动函数指定（用于符号解析问题）\necapture mysqld --funcname=_Z16dispatch_commandP3THDPK8COM_DATA19enum_server_command\n\n# 手动偏移量指定\necapture mysqld --offset=0x710410\n```\n\n**PostgreSQL 命令：**\n```bash\n# 基本用法\necapture postgres\n\n# 指定 postgres 二进制文件\necapture postgres --postgres=/usr/lib/postgresql/14/bin/postgres\n\n# 手动函数指定\necapture postgres --funcname=exec_simple_query\n```\n\n`--funcname` 和 `--offset` 标志在自动符号解析失败时提供回退机制。\n\n**来源：** [cli/cmd/mysqld.go:30-49](), [cli/cmd/postgres.go:30-45]()\n\n## 系统审计模块比较\n\n| 功能 | Bash/Zsh | MySQL | PostgreSQL |\n|---------|----------|-------|------------|\n| **钩子策略** | 两阶段（命令 + 返回值） | 两阶段（入口 + 返回） | 单阶段（仅入口） |\n| **状态存储** | events_t[PID] 哈希表 | sql_hash[PID] 哈希表 | 无（直接输出） |\n| **版本变体** | 单个 eBPF 程序 | 两个变体（5.6 vs 5.7+） | 单个程序 |\n| **输出时机** | 命令完成后 | 查询完成后 | 查询开始时 |\n| **截断** | MAX_DATA_SIZE_BASH | MAX_DATA_SIZE_MYSQL | MAX_DATA_SIZE_POSTGRES |\n| **返回值** | 退出码（0-255） | dispatch_command 结果 | 不适用 |\n| **生命周期事件** | 退出/执行跟踪 | 无 | 无 |\n| **CLI 过滤** | 错误号、PID、UID | PID、UID | PID、UID |\n\n## 实现注意事项\n\n### 内存约束\n\neBPF 程序有 512 字节的栈限制，需要仔细管理缓冲区：\n- Bash：`MAX_DATA_SIZE_BASH` 用于命令文本 [kern/bash_kern.c:21]()\n- MySQL：`MAX_DATA_SIZE_MYSQL` 用于查询 [kern/mysqld_kern.c:22]()\n- PostgreSQL：`MAX_DATA_SIZE_POSTGRES` 用于查询 [kern/postgres_kern.c:20]()\n\n大型命令/查询会被截断，通过 `alllen` 与 `len` 字段进行长度跟踪。\n\n### 基于 PID 的关联\n\nshell 和数据库模块都使用 PID 索引的哈希表来关联入口和返回探针：\n1. 入口探针将事件存储在 map 中 [kern/bash_kern.c:66](), [kern/mysqld_kern.c:95]()\n2. 返回探针检索事件 [kern/bash_kern.c:89](), [kern/mysqld_kern.c:132]()\n3. 返回探针更新返回值\n4. 返回探针输出完整事件\n5. 返回探针删除 map 条目\n\n这种模式在实现两阶段捕获的同时防止内存泄漏。\n\n### 跨版本兼容性\n\nMySQL 需要版本检测来选择正确的 eBPF 程序：\n- 模块代码通过二进制分析检测 MySQL 版本\n- 加载 `mysql56_query`/`mysql56_query_return` 或 `mysql57_query`/`mysql57_query_return`\n- COM_DATA 结构布局在版本之间有所不同\n\nPostgreSQL 在版本 10+ 中稳定的 ABI 简化了实现。\n\n**来源：** [kern/mysqld_kern.c:43-266]()"
          },
          {
            "page_plan": {
              "id": "3.2.1",
              "title": "Shell 命令审计"
            },
            "content": "# Shell 命令审计\n\n## 目的与范围\n\n本文档描述 eCapture 对 Bash 和 Zsh shell 的命令审计能力。这些模块使用附加到 `readline()` 函数的 eBPF uretprobe 来捕获交互式命令行输入及其执行返回值。这种方法在库级别拦截命令，早于它们到达 shell 历史文件，提供了一个不可绕过的审计跟踪，用于安全监控。\n\n实现采用两阶段捕获模式：第一个探针在 `readline()` 返回时捕获命令文本，第二个在执行后捕获命令的退出码。事件临时存储在 eBPF 哈希映射中以关联这两个阶段。\n\n有关数据库查询审计，请参阅[数据库查询审计](#3.2.2)。有关通用模块架构，请参阅[模块系统与生命周期](#2.4)。\n\n## eBPF 程序架构\n\n### 两阶段捕获模式\n\nBash 模块使用两个独立的 uretprobe 钩子和中间状态存储实现两阶段捕获机制：\n\n**阶段 1 - 命令行捕获：**\n标题：**命令行捕获流程**\n```mermaid\ngraph LR\n    User[\"用户按下回车\"]\n    ReadlineFunc[\"readline() 函数\"]\n    UretprobeReadline[\"uretprobe_bash_readline\"]\n    EventStruct[\"struct event\"]\n    EventsT[\"events_t 哈希映射<br/>BPF_MAP_TYPE_HASH<br/>key: pid\"]\n    EventsArray[\"events perf 数组<br/>BPF_MAP_TYPE_PERF_EVENT_ARRAY\"]\n    \n    User --> ReadlineFunc\n    ReadlineFunc -->|\"返回 char*\"| UretprobeReadline\n    UretprobeReadline -->|\"PT_REGS_RC(ctx)\"| EventStruct\n    EventStruct -->|\"bpf_map_update_elem\"| EventsT\n    EventStruct -->|\"bpf_perf_event_output\"| EventsArray\n```\n\n**阶段 2 - 返回值捕获：**\n标题：**返回值捕获流程**\n```mermaid\ngraph LR\n    Command[\"命令执行\"]\n    RetvalFunc[\"命令完成\"]\n    UretprobeRetval[\"uretprobe_bash_retval\"]\n    Lookup[\"bpf_map_lookup_elem<br/>从 events_t 按 pid 查找\"]\n    Update[\"更新 event->retval\"]\n    Output[\"bpf_perf_event_output\"]\n    Delete[\"bpf_map_delete_elem<br/>events_t\"]\n    \n    Command --> RetvalFunc\n    RetvalFunc -->|\"返回 int\"| UretprobeRetval\n    UretprobeRetval --> Lookup\n    Lookup -->|\"struct event*\"| Update\n    Update --> Output\n    Update --> Delete\n```\n\n**来源：** [kern/bash_kern.c:42-112]()\n\n### eBPF 程序结构\n\n内核侧 eBPF 程序定义了以下组件：\n\n**事件结构：**\n```c\nstruct event {\n    u32 type;      // 事件类型（READLINE、RETVAL、EXIT_OR_EXEC）\n    u32 pid;       // 进程 ID\n    u32 uid;       // 用户 ID\n    u8 line[MAX_DATA_SIZE_BASH];  // 命令行（256 字节）\n    u32 retval;    // 命令返回值\n    char comm[TASK_COMM_LEN];     // 进程名（16 字节）\n};\n```\n\n**BPF 映射：**\n- `events` - Perf 事件数组，用于向用户空间发送事件\n- `events_t` - 哈希映射，用于在两个阶段之间临时存储事件（键：pid）\n\n**探针函数：**\n- `uretprobe_bash_readline` - 在 readline() 返回时捕获命令文本\n- `uretprobe_bash_retval` - 在命令执行后捕获退出码\n- `uprobe_exec_builtin` - 检测 `exec` 内置命令执行\n- `uprobe_exit_builtin` - 检测 `exit` 内置命令执行\n\n**来源：** [kern/bash_kern.c:17-133]()\n\n---\n\n## 配置\n\n### Bash 模块配置\n\nBash 模块接受以下配置参数：\n\n| 参数 | 标志 | 类型 | 默认值 | 描述 |\n|-----------|------|------|---------|-------------|\n| Bashpath | `--bash` | string | 从 `$SHELL` 自动检测 | bash 可执行文件路径 |\n| Readline | `--readlineso` | string | 从 bash 路径自动检测 | readline.so 库路径 |\n| ErrNo | `-e, --errnumber` | int | `BashErrnoDefault` | 按退出码过滤命令 |\n\n**配置结构：**\n\n```go\n// 通过 config.NewBashConfig() 创建\ntype BashConfig struct {\n    Bashpath string  // 目标 bash 二进制文件\n    Readline string  // libreadline.so 路径\n    ErrNo    int     // 退出码过滤器\n}\n```\n\n### Zsh 模块配置\n\n| 参数 | 标志 | 类型 | 默认值 | 描述 |\n|-----------|------|------|---------|-------------|\n| Zshpath | `--zsh` | string | 从 `$SHELL` 自动检测 | zsh 可执行文件路径 |\n| ErrNo | `-e, --errnumber` | int | `ZshErrnoDefault` | 按退出码过滤命令 |\n\n**来源：** [cli/cmd/bash.go:24-39](), [cli/cmd/zsh.go:27-41]()\n\n### 命令行使用\n\n```bash\n# 基本 bash 命令捕获\necapture bash\n\n# 使用自定义路径捕获 bash 命令\necapture bash --bash=/bin/bash --readlineso=/lib/x86_64-linux-gnu/libreadline.so\n\n# 按退出码过滤（只显示失败的命令）\necapture bash -e 1\n\n# Zsh 命令捕获\necapture zsh --zsh=/bin/zsh -e 0\n```\n\n**来源：** [cli/cmd/bash.go:26-33](), [cli/cmd/zsh.go:30-36]()\n\n---\n\n## 事件结构\n\n### BashEvent 数据布局\n\n从 shell 捕获的命令被编码在 `BashEvent` 结构中，它镜像了 eBPF 内核侧结构：\n\n```mermaid\ngraph LR\n    subgraph \"内核空间 - eBPF 事件\"\n        BPFStruct[\"struct bash_event<br/>- u8 type<br/>- u32 pid<br/>- u32 uid<br/>- u8 line[256]<br/>- u32 retval<br/>- char comm[16]\"]\n    end\n    \n    subgraph \"用户空间 - Go 结构\"\n        GoStruct[\"BashEvent<br/>- BashType uint32<br/>- Pid uint32<br/>- Uid uint32<br/>- Line [256]uint8<br/>- ReturnValue uint32<br/>- Comm [16]byte<br/>- AllLines string\"]\n    end\n    \n    subgraph \"输出格式\"\n        StringOut[\"PID:123, UID:1000<br/>Comm:bash<br/>Retvalue:0<br/>Line: ls -la\"]\n    end\n    \n    BPFStruct -->|\"perf 缓冲区\"| GoStruct\n    GoStruct -->|\"String()\"| StringOut\n```\n\n**来源：** [user/event/event_bash.go:26-47]()\n\n### 字段描述\n\n| 字段 | 类型 | 大小 | 描述 |\n|-------|------|------|-------------|\n| BashType | uint32 | 4 字节 | 事件类型（见事件类型表） |\n| Pid | uint32 | 4 字节 | Shell 的进程 ID |\n| Uid | uint32 | 4 字节 | 执行命令的用户 ID |\n| Line | [256]uint8 | 256 字节 | 来自 readline 缓冲区的命令行文本 |\n| ReturnValue | uint32 | 4 字节 | 命令的退出码（0=成功） |\n| Comm | [16]byte | 16 字节 | 进程名（通常是 \"bash\" 或 \"zsh\"） |\n| AllLines | string | 可变 | 聚合的完整命令（用户空间字段） |\n\n### 事件类型\n\neBPF 程序生成三种类型的事件：\n\n| 常量 | 值 | 描述 | 来源函数 |\n|----------|-------|-------------|-----------------|\n| BASH_EVENT_TYPE_READLINE | 0 | 从 readline() 捕获的命令行 | `uretprobe_bash_readline` |\n| BASH_EVENT_TYPE_RETVAL | 1 | 捕获的命令退出码 | `uretprobe_bash_retval` |\n| BASH_EVENT_TYPE_EXIT_OR_EXEC | 2 | 检测到 shell 退出或 exec | `uprobe_exec_builtin`, `uprobe_exit_builtin` |\n\n**最大数据大小：** `MAX_DATA_SIZE_BASH` = 每个事件 256 字节（定义在 [kern/bash_kern.c:21]()）\n\n**来源：** [user/event/event_bash.go:37-47](), [kern/bash_kern.c:17-24]()\n\n---\n\n## 事件处理流程\n\n### 从 Shell 到输出的数据流\n\n标题：**完整的 Bash 命令捕获流程**\n```mermaid\nflowchart TD\n    Shell[\"用户输入命令\"]\n    Readline[\"readline() 返回<br/>命令文本\"]\n    \n    subgraph \"eBPF 内核 - 阶段 1\"\n        Probe1[\"uretprobe_bash_readline<br/>kern/bash_kern.c:42\"]\n        Filter1{\"target_pid<br/>target_uid<br/>过滤器\"}\n        CreateEvent1[\"创建 struct event<br/>- type = READLINE<br/>- pid/uid 从 bpf_get_current_*<br/>- line 从 PT_REGS_RC(ctx)\"]\n        StoreTemp[\"bpf_map_update_elem<br/>events_t[pid] = event\"]\n        Send1[\"bpf_perf_event_output<br/>到 events 映射\"]\n    end\n    \n    Shell --> Readline\n    Readline --> Probe1\n    Probe1 --> Filter1\n    Filter1 -->|\"通过\"| CreateEvent1\n    Filter1 -->|\"丢弃\"| End1[\"return 0\"]\n    CreateEvent1 --> StoreTemp\n    CreateEvent1 --> Send1\n    \n    CommandExec[\"命令执行\"]\n    CommandRet[\"命令返回<br/>退出码\"]\n    \n    subgraph \"eBPF 内核 - 阶段 2\"\n        Probe2[\"uretprobe_bash_retval<br/>kern/bash_kern.c:72\"]\n        Filter2{\"target_pid<br/>target_uid<br/>过滤器\"}\n        Lookup[\"bpf_map_lookup_elem<br/>events_t[pid]\"]\n        CheckErrno{\"target_errno<br/>匹配 retval?\"}\n        UpdateRetval[\"event_p->retval = retval<br/>event_p->type = RETVAL\"]\n        Send2[\"bpf_perf_event_output<br/>带 retval\"]\n        DeleteTemp[\"bpf_map_delete_elem<br/>events_t[pid]\"]\n    end\n    \n    Send1 --> CommandExec\n    CommandExec --> CommandRet\n    CommandRet --> Probe2\n    Probe2 --> Filter2\n    Filter2 -->|\"通过\"| Lookup\n    Filter2 -->|\"丢弃\"| End2[\"return 0\"]\n    Lookup -->|\"找到\"| CheckErrno\n    Lookup -->|\"未找到\"| End2\n    CheckErrno -->|\"匹配\"| UpdateRetval\n    CheckErrno -->|\"不匹配\"| Send2\n    UpdateRetval --> Send2\n    Send2 --> DeleteTemp\n    \n    subgraph \"用户空间处理\"\n        Reader[\"perfEventReader<br/>从 events 读取\"]\n        Decode[\"BashEvent.Decode()<br/>user/event/event_bash.go:49\"]\n        Format[\"BashEvent.String()<br/>user/event/event_bash.go:72\"]\n        Console[\"控制台输出\"]\n    end\n    \n    Send2 --> Reader\n    Reader --> Decode\n    Decode --> Format\n    Format --> Console\n```\n\n**来源：** [kern/bash_kern.c:42-112](), [user/event/event_bash.go:49-80]()\n\n### 过滤机制\n\neBPF 程序实现了三个级别的过滤：\n\n**1. PID/UID 过滤（内核级别）：**\n```c\n// 在 uretprobe_bash_readline 中（第 50-57 行）\nif (target_pid != 0 && target_pid != pid) {\n    return 0;  // 如果 PID 不匹配则丢弃\n}\nif (target_uid != 0 && target_uid != uid) {\n    return 0;  // 如果 UID 不匹配则丢弃\n}\n```\n\n**2. 退出码过滤（内核级别）：**\n```c\n// 在 uretprobe_bash_retval 中（第 92-102 行）\nif (target_errno != BASH_ERRNO_DEFAULT && target_errno != retval) {\n    // 仍然输出事件但标记为未捕获\n    event_p->retval = BASH_ERRNO_DEFAULT;\n    event_p->type = BASH_EVENT_TYPE_RETVAL;\n    bpf_perf_event_output(...);\n    return 0;\n}\n```\n\n**3. 基于 UUID 的事件关联（用户级别）：**\n\nUUID 格式：`{Pid}_{Uid}_{Comm}`\n\n示例：`1234_1000_bash`\n\n此 UUID 使得能够在事件处理流程中对来自同一 shell 会话的相关事件进行分组。\n\n**来源：** [kern/bash_kern.c:50-102](), [user/event/event_bash.go:123-125]()\n\n---\n\n## 退出码过滤\n\n### 过滤器配置\n\n退出码过滤器使用 `target_errno` 变量在 eBPF 内核级别运行：\n\n标题：**退出码过滤逻辑**\n```mermaid\ngraph TB\n    Command[\"命令完成<br/>带退出码\"]\n    Probe[\"uretprobe_bash_retval<br/>PT_REGS_RC(ctx)\"]\n    Lookup[\"查找存储的事件<br/>从 events_t 映射\"]\n    \n    CheckErrno{\"target_errno ==<br/>BASH_ERRNO_DEFAULT?\"}\n    CheckMatch{\"target_errno ==<br/>retval?\"}\n    \n    MarkNotCaptured[\"设置 retval =<br/>BASH_ERRNO_DEFAULT<br/>type = RETVAL\"]\n    UpdateRetval[\"设置 retval = 实际值<br/>type = RETVAL\"]\n    \n    Output[\"bpf_perf_event_output\"]\n    Delete[\"bpf_map_delete_elem\"]\n    \n    Command --> Probe\n    Probe --> Lookup\n    Lookup --> CheckErrno\n    \n    CheckErrno -->|\"是（捕获全部）\"| UpdateRetval\n    CheckErrno -->|\"否（过滤模式）\"| CheckMatch\n    \n    CheckMatch -->|\"匹配\"| UpdateRetval\n    CheckMatch -->|\"不匹配\"| MarkNotCaptured\n    \n    MarkNotCaptured --> Output\n    UpdateRetval --> Output\n    Output --> Delete\n```\n\n**常量：**\n- `BASH_ERRNO_DEFAULT` - 特殊值，表示\"捕获所有退出码\"\n- 当 `target_errno` 匹配此默认值时，无论退出码如何都会捕获所有命令\n- 当 `target_errno` 设置为特定值（例如 0、1、127）时，只有匹配的命令才会被完全捕获\n\n**来源：** [kern/bash_kern.c:92-102]()\n\n### 常见用例\n\n| ErrNo 值 | 用例 | 描述 |\n|-------------|----------|-------------|\n| 0 | 成功的命令 | 审计成功完成的命令 |\n| 1 | 失败的命令 | 检测失败的执行尝试 |\n| 127 | 命令未找到 | 识别拼写错误或缺少的二进制文件 |\n| 126 | 权限被拒绝 | 跟踪权限问题 |\n| Default | 所有命令 | 全面的审计跟踪 |\n\n---\n\n## 输出格式\n\n### 文本输出结构\n\n`BashEvent.String()` 方法格式化捕获的命令以在控制台显示：\n\n```\nPID:1234, UID:1000, \tComm:bash, \tRetvalue:0, \tLine:\nls -la /etc/passwd\n```\n\n**格式模板：** `PID:%d, UID:%d, \\tComm:%s, \\tRetvalue:%d, \\tLine:\\n%s`\n\n**颜色编码：** 输出使用来自 [user/event/event_bash.go:72-75]() 的标准颜色方案，尽管具体颜色取决于终端支持。\n\n**来源：** [user/event/event_bash.go:72-75]()\n\n### 十六进制输出模式\n\n使用 `--hex` 标志运行时，命令以十六进制格式通过 `StringHex()` 显示：\n\n```\nPID:1234, UID:1000, \tComm:bash, \tRetvalue:0, \tLine:\n0000    6C 73 20 2D 6C 61    ls -la\n```\n\n**来源：** [user/event/event_bash.go:77-80]()\n\n---\n\n## 探针附加点\n\n### 探针附加点\n\n模块附加四个 eBPF 探针来捕获完整的命令生命周期：\n\n标题：**eBPF 探针附加点**\n```mermaid\ngraph TB\n    Readline[\"readline() 函数<br/>在 bash 或 libreadline.so 中\"]\n    ExecBuiltin[\"execute_builtin() 函数<br/>处理 'exec' 命令\"]\n    ExitBuiltin[\"exit_builtin() 函数<br/>处理 'exit' 命令\"]\n    \n    subgraph \"eBPF 探针\"\n        P1[\"SEC('uretprobe/bash_readline')<br/>int uretprobe_bash_readline\"]\n        P2[\"SEC('uretprobe/bash_retval')<br/>int uretprobe_bash_retval\"]\n        P3[\"SEC('uprobe/exec_builtin')<br/>int uprobe_exec_builtin\"]\n        P4[\"SEC('uprobe/exit_builtin')<br/>int uprobe_exit_builtin\"]\n    end\n    \n    Readline -.->|\"uretprobe\"| P1\n    Readline -.->|\"uretprobe<br/>（不同偏移量）\"| P2\n    ExecBuiltin -.->|\"uprobe\"| P3\n    ExitBuiltin -.->|\"uprobe\"| P4\n    \n    P1 -->|\"BASH_EVENT_TYPE_READLINE\"| Events[\"events perf 数组\"]\n    P2 -->|\"BASH_EVENT_TYPE_RETVAL\"| Events\n    P3 -->|\"BASH_EVENT_TYPE_EXIT_OR_EXEC\"| Events\n    P4 -->|\"BASH_EVENT_TYPE_EXIT_OR_EXEC\"| Events\n```\n\n**探针详情：**\n\n| SEC 节 | 附加点 | 钩子类型 | 目的 |\n|-------------|--------------|-----------|---------|\n| `uretprobe/bash_readline` | `readline()` 返回 | uretprobe | 从返回值捕获命令文本 |\n| `uretprobe/bash_retval` | 命令执行返回 | uretprobe | 捕获命令退出码 |\n| `uprobe/exec_builtin` | `execute_builtin()` 入口 | uprobe | 检测 `exec` 命令（shell 替换） |\n| `uprobe/exit_builtin` | `exit_builtin()` 入口 | uprobe | 检测 `exit` 命令（shell 终止） |\n\n**数据提取：**\n- 命令文本：在 `uretprobe_bash_readline` 中从 `PT_REGS_RC(ctx)` 读取（第 64 行）\n- 退出码：在 `uretprobe_bash_retval` 中从 `PT_REGS_RC(ctx)` 读取（第 77 行）\n- PID/UID：使用 `bpf_get_current_pid_tgid()` 和 `bpf_get_current_uid_gid()` 提取\n- 进程名：通过 `bpf_get_current_comm()` 捕获\n\n**来源：** [kern/bash_kern.c:42-133]()\n\n---\n\n## 状态管理\n\n### 临时事件存储\n\neBPF 程序使用哈希映射来关联事件捕获的两个阶段：\n\n标题：**events_t 哈希映射状态机**\n```mermaid\nstateDiagram-v2\n    [*] --> Empty: Shell 空闲\n    Empty --> Stored: uretprobe_bash_readline<br/>bpf_map_update_elem(events_t)\n    Stored --> Empty: uretprobe_bash_retval<br/>bpf_map_delete_elem(events_t)\n    Stored --> Stored: 在 retval 之前的另一个 readline<br/>（覆盖条目）\n    \n    note right of Stored\n        键: pid (u32)\n        值: struct event\n        最大条目: 1024\n    end note\n```\n\n**映射定义：**\n```c\nstruct {\n    __uint(type, BPF_MAP_TYPE_HASH);\n    __type(key, u32);                  // PID\n    __type(value, struct event);       // 临时事件存储\n    __uint(max_entries, 1024);\n} events_t SEC(\".maps\");\n```\n\n**生命周期：**\n1. **插入：** 当 `readline()` 返回时，事件以 PID 作为键存储 [kern/bash_kern.c:66]()\n2. **查找：** 当命令完成时，通过 PID 检索事件 [kern/bash_kern.c:89]()\n3. **更新：** 返回值添加到现有事件 [kern/bash_kern.c:105]()\n4. **删除：** 发送到用户空间后删除事件 [kern/bash_kern.c:108]()\n\n**边缘情况：**\n- 如果用户快速连续按回车多次，每个 PID 只跟踪最后一个命令\n- 最多可以跟踪 1024 个并发 shell 会话\n- 如果 retval 钩子永远不触发（例如 shell 崩溃），孤立的事件会保留到映射满为止\n\n**来源：** [kern/bash_kern.c:33-38, 66, 89, 105-108]()\n\n---\n\n## 用户空间事件处理\n\n### BashEvent 结构\n\nGo 侧事件结构镜像内核结构，并带有附加字段：\n\n```go\ntype BashEvent struct {\n    eventType   Type\n    BashType    uint32                 // 映射到内核 'type' 字段\n    Pid         uint32\n    Uid         uint32\n    Line        [MaxDataSizeBash]uint8 // MaxDataSizeBash = 256\n    ReturnValue uint32                 // 退出码\n    Comm        [16]byte\n    base        Base\n    AllLines    string                 // 用户空间聚合字段\n}\n```\n\n**解码过程：**\n1. 原始字节通过 `perfEventReader` 从 perf 事件数组读取\n2. `BashEvent.Decode()` 使用 `binary.LittleEndian` 反序列化二进制数据 [user/event/event_bash.go:49-70]()\n3. 字段按顺序填充：BashType, Pid, Uid, Line, ReturnValue, Comm\n\n**输出格式化：**\n- `String()` 方法产生人类可读的输出 [user/event/event_bash.go:72-75]()\n- `StringHex()` 方法产生十六进制转储输出 [user/event/event_bash.go:77-80]()\n- 格式：`PID:%d, UID:%d, Comm:%s, Retvalue:%d, Line:\\n%s`\n\n**事件类型分类：**\n\n事件被分类为 `TypeModuleData` [user/event/event_bash.go:84]()，这意味着：\n- 没有 HTTP/HTTP2 协议解析\n- 没有自动 PCAP 生成\n- 直接输出到控制台或文本文件\n- 模块保持对格式化的完全控制\n\n**来源：** [user/event/event_bash.go:37-86]()\n\n---\n\n## Protobuf 事件序列化\n\nShell 事件可以通过 Protobuf/WebSocket 接口导出以用于外部集成：\n\n### Protobuf 映射\n\n```mermaid\ngraph LR\n    BashEvent[\"BashEvent 结构\"]\n    ProtoEvent[\"pb.Event protobuf\"]\n    \n    subgraph \"字段映射\"\n        Timestamp[\"Timestamp<br/>time.Now().Unix()\"]\n        UUID[\"UUID<br/>{Pid}_{Uid}_{Comm}\"]\n        IPs[\"SrcIp/DstIp<br/>127.0.0.1<br/>（本地事件）\"]\n        Ports[\"SrcPort/DstPort<br/>0（不适用）\"]\n        Process[\"Pid, Pname<br/>来自事件\"]\n        Type[\"Type<br/>BashType\"]\n        Payload[\"Length, Payload<br/>AllLines 命令文本\"]\n    end\n    \n    BashEvent --> ProtoEvent\n    Timestamp --> ProtoEvent\n    UUID --> ProtoEvent\n    IPs --> ProtoEvent\n    Ports --> ProtoEvent\n    Process --> ProtoEvent\n    Type --> ProtoEvent\n    Payload --> ProtoEvent\n```\n\n**特殊处理：**\n- Bash 事件没有网络上下文（SrcIP/DstIP 设置为 `127.0.0.1`，端口设置为 `0`）\n- 时间戳使用 `time.Now().Unix()` 而不是内核时间戳\n- Payload 包含来自 `AllLines` 的完整命令行文本\n\n**来源：** [user/event/event_bash.go:103-117]()\n\n---\n\n## 安全考虑\n\n### 审计跟踪完整性\n\nShell 命令审计提供：\n\n- **不可绕过的捕获：** 在库级别钩子，早于历史文件写入\n- **UID 跟踪：** 将命令与用户身份关联\n- **退出码跟踪：** 区分成功与失败的尝试\n- **进程关联：** 将命令链接到特定 shell 会话\n\n### 隐私影响\n\n该模块捕获：\n- 所有交互式命令输入（包括键入的密码）\n- 命令参数（可能包含敏感数据）\n- 工作目录上下文（通过进程检查）\n\n**建议：** 在生产环境中部署时使用退出码过滤和安全日志存储。\n\n---\n\n## 用例\n\n### 安全审计\n\n```bash\n# 监控特定用户执行的所有命令\necapture bash --pid=$(pgrep -u suspicious_user bash)\n\n# 跟踪失败的命令尝试（潜在的侦察）\necapture bash -e 1\n```\n\n### 合规监控\n\n```bash\n# 捕获所有成功的管理命令\necapture bash -e 0 -l /var/log/audit/bash_commands.log\n```\n\n### 调试与支持\n\n```bash\n# 在故障排除会话期间记录所有命令\necapture bash > debug_session.log\n```\n\n### 入侵检测\n\n```bash\n# 监控命令未找到错误（异常活动）\necapture bash -e 127\n```\n\n**来源：** [cli/cmd/bash.go:28-33](), [user/event/event_bash.go:72-75]()"
          },
          {
            "page_plan": {
              "id": "3.2.2",
              "title": "数据库查询审计"
            },
            "content": "# 数据库查询审计\n\n## 目的与范围\n\n本文档描述了 eCapture 的数据库查询审计功能，该功能能够实时捕获 MySQL 和 PostgreSQL 数据库服务器执行的 SQL 查询，无需数据库级别的日志配置或权限。系统使用 eBPF uprobe 拦截数据库服务器二进制文件中的查询分发函数，捕获查询文本、进程信息和执行元数据。\n\n本页涵盖 MySQL (`mysqld`) 和 PostgreSQL (`postgres`) 捕获模块。关于 shell 命令审计（bash/zsh），请参见[Shell 命令审计](#3.2.1)。关于 TLS/SSL 流量捕获，请参见[TLS/SSL 模块](#3.1)。\n\n---\n\n## 架构概述\n\n数据库查询审计的运作方式与 TLS 模块不同，它针对的是数据库服务器进程而非 SSL/TLS 库。系统将 uprobe 附加到数据库二进制文件中的特定查询处理函数上，在查询被分发执行时捕获 SQL 查询字符串。\n\n### 数据库查询捕获架构\n\n```mermaid\ngraph TB\n    subgraph DatabaseProcess[\"数据库服务器进程\"]\n        Client[\"数据库客户端<br/>mysql, psql, application\"]\n        Protocol[\"协议处理器<br/>MySQL Protocol<br/>PostgreSQL Wire Protocol\"]\n        DispatchMySQL[\"dispatch_command()<br/>MySQL 5.6-8.0<br/>MariaDB 10.5+\"]\n        DispatchPG[\"exec_simple_query()<br/>PostgreSQL 10+\"]\n        Executor[\"查询执行器<br/>SQL Parser & Optimizer\"]\n    end\n    \n    subgraph eBPFKernel[\"eBPF 内核空间\"]\n        UprobeMySQL[\"SEC('uprobe/dispatch_command')<br/>mysql56_query()<br/>mysql57_query()\"]\n        UprobeMySQL2[\"SEC('uretprobe/dispatch_command')<br/>mysql56_query_return()<br/>mysql57_query_return()\"]\n        UprobePG[\"SEC('uprobe/exec_simple_query')<br/>postgres_query()\"]\n        ExtractQuery[\"查询提取<br/>PT_REGS_PARM1/PARM2/PARM3/PARM4<br/>bpf_probe_read_user()\"]\n        EventMaps[\"eBPF 映射表<br/>sql_hash (BPF_MAP_TYPE_HASH)<br/>events (BPF_MAP_TYPE_PERF_EVENT_ARRAY)\"]\n    end\n    \n    subgraph UserSpace[\"用户空间处理\"]\n        EventStruct[\"事件结构体<br/>MysqldEvent (struct data_t)<br/>PostgresEvent (struct data_t)\"]\n        DecodeFunc[\"解码函数<br/>MysqldEvent.Decode()<br/>PostgresEvent.Decode()\"]\n        Display[\"文本输出<br/>MysqldEvent.String()<br/>PostgresEvent.String()\"]\n    end\n    \n    Client --> Protocol\n    Protocol --> DispatchMySQL\n    Protocol --> DispatchPG\n    DispatchMySQL --> Executor\n    DispatchPG --> Executor\n    \n    DispatchMySQL -.uprobe.-> UprobeMySQL\n    DispatchMySQL -.uretprobe.-> UprobeMySQL2\n    DispatchPG -.uprobe.-> UprobePG\n    \n    UprobeMySQL --> ExtractQuery\n    UprobeMySQL2 --> ExtractQuery\n    UprobePG --> ExtractQuery\n    \n    ExtractQuery --> EventMaps\n    EventMaps --> EventStruct\n    EventStruct --> DecodeFunc\n    DecodeFunc --> Display\n```\n\n**与 TLS 捕获的主要区别：**\n- **单/双钩子点**: MySQL 使用入口+返回 uprobe（`mysql56_query` + `mysql56_query_return`），PostgreSQL 仅使用入口\n- **无网络关联**: 事件包含查询文本但不包含网络 5 元组信息\n- **无主密钥**: 数据库审计不需要密钥提取\n- **直接文本捕获**: 通过 `bpf_probe_read_user()` 从内存中以明文形式捕获 SQL 查询\n\n来源：[kern/mysqld_kern.c:1-266](), [kern/postgres_kern.c:1-61](), [user/event/event_mysqld.go:1-169](), [user/event/event_postgres.go:1-119]()\n\n---\n\n## MySQL 查询审计\n\n### 支持的版本\n\nMySQL 模块支持：\n- **MySQL 5.6, 5.7, 8.0**\n- **MariaDB 10.5+**\n\n该模块针对 `dispatch_command` 函数，这是 MySQL/MariaDB 服务器二进制文件中的中央查询处理入口点。\n\n来源：[cli/cmd/mysqld.go:32-35]()\n\n### 钩子函数和 eBPF 程序\n\n#### MySQL 5.6/8.0 函数\n\nMySQL 模块实现了两个 eBPF 探针对来捕获查询执行：\n\n**mysql56_query (uprobe):**\n- 钩子：函数入口处的 `SEC(\"uprobe/dispatch_command\")`\n- 函数：[kern/mysqld_kern.c:43-99]()\n- 捕获：从 `PT_REGS_PARM3(ctx)` 获取查询字符串，从 `PT_REGS_PARM4(ctx)` 获取查询长度\n- 检查：命令类型必须是 `COM_QUERY`（`PT_REGS_PARM1(ctx)`）\n- 存储：将 `struct data_t` 写入 `sql_hash` 映射表（键：PID）\n\n**mysql56_query_return (uretprobe):**\n- 钩子：函数返回处的 `SEC(\"uretprobe/dispatch_command\")`\n- 函数：[kern/mysqld_kern.c:101-141]()\n- 捕获：从 `PT_REGS_RC(ctx)` 获取返回值\n- 检索：通过 PID 从 `sql_hash` 映射表中检索存储的查询\n- 发送：通过 `bpf_perf_event_output()` 将完整事件发送到用户空间\n\n#### MySQL 5.7+ 函数\n\nMySQL 5.7+ 使用不同的内部结构（`COM_DATA` 联合体）：\n\n**mysql57_query (uprobe):**\n- 钩子：`SEC(\"uprobe/dispatch_command_57\")`\n- 函数：[kern/mysqld_kern.c:186-226]()\n- 捕获：从 `PT_REGS_PARM2(ctx)` 获取 `COM_QUERY_DATA` 结构体，从 `PT_REGS_PARM3(ctx)` 获取命令类型\n- 结构：从 `COM_QUERY_DATA` 读取 `query.query` 指针和 `query.length`\n\n**mysql57_query_return (uretprobe):**\n- 钩子：`SEC(\"uretprobe/dispatch_command_57\")`\n- 函数：[kern/mysqld_kern.c:233-266]()\n- 捕获：布尔返回值（0=成功，1=退出）\n- 映射返回值：如果返回值为 1，则映射到 `DISPATCH_COMMAND_V57_FAILED`\n\n来源：[kern/mysqld_kern.c:43-266]()\n\n### 事件结构\n\n#### eBPF 内核结构体（struct data_t）\n\neBPF 程序在 [kern/mysqld_kern.c:19-27]() 中定义了 `struct data_t`：\n\n```c\nstruct data_t {\n    u64 pid;\n    u64 timestamp;\n    char query[MAX_DATA_SIZE_MYSQL];  // 256 字节\n    u64 alllen;\n    u64 len;\n    char comm[TASK_COMM_LEN];         // 16 字节\n    s8 retval;\n};\n```\n\n该结构体通过 `events` perf 缓冲区传输并在用户空间解码。\n\n#### 用户空间 Go 结构体（MysqldEvent）\n\n[user/event/event_mysqld.go:68-78]() 中的 Go 事件结构体镜像了 eBPF 结构体：\n\n| 字段 | 类型 | eBPF 类型 | 描述 |\n|-------|------|-----------|-------------|\n| `Pid` | `uint64` | `u64` | mysqld 服务器的进程 ID |\n| `Timestamp` | `uint64` | `u64` | 通过 `bpf_ktime_get_ns()` 获取的内核时间戳 |\n| `Query` | `[256]uint8` | `char[MAX_DATA_SIZE_MYSQL]` | SQL 查询文本（最多 256 字节）|\n| `Alllen` | `uint64` | `u64` | 原始查询的总长度（截断前）|\n| `Len` | `uint64` | `u64` | 捕获的查询文本长度（min(alllen, 256)）|\n| `Comm` | `[16]uint8` | `char[TASK_COMM_LEN]` | 通过 `bpf_get_current_comm()` 获取的进程命令名 |\n| `Retval` | `dispatchCommandReturn` | `s8` | `dispatch_command()` 的返回值 |\n\n**返回值：**\n\n`Retval` 字段指示查询执行结果：\n\n| 常量 | 值 | 描述 |\n|----------|-------|-------------|\n| `DispatchCommandSuccess` | 0 | 查询执行成功 |\n| `DispatchCommandCloseConnection` | 1 | 查询后连接关闭 |\n| `DispatchCommandWouldblock` | 2 | 查询会阻塞（异步）|\n| `DispatchCommandNotCaptured` | -1 | 探针未捕获查询 |\n| `DispatchCommandV57Failed` | -2 | MySQL 5.7 特定失败 |\n\n来源：[user/event/event_mysqld.go:38-78](), [user/event/event_mysqld.go:40-66]()\n\n### CLI 使用\n\n```bash\n# 基本 MySQL 查询捕获\necapture mysqld\n\n# 指定自定义 mysqld 二进制文件路径\necapture mysqld --mysqld /usr/sbin/mysqld\n\n# 从 MariaDB 捕获\necapture mysqld --mysqld /usr/sbin/mariadbd\n\n# 手动偏移量指定（高级）\necapture mysqld --offset 0x710410\n\n# 自定义函数名（如果未找到 dispatch_command）\necapture mysqld --funcname my_dispatch_command\n```\n\n**配置标志：**\n\n| 标志 | 短标志 | 默认值 | 描述 |\n|------|-------|---------|-------------|\n| `--mysqld` | `-m` | `/usr/sbin/mariadbd` | mysqld 二进制文件路径 |\n| `--offset` | | `0` | 手动函数偏移量（十六进制）|\n| `--funcname` | `-f` | | 要钩取的自定义函数名 |\n\n模块会自动在指定的二进制文件中定位 `dispatch_command` 函数符号。如果符号解析失败，可以使用 `--offset` 或 `--funcname` 手动指定钩子点。\n\n来源：[cli/cmd/mysqld.go:39-43]()\n\n### 输出格式\n\nMySQL 查询事件以文本格式显示：\n\n```\nPID:12345, Comm:mysqld, Time:1640000000000, length:(85/85), return:DISPATCH_COMMAND_SUCCESS, Line:SELECT * FROM users WHERE id = 42\n```\n\n输出包括：\n- **PID**: 数据库服务器进程 ID\n- **Comm**: 进程名（mysqld/mariadbd）\n- **Time**: Unix 时间戳（纳秒）\n- **length**: 捕获的长度 / 总查询长度\n- **return**: Dispatch command 返回状态\n- **Line**: SQL 查询文本\n\n来源：[user/event/event_mysqld.go:112-115]()\n\n---\n\n## PostgreSQL 查询审计\n\n### 支持的版本\n\nPostgreSQL 模块支持：\n- **PostgreSQL 10+**\n\n该模块钩取 PostgreSQL 服务器内的查询执行函数来捕获 SQL 语句。\n\n来源：[cli/cmd/postgres.go:32-33]()\n\n### 钩子函数和 eBPF 程序\n\n#### postgres_query (uprobe)\n\nPostgreSQL 使用单个 uprobe，不使用返回钩子：\n\n**postgres_query:**\n- 钩子：函数入口处的 `SEC(\"uprobe/exec_simple_query\")`\n- 函数：[kern/postgres_kern.c:35-60]()\n- 目标：PostgreSQL 服务器中的 `exec_simple_query(const char *query_string)` 函数\n- 捕获：从 `PT_REGS_PARM1(ctx)` 获取查询字符串指针（第一个参数）\n- 读取：通过 `bpf_probe_read_user()` 读取最多 `MAX_DATA_SIZE_POSTGRES`（256 字节）\n- 发送：通过 `bpf_perf_event_output()` 立即发送（不需要返回钩子）\n\n**可配置的钩子点：**\n\n`--funcname` 标志允许针对不同的查询处理入口点：\n- `exec_simple_query` - 简单查询协议（默认）\n- `exec_parse_message` - 扩展查询协议（解析阶段）\n- `exec_bind_message` - 扩展查询协议（绑定阶段）\n- `exec_execute_message` - 扩展查询协议（执行阶段）\n\n所有变体都从第一个函数参数读取查询字符串。\n\n来源：[kern/postgres_kern.c:31-60]()\n\n### 事件结构\n\n#### eBPF 内核结构体（struct data_t）\n\neBPF 程序在 [kern/postgres_kern.c:17-22]() 中定义了 `struct data_t`：\n\n```c\nstruct data_t {\n    u64 pid;\n    u64 timestamp;\n    char query[MAX_DATA_SIZE_POSTGRES];  // 256 字节\n    char comm[TASK_COMM_LEN];             // 16 字节\n};\n```\n\n该结构体通过 `events` perf 缓冲区直接传输，不经过中间存储。\n\n#### 用户空间 Go 结构体（PostgresEvent）\n\n[user/event/event_postgres.go:38-44]() 中的 Go 事件结构体镜像了 eBPF 结构体：\n\n| 字段 | 类型 | eBPF 类型 | 描述 |\n|-------|------|-----------|-------------|\n| `Pid` | `uint64` | `u64` | postgres 后端的进程 ID（来自 `bpf_get_current_pid_tgid() >> 32`）|\n| `Timestamp` | `uint64` | `u64` | 通过 `bpf_ktime_get_ns()` 获取的内核时间戳 |\n| `Query` | `[256]uint8` | `char[MAX_DATA_SIZE_POSTGRES]` | SQL 查询文本（最多 256 字节）|\n| `Comm` | `[16]uint8` | `char[TASK_COMM_LEN]` | 通过 `bpf_get_current_comm()` 获取的进程命令名 |\n\n**注意：** PostgreSQL 事件不捕获返回值或长度信息，因为钩子点位于与 MySQL 不同的查询处理阶段。\n\n来源：[user/event/event_postgres.go:30-44]()\n\n### CLI 使用\n\n```bash\n# 基本 PostgreSQL 查询捕获\necapture postgres\n\n# 指定自定义 postgres 二进制文件路径\necapture postgres --postgres /usr/lib/postgresql/14/bin/postgres\n\n# 指定要钩取的自定义函数\necapture postgres --funcname exec_simple_query\n```\n\n**配置标志：**\n\n| 标志 | 短标志 | 默认值 | 描述 |\n|------|-------|---------|-------------|\n| `--postgres` | `-m` | `/usr/bin/postgres` | postgres 二进制文件路径 |\n| `--funcname` | `-f` | | 要钩取的函数名（某些版本需要）|\n\n`--funcname` 标志对 PostgreSQL 特别重要，因为最佳钩子函数因版本和使用场景而异。常见目标包括用于基本查询捕获的 `exec_simple_query` 或用于捕获预处理语句的 `exec_parse_message`。\n\n来源：[cli/cmd/postgres.go:37-38]()\n\n### 输出格式\n\nPostgreSQL 查询事件以文本格式显示：\n\n```\nPID: 23456, Comm: postgres, Time: 1640000000000, Query: SELECT version();\n```\n\n输出包括：\n- **PID**: PostgreSQL 后端进程 ID\n- **Comm**: 进程名（postgres）\n- **Time**: Unix 时间戳（纳秒）\n- **Query**: SQL 查询文本\n\n来源：[user/event/event_postgres.go:67-69]()\n\n---\n\n## 数据流和事件处理\n\n### 模块初始化和钩子附加\n\n```mermaid\nflowchart TD\n    CLI[\"CLI 命令<br/>mysqldCommandFunc<br/>postgresCommandFunc\"]\n    RunModule[\"runModule<br/>ModuleNameMysqld<br/>ModuleNamePostgres\"]\n    ModuleFactory[\"模块工厂<br/>GetModuleFunc\"]\n    \n    subgraph \"MySQL 模块\"\n        MySQLInit[\"MMysqldProbe.Init<br/>解析二进制文件<br/>查找 dispatch_command\"]\n        MySQLOffset[\"符号解析<br/>ELF 解析<br/>偏移量计算\"]\n        MySQLAttach[\"附加 Uprobe<br/>dispatch_command 入口\"]\n    end\n    \n    subgraph \"PostgreSQL 模块\"\n        PGInit[\"MPostgresProbe.Init<br/>解析二进制文件<br/>查找 exec_* 函数\"]\n        PGOffset[\"符号解析<br/>ELF 解析<br/>函数查找\"]\n        PGAttach[\"附加 Uprobe<br/>exec_* 入口\"]\n    end\n    \n    CLI --> RunModule\n    RunModule --> ModuleFactory\n    \n    ModuleFactory -->|mysqld| MySQLInit\n    ModuleFactory -->|postgres| PGInit\n    \n    MySQLInit --> MySQLOffset\n    MySQLOffset --> MySQLAttach\n    \n    PGInit --> PGOffset\n    PGOffset --> PGAttach\n    \n    MySQLAttach --> eBPF[\"eBPF 程序已加载\"]\n    PGAttach --> eBPF\n```\n\n**初始化步骤：**\n1. **CLI 解析**: `mysqldCommandFunc` 或 `postgresCommandFunc` 处理命令行参数\n2. **模块创建**: `runModule` 使用 `ModuleNameMysqld` 或 `ModuleNamePostgres` 调用模块工厂\n3. **二进制分析**: 模块 `Init` 函数使用 ELF 解析来解析目标二进制文件（mysqld/postgres）\n4. **符号解析**: 定位目标函数符号（`dispatch_command` 或自定义函数）\n5. **Uprobe 附加**: 将 eBPF uprobe 附加到函数入口点\n\n来源：[cli/cmd/mysqld.go:46-48](), [cli/cmd/postgres.go:43-44]()\n\n### 事件捕获和解码\n\n```mermaid\nsequenceDiagram\n    participant DB as \"数据库服务器<br/>mysqld/postgres\"\n    participant Uprobe as \"eBPF Uprobe<br/>mysql56_query()<br/>postgres_query()\"\n    participant Uretprobe as \"eBPF Uretprobe<br/>mysql56_query_return()\"\n    participant Maps as \"eBPF 映射表<br/>sql_hash<br/>events\"\n    participant Reader as \"perfEventReader<br/>event.Read()\"\n    participant Decode as \"Event.Decode()<br/>binary.Read()\"\n    participant Output as \"Event.String()\"\n    \n    DB->>Uprobe: dispatch_command() 被调用\n    Uprobe->>Uprobe: PT_REGS_PARM1: 命令类型<br/>PT_REGS_PARM3: 查询指针<br/>PT_REGS_PARM4: 查询长度\n    Uprobe->>Uprobe: bpf_probe_read_user(&data.query, len, ptr)\n    Uprobe->>Maps: bpf_map_update_elem(&sql_hash, &pid, &data)\n    \n    Note over DB,Uretprobe: 仅 MySQL：等待返回\n    \n    DB->>Uretprobe: dispatch_command() 返回\n    Uretprobe->>Uretprobe: PT_REGS_RC: 返回值\n    Uretprobe->>Maps: bpf_map_lookup_elem(&sql_hash, &pid)\n    Uretprobe->>Maps: data->retval = return_value<br/>bpf_perf_event_output(&events, data)\n    \n    Maps->>Reader: perf_event 轮询\n    Reader->>Decode: 原始字节载荷\n    Decode->>Decode: binary.Read(buf, LittleEndian, &me.Pid)<br/>binary.Read(buf, LittleEndian, &me.Query)<br/>DecodeKtime(me.Timestamp)\n    Decode->>Output: 格式化事件\n    Output->>Output: PID, Comm, Time, Query, Retval\n```\n\n**事件流程：**\n1. **函数入口**: 数据库服务器调用钩取的函数（`dispatch_command` 或 `exec_simple_query`）\n2. **参数提取**: eBPF 探针使用 `PT_REGS_PARM1-4(ctx)` 读取函数参数\n3. **PID/UID 过滤**: 检查 `target_pid` 和 `target_uid` 常量（如果未定义 `KERNEL_LESS_5_2`）\n4. **查询捕获**: `bpf_probe_read_user()` 从查询字符串指针读取最多 256 字节\n5. **事件构造**: 使用 PID、时间戳、查询、comm、长度填充 `struct data_t`\n6. **中间存储（仅 MySQL）**: 以 PID 为键存储在 `sql_hash` 映射表中\n7. **返回钩子（仅 MySQL）**: 从 `sql_hash` 检索事件，添加返回值\n8. **Perf 缓冲区**: 通过 `bpf_perf_event_output(&events, BPF_F_CURRENT_CPU, &data)` 写入事件\n9. **用户空间读取**: `perfEventReader` 通过 `cilium/ebpf` 库轮询 perf 缓冲区\n10. **解码**: `Decode()` 方法使用 `binary.Read()` 和 `binary.LittleEndian` 字节序\n11. **时间戳转换**: `DecodeKtime()` 将内核 ktime 转换为 Unix 纳秒\n12. **显示**: `String()` 方法格式化包含 PID、查询、长度、返回值的事件\n\n来源：[kern/mysqld_kern.c:43-266](), [kern/postgres_kern.c:35-60](), [user/event/event_mysqld.go:80-109](), [user/event/event_postgres.go:46-64]()\n\n---\n\n## eBPF 映射表和数据结构\n\n### MySQL eBPF 映射表\n\nMySQL eBPF 程序使用 [kern/mysqld_kern.c:29-41]() 中定义的两个映射表：\n\n| 映射表名称 | 类型 | 键类型 | 值类型 | 最大条目数 | 用途 |\n|----------|------|----------|------------|-------------|---------|\n| `sql_hash` | `BPF_MAP_TYPE_HASH` | `u32` (PID) | `struct data_t` | 1024 | 入口/返回探针之间的临时存储 |\n| `events` | `BPF_MAP_TYPE_PERF_EVENT_ARRAY` | `u32` | `u32` | 1024 | 用于向用户空间发送事件的 Perf 缓冲区 |\n\n**映射表生命周期：**\n1. `mysql56_query()`: 在函数入口将事件写入 `sql_hash`\n2. `mysql56_query_return()`: 从 `sql_hash` 读取事件，添加返回值\n3. `mysql56_query_return()`: 将完整事件发送到 `events` perf 缓冲区\n4. 返回钩子从 `sql_hash` 删除条目（代码中未显示，推断得出）\n\n### PostgreSQL eBPF 映射表\n\nPostgreSQL 使用 [kern/postgres_kern.c:24-29]() 中定义的单个映射表：\n\n| 映射表名称 | 类型 | 键类型 | 值类型 | 最大条目数 | 用途 |\n|----------|------|----------|------------|-------------|---------|\n| `events` | `BPF_MAP_TYPE_PERF_EVENT_ARRAY` | `u32` | `u32` | 1024 | 用于向用户空间发送事件的 Perf 缓冲区 |\n\n**简化流程：**\n- PostgreSQL 立即发送事件，不经过中间存储\n- 没有返回钩子意味着不需要临时存储映射表\n\n来源：[kern/mysqld_kern.c:29-41](), [kern/postgres_kern.c:24-29]()\n\n---\n\n## 事件结构对比\n\n| 特性 | MySQL (MysqldEvent) | PostgreSQL (PostgresEvent) |\n|---------|---------------------|----------------------------|\n| **最大查询长度** | 256 字节 | 256 字节 |\n| **PID 字段** | ✓ (uint64) | ✓ (uint64) |\n| **时间戳** | ✓ (内核时间 → Unix 纳秒) | ✓ (内核时间 → Unix 纳秒) |\n| **进程名** | ✓ (16 字节) | ✓ (16 字节) |\n| **查询文本** | ✓ (256 字节) | ✓ (256 字节) |\n| **总长度** | ✓ (Alllen 字段) | ✗ |\n| **捕获长度** | ✓ (Len 字段) | ✗ |\n| **返回值** | ✓ (dispatchCommandReturn) | ✗ |\n| **事件类型** | `TypeOutput` | `TypeOutput` |\n| **UUID 格式** | `{PID}_{Comm}` | `{PID}_{Comm}` |\n\n两个模块都：\n- 捕获最多 256 字节的查询文本（由 `MysqldMaxDataSize` 和 `PostgresMaxDataSize` 定义）\n- 通过 `DecodeKtime` 将内核时间戳转换为 Unix 纳秒\n- 使用 `TypeOutput` 事件类型用于直接控制台显示\n- 通过 `ToProtobufEvent()` 支持 Protobuf 事件转换\n\nMySQL 提供额外的元数据（查询长度跟踪、返回值），因为在 `dispatch_command` 钩子点有更丰富的信息可用。\n\n来源：[user/event/event_mysqld.go:38-78](), [user/event/event_postgres.go:36-44]()\n\n---\n\n## Protobuf 集成\n\n两个数据库模块都实现了 `ToProtobufEvent()` 方法，用于通过 WebSocket 流进行外部集成（参见[Protobuf 与外部集成](#4.4)）。\n\n### MySQL Protobuf 事件\n\n```go\n// ToProtobufEvent 将 MysqldEvent 转换为 protobuf Event\n// 来源：user/event/event_mysqld.go:138-151\nEvent {\n    Timestamp: int64(me.Timestamp),\n    Uuid:      \"{PID}_{Comm}\",\n    SrcIp:     \"127.0.0.1\",  // 数据库事件没有网络信息\n    SrcPort:   0,\n    DstIp:     \"127.0.0.1\",\n    DstPort:   0,\n    Pid:       int64(me.Pid),\n    Pname:     Comm string,\n    Type:      uint32(me.Retval),  // Dispatch command 返回值\n    Length:    uint32(me.Len),     // 查询长度\n    Payload:   me.Query[:me.Len]   // SQL 查询字节\n}\n```\n\n### PostgreSQL Protobuf 事件\n\n```go\n// ToProtobufEvent 将 PostgresEvent 转换为 protobuf Event\n// 来源：user/event/event_postgres.go:87-101\nEvent {\n    Timestamp: int64(pe.Timestamp),\n    Uuid:      \"{PID}_{Comm}\",\n    SrcIp:     \"127.0.0.1\",  // 数据库事件没有网络信息\n    SrcPort:   0,\n    DstIp:     \"127.0.0.1\",\n    DstPort:   0,\n    Pid:       int64(pe.Pid),\n    Pname:     Comm string,\n    Type:      0,             // PostgreSQL 没有返回值\n    Length:    uint32(len(queryStr)),\n    Payload:   queryStr bytes  // SQL 查询字节\n}\n```\n\n**主要区别：**\n- MySQL 事件使用 `Type` 字段编码 `dispatchCommandReturn` 状态\n- PostgreSQL 事件的 `Type` 固定为 0\n- 两者都使用占位符 IP（`127.0.0.1`），因为数据库事件没有网络关联\n- 载荷包含原始 SQL 查询字节\n\n来源：[user/event/event_mysqld.go:138-151](), [user/event/event_postgres.go:87-101]()\n\n---\n\n## 限制和注意事项\n\n### 查询长度截断\n\n两个模块最多捕获 256 字节的查询文本：\n- **MySQL**: `MysqldMaxDataSize = 256` ([user/event/event_mysqld.go:38]())\n- **PostgreSQL**: `PostgresMaxDataSize = 256` ([user/event/event_postgres.go:36]())\n\n对于 MySQL，`Alllen` 字段指示总查询长度，允许检测截断。PostgreSQL 事件不跟踪总长度。\n\n**长查询处理：**\n```\n# MySQL 输出显示截断\nPID:12345, Comm:mysqld, length:(256/1024), return:DISPATCH_COMMAND_SUCCESS, Line:SELECT * FROM very_long_table_name WHERE column1 = 'val...\n\n# PostgreSQL 输出仅显示捕获的部分\nPID: 23456, Comm: postgres, Query: SELECT * FROM very_long_table_name WHERE column1 = 'val...\n```\n\n### 版本特定的符号要求\n\n**MySQL/MariaDB:**\n- 函数名 `dispatch_command` 在 MySQL 5.6-8.0 和 MariaDB 10.5+ 中保持一致\n- 较旧的 MySQL 5.5 版本可能使用不同的内部函数名\n- `--funcname` 标志允许在未找到符号时覆盖\n\n**PostgreSQL:**\n- 没有硬编码的默认函数名\n- 通常需要 `--funcname` 标志来指定目标函数\n- 常见目标：`exec_simple_query`、`exec_parse_message`、`exec_bind_message`\n- 函数可用性因 PostgreSQL 版本而异\n\n### 无网络上下文\n\n与 TLS 模块不同，数据库审计事件不捕获：\n- 客户端 IP 地址和端口\n- 服务器 IP 地址和端口\n- Socket 文件描述符\n- 网络连接状态\n\n这是因为钩子点位于查询处理层，在网络协议处理之后。进程 ID（`Pid`）和命令名（`Comm`）是将查询关联到数据库服务器实例的主要标识符。\n\n### 进程 vs 连接跟踪\n\n数据库事件与后端进程 PID 相关联，而非客户端连接：\n- **MySQL**: 具有多个线程的单个 `mysqld` 进程（一个 PID）\n- **PostgreSQL**: 每个连接有单独的后端进程（不同的 PID）\n\n这影响事件关联：\n- 来自所有连接的 MySQL 事件共享相同的 PID\n- PostgreSQL 事件可以按后端 PID 分组以跟踪每个连接的活动\n\n来源：[user/event/event_mysqld.go:158-159](), [user/event/event_postgres.go:108-109]()\n\n---\n\n## 使用场景\n\n### 安全审计\n\n数据库查询审计支持：\n- **SQL 注入检测**: 捕获具有异常语法的可疑查询模式\n- **权限提升监控**: 跟踪访问敏感表或执行管理操作的查询\n- **合规日志记录**: 记录所有数据库访问以用于审计跟踪，无需数据库级别的日志开销\n\n### 性能分析\n\n查询捕获支持：\n- **慢查询识别**: 将捕获的查询与性能指标关联（需要外部工具）\n- **查询模式分析**: 了解应用程序数据库访问模式\n- **连接跟踪**（PostgreSQL）: 通过后端 PID 监控每个连接的查询序列\n\n### 开发和调试\n\n实时查询捕获有助于：\n- **ORM 调试**: 观察 ORM（Hibernate、SQLAlchemy 等）生成的实际 SQL\n- **应用程序跟踪**: 通过 PID 将应用程序代码执行与数据库查询关联\n- **查询优化**: 在查询到达数据库日志之前捕获它们以进行即时分析\n\n---\n\n## 模块注册和 CLI 集成\n\n### 模块名称常量\n\n数据库模块使用预定义常量注册到模块系统：\n\n```go\n// MySQL 模块注册\n// 来源：cli/cmd/mysqld.go:48\nrunModule(module.ModuleNameMysqld, myc)\n\n// PostgreSQL 模块注册  \n// 来源：cli/cmd/postgres.go:44\nrunModule(module.ModuleNamePostgres, pgc)\n```\n\n这些常量（`ModuleNameMysqld`、`ModuleNamePostgres`）映射到分别实例化 `MMysqldProbe` 和 `MPostgresProbe` 的模块工厂函数。\n\n### 配置结构\n\n**MySQL 配置：**\n- `MysqldConfig` 结构体 ([cli/cmd/mysqld.go:27]())\n- 字段：`Mysqldpath`、`Offset`、`FuncName`\n- 通过 `config.NewMysqldConfig()` 创建\n\n**PostgreSQL 配置：**\n- `PostgresConfig` 结构体 ([cli/cmd/postgres.go:27]())\n- 字段：`PostgresPath`、`FuncName`\n- 通过 `config.NewPostgresConfig()` 创建\n\n两者都从基础配置继承通用配置字段（PID 过滤、UID 过滤、输出日志记录、十六进制显示等）。\n\n来源：[cli/cmd/mysqld.go:27-49](), [cli/cmd/postgres.go:27-44]()"
          },
          {
            "page_plan": {
              "id": "3.3",
              "title": "TC 网络数据包捕获"
            },
            "content": "# TC 网络数据包捕获\n\n## 目的与范围\n\n本文档解释了 eCapture 基于流量控制（TC）的网络数据包捕获子系统。TC eBPF 程序附加到网络接口，在内核层面拦截数据包，使得能够捕获加密网络流量以及从 TLS 库中提取的明文数据。TC 子系统通过使用基于 kprobe 的连接跟踪，将网络连接映射到进程，从而提供进程归属功能。\n\n有关 TLS/SSL 明文捕获的信息，请参阅 [TLS/SSL 模块](#3.1)。有关 PCAP 文件生成和输出格式的信息，请参阅 [PCAP 集成](#4.2)。\n\n## 架构概述\n\nTC 数据包捕获系统由三个主要组件组成：\n\n1. **TC 分类器程序**：附加到网络接口的 eBPF 程序，在入口和出口点拦截数据包\n2. **连接跟踪 Kprobes**：在 `tcp_sendmsg` 和 `udp_sendmsg` 上的 eBPF kprobes，将网络连接映射到进程\n3. **网络映射系统**：一个 LRU 哈希映射，维护网络四元组与进程元数据之间的关联\n\n```mermaid\ngraph TB\n    subgraph \"网络接口层\"\n        NIC[\"网络接口<br/>(eth0, wlan0, 等)\"]\n    end\n    \n    subgraph \"TC eBPF 程序 - kern/tc.h\"\n        INGRESS[\"ingress_cls_func()<br/>SEC classifier<br/>第 285-288 行\"]\n        EGRESS[\"egress_cls_func()<br/>SEC classifier<br/>第 279-282 行\"]\n        CAPTURE[\"capture_packets()<br/>主捕获逻辑<br/>第 135-276 行\"]\n    end\n    \n    subgraph \"连接跟踪 Kprobes - kern/tc.h\"\n        TCP_PROBE[\"tcp_sendmsg<br/>SEC kprobe<br/>第 290-347 行\"]\n        UDP_PROBE[\"udp_sendmsg<br/>SEC kprobe<br/>第 349-397 行\"]\n    end\n    \n    subgraph \"eBPF Maps - kern/tc.h\"\n        NET_MAP[\"network_map<br/>BPF_MAP_TYPE_LRU_HASH<br/>第 73-77 行\"]\n        SKB_EVENTS[\"skb_events<br/>BPF_MAP_TYPE_PERF_EVENT_ARRAY<br/>第 57-62 行\"]\n        SKB_BUFFER[\"skb_data_buffer_heap<br/>BPF_MAP_TYPE_PERCPU_ARRAY<br/>第 64-69 行\"]\n    end\n    \n    subgraph \"用户空间 - user/module/\"\n        MODULE[\"MOpenSSLProbe<br/>嵌入 MTCProbe<br/>probe_openssl.go:83-106\"]\n        PROCESSOR[\"事件处理器<br/>数据包处理\"]\n    end\n    \n    NIC -->|\"入口数据包\"| INGRESS\n    NIC <--\"|出口数据包\"| EGRESS\n    \n    INGRESS --> CAPTURE\n    EGRESS --> CAPTURE\n    \n    TCP_PROBE -->|\"存储 tuple->ctx\"| NET_MAP\n    UDP_PROBE -->|\"存储 tuple->ctx\"| NET_MAP\n    \n    CAPTURE -->|\"查找 ctx\"| NET_MAP\n    CAPTURE -->|\"发送事件\"| SKB_EVENTS\n    CAPTURE -->|\"使用缓冲区\"| SKB_BUFFER\n    \n    SKB_EVENTS -->|\"perf 事件\"| MODULE\n    MODULE --> PROCESSOR\n    \n    style CAPTURE fill:#f9f9f9\n    style NET_MAP fill:#f9f9f9\n    style TCP_PROBE fill:#f9f9f9\n    style UDP_PROBE fill:#f9f9f9\n```\n\n**来源**：[kern/tc.h:1-398]()，[user/module/probe_openssl.go:83-106]()\n\n## TC 分类器程序\n\nTC 分类器是附加到网络设备并处理通过它们的每个数据包的 eBPF 程序。eCapture 部署两个分类器程序：一个用于入口流量，一个用于出口流量。\n\n### 附加点\n\n```mermaid\ngraph LR\n    subgraph \"内核网络栈\"\n        RX[\"从 NIC 接收数据包\"]\n        TX[\"向 NIC 发送数据包\"]\n    end\n    \n    subgraph \"TC 钩子\"\n        ING[\"ingress_cls_func()<br/>tc.h:285-288\"]\n        EGR[\"egress_cls_func()<br/>tc.h:279-282\"]\n    end\n    \n    subgraph \"捕获逻辑\"\n        CAP[\"capture_packets(skb, is_ingress)<br/>tc.h:135-276\"]\n    end\n    \n    RX --> ING\n    ING --> CAP\n    \n    CAP --> EGR\n    EGR --> TX\n    \n    CAP -->|\"TC_ACT_OK<br/>通过\"| TX\n```\n\n两个分类器函数都委托给相同的 `capture_packets()` 函数，并带有方向标志：\n\n- **ingress_cls_func**：处理传入的数据包 [kern/tc.h:285-288]()\n- **egress_cls_func**：处理传出的数据包 [kern/tc.h:279-282]()\n\n分类器返回 `TC_ACT_OK` 以允许数据包继续通过网络栈而不进行修改 [kern/common.h:58]()。\n\n**来源**：[kern/tc.h:135-288]()，[kern/common.h:58]()\n\n## 数据包捕获逻辑\n\n`capture_packets()` 函数实现核心的数据包捕获逻辑。它操作内核提供的套接字缓冲区结构（`struct __sk_buff`）。\n\n### 处理流程\n\n```mermaid\nflowchart TD\n    START[\"capture_packets(skb, is_ingress)\"]\n    \n    VALIDATE[\"验证数据包长度<br/>eth + ip 头部<br/>tc.h:141-144\"]\n    \n    FILTER[\"PCAP 过滤器检查<br/>filter_pcap_l2()<br/>tc.h:148-150\"]\n    \n    PROTO_CHECK{\"协议?\"}\n    \n    IPV4[\"解析 IPv4 数据包<br/>提取四元组<br/>tc.h:199-236\"]\n    \n    IPV6[\"解析 IPv6 数据包<br/>提取四元组<br/>tc.h:156-198\"]\n    \n    LOOKUP[\"查找 network_map<br/>通过 conn_id<br/>tc.h:225 或 188\"]\n    \n    FOUND{\"找到<br/>上下文?\"}\n    \n    REVERSE[\"尝试反向查找<br/>交换 src/dst<br/>tc.h:227-234 或 189-197\"]\n    \n    FILTER_PID[\"按 PID/UID 过滤<br/>target_pid, target_uid<br/>tc.h:244-249\"]\n    \n    BUILD[\"构建 skb_data_event_t<br/>timestamp, len, ifindex<br/>tc.h:239-258\"]\n    \n    SEND[\"发送到 skb_events<br/>bpf_perf_event_output<br/>tc.h:271\"]\n    \n    RETURN[\"返回 TC_ACT_OK<br/>tc.h:275\"]\n    \n    START --> VALIDATE\n    VALIDATE -->|\"失败\"| RETURN\n    VALIDATE -->|\"通过\"| FILTER\n    \n    FILTER -->|\"拒绝\"| RETURN\n    FILTER -->|\"接受\"| PROTO_CHECK\n    \n    PROTO_CHECK -->|\"IPv4\"| IPV4\n    PROTO_CHECK -->|\"IPv6\"| IPV6\n    PROTO_CHECK -->|\"其他\"| RETURN\n    \n    IPV4 --> LOOKUP\n    IPV6 --> LOOKUP\n    \n    LOOKUP --> FOUND\n    FOUND -->|\"未找到\"| REVERSE\n    FOUND -->|\"已找到\"| FILTER_PID\n    \n    REVERSE --> FOUND\n    \n    FILTER_PID -->|\"通过\"| BUILD\n    FILTER_PID -->|\"拒绝\"| RETURN\n    \n    BUILD --> SEND\n    SEND --> RETURN\n```\n\n**来源**：[kern/tc.h:135-276]()\n\n### 协议支持\n\nTC 捕获支持多种协议，包括 IPv4 和 IPv6：\n\n| 协议 | 常量 | 过滤位置 |\n|----------|----------|-----------------|\n| TCP | `IPPROTO_TCP` | [kern/tc.h:208,320,332]() |\n| UDP | `IPPROTO_UDP` | [kern/tc.h:208,370,382]() |\n| ICMP | `IPPROTO_ICMP` | [kern/tc.h:208]() |\n| ICMPv6 | `IPPROTO_ICMPV6` | [kern/tc.h:164]() |\n\n捕获提取以下网络元组信息：\n\n```c\nstruct net_id_t {\n    u32 protocol;      // IPPROTO_TCP 或 IPPROTO_UDP\n    u32 src_port;      // 源端口\n    u32 src_ip4;       // 源 IPv4 地址\n    u32 dst_port;      // 目标端口\n    u32 dst_ip4;       // 目标 IPv4 地址\n    u32 src_ip6[4];    // 源 IPv6 地址\n    u32 dst_ip6[4];    // 目标 IPv6 地址\n};\n```\n\n**来源**：[kern/tc.h:39-47,156-236]()\n\n## 使用 Kprobes 进行连接跟踪\n\n为了将捕获的数据包归属到特定进程，eCapture 在建立网络连接的内核函数上使用 kprobes。这些 kprobes 在数据包传输之前捕获进程上下文。\n\n### Kprobe 附加点\n\n```mermaid\ngraph TB\n    subgraph \"应用程序空间\"\n        APP[\"应用程序进程<br/>send()/sendto()\"]\n    end\n    \n    subgraph \"系统调用层\"\n        SYSCALL[\"sys_sendto/sys_write\"]\n    end\n    \n    subgraph \"内核函数\"\n        TCP[\"tcp_sendmsg(sock *sk, ...)<br/>tc.h:291-347\"]\n        UDP[\"udp_sendmsg(sock *sk, ...)<br/>tc.h:350-397\"]\n    end\n    \n    subgraph \"eBPF Kprobes\"\n        TCP_PROBE[\"SEC kprobe/tcp_sendmsg<br/>提取 sock 信息<br/>存储到 network_map\"]\n        UDP_PROBE[\"SEC kprobe/udp_sendmsg<br/>提取 sock 信息<br/>存储到 network_map\"]\n    end\n    \n    subgraph \"数据提取\"\n        SOCK[\"struct sock<br/>__sk_common\"]\n        EXTRACT[\"提取:<br/>- family (AF_INET/AF_INET6)<br/>- src/dst IP<br/>- src/dst port\"]\n    end\n    \n    subgraph \"上下文收集\"\n        CTX[\"收集:<br/>- PID (bpf_get_current_pid_tgid)<br/>- UID (bpf_get_current_uid_gid)<br/>- comm (bpf_get_current_comm)\"]\n    end\n    \n    subgraph \"存储\"\n        MAP[\"network_map<br/>键: net_id_t<br/>值: net_ctx_t\"]\n    end\n    \n    APP --> SYSCALL\n    SYSCALL --> TCP\n    SYSCALL --> UDP\n    \n    TCP --> TCP_PROBE\n    UDP --> UDP_PROBE\n    \n    TCP_PROBE --> SOCK\n    UDP_PROBE --> SOCK\n    \n    SOCK --> EXTRACT\n    EXTRACT --> CTX\n    \n    CTX --> MAP\n    \n    style TCP_PROBE fill:#f9f9f9\n    style UDP_PROBE fill:#f9f9f9\n    style MAP fill:#f9f9f9\n```\n\n**来源**：[kern/tc.h:290-397]()\n\n### 进程上下文提取\n\n两个 kprobes 都提取相同的信息并将其存储在 `network_map` 中：\n\n```c\nstruct net_ctx_t {\n    u32 pid;              // 进程 ID\n    u32 uid;              // 用户 ID\n    char comm[16];        // 命令名称 (TASK_COMM_LEN)\n};\n```\n\nkprobes 执行以下步骤：\n\n1. **获取进程上下文** [kern/tc.h:292-294,351-353]()\n   - `bpf_get_current_pid_tgid() >> 32` - 提取 PID\n   - `bpf_get_current_uid_gid()` - 提取 UID\n   - `bpf_get_current_comm()` - 获取进程名称\n\n2. **提取套接字信息** [kern/tc.h:304-337,354-387]()\n   - 读取 `sock->__sk_common.skc_family` - 地址族\n   - 读取 `sock->__sk_common.skc_num` - 本地端口\n   - 读取 `sock->__sk_common.skc_dport` - 远程端口\n   - 读取源/目标 IP 地址\n\n3. **存储映射** [kern/tc.h:345,395]()\n   - 从网络元组创建 `net_id_t` 键\n   - 从进程上下文创建 `net_ctx_t` 值\n   - `bpf_map_update_elem(&network_map, &conn_id, &net_ctx, BPF_ANY)`\n\n**来源**：[kern/tc.h:290-397]()\n\n## 网络映射系统\n\n`network_map` 是将网络连接与进程信息关联的核心数据结构。它使用 LRU（最近最少使用）驱逐策略来维护活动连接的有界缓存。\n\n### 映射配置\n\n```mermaid\ngraph LR\n    subgraph \"映射定义 - tc.h:73-77\"\n        TYPE[\"类型: BPF_MAP_TYPE_LRU_HASH\"]\n        KEY[\"键: struct net_id_t<br/>四元组 + 协议\"]\n        VALUE[\"值: struct net_ctx_t<br/>pid + uid + comm\"]\n        SIZE[\"最大条目数: 10240\"]\n    end\n    \n    subgraph \"键结构 - net_id_t\"\n        K_PROTO[\"protocol: u32\"]\n        K_SPORT[\"src_port: u32\"]\n        K_SIP4[\"src_ip4: u32\"]\n        K_DPORT[\"dst_port: u32\"]\n        K_DIP4[\"dst_ip4: u32\"]\n        K_SIP6[\"src_ip6: u32[4]\"]\n        K_DIP6[\"dst_ip6: u32[4]\"]\n    end\n    \n    subgraph \"值结构 - net_ctx_t\"\n        V_PID[\"pid: u32\"]\n        V_UID[\"uid: u32\"]\n        V_COMM[\"comm: char[16]\"]\n    end\n    \n    TYPE --> KEY\n    KEY --> VALUE\n    VALUE --> SIZE\n    \n    KEY --> K_PROTO\n    KEY --> K_SPORT\n    KEY --> K_DIP4\n    \n    VALUE --> V_PID\n    VALUE --> V_UID\n    VALUE --> V_COMM\n```\n\n**来源**：[kern/tc.h:39-77]()\n\n### 双向查找\n\n由于数据包可以从任一方向到达（客户端→服务器或服务器→客户端），`capture_packets()` 函数实现了双向查找：\n\n1. **初始查找**：尝试使用数据包的源作为连接源来查找连接 [kern/tc.h:225,188]()\n2. **反向查找**：如果未找到，交换源和目标后再次尝试 [kern/tc.h:227-234,189-197]()\n\n这确保传入和传出的数据包都能正确归属到发起进程。\n\n**来源**：[kern/tc.h:188-234]()\n\n## 数据包过滤\n\neCapture 支持多级过滤，以减少开销并仅捕获相关流量。\n\n### 过滤层次结构\n\n```mermaid\nflowchart TD\n    PKT[\"传入数据包\"]\n    \n    L1[\"长度过滤器<br/>最小头部大小<br/>tc.h:141-144\"]\n    \n    L2[\"PCAP 过滤器（可选）<br/>filter_pcap_l2()<br/>tc.h:121-132,148-150\"]\n    \n    L3[\"协议过滤器<br/>仅 TCP/UDP/ICMP<br/>tc.h:164,208\"]\n    \n    L4[\"进程过滤器<br/>target_pid, target_uid<br/>tc.h:244-249\"]\n    \n    CAPTURE[\"捕获数据包\"]\n    DROP[\"丢弃数据包\"]\n    \n    PKT --> L1\n    L1 -->|\"< 最小大小\"| DROP\n    L1 -->|\"≥ 最小大小\"| L2\n    \n    L2 -->|\"拒绝\"| DROP\n    L2 -->|\"接受\"| L3\n    \n    L3 -->|\"不支持\"| DROP\n    L3 -->|\"支持\"| L4\n    \n    L4 -->|\"不匹配\"| DROP\n    L4 -->|\"匹配\"| CAPTURE\n```\n\n### PCAP 过滤器集成\n\n`filter_pcap_l2()` 函数 [kern/tc.h:121-132]() 作为从 PCAP 过滤器表达式生成的 BPF 字节码的注入点。该函数标记为 `__noinline` 以防止编译器优化，允许用户空间修补其指令。\n\n过滤器修补在用户空间启动 [user/module/probe_openssl.go:303-307]()：\n\n```go\nif m.eBPFProgramType == TlsCaptureModelTypePcap && pcapFilter != \"\" {\n    ebpfFuncs := []string{tcFuncNameIngress, tcFuncNameEgress}\n    m.bpfManager.InstructionPatchers = prepareInsnPatchers(m.bpfManager,\n        ebpfFuncs, pcapFilter)\n}\n```\n\n**来源**：[kern/tc.h:121-150]()，[user/module/probe_openssl.go:303-307]()\n\n### 进程过滤\n\n当设置了 `target_pid` 或 `target_uid`（内核 ≥ 5.2）时，数据包被过滤以匹配特定进程 [kern/tc.h:244-249]()：\n\n```c\nif (target_pid != 0 && target_pid != net_ctx->pid) {\n    return TC_ACT_OK;\n}\nif (target_uid != 0 && target_uid != net_ctx->uid) {\n    return TC_ACT_OK;\n}\n```\n\n此过滤发生在成功连接查找之后，确保只捕获属于目标进程的数据包。\n\n**注意**：kprobes 本身不按 PID/UID 过滤 [kern/tc.h:296-302]()，因为 `network_map` 必须包含所有连接，以便 TC 分类器执行归属。进程过滤仅在数据包捕获期间发生。\n\n**来源**：[kern/tc.h:244-249,296-302]()，[kern/common.h:64-71]()\n\n## 数据结构\n\n### 事件结构\n\n捕获的数据包元数据使用 `skb_data_event_t` 结构传输到用户空间：\n\n```c\nstruct skb_data_event_t {\n    uint64_t ts;                // 时间戳 (bpf_ktime_get_ns)\n    u32 pid;                    // 进程 ID\n    char comm[TASK_COMM_LEN];   // 进程名称\n    u32 len;                    // 数据包长度 (skb->len)\n    u32 ifindex;                // 网络接口索引\n};\n```\n\n事件包含最小元数据（36 字节）[kern/tc.h:20]()，数据包有效载荷通过 `bpf_perf_event_output()` 的 flags 参数附加 [kern/tc.h:260-271]()：\n\n```c\nu64 flags = BPF_F_CURRENT_CPU;\nflags |= (u64)skb->len << 32;  // 在高 32 位编码数据包长度\nbpf_perf_event_output(skb, &skb_events, flags, &event, TC_PACKET_MIN_SIZE);\n```\n\n**来源**：[kern/tc.h:30-37,239-271]()\n\n### 缓冲区管理\n\n为了避免大型结构导致的栈溢出，eCapture 使用每 CPU 数组映射进行临时事件存储：\n\n```c\nstruct {\n    __uint(type, BPF_MAP_TYPE_PERCPU_ARRAY);\n    __type(key, u32);\n    __type(value, struct skb_data_event_t);\n    __uint(max_entries, 1);\n} skb_data_buffer_heap SEC(\".maps\");\n```\n\n`make_skb_data_event()` 函数 [kern/tc.h:92-100]() 从此映射检索缓冲区，该映射由内核自动按 CPU 管理。\n\n**来源**：[kern/tc.h:64-100]()\n\n## 与捕获模块的集成\n\nTC 数据包捕获主要与 TLS 捕获模块集成，以提供完整的网络流量可见性。\n\n### MTCProbe 基础结构\n\nTC 功能封装在 `MTCProbe` 结构体中，该结构体被需要网络数据包捕获的捕获模块嵌入 [user/module/probe_openssl.go:84]()：\n\n```mermaid\ngraph TB\n    subgraph \"模块层次结构\"\n        MOD[\"Module<br/>基础模块结构\"]\n        MTCP[\"MTCProbe<br/>TC 探针基础<br/>probe_tc.go\"]\n        MOSSL[\"MOpenSSLProbe<br/>OpenSSL/BoringSSL 捕获<br/>probe_openssl.go:83-106\"]\n    end\n    \n    subgraph \"MTCProbe 中的 TC 组件\"\n        PKT_CHAN[\"tcPacketsChan<br/>chan *TcPacket<br/>缓冲区: 2048\"]\n        PKT_BUF[\"tcPackets<br/>[]*TcPacket<br/>批处理缓冲区: 256\"]\n        PCAP_FILE[\"pcapngFilename<br/>输出文件路径\"]\n        TIME[\"startTime, bootTime<br/>时间戳转换\"]\n    end\n    \n    subgraph \"PCAP 生成 - probe_tc.go\"\n        WRITER[\"PCAP-NG 写入器<br/>savePcapngSslKeyLog()\"]\n        DSB[\"DSB 块<br/>TLS 密钥日志\"]\n    end\n    \n    MOD -.->|\"嵌入\"| MTCP\n    MTCP -.->|\"嵌入\"| MOSSL\n    \n    MTCP --> PKT_CHAN\n    MTCP --> PKT_BUF\n    MTCP --> PCAP_FILE\n    MTCP --> TIME\n    \n    MOSSL -->|\"TcSkbEvent\"| PKT_CHAN\n    PKT_CHAN --> WRITER\n    WRITER --> PCAP_FILE\n    WRITER --> DSB\n```\n\n**来源**：[user/module/probe_openssl.go:83-106]()，[user/module/probe_tc.go]()\n\n### 事件流\n\n当 OpenSSL 模块在 PCAP 模式下运行时，它接收 TC 数据包事件和 TLS 主密钥事件：\n\n1. **初始化** [user/module/probe_openssl.go:137-148]()：\n   - 设置 `eBPFProgramType = TlsCaptureModelTypePcap`\n   - 创建 `tcPacketsChan` 缓冲通道（2048 个条目）\n   - 初始化 `tcPackets` 批处理缓冲区（256 个条目）\n   - 存储 PCAP 输出文件名\n\n2. **事件分发** [user/module/probe_openssl.go:733-753]()：\n   ```go\n   switch ev := eventStruct.(type) {\n   case *event.TcSkbEvent:\n       err := m.dumpTcSkb(ev)  // 处理 TC 数据包\n   case *event.MasterSecretEvent:\n       m.saveMasterSecret(ev)   // 处理 TLS 密钥\n   }\n   ```\n\n3. **PCAP 输出** [user/module/probe_openssl.go:558-565]()：\n   - TC 数据包写入 PCAP-NG 文件\n   - TLS 主密钥写入为 DSB（解密密钥块）\n   - 使 Wireshark 能够解密捕获的 TLS 流量\n\n**来源**：[user/module/probe_openssl.go:137-148,558-565,733-753]()\n\n## 用户空间事件读取\n\n用户空间模块使用标准事件读取基础设施从 `skb_events` perf 事件数组读取 TC 事件。\n\n### 事件读取器设置\n\n```mermaid\nflowchart LR\n    subgraph \"eBPF Maps\"\n        SKB_MAP[\"skb_events<br/>PERF_EVENT_ARRAY\"]\n    end\n    \n    subgraph \"模块事件系统 - imodule.go\"\n        EVENTS[\"Events() []*ebpf.Map<br/>返回映射列表\"]\n        DECODE[\"DecodeFun(*ebpf.Map)<br/>返回解码器\"]\n        READER[\"perfEventReader()<br/>imodule.go:308-350\"]\n    end\n    \n    subgraph \"事件处理\"\n        PERF[\"perf.NewReader()<br/>cilium/ebpf/perf\"]\n        LOOP[\"读取循环<br/>record, err := rd.Read()\"]\n        DEC[\"解码事件<br/>child.Decode(em, record.RawSample)\"]\n        DISP[\"Dispatcher()<br/>child.Dispatcher(evt)\"]\n    end\n    \n    SKB_MAP --> EVENTS\n    EVENTS --> READER\n    READER --> PERF\n    PERF --> LOOP\n    LOOP --> DEC\n    DEC --> DISP\n```\n\n读取过程 [user/module/imodule.go:285-350]()：\n\n1. **映射发现**：`Events()` 返回所有事件映射，包括 `skb_events`\n2. **读取器创建**：`perfEventReader()` 创建具有可配置缓冲区大小的 perf 事件读取器\n3. **事件循环**：持续从 perf 环形缓冲区读取\n4. **解码**：`Decode()` 将原始事件字节解析为 `TcSkbEvent` 结构\n5. **分发**：将事件传递给模块的 `Dispatcher()` 进行处理\n\n**来源**：[user/module/imodule.go:285-350]()\n\n## 内核版本兼容性\n\nTC 捕获有特定的内核版本要求：\n\n| 功能 | 最低内核版本 | 说明 |\n|---------|----------------|------|\n| TC 分类器 | 4.1+ | 基本 TC BPF 支持 |\n| PCAP 过滤器注入 | 5.2+ | `filter_pcap_l2()` 修补所需 |\n| PID/UID 过滤 | 5.2+ | 使用全局常量变量 [kern/common.h:64-71]() |\n\n对于内核 < 5.2，存在以下限制：\n- 无运行时 PCAP 过滤器注入\n- TC 程序中无 PID/UID 过滤\n- 通过 kprobes 的连接跟踪仍然有效\n\n`KERNEL_LESS_5_2` 预处理指令 [kern/common.h:64-71]() 控制需要较新内核的功能的条件编译。\n\n**来源**：[kern/common.h:64-71]()，[kern/tc.h:147-150,243-250]()\n\n## 总结\n\n基于 TC 的数据包捕获系统通过以下方式提供全面的网络可见性：\n\n1. **拦截所有流量**：TC 分类器在网络接口层捕获数据包，在加密之前/解密之后\n2. **进程归属**：在 `tcp_sendmsg`/`udp_sendmsg` 上的 Kprobes 通过 `network_map` LRU 哈希将连接映射到进程\n3. **双向捕获**：处理入口和出口流量，具有自动源/目标反转功能\n4. **灵活过滤**：支持 PCAP 过滤器表达式、协议过滤和 PID/UID 过滤\n5. **TLS 集成**：将网络数据包与 TLS 主密钥结合，以 PCAP-NG 格式实现完整的流量解密\n\n这种方法使 eCapture 能够捕获完整的网络流量及进程上下文，即使对于加密连接，也无需应用程序插桩或证书安装。\n\n**来源**：[kern/tc.h:1-398]()，[user/module/probe_openssl.go:83-106,303-307,558-565,733-753]()，[user/module/imodule.go:285-350]()"
          },
          {
            "page_plan": {
              "id": "4",
              "title": "输出格式"
            },
            "content": "# 输出格式\n\neCapture 提供四种不同的输出格式，用于捕获的网络流量、主密钥和审计数据。每种格式服务于特定的使用场景，并与不同的分析工具集成。输出格式决定了数据编码（文本、二进制 PCAP、密钥日志、protobuf）和目标位置（控制台、文件、TCP 套接字、WebSocket）。\n\n## 输出格式概览\n\n| 格式 | 主要用途 | 输出目标 | Wireshark 兼容 | 实时显示 |\n|--------|------------------|-------------------|---------------------|-----------|\n| **文本** | 交互式调试、日志分析 | 控制台、文件、WebSocket | 否 | 是 |\n| **PCAP** | 网络分析、流量重放 | PCAP-NG 文件 | 是 | 否 |\n| **密钥日志** | 使用外部工具进行 TLS 解密 | NSS 密钥日志文件 | 是（配合 tcpdump） | 否 |\n| **Protobuf** | 工具集成、eCaptureQ GUI | TCP、WebSocket | 否 | 是 |\n\n详细信息请参考各子页面：\n- [文本输出模式](#4.1) - 纯文本格式化、HTTP 解析、颜色编码\n- [PCAP 集成](#4.2) - PCAP-NG 文件生成、DSB 块、Wireshark 工作流\n- [TLS 密钥日志](#4.3) - 主密钥提取、SSLKEYLOGFILE 格式\n- [Protobuf 与外部集成](#4.4) - 二进制协议、WebSocket 流式传输、eCaptureQ\n\n**来源：** [README.md:172-253](), [user/module/probe_openssl.go:58-76](), [user/config/iconfig.go:73-79]()\n\n## 输出格式架构\n\n### 格式选择与编码流程\n\n以下图表展示了 CLI 标志如何转换为输出编码器和目标写入器：\n\n```mermaid\ngraph TB\n    CLI[\"cobra.Command<br/>--model/-m 标志<br/>--pcapfile/-w<br/>--keylogfile<br/>--logaddr<br/>--eventaddr\"]\n    \n    Config[\"OpensslConfig.Model<br/>OpensslConfig.PcapFile<br/>OpensslConfig.KeylogFile\"]\n    \n    ModuleInit[\"MOpenSSLProbe.Init()\"]\n    \n    FormatSwitch{Model 值}\n    \n    TextBranch[\"eBPFProgramType =<br/>TlsCaptureModelTypeText<br/>调用 setupManagersText()\"]\n    PcapBranch[\"eBPFProgramType =<br/>TlsCaptureModelTypePcap<br/>打开 pcapFile<br/>调用 setupManagersPcap()\"]\n    KeylogBranch[\"eBPFProgramType =<br/>TlsCaptureModelTypeKeylog<br/>打开 keylogFile<br/>调用 setupManagersKeylog()\"]\n    \n    TextEncode[\"IEventStruct.String()<br/>IEventStruct.StringHex()\"]\n    PcapEncode[\"savePcapngSslKeyLog()<br/>saveMasterSecret()<br/>dumpTcSkb()\"]\n    KeylogEncode[\"keylogger.WriteString()<br/>NSS 格式\"]\n    ProtobufEncode[\"IEventStruct.ToProtobufEvent()<br/>proto.Marshal()\"]\n    \n    ConsoleOut[\"os.Stdout<br/>zerolog.ConsoleWriter\"]\n    FileOut[\"os.File<br/>rotateLog 包装器\"]\n    TcpOut[\"net.Conn<br/>TCP 套接字\"]\n    WsOut[\"ws.Client<br/>WebSocket\"]\n    \n    CLI --> Config\n    Config --> ModuleInit\n    ModuleInit --> FormatSwitch\n    \n    FormatSwitch -->|text| TextBranch\n    FormatSwitch -->|pcap/pcapng| PcapBranch\n    FormatSwitch -->|keylog/key| KeylogBranch\n    \n    TextBranch --> TextEncode\n    TextBranch -.->|如果 codecTypeProtobuf| ProtobufEncode\n    PcapBranch --> PcapEncode\n    KeylogBranch --> KeylogEncode\n    \n    TextEncode --> ConsoleOut\n    TextEncode --> FileOut\n    PcapEncode --> FileOut\n    KeylogEncode --> FileOut\n    ProtobufEncode --> TcpOut\n    ProtobufEncode --> WsOut\n```\n\n**来源：** [user/module/probe_openssl.go:109-176](), [user/config/iconfig.go:95-112](), [cli/cmd/root.go:178-247]()\n\n### 格式类型常量\n\n输出格式使用代码库中的 `TlsCaptureModelType` 枚举定义：\n\n| 枚举值 | 常量名称 | CLI 标志 | 描述 |\n|------------|--------------|----------|-------------|\n| `0` | `TlsCaptureModelTypePcap` | `pcap`、`pcapng` | PCAP-NG 二进制格式 |\n| `1` | `TlsCaptureModelTypeText` | `text`（默认） | 人类可读文本 |\n| `2` | `TlsCaptureModelTypeKeylog` | `keylog`、`key` | NSS 密钥日志格式 |\n\nCLI 通过 `--model/-m` 标志接受字符串值：\n- `text` → `TlsCaptureModelTypeText` → 使用 `setupManagersText()`\n- `pcap` 或 `pcapng` → `TlsCaptureModelTypePcap` → 使用 `setupManagersPcap()`\n- `keylog` 或 `key` → `TlsCaptureModelTypeKeylog` → 使用 `setupManagersKeylog()`\n\n当在 `--eventaddr` 中使用远程目标（`tcp://` 或 `ws://`）时，Protobuf 格式会自动启用。\n\n**来源：** [user/module/probe_openssl.go:58-76](), [user/config/iconfig.go:73-79]()\n\n## 事件结构与序列化\n\n所有捕获的事件都实现了 `IEventStruct` 接口，该接口定义了多种输出格式的方法：\n\n### IEventStruct 接口方法\n\n```go\ntype IEventStruct interface {\n    Decode(payload []byte) error\n    String() string                    // 文本格式\n    StringHex() string                 // 带十六进制转储的文本格式\n    Clone() IEventStruct\n    EventType() Type\n    GetUUID() string\n    Payload() []byte\n    PayloadLen() int\n    Base() Base                        // 公共元数据\n    ToProtobufEvent() *pb.Event       // Protobuf 格式\n}\n```\n\n### 按模块分类的事件类型\n\n| 模块 | 事件结构 | 包含内容 | 输出模式 |\n|--------|----------------|----------|--------------|\n| TLS/SSL | `SSLDataEvent` | 加密负载、元组、TLS 版本 | 文本、PCAP、Protobuf |\n| TLS/SSL | `ConnDataEvent` | 连接 4 元组（IP:端口对） | PCAP、Protobuf |\n| TLS/SSL | `MasterSecretEvent` | 客户端随机数、主密钥 | 密钥日志、PCAP（DSB） |\n| TLS/SSL | `TcSkbEvent` | 来自 TC 钩子的原始数据包数据 | PCAP |\n| GoTLS | `TlsDataEvent` | Go TLS 明文、连接信息 | 文本、PCAP、Protobuf |\n| GnuTLS | `GnutlsDataEvent` | GnuTLS 明文 | 文本、Protobuf |\n| NSS | `NsprDataEvent` | NSS/NSPR 明文 | 文本、Protobuf |\n| Bash | `BashEvent` | Shell 命令行 | 文本、Protobuf |\n| MySQL | `MysqldEvent` | SQL 查询、返回值 | 文本、Protobuf |\n| PostgreSQL | `PostgresEvent` | SQL 查询 | 文本、Protobuf |\n\n每个事件结构为其支持的输出格式实现序列化：\n- `String()` / `StringHex()` 用于带可选颜色编码的文本输出\n- `ToProtobufEvent()` 用于二进制 protobuf 序列化\n- 模块特定方法（`saveMasterSecret()`、`dumpTcSkb()`）用于 PCAP/密钥日志\n\n**来源：** [user/event/event_openssl.go:77-391](), [user/event/event_masterkey.go:37-273](), [user/event/event_bash.go:37-133](), [user/event/event_mysqld.go:68-168]()\n\n## 输出目标配置\n\neCapture 将日志记录（诊断消息）与事件输出（捕获的数据）分离。两者都支持多种目标类型。\n\n### 目标类型检测\n\n```mermaid\ngraph TB\n    Flags[\"CLI 标志：<br/>--logaddr<br/>--eventaddr<br/>--ecaptureq\"]\n    \n    ParseFunc[\"initLogger() 函数\"]\n    \n    CheckFormat{地址格式？}\n    \n    StdoutType[\"loggerTypeStdout = 0<br/>空字符串\"]\n    FileType[\"loggerTypeFile = 1<br/>文件路径<br/>/path/to/file.log\"]\n    TcpType[\"loggerTypeTcp = 2<br/>tcp://host:port\"]\n    WsType[\"loggerTypeWebsocket = 3<br/>ws://host:port/path\"]\n    \n    CreateStdout[\"zerolog.ConsoleWriter<br/>os.Stdout\"]\n    CreateFile[\"os.Create(path)<br/>可选：roratelog.Logger\"]\n    CreateTcp[\"net.Dial(tcp, addr)<br/>设置 codecTypeProtobuf\"]\n    CreateWs[\"ws.Client.Dial(url)<br/>设置 codecTypeProtobuf\"]\n    \n    MultiWriter[\"zerolog.MultiLevelWriter<br/>组合 logger + eventCollector\"]\n    \n    Flags --> ParseFunc\n    ParseFunc --> CheckFormat\n    \n    CheckFormat -->|空| StdoutType\n    CheckFormat -->|路径| FileType\n    CheckFormat -->|tcp://| TcpType\n    CheckFormat -->|ws://| WsType\n    \n    StdoutType --> CreateStdout\n    FileType --> CreateFile\n    TcpType --> CreateTcp\n    WsType --> CreateWs\n    \n    CreateStdout --> MultiWriter\n    CreateFile --> MultiWriter\n    CreateTcp --> MultiWriter\n    CreateWs --> MultiWriter\n```\n\n**来源：** [cli/cmd/root.go:68-73](), [cli/cmd/root.go:178-247]()\n\n### 目标类型常量与行为\n\n| 常量 | 值 | 触发模式 | 写入器实现 | 编解码器类型 |\n|----------|-------|----------------|----------------------|------------|\n| `loggerTypeStdout` | `0` | 空字符串 | `zerolog.ConsoleWriter` → `os.Stdout` | 文本 |\n| `loggerTypeFile` | `1` | `/path/to/file` | `os.Create()` + 可选 `roratelog.Logger` | 文本 |\n| `loggerTypeTcp` | `2` | `tcp://host:port` | `net.Dial(\"tcp\", addr)` | Protobuf |\n| `loggerTypeWebsocket` | `3` | `ws://` 或 `wss://` | `ws.Client.Dial(url)` | Protobuf |\n\n### 编解码器选择逻辑\n\n目标类型决定用于事件序列化的编解码器：\n\n```go\n// 在 initLogger() 函数中\nif strings.Contains(addr, \"tcp://\") || strings.Contains(addr, \"ws://\") {\n    // 远程目标使用 protobuf\n    module.eventOutputType = codecTypeProtobuf\n} else {\n    // 本地目标使用文本\n    module.eventOutputType = codecTypeText\n}\n```\n\n远程目标（`tcp://`、`ws://`）通过 `IEventStruct.ToProtobufEvent()` 自动启用 protobuf 编码，而本地目标使用 `IEventStruct.String()`。\n\n### 日志轮转\n\n文件目标在配置时支持自动轮转：\n- `--eventroratesize <MB>` - 当文件达到大小限制时轮转\n- `--eventroratetime <秒>` - 按时间间隔轮转\n\n轮转由文件句柄周围的 `roratelog.Logger` 包装器处理。\n\n**来源：** [cli/cmd/root.go:68-73](), [cli/cmd/root.go:178-247](), [cli/cmd/root.go:151-152]()\n\n### 按类型路由事件\n\n事件管道使用三种分类类型将事件路由通过不同的处理阶段：\n\n| 事件类型 | 常量值 | 处理器 | 目的 |\n|------------|---------------|---------|---------|\n| `TypeOutput` | `event.TypeOutput` | `module.output()` | 预格式化事件，直接输出 |\n| `TypeEventProcessor` | `event.TypeEventProcessor` | `EventProcessor.Write()` | HTTP/HTTP2 解析、协议检测 |\n| `TypeModuleData` | `event.TypeModuleData` | `module.Dispatcher()` | 内部缓存、PCAP 写入、密钥日志 |\n\n事件在 `Clone()` 期间被分配类型：\n\n```go\n// SSLDataEvent 的示例\nfunc (se *SSLDataEvent) Clone() IEventStruct {\n    event := new(SSLDataEvent)\n    event.eventType = TypeModuleData  // 路由到模块调度器\n    return event\n}\n```\n\n**来源：** [user/event/event_openssl.go:200-204](), [user/module/imodule.go:430-447]()\n\n## 格式特定使用场景\n\n### 文本模式\n\n**使用场景：**\n- 交互式调试和实时监控\n- 基于控制台的流量检查\n- 使用 grep/awk 进行日志文件分析\n- HTTP/HTTP2 协议分析\n\n**输出示例：**\n- 带颜色编码的纯文本请求/响应体\n- HTTP/1.1 头部和内容\n- 带流 ID 的 HTTP/2 逐帧解码\n- 连接元数据（PID、进程名、IP:端口元组）\n\n有关格式化详细信息、颜色方案和 HTTP 解析，请参阅[文本输出模式](#4.1)。\n\n**来源：** [user/module/probe_openssl.go:756-775](), [user/event/event_openssl.go:167-198]()\n\n### PCAP 模式\n\n**使用场景：**\n- 使用 Wireshark 进行网络分析\n- 流量归档以供后续分析\n- 与现有基于 PCAP 的工具集成\n- 将明文捕获与数据包检查结合\n\n**输出结构：**\n- 带接口描述块（IDB）的 PCAP-NG 文件格式\n- 用于捕获数据包的增强数据包块（EPB）\n- 包含主密钥的解密秘密块（DSB）\n- 自动密钥到连接的关联\n\n有关文件格式详细信息和 Wireshark 工作流，请参阅 [PCAP 集成](#4.2)。\n\n**来源：** [user/module/probe_openssl.go:733-754]()\n\n### 密钥日志模式\n\n**使用场景：**\n- 使用 Wireshark 解密现有 pcap 文件\n- 使用 tshark 进行实时解密\n- 符合基于 SSLKEYLOGFILE 的工具\n- 将密钥捕获与数据包捕获分离\n\n**输出格式：**\n```\nCLIENT_RANDOM <32字节十六进制> <48字节十六进制主密钥>\nCLIENT_HANDSHAKE_TRAFFIC_SECRET <32字节十六进制> <秘密>\nSERVER_HANDSHAKE_TRAFFIC_SECRET <32字节十六进制> <秘密>\n```\n\n有关 TLS 1.2/1.3 密钥提取和集成示例，请参阅 [TLS 密钥日志](#4.3)。\n\n**来源：** [user/module/probe_openssl.go:482-642]()\n\n### Protobuf 模式\n\n**使用场景：**\n- eCaptureQ GUI 集成\n- 使用结构化数据进行自定义工具开发\n- 通过 TCP/WebSocket 进行远程监控\n- 事件转发到 SIEM 系统\n\n**协议：**\n- 通过 `pb.Event` 消息类型进行二进制 protobuf 编码\n- 字段：`timestamp`、`uuid`、`pid`、`pname`、`src_ip`、`dst_ip`、`payload`\n- 带心跳机制的 WebSocket 帧\n\n有关协议模式和客户端示例，请参阅 [Protobuf 与外部集成](#4.4)。\n\n**来源：** [user/event/event_openssl.go:237-266](), [protobuf/PROTOCOLS.md]()\n\n## CLI 配置参考\n\n### 全局输出标志\n\n| 标志 | 简写 | 类型 | 默认值 | 描述 |\n|------|-------|------|---------|-------------|\n| `--logaddr` | `-l` | string | `\"\"` | 日志记录器目标：文件路径、`tcp://host:port`、`ws://host:port` |\n| `--eventaddr` | | string | `\"\"` | 事件收集器目标（如果未设置，则使用 `--logaddr`） |\n| `--ecaptureq` | | string | `\"\"` | 用于 eCaptureQ 集成的本地 WebSocket 服务器 |\n| `--listen` | | string | `localhost:28256` | 用于运行时配置更新的 HTTP API 服务器 |\n| `--eventroratesize` | | uint16 | `0` | 当大小超过 N MB 时轮转事件文件（0=禁用） |\n| `--eventroratetime` | | uint16 | `0` | 每 N 秒轮转事件文件（0=禁用） |\n\n### 模块特定格式标志\n\n适用于 `tls`、`gotls`、`gnutls`、`nss` 模块：\n\n| 标志 | 简写 | 类型 | 默认值 | 描述 |\n|------|-------|------|---------|-------------|\n| `--model` | `-m` | string | `text` | 格式：`text`、`pcap`、`pcapng`、`keylog`、`key` |\n| `--pcapfile` | `-w` | string | `ecapture_openssl.pcapng` | PCAP 模式的输出文件 |\n| `--keylogfile` | | string | `ecapture_masterkey.log` | 密钥日志模式的输出文件 |\n| `--hex` | | bool | `false` | 在文本模式下十六进制转储负载 |\n\n### 示例命令\n\n```bash\n# 文本模式输出到控制台\nsudo ecapture tls\n\n# 文本模式输出到文件并启用轮转\nsudo ecapture tls --eventaddr=/var/log/ecapture.log --eventroratesize=100\n\n# PCAP 模式使用自定义文件\nsudo ecapture tls -m pcap -w /tmp/capture.pcapng -i eth0\n\n# 用于 Wireshark 解密的密钥日志模式\nsudo ecapture tls -m keylog --keylogfile=/tmp/keys.log\n\n# Protobuf 流式传输到 eCaptureQ\nsudo ecapture tls --ecaptureq=:9090\n\n# 远程 TCP 流式传输\nsudo ecapture tls --eventaddr=tcp://192.168.1.100:8080\n```\n\n**来源：** [cli/cmd/root.go:136-153](), [README.md:172-253]()\n\n## 输出格式比较\n\n| 格式 | CLI 标志 | 需要文件 | 实时显示 | 协议解析 | 主密钥 | Wireshark 兼容 |\n|--------|----------|---------------|-------------------|------------------|-------------|---------------------|\n| **文本** | `-m text` | 可选 | ✓ 是（stdout） | ✓ HTTP/1.x、HTTP/2 | ✗ 否（自 v0.7.0） | ✗ 否 |\n| **PCAP** | `-m pcap` | ✓ 必需（`-w`） | ✗ 否 | ✗ 否 | ✓ 是（DSB 块） | ✓ 是 |\n| **密钥日志** | `-m keylog` | ✓ 必需 | ✗ 否 | ✗ 否 | ✓ 是（NSS 格式） | ✓ 是（配合 tcpdump） |\n| **Protobuf** | 自动 | 可选 | ✓ 是（TCP/WS） | △ 依赖模块 | ✓ 嵌入事件中 | ✗ 否 |\n\n### 格式选择指南\n\n**选择文本模式的情况：**\n- 需要对捕获的流量进行即时视觉反馈\n- 想要通过 grep/搜索 HTTP 请求/响应\n- 正在进行交互式应用程序行为调试\n- 需要 HTTP/2 逐帧分析\n\n**选择 PCAP 模式的情况：**\n- 需要在 Wireshark 中进行全面的数据包分析\n- 想要归档流量以供后续取证\n- 需要明文和加密数据包数据\n- 想要将主密钥嵌入捕获文件\n\n**选择密钥日志模式的情况：**\n- 已经使用 tcpdump/tshark 进行捕获\n- 需要与 SSLKEYLOGFILE 兼容的输出\n- 想要解密现有的 PCAP 文件\n- 正在使用 Wireshark 的 TLS 解密功能\n\n**选择 Protobuf 模式的情况：**\n- 正在与 eCaptureQ 或自定义工具集成\n- 需要结构化的、机器可解析的事件\n- 正在转发到远程系统\n- 想要通过网络进行实时流式传输\n\n**来源：** [README.md:172-253](), [CHANGELOG.md:487-493](), [user/config/iconfig.go:73-79]()"
          },
          {
            "page_plan": {
              "id": "4.1",
              "title": "文本输出模式"
            },
            "content": "# 文本输出模式\n\n## 目的与范围\n\n文本输出模式为捕获的网络流量和系统事件提供人类可读的控制台和文件输出。此模式将捕获的 SSL/TLS 明文、数据库查询和 shell 命令格式化为结构化文本，支持协议解析、颜色编码和连接元数据。与生成二进制数据包捕获的 PCAP 模式（参见 [PCAP 集成](#4.2)）或导出解密密钥的密钥日志模式（参见 [TLS 密钥日志](#4.3)）不同，文本输出模式专为即时查看和日志文件分析而设计。\n\n本页涵盖：\n- 事件字符串格式化机制（`String()` 和 `StringHex()` 方法）\n- 协议感知解析（HTTP/1.x、HTTP/2、gzip 解压缩）\n- 流量方向的颜色编码输出\n- 从捕获到控制台的事件处理流程\n- 十六进制转储和截断的配置选项\n\n---\n\n## 事件格式化架构\n\n文本输出模式依赖于多态格式化系统，其中每种事件类型实现 `IEventStruct` 接口，提供两种输出方法：\n\n```mermaid\nclassDiagram\n    class IEventStruct {\n        <<interface>>\n        +String() string\n        +StringHex() string\n        +Payload() []byte\n        +GetUUID() string\n        +Base() Base\n    }\n    \n    class SSLDataEvent {\n        +DataType int64\n        +Pid uint32\n        +Comm [16]byte\n        +Fd uint32\n        +Version int32\n        +Tuple string\n        +Data [MaxDataSize]byte\n        +DataLen int32\n        +String() string\n        +StringHex() string\n        +BaseInfo() string\n    }\n    \n    class BashEvent {\n        +Pid uint32\n        +Uid uint32\n        +Line [256]byte\n        +ReturnValue uint32\n        +Comm [16]byte\n        +AllLines string\n        +String() string\n        +StringHex() string\n    }\n    \n    class MysqldEvent {\n        +Pid uint64\n        +Query [256]byte\n        +Alllen uint64\n        +Len uint64\n        +Comm [16]byte\n        +Retval int8\n        +String() string\n        +StringHex() string\n    }\n    \n    class NsprDataEvent {\n        +DataType int64\n        +Pid uint32\n        +Data [MaxDataSize]byte\n        +DataLen int32\n        +String() string\n        +StringHex() string\n    }\n    \n    IEventStruct <|.. SSLDataEvent\n    IEventStruct <|.. BashEvent\n    IEventStruct <|.. MysqldEvent\n    IEventStruct <|.. NsprDataEvent\n```\n\n**来源：** [user/event/ievent.go:41-52](), [user/event/event_openssl.go:77-92](), [user/event/event_bash.go:37-47](), [user/event/event_mysqld.go:68-78](), [user/event/event_nspr.go:26-36]()\n\n### String 与 StringHex 方法\n\n每种事件类型提供两种格式化变体：\n\n| 方法 | 目的 | 输出格式 |\n|--------|---------|---------------|\n| `String()` | 默认文本输出 | 带元数据头的纯文本载荷 |\n| `StringHex()` | 十六进制转储 | 带 ASCII 侧边栏的多行十六进制转储 |\n\n`EventProcessor` 根据 `isHex` 标志在这两者之间进行选择：\n\n[pkg/event_processor/processor.go:48]()\n```\nisHex        bool\n```\n\n当调用 `eventWorker.Display()` 时，它会检查此标志并在启用时应用十六进制编码：\n\n[pkg/event_processor/iworker.go:192-194]()\n```\nif ew.processor.isHex {\n    b = []byte(hex.Dump(b))\n}\n```\n\n**来源：** [pkg/event_processor/processor.go:48](), [pkg/event_processor/iworker.go:192-194]()\n\n---\n\n## 连接元数据显示\n\n文本输出包含从 eBPF 事件中提取的丰富连接元数据。对于 SSL/TLS 连接，`SSLDataEvent.BaseInfo()` 方法格式化此信息：\n\n**输出格式示例：**\n```\nPID:1234, Comm:curl, TID:1234, Version:TLS1_3_VERSION, Received 512 bytes from 93.184.216.34:443\n```\n\n**格式化字段：**\n\n| 字段 | 来源 | 描述 |\n|-------|--------|-------------|\n| PID | `SSLDataEvent.Pid` | 进程标识符 |\n| Comm | `SSLDataEvent.Comm` | 进程命令名称（最大 16 字节） |\n| TID | `SSLDataEvent.Tid` | 线程标识符 |\n| Version | `SSLDataEvent.Version` | TLS 版本（通过 `TlsVersion.String()` 转换） |\n| Direction | `SSLDataEvent.DataType` | ProbeEntry（接收）或 ProbeRet（发送） |\n| Tuple | `SSLDataEvent.Tuple` | IP:Port-IP:Port 连接元组 |\n\n[user/event/event_openssl.go:181-198]()\n\n`Tuple` 字段由来自 TC（流量控制）钩子事件的 `ConnDataEvent` 填充，提供用于连接归属的网络四元组。\n\n**来源：** [user/event/event_openssl.go:181-198](), [user/event/event_openssl.go:55-75]()\n\n---\n\n## 颜色编码输出系统\n\n文本输出模式使用 ANSI 颜色代码来直观地区分流量方向和事件类型：\n\n```mermaid\ngraph LR\n    ProbeEntry[\"ProbeEntry<br/>(SSL_read)\"]\n    ProbeRet[\"ProbeRet<br/>(SSL_write)\"]\n    GreenOutput[\"绿色文本<br/>COLORGREEN\"]\n    PurpleOutput[\"紫色文本<br/>COLORPURPLE\"]\n    Console[\"控制台/文件输出\"]\n    \n    ProbeEntry --> GreenOutput\n    ProbeRet --> PurpleOutput\n    GreenOutput --> Console\n    PurpleOutput --> Console\n```\n\n**颜色代码定义：**\n\n[user/event/event.go:8-13]()\n```\nCOLORPURPLE = \"\\033[35m\"  // 发送（出站流量）\nCOLORGREEN  = \"\\033[32m\"  // 接收（入站流量）\nCOLORYELLOW = \"\\033[33m\"  // 地址/元组高亮\nCOLORRED    = \"\\033[31m\"  // 错误/未知类型\nCOLORRESET  = \"\\033[0m\"   // 重置为默认\nCOLORBLUE   = \"\\033[34m\"  // 过滤指示器\n```\n\n### 在 SSLDataEvent 中的应用\n\n[user/event/event_openssl.go:168-179]()\n\n`String()` 方法根据 `AttachType` 应用颜色：\n```\nswitch AttachType(se.DataType) {\ncase ProbeEntry:\n    prefix = COLORGREEN\ncase ProbeRet:\n    prefix = COLORPURPLE\n}\n```\n\n对于接收的数据（绿色）：\n```\nReceived 256 bytes from 93.184.216.34:443\n<绿色文本>GET / HTTP/1.1\nHost: example.com\n...</绿色文本>\n```\n\n对于发送的数据（紫色）：\n```\nSend 512 bytes to 93.184.216.34:443\n<紫色文本>HTTP/1.1 200 OK\nContent-Type: text/html\n...</紫色文本>\n```\n\n**来源：** [user/event/event.go:8-13](), [user/event/event_openssl.go:168-179](), [user/event/event_openssl.go:151-166]()\n\n---\n\n## 协议感知解析\n\n文本输出模式包括 HTTP 流量的自动协议检测和解析，提供结构化格式而不是原始字节转储。\n\n### 解析器检测流程\n\n```mermaid\nflowchart TD\n    PayloadArrival[\"载荷到达<br/>eventWorker\"]\n    NewParser[\"NewParser(payload)<br/>检测协议\"]\n    HTTPReqDetect[\"HTTPRequest.detect()<br/>http.ReadRequest()\"]\n    HTTPRespDetect[\"HTTPResponse.detect()<br/>http.ReadResponse()\"]\n    HTTP2ReqDetect[\"HTTP2Request.detect()<br/>H2C 魔数检查\"]\n    HTTP2RespDetect[\"HTTP2Response.detect()<br/>帧检测\"]\n    \n    DefaultParser[\"DefaultParser<br/>原始输出\"]\n    HTTPRequestParser[\"HTTPRequest 解析器<br/>DumpRequest()\"]\n    HTTPResponseParser[\"HTTPResponse 解析器<br/>DumpResponse()\"]\n    HTTP2Parser[\"HTTP2 解析器<br/>帧格式化\"]\n    \n    Display[\"Display()<br/>格式化输出\"]\n    \n    PayloadArrival --> NewParser\n    NewParser --> HTTPReqDetect\n    NewParser --> HTTPRespDetect\n    NewParser --> HTTP2ReqDetect\n    NewParser --> HTTP2RespDetect\n    \n    HTTPReqDetect -->|成功| HTTPRequestParser\n    HTTPRespDetect -->|成功| HTTPResponseParser\n    HTTP2ReqDetect -->|成功| HTTP2Parser\n    HTTP2RespDetect -->|成功| HTTP2Parser\n    \n    HTTPReqDetect -->|失败| DefaultParser\n    HTTPRespDetect -->|失败| DefaultParser\n    HTTP2ReqDetect -->|失败| DefaultParser\n    HTTP2RespDetect -->|失败| DefaultParser\n    \n    HTTPRequestParser --> Display\n    HTTPResponseParser --> Display\n    HTTP2Parser --> Display\n    DefaultParser --> Display\n```\n\n**来源：** [pkg/event_processor/iparser.go:85-115]()\n\n### HTTP/1.x 请求解析\n\n[pkg/event_processor/http_request.go:28-35]()\n\n`HTTPRequest` 解析器使用 Go 的 `net/http` 包来解析请求：\n\n```mermaid\nsequenceDiagram\n    participant Worker as eventWorker\n    participant Parser as HTTPRequest\n    participant NetHTTP as http.ReadRequest\n    participant Gzip as gzip.NewReader\n    participant Output as httputil.DumpRequest\n    \n    Worker->>Parser: Write(payload)\n    Parser->>NetHTTP: 解析 HTTP 头\n    NetHTTP-->>Parser: http.Request 对象\n    \n    Parser->>Parser: 检查 Content-Encoding\n    alt 是 gzip\n        Parser->>Gzip: 解压缩正文\n        Gzip-->>Parser: 解压缩的数据\n    end\n    \n    Parser->>Output: DumpRequest(request, false)\n    Output-->>Parser: 格式化字节\n    Parser->>Worker: 附加解压缩的正文\n    Worker->>Worker: 应用颜色代码\n```\n\n[pkg/event_processor/http_request.go:105-157]()\n\n**关键特性：**\n- 当存在 `Content-Encoding: gzip` 头时自动进行 gzip 解压缩\n- 使用 `httputil.DumpRequest()` 进行一致的格式化\n- HTTP/2.0 检测（对于 HTTP/2 返回原始字节）\n- 使用 `io.ErrUnexpectedEOF` 处理截断的正文\n\n**来源：** [pkg/event_processor/http_request.go:54-81](), [pkg/event_processor/http_request.go:105-157]()\n\n### HTTP/1.x 响应解析\n\n[pkg/event_processor/http_response.go:28-37]()\n\n响应解析遵循类似模式，但有额外考虑：\n\n[pkg/event_processor/http_response.go:115-175]()\n\n**分块传输处理：**\n- 检测 `ContentLength < 0` 表示分块编码\n- 当 `ContentLength > rawLength` 时记录截断警告\n- 支持 HEAD 方法响应（带有 Content-Length 头的零长度正文）\n\n**Gzip 支持：**\n```\nswitch hr.response.Header.Get(\"Content-Encoding\") {\ncase \"gzip\":\n    reader, err = gzip.NewReader(bytes.NewReader(rawData))\n    rawData, err = io.ReadAll(reader)\n    hr.packerType = PacketTypeGzip\n```\n\n**来源：** [pkg/event_processor/http_response.go:115-175]()\n\n### 默认解析器（非 HTTP）\n\n[pkg/event_processor/iparser.go:117-166]()\n\n当未检测到协议时，`DefaultParser` 提供备用格式化：\n\n**行为：**\n1. 检查第一个字节：如果 `< 32` 或 `> 126`（非 ASCII），输出十六进制转储\n2. 否则，输出为修剪后的字符串\n\n```\nif b[0] < 32 || b[0] > 126 {\n    return []byte(hex.Dump(b))\n}\nreturn []byte(CToGoString(dp.reader.Bytes()))\n```\n\n**来源：** [pkg/event_processor/iparser.go:152-160]()\n\n---\n\n## 事件处理流程\n\n文本输出系统通过多阶段流程处理事件：\n\n```mermaid\nflowchart TB\n    subgraph \"模块层\"\n        Module[\"捕获模块<br/>(TLS/Bash/MySQL)\"]\n    end\n    \n    subgraph \"EventProcessor\"\n        Incoming[\"incoming chan<br/>IEventStruct\"]\n        Dispatch[\"dispatch()<br/>按 UUID 路由\"]\n        WorkerQueue[\"workerQueue<br/>map[string]IWorker\"]\n    end\n    \n    subgraph \"eventWorker（每个连接）\"\n        IncomingChan[\"incoming chan<br/>IEventStruct\"]\n        WriteEvent[\"writeEvent()<br/>累积载荷\"]\n        PayloadBuf[\"payload *bytes.Buffer\"]\n        Ticker[\"ticker (100ms)<br/>空闲检测\"]\n        ParserEvents[\"parserEvents()<br/>协议检测\"]\n        ParserInst[\"parser IParser<br/>(HTTP/HTTP2/Default)\"]\n        Display[\"Display()<br/>格式化输出\"]\n    end\n    \n    subgraph \"输出\"\n        OutComing[\"outComing chan []byte\"]\n        Logger[\"logger io.Writer\"]\n    end\n    \n    Module -->|Write()| Incoming\n    Incoming --> Dispatch\n    Dispatch -->|获取/创建| WorkerQueue\n    WorkerQueue -->|路由到| IncomingChan\n    \n    IncomingChan --> WriteEvent\n    WriteEvent --> PayloadBuf\n    \n    Ticker -->|超时| ParserEvents\n    PayloadBuf --> ParserEvents\n    ParserEvents --> ParserInst\n    ParserInst --> Display\n    \n    Display -->|isHex 检查| OutComing\n    OutComing --> Logger\n```\n\n**来源：** [pkg/event_processor/processor.go:66-89](), [pkg/event_processor/iworker.go:262-306](), [pkg/event_processor/iworker.go:174-228]()\n\n### EventProcessor：中央调度器\n\n[pkg/event_processor/processor.go:30-50]()\n\n`EventProcessor` 维护一个按连接 UUID 索引的工作队列：\n\n**关键字段：**\n- `incoming chan event.IEventStruct` - 从模块接收事件\n- `outComing chan []byte` - 将格式化输出发送到日志记录器\n- `workerQueue map[string]IWorker` - 每个连接的活动工作器\n- `isHex bool` - 全局十六进制转储标志\n- `truncateSize uint64` - 载荷截断限制\n\n**调度逻辑：**\n\n[pkg/event_processor/processor.go:91-109]()\n\n```\nuuid := e.GetUUID()  // 格式：\"PID_TID_Comm_FD_DataType\"\nfound, eWorker := ep.getWorkerByUUID(uuid)\nif !found {\n    eWorker = NewEventWorker(uuid, ep)\n    ep.addWorkerByUUID(eWorker)\n}\nerr := eWorker.Write(e)\n```\n\n**来源：** [pkg/event_processor/processor.go:30-50](), [pkg/event_processor/processor.go:91-109]()\n\n### eventWorker：每个连接的状态机\n\n[pkg/event_processor/iworker.go:70-89]()\n\n每个 `eventWorker` 管理单个连接的事件流：\n\n**生命周期状态：**\n\n```mermaid\nstateDiagram-v2\n    [*] --> Init: NewEventWorker()\n    Init --> Accumulating: Write(event)\n    Accumulating --> Accumulating: 更多事件\n    Accumulating --> Parsing: Ticker 超时 (1s)\n    Parsing --> Formatting: parserEvents()\n    Formatting --> Output: Display()\n    Output --> Init: Reset()\n    \n    Accumulating --> Destroying: 关闭信号\n    Destroying --> [*]: drainAndClose()\n    \n    note right of Accumulating\n        LifeCycleStateDefault:\n        最多 10 个 tick (1s)\n        \n        LifeCycleStateSock:\n        持续到套接字\n        关闭通知\n    end note\n```\n\n**两种生命周期模式：**\n\n[pkg/event_processor/iworker.go:57-63]()\n\n| 状态 | 触发器 | 行为 |\n|-------|---------|----------|\n| `LifeCycleStateDefault` | 标准 UUID | 空闲 1 秒后自毁 |\n| `LifeCycleStateSock` | UUID 以 \"sock:\" 开头 | 持续到套接字关闭 |\n\n**来源：** [pkg/event_processor/iworker.go:57-89](), [pkg/event_processor/iworker.go:262-306]()\n\n### Display 方法：输出格式化\n\n[pkg/event_processor/iworker.go:174-228]()\n\n`Display()` 方法协调最终输出格式化：\n\n```mermaid\nflowchart TD\n    Start[\"调用 Display()\"]\n    CheckLen{\"payload.Len() > 0?\"}\n    ParserEvents[\"parserEvents()<br/>检测协议并格式化\"]\n    CheckHex{\"processor.isHex?\"}\n    HexDump[\"hex.Dump(b)\"]\n    CheckLogger{\"logger 类型?\"}\n    \n    CollectorPath[\"CollectorWriter<br/>（文本文件/控制台）\"]\n    ProtobufPath[\"Protobuf 序列化<br/>（WebSocket 流）\"]\n    \n    FormatText[\"使用元数据格式化:<br/>PID, Comm, Src:Port, Dest:Port\"]\n    SerializeProto[\"ToProtobufEvent()<br/>编组为字节\"]\n    \n    WriteChannel[\"writeToChan(b)<br/>发送到 outComing\"]\n    Reset[\"重置解析器<br/>重置载荷缓冲区\"]\n    \n    Start --> CheckLen\n    CheckLen -->|是| ParserEvents\n    CheckLen -->|否| Reset\n    \n    ParserEvents --> CheckHex\n    CheckHex -->|true| HexDump\n    CheckHex -->|false| CheckLogger\n    HexDump --> CheckLogger\n    \n    CheckLogger -->|CollectorWriter| CollectorPath\n    CheckLogger -->|其他| ProtobufPath\n    \n    CollectorPath --> FormatText\n    ProtobufPath --> SerializeProto\n    \n    FormatText --> WriteChannel\n    SerializeProto --> WriteChannel\n    WriteChannel --> Reset\n    Reset --> Start\n```\n\n**输出格式选择：**\n\n[pkg/event_processor/iworker.go:198-227]()\n\n1. **CollectorWriter（文本模式）：**\n   ```\n   PID:1234, Comm:curl, Src:192.168.1.100:54321, Dest:93.184.216.34:443,\n   <格式化的载荷>\n   ```\n\n2. **Protobuf 模式：**\n   - 序列化的 `pb.LogEntry` 带有 `pb.Event` 载荷\n   - 用于 WebSocket 流式传输到 eCaptureQ GUI\n   - 详见 [Protobuf 与外部集成](#4.4)\n\n**来源：** [pkg/event_processor/iworker.go:174-228]()\n\n---\n\n## 载荷截断\n\n为防止大载荷导致的内存耗尽，文本输出模式支持可配置的截断：\n\n[pkg/event_processor/iworker.go:230-245]()\n\n```\ntsize := int(ew.processor.truncateSize)\nif tsize > 0 && ew.payload.Len() >= tsize {\n    ew.payload.Truncate(tsize)\n    ew.Log(fmt.Sprintf(\"Events truncated, size: %d bytes\\n\", tsize))\n    return\n}\n```\n\n**配置：**\n\n[pkg/event_processor/processor.go:206-215]()\n\n```\nfunc NewEventProcessor(logger io.Writer, isHex bool, truncateSize uint64) *EventProcessor\n```\n\n**截断行为：**\n- 当累积载荷达到 `truncateSize` 字节时应用\n- 停止接受该工作器的新事件\n- 记录截断消息\n- 工作器继续处理截断后的载荷\n\n**来源：** [pkg/event_processor/iworker.go:230-245](), [pkg/event_processor/processor.go:206-215]()\n\n---\n\n## 十六进制转储格式\n\n当启用 `isHex` 模式时，系统使用结构化的十六进制转储格式：\n\n[pkg/event_processor/base_event.go:211-252]()\n\n**格式布局：**\n```\n0000    47 45 54 20 2F 20 48 54    54 50 2F 31 2E 31 0D 0A    GET / HTTP/1.1..\n0016    48 6F 73 74 3A 20 65 78    61 6D 70 6C 65 2E 63 6F    Host: example.co\n0032    6D 0D 0A 0D 0A                                       m....\n```\n\n**列结构：**\n| 列 | 宽度 | 内容 |\n|--------|-------|---------|\n| 偏移量 | 4 字符 | 字节位置（十六进制） |\n| 十六进制组 1 | 24 字符 | 8 字节十六进制（第 4 字节后 2 空格） |\n| 十六进制组 2 | 24 字符 | 8 字节十六进制（第 4 字节后 2 空格） |\n| ASCII | 16 字符 | ASCII 表示（不可打印 → '.'） |\n\n**实现细节：**\n\n```\nChunkSize = 16       // 每行字节数\nChunkSizeHalf = 8    // 间距分割点\n\nfor i := 0; i < n; i++ {\n    if i%ChunkSize == 0 {\n        fmt.Fprintf(bb, \"%04d\", i)  // 偏移量\n    }\n    if i%ChunkSizeHalf == 0 {\n        bb.WriteString(\"    \")      // 组分隔符\n    }\n    fmt.Fprintf(bb, \" %02X\", b[i])  // 十六进制字节\n    \n    // 将非 ASCII 转换为 '.'\n    if b[i] < 32 || b[i] > 126 {\n        a[i%ChunkSize] = '.'\n    } else {\n        a[i%ChunkSize] = b[i]\n    }\n}\n```\n\n**来源：** [pkg/event_processor/base_event.go:35-36](), [pkg/event_processor/base_event.go:211-252]()\n\n---\n\n## 模块特定输出示例\n\n### SSL/TLS 数据输出\n\n**标准格式：**\n```\nPID:12345, Comm:curl, TID:12345, Version:TLS1_3_VERSION, Received 1024 bytes from 93.184.216.34:443\nGET /api/v1/users HTTP/1.1\nHost: api.example.com\nUser-Agent: curl/7.68.0\nAccept: */*\n```\n\n**十六进制格式：**\n```\nPID:12345, Comm:curl, TID:12345, Received 1024 bytes, Payload:\n0000    47 45 54 20 2F 61 70 69    2F 76 31 2F 75 73 65 72    GET /api/v1/user\n0016    73 20 48 54 54 50 2F 31    2E 31 0D 0A 48 6F 73 74    s HTTP/1.1..Host\n...\n```\n\n**来源：** [user/event/event_openssl.go:168-179](), [user/event/event_openssl.go:151-166]()\n\n### Bash 命令输出\n\n[user/event/event_bash.go:72-74]()\n\n```\nPID:5678, UID:1000, \tComm:bash, \tRetvalue:0, \tLine:\nls -la /etc/passwd && cat /etc/hosts\n```\n\n**来源：** [user/event/event_bash.go:72-80]()\n\n### MySQL 查询输出\n\n[user/event/event_mysqld.go:112-114]()\n\n```\nPID:3306, Comm:mysqld, Time:1634567890000000000,  length:(45/45),  return:DISPATCH_COMMAND_SUCCESS, Line:SELECT * FROM users WHERE id = 1234\n```\n\n**返回状态值：**\n\n| 代码 | 常量 | 含义 |\n|------|----------|---------|\n| 0 | `DISPATCH_COMMAND_SUCCESS` | 查询执行成功 |\n| 1 | `DISPATCH_COMMAND_CLOSE_CONNECTION` | 连接关闭 |\n| 2 | `DISPATCH_COMMAND_WOULDBLOCK` | 非阻塞操作挂起 |\n| -1 | `DISPATCH_COMMAND_NOT_CAPTURED` | 捕获查询失败 |\n| -2 | `DISPATCH_COMMAND_V57_FAILED` | MySQL 5.7 特定失败 |\n\n**来源：** [user/event/event_mysqld.go:40-66](), [user/event/event_mysqld.go:112-114]()\n\n### PostgreSQL 查询输出\n\n[user/event/event_postgres.go:68-69]()\n\n```\nPID: 5432, Comm: postgres, Time: 1634567890000000000, Query: SELECT id, name FROM accounts WHERE created_at > '2023-01-01'\n```\n\n**来源：** [user/event/event_postgres.go:68-69]()\n\n### NSPR/NSS (Firefox) 输出\n\n[user/event/event_nspr.go:98-120]()\n\n```\nPID:9876, Comm:Socket Thread, TID:9877, TYPE:Received, DataLen:512 bytes, Payload:\nHTTP/1.1 200 OK\nContent-Type: application/json\n...\n```\n\n**线程过滤：**\n- Firefox SSL 通信发生在专用的 \"Socket Thread\" 上\n- 基于线程名称的可选过滤（当前默认禁用）\n\n**来源：** [user/event/event_nspr.go:98-120]()\n\n---\n\n## 配置与使用\n\n### 初始化\n\n[pkg/event_processor/processor.go:206-215]()\n\n```\nprocessor := NewEventProcessor(logger, isHex, truncateSize)\n```\n\n**参数：**\n- `logger io.Writer` - 输出目标（控制台、文件或自定义写入器）\n- `isHex bool` - 启用十六进制转储模式\n- `truncateSize uint64` - 最大载荷大小（0 = 无限制）\n\n### 日志记录器类型\n\n**1. CollectorWriter（文本模式）：**\n\n[user/event/ievent.go:54-70]()\n\n```\nlogger := zerolog.New(os.Stdout).With().Timestamp().Logger()\ncollectorWriter := event.NewCollectorWriter(&logger)\nprocessor := NewEventProcessor(collectorWriter, false, 0)\n```\n\n**2. 标准 io.Writer：**\n```\nfile, _ := os.OpenFile(\"capture.log\", os.O_CREATE|os.O_WRONLY, 0644)\nprocessor := NewEventProcessor(file, false, 0)\n```\n\n**来源：** [user/event/ievent.go:54-70](), [pkg/event_processor/processor.go:206-215]()\n\n### 运行时操作\n\n```mermaid\nsequenceDiagram\n    participant Module as 捕获模块\n    participant EP as EventProcessor\n    participant Worker as eventWorker\n    participant Parser as IParser\n    participant Logger as io.Writer\n    \n    Module->>EP: Write(event)\n    EP->>Worker: incoming <- event\n    Worker->>Worker: 累积载荷\n    \n    Note over Worker: 100ms 空闲超时\n    \n    Worker->>Worker: Display()\n    Worker->>Parser: NewParser(payload)\n    Parser-->>Worker: 检测到的类型\n    Worker->>Parser: Write(payload)\n    Parser->>Parser: 格式化 (HTTP/hex/default)\n    Parser-->>Worker: 格式化的字节\n    \n    alt isHex == true\n        Worker->>Worker: hex.Dump(bytes)\n    end\n    \n    Worker->>EP: outComing <- bytes\n    EP->>Logger: Write(formatted)\n```\n\n**来源：** [pkg/event_processor/processor.go:66-89](), [pkg/event_processor/iworker.go:262-306]()\n\n---\n\n## 性能考虑\n\n### 缓冲与通道\n\n[pkg/event_processor/processor.go:25-28]()\n\n```\nMaxIncomingChanLen = 1024\nMaxParserQueueLen  = 1024\nMaxChanLen         = 1024  // 每个 eventWorker\n```\n\n**通道深度：**\n- `EventProcessor.incoming` - 1024 个事件\n- `EventProcessor.outComing` - 1024 个格式化输出\n- `eventWorker.incoming` - 每个连接 1024 个事件\n\n**背压处理：**\n- 如果通道已满，事件将被静默丢弃\n- 无阻塞以防止 eBPF 环形缓冲区溢出\n\n**来源：** [pkg/event_processor/processor.go:25-28](), [pkg/event_processor/iworker.go:51-55]()\n\n### 工作器生命周期管理\n\n**空闲超时：**\n\n[pkg/event_processor/iworker.go:51-52]()\n\n```\nMaxTickerCount = 10   // 10 个 tick × 100ms = 1 秒\n```\n\n**默认生命周期：**\n- 工作器在 1 秒不活动后自毁\n- 减少短期连接的内存使用\n\n**套接字生命周期：**\n- 带有 \"sock:\" UUID 前缀的工作器持续到套接字关闭\n- 启用面向连接的聚合\n- 详见 [网络连接跟踪](#2.6)\n\n**来源：** [pkg/event_processor/iworker.go:51-63](), [pkg/event_processor/iworker.go:262-306]()\n\n### 内存优化\n\n**截断：**\n- 防止无限制的载荷增长\n- 在解析之前应用于每个工作器\n- 通过 `truncateSize` 参数可配置\n\n**解析器重置：**\n\n[pkg/event_processor/iworker.go:183-187]()\n\n```\ndefer func() {\n    ew.parser.Reset()\n    ew.payload.Reset()\n    ew.status = ProcessStateInit\n}()\n```\n\n每个显示周期重置缓冲区以回收内存。\n\n**来源：** [pkg/event_processor/iworker.go:230-245](), [pkg/event_processor/iworker.go:183-187]()"
          },
          {
            "page_plan": {
              "id": "4.2",
              "title": "PCAP 集成"
            },
            "content": "# PCAP 集成\n\n## 目的与范围\n\n本文档描述了 eCapture 的 PCAP-NG 文件生成功能，它能够以与 Wireshark 及其他网络分析工具兼容的格式捕获和存储网络数据包。PCAP 集成可捕获加密的网络流量以及解密它所需的 TLS/SSL 密钥，并将它们一起存储在一个包含解密密钥块（DSB）的 PCAP-NG 文件中。\n\n有关其他输出格式的信息，请参阅 [文本输出模式](#4.1) 和 [TLS 密钥日志](#4.3)。有关底层数据包捕获机制的详细信息，请参阅 [网络连接跟踪](#2.6)。\n\n---\n\n## 概述\n\neCapture 的 PCAP 集成在 `pcap` 或 `pcapng` 模式下运行，与文本模式的根本区别在于它捕获完整的网络数据包而不仅仅是明文内容。该模式将三个数据源整合到统一的 PCAP-NG 文件中：\n\n1. **网络数据包**：通过 TC（流量控制）eBPF 分类器在入站/出站方向捕获\n2. **TLS 主密钥**：通过 uprobe 钩子在 SSL/TLS 函数上提取\n3. **连接元数据**：包括进程信息（PID、UID、命令名）\n\n生成的 PCAP-NG 文件可以在 Wireshark 中打开，并使用嵌入的主密钥自动解密 TLS 流量。\n\n**PCAP 集成架构**\n\n```mermaid\ngraph TB\n    subgraph \"捕获源\"\n        TC[TC eBPF 程序<br/>capture_packets<br/>入站/出站]\n        UPROBE[Uprobe 钩子<br/>SSL_read/SSL_write<br/>SSL_do_handshake]\n        KPROBE[Kprobe 钩子<br/>tcp_sendmsg<br/>udp_sendmsg]\n    end\n    \n    subgraph \"事件处理\"\n        TC_EVENT[TcSkbEvent<br/>网络数据包<br/>4元组 + 载荷]\n        MS_EVENT[MasterSecretEvent<br/>TLS 1.2/1.3 密钥<br/>ClientRandom + 密钥]\n        CONN_EVENT[ConnDataEvent<br/>PID/FD 映射<br/>元组生成]\n    end\n    \n    subgraph \"PCAP 写入器 - MTCProbe\"\n        PACKET_CHAN[tcPacketsChan<br/>缓冲通道<br/>容量 2048]\n        PACKET_BUF[tcPackets 切片<br/>容量 256<br/>批量缓冲]\n        MASTERKEY_BUF[masterKeyBuffer<br/>bytes.Buffer<br/>DSB 数据]\n    end\n    \n    subgraph \"文件输出\"\n        PCAPNG_WRITER[PcapNG 写入器<br/>gopacket/pcapgo]\n        DSB_BLOCKS[DSB 块<br/>解密密钥<br/>TLS 密钥日志格式]\n        EPB_BLOCKS[EPB 块<br/>增强数据包<br/>含元数据]\n    end\n    \n    TC --> TC_EVENT\n    UPROBE --> MS_EVENT\n    KPROBE --> CONN_EVENT\n    \n    TC_EVENT -->|dumpTcSkb| PACKET_CHAN\n    MS_EVENT -->|savePcapngSslKeyLog| MASTERKEY_BUF\n    CONN_EVENT -->|AddConn| PACKET_CHAN\n    \n    PACKET_CHAN --> PACKET_BUF\n    PACKET_BUF -->|savePcapng| PCAPNG_WRITER\n    MASTERKEY_BUF -->|savePcapng| DSB_BLOCKS\n    \n    PCAPNG_WRITER --> EPB_BLOCKS\n    DSB_BLOCKS --> PCAPNG_WRITER\n    \n    style TC fill:#bbdefb\n    style UPROBE fill:#c5e1a5\n    style PCAPNG_WRITER fill:#fff9c4\n    style DSB_BLOCKS fill:#f8bbd0\n```\n\n来源：[user/module/probe_openssl.go:137-148](), [user/module/probe_openssl.go:287-296](), [README.md:173-187]()\n\n---\n\n## 激活与配置\n\n### 命令行使用\n\n使用 `-m pcap` 或 `-m pcapng` 参数激活 PCAP 模式，配合 `tls` 或 `gotls` 模块。必需的参数包括：\n\n| 参数 | 描述 | 默认值 |\n|------|------|--------|\n| `-m pcap` 或 `-m pcapng` | 激活 PCAP 模式 | 无（必需） |\n| `--pcapfile` | 输出文件路径 | `ecapture_openssl.pcapng` |\n| `-i` | 要捕获的网络接口 | 无（必需） |\n| PCAP 过滤表达式 | 可选的 BPF 过滤器 | 无 |\n\n命令示例：\n```bash\nsudo ecapture tls -m pcap -i eth0 --pcapfile=capture.pcapng tcp port 443\n```\n\n**模式选择实现**\n\n```mermaid\ngraph LR\n    CLI_PARSE[CLI 解析器<br/>cobra 命令] --> MODEL_CONFIG[OpensslConfig.Model<br/>字符串值]\n    MODEL_CONFIG --> SWITCH{模式选择}\n    \n    SWITCH -->|\"pcap/pcapng\"| PCAP_INIT[TlsCaptureModelTypePcap<br/>eBPFProgramType = 1]\n    SWITCH -->|\"keylog/key\"| KEYLOG_INIT[TlsCaptureModelTypeKeylog<br/>eBPFProgramType = 2]\n    SWITCH -->|\"text/default\"| TEXT_INIT[TlsCaptureModelTypeText<br/>eBPFProgramType = 0]\n    \n    PCAP_INIT --> PCAP_SETUP[创建 tcPacketsChan<br/>设置 pcapngFilename<br/>setupManagersPcap]\n    KEYLOG_INIT --> KEYLOG_SETUP[打开 keylogger 文件<br/>setupManagersKeylog]\n    TEXT_INIT --> TEXT_SETUP[setupManagersText]\n    \n    PCAP_SETUP --> RUN[Module.Run]\n    KEYLOG_SETUP --> RUN\n    TEXT_SETUP --> RUN\n```\n\n来源：[user/module/probe_openssl.go:127-154](), [user/config/iconfig.go:73-79](), [cli/cmd/root.go:249-296]()\n\n### 配置结构\n\nPCAP 模式通过 `OpensslConfig` 进行配置：\n\n```\nOpensslConfig.Model = \"pcap\" 或 \"pcapng\"\nOpensslConfig.PcapFile = 输出文件路径\nOpensslConfig.Ifname = 网络接口名称\nOpensslConfig.PcapFilter = 可选的 BPF 过滤表达式\n```\n\n此配置会触发以下组件的初始化：\n- `tcPacketsChan`：缓冲通道（容量 2048）用于数据包排队\n- `tcPackets`：切片缓冲区（容量 256）用于批量写入\n- `pcapngFilename`：输出文件的绝对路径\n\n来源：[user/module/probe_openssl.go:137-148]()\n\n---\n\n## PCAP-NG 文件格式\n\n### 文件结构\n\neCapture 生成 PCAP-NG（下一代）文件，它在经典 PCAP 格式基础上扩展了更丰富的元数据。文件结构由以下部分组成：\n\n1. **节头块（SHB）**：文件标识和字节序\n2. **接口描述块（IDB）**：网络接口元数据\n3. **解密密钥块（DSB）**：TLS 主密钥用于解密\n4. **增强数据包块（EPB）**：带时间戳的单个数据包数据\n\n**PCAP-NG 块结构**\n\n```mermaid\ngraph TB\n    FILE[PCAP-NG 文件]\n    \n    FILE --> SHB[节头块<br/>字节序: 0x1A2B3C4D<br/>版本: 1.0]\n    \n    SHB --> IDB[接口描述块<br/>LinkType: 以太网<br/>SnapLen: 262144<br/>名称/描述]\n    \n    IDB --> DSB1[解密密钥块<br/>SecretsType: TLS 密钥日志<br/>CLIENT_RANDOM 格式<br/>TLS 1.2/1.3 密钥]\n    \n    IDB --> EPB1[增强数据包块<br/>InterfaceID: 0<br/>时间戳: ns 精度<br/>捕获长度<br/>原始长度<br/>数据包数据]\n    \n    EPB1 --> EPB2[增强数据包块<br/>...]\n    \n    EPB2 --> DSB2[解密密钥块<br/>附加密钥]\n    \n    DSB2 --> EPB3[增强数据包块<br/>...]\n    \n    EPB3 --> EPBN[增强数据包块<br/>...]\n    \n    style SHB fill:#e1f5fe\n    style IDB fill:#fff3e0\n    style DSB1 fill:#f3e5f5\n    style DSB2 fill:#f3e5f5\n    style EPB1 fill:#e8f5e9\n    style EPB2 fill:#e8f5e9\n    style EPB3 fill:#e8f5e9\n```\n\n来源：[user/module/probe_openssl.go:558-565](), [user/module/probe_openssl.go:625-632]()\n\n### 增强数据包块（EPB）内容\n\n每个捕获的数据包存储为一个 EPB，包含：\n\n- **接口 ID**：链接到 IDB（通常为 0）\n- **时间戳**：纳秒精度（启动时间 + 单调时钟）\n- **捕获的数据包长度**：实际捕获的字节数\n- **原始数据包长度**：线路长度（如果截断可能超过捕获长度）\n- **数据包数据**：原始以太网帧，包括：\n  - 以太网头（14 字节）\n  - IP 头（IPv4 或 IPv6）\n  - 传输层头（TCP/UDP）\n  - 应用层载荷（加密或解密）\n\n数据包数据来自 TC eBPF 程序，它们在入站/出站点捕获完整的网络帧。\n\n来源：[user/module/probe_openssl.go:747-750]()\n\n---\n\n## 解密密钥块（DSB）\n\n### 目的与格式\n\nDSB 是 PCAP-NG 块类型，用于存储 TLS 解密密钥，使 Wireshark 能够自动解密捕获的 TLS 流量。eCapture 嵌入包含主密钥的 DSB 块，采用浏览器和其他 TLS 工具使用的 SSLKEYLOGFILE 格式。\n\n### DSB 数据格式\n\nDSB 块包含标准密钥日志格式的 TLS 密钥：\n\n```\nCLIENT_RANDOM <client_random_hex> <master_secret_hex>\nCLIENT_HANDSHAKE_TRAFFIC_SECRET <client_random_hex> <secret_hex>\nSERVER_HANDSHAKE_TRAFFIC_SECRET <client_random_hex> <secret_hex>\nCLIENT_TRAFFIC_SECRET_0 <client_random_hex> <secret_hex>\nSERVER_TRAFFIC_SECRET_0 <client_random_hex> <secret_hex>\nEXPORTER_SECRET <client_random_hex> <secret_hex>\n```\n\n对于 TLS 1.2，仅写入 `CLIENT_RANDOM`。对于 TLS 1.3，会派生并写入多个流量密钥。\n\n**主密钥提取与 DSB 写入**\n\n```mermaid\ngraph TB\n    subgraph \"Uprobe 捕获\"\n        SSL_HANDSHAKE[SSL_do_handshake<br/>uprobe 入口/返回]\n        SSL_WBIO[SSL_get_wbio<br/>获取 FD 映射]\n        SSL_STATE[SSL_in_before/SSL_state<br/>握手状态]\n    end\n    \n    subgraph \"eBPF 事件\"\n        MS_EVENT_12[MasterSecretEvent<br/>TLS 1.2<br/>ClientRandom 32B<br/>MasterKey 48B]\n        MS_EVENT_13[MasterSecretEvent<br/>TLS 1.3<br/>ClientRandom 32B<br/>HandshakeSecret 64B<br/>AppTrafficSecrets 64B]\n        MS_EVENT_BSSL[MasterSecretBSSLEvent<br/>BoringSSL 变体<br/>HashLen 动态<br/>各种密钥]\n    end\n    \n    subgraph \"用户空间处理\"\n        DISPATCHER[Dispatcher<br/>事件类型路由]\n        SAVE_MS[saveMasterSecret<br/>OpenSSL 格式]\n        SAVE_BSSL[saveMasterSecretBSSL<br/>BoringSSL 格式]\n        NULL_CHECK{空密钥<br/>检查}\n        DEDUP[masterKeys map<br/>按 ClientRandom<br/>去重]\n    end\n    \n    subgraph \"DSB 生成\"\n        HKDF_EXPAND[HKDF ExpandLabel<br/>TLS 1.3 密钥<br/>派生]\n        FORMAT_12[格式化 TLS 1.2<br/>CLIENT_RANDOM 行]\n        FORMAT_13[格式化 TLS 1.3<br/>6 种密钥类型]\n        BUFFER[masterKeyBuffer<br/>bytes.Buffer]\n    end\n    \n    subgraph \"文件写入\"\n        PCAP_WRITER[savePcapngSslKeyLog<br/>写入 DSB 到文件]\n        FLUSH[定期刷新<br/>每 2 秒]\n    end\n    \n    SSL_HANDSHAKE --> MS_EVENT_12\n    SSL_HANDSHAKE --> MS_EVENT_13\n    SSL_HANDSHAKE --> MS_EVENT_BSSL\n    \n    MS_EVENT_12 --> DISPATCHER\n    MS_EVENT_13 --> DISPATCHER\n    MS_EVENT_BSSL --> DISPATCHER\n    \n    DISPATCHER --> SAVE_MS\n    DISPATCHER --> SAVE_BSSL\n    \n    SAVE_MS --> NULL_CHECK\n    SAVE_BSSL --> NULL_CHECK\n    \n    NULL_CHECK -->|非空| DEDUP\n    NULL_CHECK -->|全为空| DROP[丢弃事件]\n    \n    DEDUP -->|新 ClientRandom| HKDF_EXPAND\n    DEDUP -->|重复| DROP\n    \n    HKDF_EXPAND --> FORMAT_12\n    HKDF_EXPAND --> FORMAT_13\n    \n    FORMAT_12 --> BUFFER\n    FORMAT_13 --> BUFFER\n    \n    BUFFER --> PCAP_WRITER\n    PCAP_WRITER --> FLUSH\n```\n\n来源：[user/module/probe_openssl.go:482-575](), [user/module/probe_openssl.go:577-642]()\n\n### 实现细节\n\n#### TLS 1.2 主密钥\n\n对于 TLS 1.2，主密钥直接从 SSL 结构中捕获：\n\n1. 在 `SSL_do_handshake` 上使用 uprobe 捕获 SSL 上下文\n2. 导航到 `s3->tmp.new_cipher` 以获取密码套件\n3. 读取 `session->master_key`（48 字节）\n4. 读取 `session->client_random`（32 字节）\n5. 格式：`CLIENT_RANDOM <32 十六进制字节> <48 十六进制字节>`\n\n#### TLS 1.3 流量密钥\n\n对于 TLS 1.3，提取并派生多个密钥：\n\n1. 从 SSL 结构捕获 `handshake_secret`、`handshake_traffic_hash`\n2. 使用 HKDF 派生：\n   - `client_handshake_traffic_secret` = HKDF-Expand-Label(handshake_secret, \"c hs traffic\", handshake_traffic_hash, hash_len)\n   - `server_handshake_traffic_secret` = HKDF-Expand-Label(handshake_secret, \"s hs traffic\", handshake_traffic_hash, hash_len)\n3. 直接捕获 `client_app_traffic_secret`、`server_app_traffic_secret`、`exporter_master_secret`\n4. 将所有六种密钥类型写入 DSB\n\nHKDF 扩展在用户空间执行，使用捕获的哈希算法（根据密码套件使用 SHA256 或 SHA384）。\n\n来源：[user/module/probe_openssl.go:502-551](), [pkg/util/hkdf/hkdf.go]()\n\n#### 空密钥检测\n\neCapture 在写入 DSB 之前会验证捕获的密钥不是空值（全为零）。这可以防止密钥日志损坏：\n\n- 对于 TLS 1.2：检查 `master_key` 的全部 48 字节是否为零\n- 对于 TLS 1.3：检查所有流量密钥是否为零（5 个不同的密钥）\n- 如果所有密钥都为空，则丢弃该事件\n\n来源：[user/module/probe_openssl.go:644-731]()\n\n#### 去重\n\n主密钥使用 `map[string]bool` 去重，键为十六进制编码的 `ClientRandom`：\n\n```\nClientRandom（32 字节）-> 十六进制字符串（64 字符）-> map 键\n```\n\n如果 `ClientRandom` 已存在于 map 中，则不写入重复的密钥。这可以防止同一 TLS 会话写入多个相同的 DSB 块。\n\n来源：[user/module/probe_openssl.go:483-489](), [user/module/probe_openssl.go:578-584]()\n\n---\n\n## TC 数据包捕获集成\n\n### 流量控制（TC）eBPF 程序\n\nPCAP 模式依赖于附加到网络接口的 TC eBPF 分类器来捕获数据包。与在应用层捕获明文的 uprobe 不同，TC 程序捕获包括加密载荷在内的完整网络数据包。\n\n**TC 分类器附加点**\n\n```mermaid\ngraph LR\n    subgraph \"网络接口\"\n        NIC[网络接口<br/>例如 eth0]\n    end\n    \n    subgraph \"TC 入站路径\"\n        ING_QDISC[入站 Qdisc<br/>clsact]\n        ING_FILTER[TC 分类器<br/>capture_packets_ingress<br/>BPF 程序]\n    end\n    \n    subgraph \"TC 出站路径\"\n        EG_QDISC[出站 Qdisc<br/>clsact]\n        EG_FILTER[TC 分类器<br/>capture_packets_egress<br/>BPF 程序]\n    end\n    \n    subgraph \"内核网络栈\"\n        IP_LAYER[IP 层<br/>路由/过滤]\n        SOCKET[套接字层<br/>应用程序 I/O]\n    end\n    \n    subgraph \"eBPF Map\"\n        SKB_EVENTS[skb_events<br/>perf/ring 缓冲区<br/>TcSkbEvent 数据]\n    end\n    \n    NIC -->|入站| ING_QDISC\n    ING_QDISC --> ING_FILTER\n    ING_FILTER -->|TC_ACT_OK| IP_LAYER\n    \n    IP_LAYER --> SOCKET\n    \n    SOCKET -->|出站| EG_QDISC\n    EG_QDISC --> EG_FILTER\n    EG_FILTER -->|TC_ACT_OK| NIC\n    \n    ING_FILTER -->|捕获| SKB_EVENTS\n    EG_FILTER -->|捕获| SKB_EVENTS\n```\n\n来源：[user/module/probe_openssl.go:303-307]()\n\n### TcSkbEvent 结构\n\n每个捕获的数据包生成一个 `TcSkbEvent`，包含：\n\n| 字段 | 类型 | 描述 |\n|------|------|------|\n| `Pid` | uint32 | 发送/接收数据包的进程 ID |\n| `Tid` | uint32 | 线程 ID |\n| `Uid` | uint32 | 用户 ID |\n| `Gid` | uint32 | 组 ID |\n| `Comm` | [16]byte | 命令名（进程） |\n| `SAddr` | [16]byte | 源 IP 地址（IPv4/IPv6） |\n| `DAddr` | [16]byte | 目标 IP 地址 |\n| `Sport` | uint16 | 源端口 |\n| `Dport` | uint16 | 目标端口 |\n| `PacketLen` | uint32 | 总数据包长度 |\n| `Payload` | []byte | 数据包数据（以太网帧） |\n| `Direction` | uint8 | 0=出站，1=入站 |\n\n捕获完整的以太网帧，包括头部和加密载荷。\n\n来源：[user/event/event_tc.go]()\n\n### BPF 过滤器集成\n\n当提供 PCAP 过滤表达式（例如 `tcp port 443`）时，它会在加载时被编译为 eBPF 指令并修补到 TC 分类器程序中：\n\n1. 使用 libpcap 语法解析过滤表达式\n2. 编译为经典 BPF 指令\n3. 转换为 eBPF 指令\n4. 使用 `InstructionPatchers` 修补到 TC 程序中\n\n这种过滤在内核空间发生，减少了发送到用户空间的事件量。\n\n来源：[user/module/probe_openssl.go:303-307]()\n\n---\n\n## 数据包处理流程\n\n### 从 TC 到文件的事件流\n\n**数据包捕获流程**\n\n```mermaid\ngraph TB\n    subgraph \"内核空间\"\n        TC_ING[TC 入站分类器]\n        TC_EG[TC 出站分类器]\n        PERF_MAP[Perf 事件数组<br/>或环形缓冲区]\n    end\n    \n    subgraph \"用户空间 - 事件读取器\"\n        PERF_READER[perfEventReader<br/>或 ringbufEventReader]\n        DECODE[解码 TcSkbEvent<br/>从原始字节]\n    end\n    \n    subgraph \"模块分发器\"\n        DISPATCHER[MOpenSSLProbe.Dispatcher]\n        DUMP_TCSKB[dumpTcSkb 方法]\n    end\n    \n    subgraph \"数据包缓冲\"\n        BUILD_PKT[buildTcPacket<br/>构造 TcPacket]\n        CHAN[tcPacketsChan<br/>缓冲通道<br/>容量: 2048]\n        CONSUMER[通道消费者<br/>goroutine]\n        SLICE[tcPackets 切片<br/>批量缓冲<br/>容量: 256]\n    end\n    \n    subgraph \"文件写入\"\n        LOCK[tcPacketLocker<br/>互斥锁]\n        SAVE[savePcapng<br/>写入 EPB 块]\n        WRITER[PcapNG 写入器<br/>gopacket/pcapgo]\n        FLUSH[刷新到磁盘<br/>每 2 秒]\n    end\n    \n    TC_ING --> PERF_MAP\n    TC_EG --> PERF_MAP\n    \n    PERF_MAP --> PERF_READER\n    PERF_READER --> DECODE\n    DECODE --> DISPATCHER\n    \n    DISPATCHER --> DUMP_TCSKB\n    DUMP_TCSKB --> BUILD_PKT\n    BUILD_PKT --> CHAN\n    \n    CHAN --> CONSUMER\n    CONSUMER --> SLICE\n    \n    SLICE -->|批量写入| LOCK\n    LOCK --> SAVE\n    SAVE --> WRITER\n    WRITER --> FLUSH\n```\n\n来源：[user/module/probe_openssl.go:747-750](), [user/module/probe_tc.go]()\n\n### TcPacket 构造\n\n`dumpTcSkb` 方法将 `TcSkbEvent` 转换为 `TcPacket` 结构：\n\n1. **时间戳转换**：将内核单调时间转换为墙上时钟时间\n   - `timestamp_ns = boot_time + skb_event.timestamp_ns`\n2. **数据包数据提取**：从事件载荷复制以太网帧\n3. **元数据附加**：包含 PID、命令、元组信息\n4. **入队**：发送到 `tcPacketsChan` 进行缓冲处理\n\n`TcPacket` 结构包含：\n- 时间戳（纳秒精度）\n- 数据包数据（以太网帧字节）\n- 连接信息（用于与 uprobe 关联）\n\n来源：[user/module/probe_tc.go]()\n\n### 批量写入\n\n数据包以批量方式写入 PCAP-NG 文件以提高性能：\n\n1. 消费者 goroutine 从 `tcPacketsChan` 读取\n2. 在 `tcPackets` 切片中累积数据包（最多 256 个）\n3. 当切片满或超时时，调用 `savePcapng`\n4. `savePcapng` 获取锁并将所有数据包写入为 EPB 块\n5. 每 2 秒将写入器刷新到磁盘\n\n这种批量处理减少了系统调用开销并提高了吞吐量。\n\n来源：[user/module/probe_tc.go]()\n\n---\n\n## 文件写入器实现\n\n### PcapNG 写入器初始化\n\neCapture 使用 `gopacket/pcapgo` 库生成 PCAP-NG 文件：\n\n```\nWriter: *pcapgo.NgWriter\nFile: *os.File 使用 O_CREATE | O_WRONLY | O_TRUNC 打开\nInterface: pcapgo.NgInterface 包含 LinkType、SnapLen、Name、Description\n```\n\n初始化序列：\n1. 创建/截断输出文件\n2. 使用文件句柄创建 `NgWriter`\n3. 写入节头块（SHB）\n4. 写入接口描述块（IDB）\n5. 设置定期刷新定时器（2 秒）\n\n来源：[user/module/probe_tc.go]()\n\n### DSB 写入\n\n通过 `savePcapngSslKeyLog` 写入解密密钥：\n\n1. 在 `masterKeyBuffer` 中将主密钥格式化为 TLS 密钥日志行\n2. 调用 `NgWriter.WriteDecryptionSecretsBlock`：\n   - SecretsType: `pcapgo.DSB_SECRETS_TYPE_TLS`（0x544c534b）\n   - SecretsData: 密钥日志格式化字节\n3. 清空 `masterKeyBuffer` 用于下一批\n\nDSB 块可以出现在文件的任何位置，与 EPB 块交错。Wireshark 处理所有 DSB 块来构建其解密密钥表。\n\n来源：[user/module/probe_openssl.go:558-565]()\n\n### EPB 写入\n\n每个数据包写入为增强数据包块：\n\n```\nCaptureInfo: gopacket.CaptureInfo {\n    Timestamp: time.Unix(0, timestamp_ns)\n    CaptureLength: len(packet_data)\n    Length: len(packet_data)\n    InterfaceIndex: 0\n}\n```\n\n`NgWriter.WritePacket` 方法处理 EPB 块格式化，包括：\n- 块类型和长度字段\n- 接口 ID\n- 时间戳（高/低 32 位拆分）\n- 捕获长度和原始长度\n- 数据包数据\n- 填充到 32 位边界\n- 块总长度尾部\n\n来源：[user/module/probe_tc.go]()\n\n### 定期刷新\n\n为了确保即使在数据包不频繁时数据也能写入磁盘：\n\n1. 启动定时器 goroutine，间隔 2 秒\n2. 每次触发时，获取锁并刷新写入器\n3. 记录数据包计数统计\n4. 继续直到上下文取消\n\n这可以防止程序终止时数据丢失。\n\n来源：[user/module/probe_tc.go]()\n\n---\n\n## 进程与连接关联\n\n### PID/FD 到套接字映射\n\n为了将网络数据包（在 TC 层捕获）与 TLS 明文（在 SSL 层捕获）关联，eCapture 维护双向映射：\n\n**连接跟踪架构**\n\n```mermaid\ngraph TB\n    subgraph \"Kprobe 捕获\"\n        CONNECT[tcp_connect<br/>udp_connect<br/>或 sys_connect]\n        SENDMSG[tcp_sendmsg<br/>udp_sendmsg]\n        DESTROY[tcp_destroy_sock<br/>或 inet_sock_destruct]\n    end\n    \n    subgraph \"连接事件\"\n        CONN_CREATE[ConnDataEvent<br/>IsDestroy=0<br/>Pid, Fd, Sock, Tuple]\n        CONN_DESTROY[ConnDataEvent<br/>IsDestroy=1<br/>Sock]\n    end\n    \n    subgraph \"用户空间映射\"\n        PID_CONNS[\"pidConns<br/>map[pid]map[fd]ConnInfo<br/>ConnInfo={tuple, sock}\"]\n        SOCK_MAP[\"sock2pidFd<br/>map[sock][2]uint32<br/>[2]uint32={pid, fd}\"]\n    end\n    \n    subgraph \"TLS 数据捕获\"\n        SSL_READ[SSL_read uprobe<br/>返回 Fd]\n        SSL_WRITE[SSL_write uprobe<br/>返回 Fd]\n        LOOKUP[通过 PID+FD 获取连接<br/>返回 tuple+sock]\n    end\n    \n    subgraph \"TC 数据包匹配\"\n        TC_PKT[TC 数据包<br/>包含 tuple<br/>SAddr:Sport-DAddr:Dport]\n        MATCH[匹配 tuple<br/>到 PID/Comm]\n    end\n    \n    CONNECT --> CONN_CREATE\n    DESTROY --> CONN_DESTROY\n    \n    CONN_CREATE --> PID_CONNS\n    CONN_CREATE --> SOCK_MAP\n    \n    CONN_DESTROY --> PID_CONNS\n    CONN_DESTROY --> SOCK_MAP\n    \n    SSL_READ --> LOOKUP\n    SSL_WRITE --> LOOKUP\n    LOOKUP --> PID_CONNS\n    \n    PID_CONNS --> TC_PKT\n    TC_PKT --> MATCH\n```\n\n来源：[user/module/probe_openssl.go:398-480]()\n\n### 连接生命周期\n\n1. **创建**：当连接建立时（通过 kprobe 在 `tcp_connect` 或 `sys_connect` 上检测）：\n   - 生成 4 元组：`SrcIP:SrcPort-DstIP:DstPort`\n   - 映射 PID+FD -> {tuple, sock}\n   - 映射 sock -> {PID, FD}\n\n2. **使用**：当捕获 SSL 数据时（通过 uprobe 在 `SSL_read`/`SSL_write` 上）：\n   - 通过 PID+FD 查找 tuple 和 sock\n   - 将 tuple 附加到 `SSLDataEvent`\n   - 事件处理器使用 tuple 与 TC 数据包关联\n\n3. **销毁**：当套接字关闭时（通过 kprobe 在 `tcp_destroy_sock` 上检测）：\n   - 移除 PID+FD -> ConnInfo 映射\n   - 移除 sock -> PID+FD 映射\n   - 延迟删除（3 秒）以允许飞行中的事件完成\n\n这种关联使 Wireshark 能够显示：\n- 哪个进程生成了每个数据包\n- 进程所属的用户\n- 进程的命令名\n\n来源：[user/module/probe_openssl.go:398-462]()\n\n---\n\n## Wireshark 集成\n\n### 打开 PCAP-NG 文件\n\n在 Wireshark 中查看捕获的流量：\n\n1. **直接打开**：`wireshark ecapture.pcapng`\n   - TLS 流量使用嵌入的 DSB 块自动解密\n   - 无需额外配置\n\n2. **手动密钥日志**：如果未嵌入 DSB，使用 `编辑 -> 首选项 -> 协议 -> TLS -> (Pre)-Master-Secret 日志文件名`\n\n3. **实时捕获**：当 eCapture 运行时，Wireshark 可以打开文件进行实时查看（文件每 2 秒刷新一次）\n\n### 显示过滤器\n\n用于 eCapture PCAP-NG 文件的有用 Wireshark 过滤器：\n\n| 过滤器 | 目的 |\n|--------|------|\n| `http` | HTTP/1.x 解密的请求/响应 |\n| `http2` | HTTP/2 解密的帧 |\n| `http3` | HTTP/3 QUIC 解密的流 |\n| `tls.handshake.type == 1` | TLS ClientHello 消息 |\n| `frame.comment` | 带注释的数据包（PID/Comm） |\n\n来源：[README.md:189-230]()\n\n### 协议层次结构\n\nPCAP-NG 文件包含完整的协议栈：\n\n```\n以太网 II\n  └─ IPv4 或 IPv6\n      └─ TCP 或 UDP\n          └─ TLS 1.2/1.3\n              └─ HTTP/1.1、HTTP/2 或 HTTP/3（QUIC）\n```\n\n当存在 DSB 块时，Wireshark 会自动解析所有层并显示解密的应用数据。\n\n---\n\n## 性能考虑\n\n### 缓冲区大小\n\n| 缓冲区 | 大小 | 目的 |\n|--------|------|------|\n| `tcPacketsChan` | 2048 个数据包 | 异步生产者/消费者缓冲 |\n| `tcPackets` 切片 | 256 个数据包 | 批量写入以减少系统调用 |\n| 每 CPU map | 可配置（默认 1024 * PAGE_SIZE） | eBPF 事件缓冲区大小 |\n\n更大的缓冲区在高流量下减少数据包丢失，但会增加内存使用。\n\n来源：[user/module/probe_openssl.go:137-148](), [cli/cmd/root.go:143]()\n\n### 数据包丢失场景\n\n1. **eBPF map 溢出**：如果每 CPU map 填满，事件在内核中被丢弃\n2. **通道溢出**：如果 `tcPacketsChan` 填满（2048 个数据包），可能发生阻塞\n3. **处理延迟**：如果用户空间无法跟上内核事件速率\n\n系统会记录数据包丢失的警告，包括来自 perf 缓冲区的丢失样本计数。\n\n来源：[user/module/imodule.go:336-338]()\n\n### 优化策略\n\n1. **增加 map 大小**：使用 `--mapsize` 标志为 eBPF map 分配更多内存\n2. **积极过滤**：使用 PCAP 过滤表达式减少捕获的数据包量\n3. **针对特定进程**：使用 `-p` 标志仅捕获特定 PID\n4. **SSD 存储**：将 PCAP-NG 文件写入快速存储（SSD）以减少 I/O 瓶颈\n\n---\n\n## 实现类图\n\n**关键类及其关系**\n\n```mermaid\nclassDiagram\n    class MOpenSSLProbe {\n        -tcPacketsChan chan TcPacket\n        -tcPackets []TcPacket\n        -tcPacketLocker sync.Mutex\n        -pcapngFilename string\n        -masterKeyBuffer bytes.Buffer\n        -pidConns map[uint32]map[uint32]ConnInfo\n        -sock2pidFd map[uint64][2]uint32\n        +setupManagersPcap() error\n        +dumpTcSkb(TcSkbEvent) error\n        +savePcapng() error\n        +savePcapngSslKeyLog([]byte) error\n        +saveMasterSecret(MasterSecretEvent)\n        +AddConn(pid, fd, tuple, sock)\n        +GetConn(pid, fd) ConnInfo\n        +DestroyConn(sock)\n    }\n    \n    class TcSkbEvent {\n        +Pid uint32\n        +Comm [16]byte\n        +SAddr [16]byte\n        +DAddr [16]byte\n        +Sport uint16\n        +Dport uint16\n        +PacketLen uint32\n        +Payload []byte\n        +Direction uint8\n    }\n    \n    class TcPacket {\n        +Timestamp time.Time\n        +Data []byte\n        +Info gopacket.CaptureInfo\n    }\n    \n    class MasterSecretEvent {\n        +Version uint32\n        +ClientRandom [32]byte\n        +MasterKey [48]byte\n        +HandshakeSecret [64]byte\n        +ClientAppTrafficSecret [64]byte\n        +ServerAppTrafficSecret [64]byte\n        +ExporterMasterSecret [64]byte\n        +CipherId uint32\n    }\n    \n    class ConnInfo {\n        +tuple string\n        +sock uint64\n    }\n    \n    class NgWriter {\n        +WriteDecryptionSecretsBlock() error\n        +WritePacket() error\n        +Flush() error\n    }\n    \n    MOpenSSLProbe --> TcSkbEvent : 接收\n    MOpenSSLProbe --> TcPacket : 创建\n    MOpenSSLProbe --> MasterSecretEvent : 接收\n    MOpenSSLProbe --> ConnInfo : 管理\n    MOpenSSLProbe --> NgWriter : 使用\n    TcSkbEvent --> TcPacket : 转换为\n```\n\n来源：[user/module/probe_openssl.go:83-106](), [user/event/event_tc.go](), [user/event/event_ssl.go]()\n\n---\n\n## 错误处理\n\n### 常见问题\n\n| 问题 | 原因 | 解决方案 |\n|------|------|----------|\n| PCAP 文件为空 | 没有数据包匹配过滤器 | 检查接口和过滤表达式 |\n| 缺少 DSB 块 | 未捕获 TLS 握手 | 确保在连接前开始捕获 |\n| Wireshark 无法解密 | 密码套件/版本错误 | 检查 TLS 版本兼容性 |\n| 文件未刷新 | 程序被强制终止 | 等待优雅关闭或使用更长的捕获时间 |\n\n### 日志记录\n\nPCAP 模式日志包括：\n\n- 数据包保存计数（每 2 秒）：`INF packets saved into pcapng file. count=123`\n- 主密钥保存：`INF CLIENT_RANDOM save success CLientRandom=... TlsVersion=...`\n- DSB 写入失败：`WRN save sslKeylog failed`\n- 初始化时的文件路径：`INF packets saved into pcapng file. pcapng path=...`\n\n来源：[README.md:189-230]()\n\n---\n\n## 与其他模式的比较\n\n| 功能 | PCAP 模式 | 文本模式 | Keylog 模式 |\n|------|-----------|----------|-------------|\n| 输出格式 | PCAP-NG 文件 | 文本日志 | SSLKEYLOGFILE |\n| 网络数据包 | 完整捕获 | 不捕获 | 不捕获 |\n| 明文内容 | 通过 DSB 解密 | 直接输出 | 不包含 |\n| Wireshark 兼容 | 是（原生） | 否 | 是（手动导入） |\n| 性能影响 | 最高（完整数据包） | 最低 | 低 |\n| 使用场景 | 网络分析 | 快速检查 | tcpdump 集成 |\n\n有关其他模式的详细信息，请参阅 [文本输出模式](#4.1) 和 [TLS 密钥日志](#4.3)。\n\n---\n\n## 相关组件\n\n此 PCAP 集成依赖于几个其他 eCapture 子系统：\n\n- **TC 程序**：有关 TC eBPF 分类器的详细信息，请参阅 [网络连接跟踪](#2.6)\n- **主密钥提取**：有关 TLS 密钥捕获的详细信息，请参阅 [主密钥提取](#3.1.4)\n- **事件处理**：有关事件路由的详细信息，请参阅 [事件处理流程](#2.2)\n- **模块系统**：有关 `IModule` 接口的详细信息，请参阅 [模块系统与生命周期](#2.4)\n\nPCAP 模式是 TLS 模块支持的三种输出格式之一，每种格式针对不同的使用场景和工作流程进行了优化。"
          },
          {
            "page_plan": {
              "id": "4.3",
              "title": "TLS 密钥日志"
            },
            "content": "# TLS 密钥日志\n\n## 目的与范围\n\n本文档描述 eCapture 的 TLS 密钥日志功能，该功能从 OpenSSL 和 BoringSSL 应用程序中提取 TLS/SSL 主密钥，并将其写入 SSLKEYLOGFILE 格式的文件。此格式与 Wireshark 等网络协议分析器兼容，使得无需服务器私钥即可解密捕获的 TLS 流量。\n\n有关捕获实际网络数据包以进行解密的信息，请参阅 [PCAP 集成](#4.2)。有关基于文本的明文捕获而无需网络数据包关联的信息，请参阅 [文本输出模式](#4.1)。\n\n## 概述\n\nTLS 密钥日志通过以下方式运行：\n1. **提取主密钥**：使用 eBPF uprobe 从 SSL/TLS 库结构中提取\n2. **格式化密钥**：根据 SSLKEYLOGFILE 规范格式化\n3. **写入文件**：写入可被 Wireshark 或其他解密工具加载的文件\n4. **去重条目**：避免多次写入相同的 client_random\n\n输出文件遵循 NSS 密钥日志格式，其中每一行包含一个标签、客户端随机数和对应的十六进制格式的密钥。\n\n来源：[user/module/probe_openssl.go:58-76](), [user/config/iconfig.go:72-79]()\n\n## 密钥日志架构\n\n```mermaid\ngraph TB\n    subgraph \"应用程序空间\"\n        APP[\"OpenSSL/BoringSSL<br/>应用程序\"]\n    end\n    \n    subgraph \"eBPF 钩子\"\n        UPROBE[\"uprobe/SSL_write_key<br/>probe_ssl_master_key\"]\n    end\n    \n    subgraph \"内核 eBPF 映射\"\n        MS_EVENTS[\"mastersecret_events<br/>PERF_EVENT_ARRAY\"]\n        BPF_CTX[\"bpf_context<br/>LRU_HASH\"]\n    end\n    \n    subgraph \"用户空间 - MOpenSSLProbe\"\n        DISPATCH[\"Dispatcher()<br/>事件路由\"]\n        SAVE_OSSL[\"saveMasterSecret()<br/>OpenSSL 处理器\"]\n        SAVE_BSSL[\"saveMasterSecretBSSL()<br/>BoringSSL 处理器\"]\n        DEDUP[\"masterKeys map<br/>去重\"]\n        FORMAT[\"SSLKEYLOGFILE<br/>格式化\"]\n    end\n    \n    subgraph \"输出\"\n        KEYLOG_FILE[\"keylog.log<br/>SSLKEYLOGFILE 格式\"]\n    end\n    \n    APP -->|\"SSL_write()<br/>SSL_do_handshake()\"| UPROBE\n    UPROBE -->|\"提取 ssl_st<br/>ssl_session_st<br/>ssl3_state_st\"| BPF_CTX\n    UPROBE -->|\"发送事件\"| MS_EVENTS\n    MS_EVENTS -->|\"MasterSecretEvent<br/>MasterSecretBSSLEvent\"| DISPATCH\n    DISPATCH -->|\"OpenSSL\"| SAVE_OSSL\n    DISPATCH -->|\"BoringSSL\"| SAVE_BSSL\n    SAVE_OSSL --> DEDUP\n    SAVE_BSSL --> DEDUP\n    DEDUP -->|\"新的 client_random\"| FORMAT\n    FORMAT --> KEYLOG_FILE\n    \n    style UPROBE fill:#e3f2fd\n    style DEDUP fill:#fff3e0\n    style FORMAT fill:#e8f5e9\n    style KEYLOG_FILE fill:#f3e5f5\n```\n\n**图示：TLS 密钥日志数据流**\n\n系统在主密钥在内存中可用的时刻，钩住 SSL/TLS 握手函数以提取主密钥。eBPF 程序从 SSL 库结构中读取密钥材料并将事件发送到用户空间，在用户空间中对其进行格式化并写入密钥日志文件。\n\n来源：[user/module/probe_openssl.go:482-575](), [kern/openssl_masterkey.h:80-257](), [kern/boringssl_masterkey.h:169-403]()\n\n## 配置\n\n密钥日志模式通过 `OpensslConfig.Model` 字段配置：\n\n| 配置值 | 常量 | 描述 |\n|--------|------|------|\n| `\"keylog\"` | `TlsCaptureModelKeylog` | 仅写入主密钥 |\n| `\"key\"` | `TlsCaptureModelKey` | keylog 模式的别名 |\n\n密钥日志文件路径通过 `OpensslConfig.KeylogFile` 指定（默认值：`./ecapture.keylog`）。\n\n```go\n// probe_openssl.go:128-136 的初始化示例\nswitch model {\ncase config.TlsCaptureModelKeylog, config.TlsCaptureModelKey:\n    m.keyloggerFilename = m.conf.(*config.OpensslConfig).KeylogFile\n    m.keylogger, err = os.OpenFile(m.keyloggerFilename, \n        os.O_APPEND|os.O_WRONLY|os.O_CREATE, 0o600)\n    m.eBPFProgramType = TlsCaptureModelTypeKeylog\n}\n```\n\n来源：[user/module/probe_openssl.go:128-136](), [user/config/iconfig.go:72-79]()\n\n## SSLKEYLOGFILE 格式\n\nSSLKEYLOGFILE 格式由空格分隔的记录组成，每行一个：\n\n```\n<Label> <ClientRandom> <Secret>\n```\n\n其中：\n- **Label**：标识密钥类型（例如，`CLIENT_RANDOM`、`CLIENT_HANDSHAKE_TRAFFIC_SECRET`）\n- **ClientRandom**：来自 TLS 握手的 32 字节随机值，十六进制编码\n- **Secret**：密钥材料，十六进制编码（TLS 1.2 为 48 字节，TLS 1.3 根据密码套件为 32 或 48 字节）\n\n### 支持的标签\n\n| 标签 | TLS 版本 | 描述 |\n|------|----------|------|\n| `CLIENT_RANDOM` | TLS 1.2 | TLS 1.2 及更早版本的主密钥 |\n| `CLIENT_EARLY_TRAFFIC_SECRET` | TLS 1.3 | 0-RTT 密钥（如果启用了早期数据） |\n| `CLIENT_HANDSHAKE_TRAFFIC_SECRET` | TLS 1.3 | 客户端握手流量密钥 |\n| `SERVER_HANDSHAKE_TRAFFIC_SECRET` | TLS 1.3 | 服务器握手流量密钥 |\n| `CLIENT_TRAFFIC_SECRET_0` | TLS 1.3 | 客户端应用流量密钥 |\n| `SERVER_TRAFFIC_SECRET_0` | TLS 1.3 | 服务器应用流量密钥 |\n| `EXPORTER_SECRET` | TLS 1.3 | 导出器主密钥 |\n\n来源：[user/module/probe_openssl.go:499-553](), [pkg/util/hkdf/hkdf.go]()\n\n## TLS 1.2 主密钥提取\n\n### OpenSSL TLS 1.2\n\n```mermaid\ngraph LR\n    SSL_ST[\"ssl_st\"] -->|\"+SSL_ST_VERSION\"| VERSION[\"version<br/>int\"]\n    SSL_ST -->|\"+SSL_ST_SESSION\"| SESSION_PTR[\"*ssl_session_st\"]\n    SESSION_PTR -->|\"+SSL_SESSION_ST_MASTER_KEY\"| MASTER_KEY[\"master_key[48]<br/>字节数组\"]\n    SSL_ST -->|\"+SSL_ST_S3\"| S3_PTR[\"*ssl3_state_st\"]\n    S3_PTR -->|\"+SSL3_STATE_ST_CLIENT_RANDOM\"| CLIENT_RANDOM[\"client_random[32]<br/>字节数组\"]\n    \n    VERSION --> OUTPUT[\"MasterSecretEvent\"]\n    CLIENT_RANDOM --> OUTPUT\n    MASTER_KEY --> OUTPUT\n    \n    style OUTPUT fill:#e8f5e9\n```\n\n**图示：OpenSSL TLS 1.2 结构导航**\n\n对于 TLS 1.2，eBPF 程序提取：\n1. **Client Random**：从 `ssl_st->s3->client_random` \n2. **Master Key**：从 `ssl_st->session->master_key`（48 字节）\n3. **Version**：从 `ssl_st->version`\n\n用户空间处理器将其格式化为：\n```\nCLIENT_RANDOM <32字节十六进制> <48字节十六进制>\n```\n\n来源：[kern/openssl_masterkey.h:82-168](), [user/module/probe_openssl.go:493-500]()\n\n### BoringSSL TLS 1.2\n\nBoringSSL 使用不同的结构布局：\n\n```mermaid\ngraph LR\n    SSL_ST[\"ssl_st\"] -->|\"+SSL_ST_S3\"| S3_PTR[\"*ssl3_state_st\"]\n    S3_PTR -->|\"+BSSL__SSL3_STATE_HS\"| HS_PTR[\"*SSL_HANDSHAKE\"]\n    HS_PTR -->|\"+BSSL__SSL_HANDSHAKE_NEW_SESSION<br/>或回退到 ssl_st->session\"| SESSION_PTR[\"*ssl_session_st\"]\n    SESSION_PTR -->|\"+SSL_SESSION_ST_SECRET\"| SECRET[\"secret_[48]<br/>字节数组\"]\n    SESSION_PTR -->|\"+SSL_SESSION_ST_SECRET_LENGTH\"| SECRET_LEN[\"secret_length\"]\n    S3_PTR -->|\"偏移量 16\"| CLIENT_RANDOM[\"client_random[32]\"]\n    HS_PTR -->|\"+SSL_HANDSHAKE_HASH_LEN_\"| HASH_LEN[\"hash_len\"]\n    \n    SECRET --> OUTPUT[\"MasterSecretBSSLEvent\"]\n    SECRET_LEN --> OUTPUT\n    CLIENT_RANDOM --> OUTPUT\n    HASH_LEN --> OUTPUT\n    \n    style OUTPUT fill:#e8f5e9\n```\n\n**图示：BoringSSL TLS 1.2 结构导航**\n\nBoringSSL 在 `ssl_session_st->secret_` 中存储密钥，变长存储在 `secret_length` 中。eBPF 程序检查多个位置以找到会话：\n1. 首先：`ssl_st->s3->hs->new_session`\n2. 回退：`ssl_st->session`\n\n来源：[kern/boringssl_masterkey.h:139-342](), [user/module/probe_openssl.go:577-642]()\n\n## TLS 1.3 主密钥提取\n\nTLS 1.3 使用通过 HKDF（基于 HMAC 的密钥派生函数）派生的多个密钥。eCapture 提取基础密钥并在用户空间执行 HKDF 扩展。\n\n### OpenSSL TLS 1.3 结构布局\n\n```mermaid\ngraph TB\n    SSL_ST[\"ssl_st<br/>指针\"] -->|\"+SSL_ST_VERSION\"| VERSION[\"version<br/>TLS1_3_VERSION\"]\n    SSL_ST -->|\"+SSL_ST_SESSION\"| SESSION[\"*ssl_session_st\"]\n    SESSION -->|\"+SSL_SESSION_ST_CIPHER\"| CIPHER[\"*ssl_cipher_st\"]\n    CIPHER -->|\"+SSL_CIPHER_ST_ID\"| CIPHER_ID[\"cipher_id<br/>uint32\"]\n    \n    SSL_ST -->|\"+SSL_ST_S3\"| S3[\"*ssl3_state_st\"]\n    S3 -->|\"+SSL3_STATE_ST_CLIENT_RANDOM\"| CLIENT_RANDOM[\"client_random[32]\"]\n    \n    SSL_ST -->|\"+SSL_ST_EARLY_SECRET\"| EARLY[\"early_secret[64]\"]\n    SSL_ST -->|\"+SSL_ST_HANDSHAKE_SECRET\"| HS[\"handshake_secret[64]\"]\n    SSL_ST -->|\"+SSL_ST_HANDSHAKE_TRAFFIC_HASH\"| HTH[\"handshake_traffic_hash[64]\"]\n    SSL_ST -->|\"+SSL_ST_CLIENT_APP_TRAFFIC_SECRET\"| CATS[\"client_app_traffic_secret[64]\"]\n    SSL_ST -->|\"+SSL_ST_SERVER_APP_TRAFFIC_SECRET\"| SATS[\"server_app_traffic_secret[64]\"]\n    SSL_ST -->|\"+SSL_ST_EXPORTER_MASTER_SECRET\"| EMS[\"exporter_master_secret[64]\"]\n    \n    style VERSION fill:#fff3e0\n    style CLIENT_RANDOM fill:#e8f5e9\n    style HS fill:#e3f2fd\n```\n\n**图示：OpenSSL TLS 1.3 密钥在 ssl_st 中的位置**\n\n对于 OpenSSL 1.1.1+，密钥直接存储在 `ssl_st` 结构中。密码 ID 决定哈希函数（SHA-256 用于 32 字节密钥，SHA-384 用于 48 字节密钥）。\n\n来源：[kern/openssl_masterkey.h:171-256](), [user/module/probe_openssl.go:501-551]()\n\n### BoringSSL TLS 1.3 结构布局\n\n```mermaid\ngraph TB\n    SSL_ST[\"ssl_st\"] -->|\"+SSL_ST_S3\"| S3[\"*ssl3_state_st\"]\n    S3 -->|\"偏移量 16\"| CLIENT_RANDOM[\"client_random[32]\"]\n    S3 -->|\"+BSSL__SSL3_STATE_HS\"| HS_PTR[\"*SSL_HANDSHAKE\"]\n    S3 -->|\"+BSSL__SSL3_STATE_EXPORTER_SECRET\"| EXPORTER[\"exporter_secret[64]\"]\n    \n    HS_PTR -->|\"+SSL_HANDSHAKE_HASH_LEN_\"| HASH_LEN[\"hash_len<br/>uint8\"]\n    HS_PTR -->|\"+SSL_HANDSHAKE_EARLY_TRAFFIC_SECRET_\"| EARLY[\"early_traffic_secret_[48]\"]\n    HS_PTR -->|\"+SSL_HANDSHAKE_CLIENT_HANDSHAKE_SECRET_\"| CHS[\"client_handshake_secret_[48]\"]\n    HS_PTR -->|\"+SSL_HANDSHAKE_SERVER_HANDSHAKE_SECRET_\"| SHS[\"server_handshake_secret_[48]\"]\n    HS_PTR -->|\"+SSL_HANDSHAKE_CLIENT_TRAFFIC_SECRET_0_\"| CTS[\"client_traffic_secret_0_[48]\"]\n    HS_PTR -->|\"+SSL_HANDSHAKE_SERVER_TRAFFIC_SECRET_0_\"| STS[\"server_traffic_secret_0_[48]\"]\n    \n    HS_PTR -->|\"+BSSL__SSL_HANDSHAKE_STATE\"| STATE[\"state<br/>int32\"]\n    HS_PTR -->|\"+BSSL__SSL_HANDSHAKE_STATE+4\"| TLS13_STATE[\"tls13_state<br/>int32\"]\n    \n    style HASH_LEN fill:#fff3e0\n    style STATE fill:#e8f5e9\n    style TLS13_STATE fill:#e8f5e9\n```\n\n**图示：BoringSSL TLS 1.3 密钥在 SSL_HANDSHAKE 中的位置**\n\nBoringSSL 将 TLS 1.3 密钥存储在 `SSL_HANDSHAKE` 结构的私有字段中。偏移量基于结构的已知布局计算，考虑了内存对齐。密钥最大为 48 字节（SSL_MAX_MD_SIZE）。\n\n来源：[kern/boringssl_masterkey.h:343-402](), [kern/boringssl_const.h:1-63]()\n\n### TLS 1.3 的 HKDF 扩展\n\n对于 TLS 1.3，eCapture 从 SSL 结构中提取 `handshake_secret` 和 `handshake_traffic_hash`，然后使用 HKDF-Expand-Label 计算客户端和服务器握手流量密钥：\n\n```\nCLIENT_HANDSHAKE_TRAFFIC_SECRET = HKDF-Expand-Label(\n    handshake_secret,\n    \"c hs traffic\",\n    handshake_traffic_hash,\n    hash_length\n)\n\nSERVER_HANDSHAKE_TRAFFIC_SECRET = HKDF-Expand-Label(\n    handshake_secret,\n    \"s hs traffic\",\n    handshake_traffic_hash,\n    hash_length\n)\n```\n\n哈希函数（SHA-256 或 SHA-384）由密码套件决定：\n- **TLS_AES_128_GCM_SHA256** (0x1301)：32 字节，SHA-256\n- **TLS_CHACHA20_POLY1305_SHA256** (0x1303)：32 字节，SHA-256\n- **TLS_AES_256_GCM_SHA384** (0x1302)：48 字节，SHA-384\n\n来源：[user/module/probe_openssl.go:502-551](), [pkg/util/hkdf/hkdf.go]()\n\n## 密钥去重\n\neCapture 维护一个以 client_random（十六进制编码）为键的 `masterKeys` 映射以防止重复条目：\n\n```go\ntype MOpenSSLProbe struct {\n    masterKeys map[string]bool  // map[client_random_hex]bool\n    // ...\n}\n\nfunc (m *MOpenSSLProbe) saveMasterSecret(secretEvent *event.MasterSecretEvent) {\n    k := fmt.Sprintf(\"%02x\", secretEvent.ClientRandom)\n    \n    _, f := m.masterKeys[k]\n    if f {\n        // 已存在，跳过\n        return\n    }\n    \n    // ... 格式化并写入 ...\n    m.masterKeys[k] = true\n}\n```\n\n这是必要的，因为：\n1. 在一个连接期间 SSL/TLS 函数可能被多次调用\n2. 会话恢复可以重用相同的 client_random\n3. 多个捕获点（SSL_write、SSL_read、SSL_do_handshake）可能观察到相同的密钥\n\n来源：[user/module/probe_openssl.go:96-99](), [user/module/probe_openssl.go:482-575]()\n\n## 空密钥检测\n\neCapture 在写入密钥日志文件之前验证密钥不是全零。这可以防止写入无效或未初始化的密钥：\n\n```mermaid\ngraph TB\n    EVENT[\"主密钥事件\"] --> CHECK_VERSION{\"TLS 版本？\"}\n    CHECK_VERSION -->|\"TLS 1.2\"| CHECK_12[\"检查 master_key<br/>是否全零\"]\n    CHECK_VERSION -->|\"TLS 1.3\"| CHECK_13[\"检查所有 5 个密钥：<br/>- client_handshake<br/>- server_handshake<br/>- client_traffic_0<br/>- server_traffic_0<br/>- exporter\"]\n    \n    CHECK_12 -->|\"全零\"| DISCARD[\"丢弃事件\"]\n    CHECK_12 -->|\"有效\"| WRITE[\"写入 keylog\"]\n    \n    CHECK_13 -->|\"全零\"| DISCARD\n    CHECK_13 -->|\"至少一个<br/>非零\"| WRITE\n    \n    style CHECK_12 fill:#fff3e0\n    style CHECK_13 fill:#fff3e0\n    style DISCARD fill:#ffebee\n    style WRITE fill:#e8f5e9\n```\n\n**图示：空密钥检测逻辑**\n\n验证发生在函数 `mk12NullSecrets()` 和 `mk13NullSecrets()` 中：\n\n```go\n// TLS 1.2：检查范围 [0:hashLen] 中的所有字节是否为零\nfunc (m *MOpenSSLProbe) mk12NullSecrets(hashLen int, secret []byte) bool {\n    isNull := true\n    for i := 0; i < hashLen; i++ {\n        if secret[i] != 0 {\n            isNull = false\n            break\n        }\n    }\n    return isNull\n}\n\n// TLS 1.3：检查所有 5 个密钥是否为零\nfunc (m *MOpenSSLProbe) mk13NullSecrets(hashLen int,\n    ClientHandshakeSecret [64]byte,\n    ClientTrafficSecret0 [64]byte,\n    ServerHandshakeSecret [64]byte,\n    ServerTrafficSecret0 [64]byte,\n    ExporterSecret [64]byte) bool {\n    // 如果所有 5 个密钥都为空（isNullCount == 5），返回 true\n    // 如果至少有一个密钥有非零字节，返回 false\n}\n```\n\n来源：[user/module/probe_openssl.go:652-731]()\n\n## 输出文件格式示例\n\n典型的密钥日志文件包含如下条目：\n\n```\nCLIENT_RANDOM 0123456789abcdef... 0a1b2c3d4e5f6789...\nCLIENT_HANDSHAKE_TRAFFIC_SECRET 0123456789abcdef... 1a2b3c4d5e6f7890...\nSERVER_HANDSHAKE_TRAFFIC_SECRET 0123456789abcdef... 2b3c4d5e6f789012...\nCLIENT_TRAFFIC_SECRET_0 0123456789abcdef... 3c4d5e6f78901234...\nSERVER_TRAFFIC_SECRET_0 0123456789abcdef... 4d5e6f7890123456...\nEXPORTER_SECRET 0123456789abcdef... 5e6f789012345678...\n```\n\n文件以 `O_APPEND` 模式打开，允许多次 eCapture 运行在同一文件中累积密钥。文件权限设置为 `0o600`（仅所有者可读/写）以保证安全。\n\n来源：[user/module/probe_openssl.go:131-136](), [user/module/probe_openssl.go:567-572]()\n\n## 与 Wireshark 集成\n\n要在 Wireshark 中使用密钥日志文件解密 TLS 流量：\n\n1. **捕获数据包**：使用 eCapture 的 PCAP 模式或 tcpdump\n2. **生成密钥日志文件**：使用 eCapture 的密钥日志模式：\n   ```bash\n   ecapture tls --keylogfile=/tmp/keys.log\n   ```\n3. **配置 Wireshark**：\n   - 编辑 → 首选项 → 协议 → TLS\n   - 将\"(Pre)-Master-Secret log filename\"设置为 `/tmp/keys.log`\n4. **重新加载捕获**或重启 Wireshark\n\nWireshark 将自动解密与密钥日志文件中 client_random 值匹配的 TLS 流量。\n\n### 组合 PCAP + Keylog 模式\n\n当使用 PCAP 模式时，eCapture 可以将密钥日志数据直接嵌入 PCAPNG 文件作为解密密钥块（DSB），无需单独的密钥日志文件。详情请参阅 [PCAP 集成](#4.2)。\n\n来源：[user/module/probe_openssl.go:560-564]()\n\n## 密钥提取的状态验证\n\neBPF 程序在提取密钥之前验证 TLS 握手已达到适当的状态：\n\n### OpenSSL 状态要求\n\n对于 OpenSSL，密钥提取发生在握手完成后的任何 SSL_write 或 SSL_read 调用期间。检查版本字段，但不执行明确的状态验证，因为密钥存储在持久结构中。\n\n### BoringSSL 状态要求\n\nBoringSSL 维护明确的握手状态机。eBPF 程序验证：\n\n**TLS 1.2 状态：**\n- 客户端：`state >= CLIENT_STATE12_SEND_CLIENT_FINISHED` (16)\n- 服务器：`state >= SERVER_STATE12_READ_CLIENT_FINISHED` (18)\n\n**TLS 1.3 状态：**\n- 客户端：`tls13_state >= CLIENT_STATE13_READ_SERVER_FINISHED` (8)\n- 服务器：`tls13_state >= SERVER_STATE13_READ_CLIENT_FINISHED` (14)\n\n```c\n// 来自 boringssl_masterkey.h:289-293\nif (ssl3_hs_state.state < CLIENT_STATE12_SEND_CLIENT_FINISHED) {\n    // 尚未完成。\n    return 0;\n}\n\n// 来自 boringssl_masterkey.h:345-348\nif (ssl3_hs_state.tls13_state < CLIENT_STATE13_READ_SERVER_FINISHED) {\n    // 尚未完成。\n    return 0;\n}\n```\n\n这确保仅在握手完成且所有密钥材料可用后才提取密钥。\n\n来源：[kern/boringssl_masterkey.h:263-348](), [kern/boringssl_masterkey.h:77-86]()\n\n## 错误处理\n\n密钥日志系统处理几种错误情况：\n\n| 条件 | 行为 |\n|------|------|\n| 文件打开失败 | 初始化失败，向用户返回错误 |\n| 写入失败 | 记录警告，丢弃事件 |\n| 检测到空密钥 | 静默丢弃事件 |\n| 重复的 client_random | 跳过事件，不写入 |\n| 哈希长度超过缓冲区 | 截断到最大大小并发出警告 |\n| eBPF 探针读取失败 | 不向用户空间发送事件 |\n\n日志记录器提供有关每个成功写入密钥的详细信息：\n\n```go\nm.logger.Info().\n    Str(\"TlsVersion\", v.String()).\n    Str(\"CLientRandom\", k).\n    Int(\"bytes\", l).\n    Msg(\"CLIENT_RANDOM save success\")\n```\n\n来源：[user/module/probe_openssl.go:567-572](), [user/module/probe_openssl.go:594-607]()\n\n## 实现总结\n\n密钥日志实现跨越三个层次：\n\n```mermaid\ngraph TB\n    subgraph \"1. eBPF 层（内核空间）\"\n        PROBE[\"probe_ssl_master_key()<br/>SSL 函数上的 uprobe\"]\n        EXTRACT[\"结构导航<br/>内存读取\"]\n        EVENT[\"mastersecret_events<br/>Perf 事件数组\"]\n    end\n    \n    subgraph \"2. 事件处理（用户空间）\"\n        DECODE[\"Decode()<br/>event.MasterSecretEvent\"]\n        DISPATCH[\"Dispatcher()<br/>按事件类型路由\"]\n        VALIDATE[\"空密钥检查<br/>状态验证\"]\n    end\n    \n    subgraph \"3. 格式化与写入\"\n        HKDF[\"HKDF 扩展<br/>（仅 TLS 1.3）\"]\n        FORMAT_FUNC[\"格式化 SSLKEYLOGFILE<br/>标签 + ClientRandom + 密钥\"]\n        DEDUP_CHECK[\"去重<br/>masterKeys map\"]\n        WRITE_FILE[\"写入文件<br/>O_APPEND 模式\"]\n    end\n    \n    PROBE --> EXTRACT\n    EXTRACT --> EVENT\n    EVENT --> DECODE\n    DECODE --> DISPATCH\n    DISPATCH --> VALIDATE\n    VALIDATE -->|\"有效\"| HKDF\n    HKDF --> FORMAT_FUNC\n    FORMAT_FUNC --> DEDUP_CHECK\n    DEDUP_CHECK -->|\"新的\"| WRITE_FILE\n    \n    style PROBE fill:#e3f2fd\n    style VALIDATE fill:#fff3e0\n    style DEDUP_CHECK fill:#fff3e0\n    style WRITE_FILE fill:#e8f5e9\n```\n\n**图示：密钥日志实现层次**\n\n系统通过以下方式实现高可靠性：\n- **原子写入**：每一行原子写入文件\n- **去重**：防止冗余条目\n- **验证**：在写入前确保密钥非空\n- **状态检查**：仅在握手完成后提取密钥\n- **错误处理**：失败时优雅降级\n\n来源：[user/module/probe_openssl.go:733-754](), [kern/openssl_masterkey.h:80-257](), [kern/boringssl_masterkey.h:169-403]()"
          },
          {
            "page_plan": {
              "id": "4.4",
              "title": "Protobuf 与外部集成"
            },
            "content": "# Protobuf 与外部集成\n\n## 目的与范围\n\n本文档描述 eCapture 基于 protobuf 的事件序列化和外部集成能力。它涵盖了如何将捕获的事件转换为 Protocol Buffer 格式以传输到外部系统、用于实时事件转发的 WebSocket 流协议，以及与 eCaptureQ 图形用户界面的集成。\n\n有关基于文本的输出格式的信息，请参阅[文本输出模式](#4.1)。有关 PCAP 文件生成，请参阅[PCAP 集成](#4.2)。有关通过 HTTP API 进行配置管理，请参阅[配置系统](#2.3)。\n\n---\n\n## Protobuf 事件模式\n\n### 事件接口与序列化\n\neCapture 中的所有事件类型都实现了 `IEventStruct` 接口，该接口包含用于序列化的 `ToProtobufEvent()` 方法。这种标准化方法使得无论来自哪个模块，都能以统一的方式将事件传输到外部系统。\n\n**图示：事件序列化接口**\n\n```mermaid\ngraph TB\n    IEventStruct[\"IEventStruct 接口\"]\n    ToProtobuf[\"ToProtobufEvent() *pb.Event\"]\n    \n    SSLDataEvent[\"SSLDataEvent\"]\n    MasterSecretEvent[\"MasterSecretEvent\"]\n    GnutlsDataEvent[\"GnutlsDataEvent\"]\n    NsprDataEvent[\"NsprDataEvent\"]\n    BashEvent[\"BashEvent\"]\n    MysqldEvent[\"MysqldEvent\"]\n    PostgresEvent[\"PostgresEvent\"]\n    ConnDataEvent[\"ConnDataEvent\"]\n    TcSkbEvent[\"TcSkbEvent\"]\n    \n    IEventStruct --> ToProtobuf\n    \n    SSLDataEvent -.实现.-> IEventStruct\n    MasterSecretEvent -.实现.-> IEventStruct\n    GnutlsDataEvent -.实现.-> IEventStruct\n    NsprDataEvent -.实现.-> IEventStruct\n    BashEvent -.实现.-> IEventStruct\n    MysqldEvent -.实现.-> IEventStruct\n    PostgresEvent -.实现.-> IEventStruct\n    ConnDataEvent -.实现.-> IEventStruct\n    TcSkbEvent -.实现.-> IEventStruct\n    \n    ProtoEvent[\"pb.Event 消息<br/>timestamp, uuid, src_ip, src_port<br/>dst_ip, dst_port, pid, pname<br/>type, length, payload\"]\n    \n    ToProtobuf --> ProtoEvent\n```\n\n来源：[user/event/event_openssl.go:237-266](), [user/event/event_masterkey.go:123-137](), [user/event/event_gnutls.go:125-138](), [user/event/event_nspr.go:143-157](), [user/event/event_bash.go:103-117](), [user/event/event_mysqld.go:138-152](), [user/event/event_postgres.go:87-102]()\n\n### Protobuf 事件结构\n\n统一的 `pb.Event` protobuf 消息包含以下字段：\n\n| 字段 | 类型 | 描述 |\n|-------|------|-------------|\n| `timestamp` | int64 | 事件时间戳，纳秒（Unix 纪元） |\n| `uuid` | string | 唯一事件标识符（因事件类型而异） |\n| `src_ip` | string | 源 IP 地址（如果可用） |\n| `src_port` | uint32 | 源端口号（如果可用） |\n| `dst_ip` | string | 目标 IP 地址（如果可用） |\n| `dst_port` | uint32 | 目标端口号（如果可用） |\n| `pid` | int64 | 生成事件的进程 ID |\n| `pname` | string | 进程名称（命令） |\n| `type` | uint32 | 事件特定类型字段（因模块而异） |\n| `length` | uint32 | 载荷长度（字节） |\n| `payload` | bytes | 原始事件数据（因事件类型而异） |\n\n来源：[user/event/event_openssl.go:237-266](), [protobuf/PROTOCOLS.md]()\n\n### 事件类型转换\n\n每种事件类型根据其数据结构以不同方式实现 `ToProtobufEvent()`：\n\n**表：事件类型 Protobuf 映射**\n\n| 事件类型 | UUID 格式 | Type 字段 | Payload 内容 | IP/端口可用 |\n|------------|-------------|------------|-----------------|-------------------|\n| `SSLDataEvent` | `sock:PID_TID_Comm_FD_DataType_Tuple_Sock` | 数据方向（0=接收, 1=发送） | SSL/TLS 明文 | 是（来自 tuple） |\n| `MasterSecretEvent` | `ClientRandom`（十六进制） | TLS 版本 | Keylog 格式字符串 | 否（127.0.0.1:0） |\n| `MasterSecretBSSLEvent` | `ClientRandom`（十六进制） | TLS 版本 | Keylog 格式字符串 | 否（127.0.0.1:0） |\n| `GnutlsDataEvent` | `PID_TID_Comm_DataType` | 数据方向 | GnuTLS 明文 | 否（127.0.0.1:0） |\n| `NsprDataEvent` | `PID_TID_Comm_DataType` | 数据方向 | NSS 明文 | 否（127.0.0.1:0） |\n| `BashEvent` | `PID_UID_Comm` | Bash 事件类型 | 命令行 | 否（127.0.0.1:0） |\n| `MysqldEvent` | `PID_Comm` | 返回值 | SQL 查询 | 否（127.0.0.1:0） |\n| `PostgresEvent` | `PID_Comm` | 0 | SQL 查询 | 否（127.0.0.1:0） |\n| `ConnDataEvent` | `PID_TID_Comm_FD` | 0 | 连接 tuple | 是（来自 tuple） |\n| `TcSkbEvent` | `PID_Ifindex_Comm` | 0 | 网络数据包 | 否（127.0.0.1:0） |\n\n来源：[user/event/event_openssl.go:237-266](), [user/event/event_masterkey.go:123-137,242-256](), [user/event/event_gnutls.go:125-138](), [user/event/event_nspr.go:143-157](), [user/event/event_bash.go:103-117](), [user/event/event_mysqld.go:138-152](), [user/event/event_postgres.go:87-102](), [user/event/event_openssl_tc.go:99-113]()\n\n---\n\n## 事件序列化架构\n\n### 序列化流程\n\n事件从 eBPF 程序流经事件处理流程，并可选择性地序列化为 protobuf 格式以进行外部传输。\n\n**图示：Protobuf 序列化流程**\n\n```mermaid\nflowchart LR\n    subgraph eBPF[\"eBPF 内核空间\"]\n        Maps[\"eBPF Maps<br/>perf_event_array<br/>ring_buffer\"]\n    end\n    \n    subgraph EventProcessing[\"事件处理层\"]\n        Reader[\"事件读取器<br/>perfEventReader<br/>ringbufEventReader\"]\n        Decoder[\"Decode()<br/>二进制反序列化\"]\n        EventStruct[\"IEventStruct<br/>具体事件类型\"]\n    end\n    \n    subgraph Serialization[\"序列化层\"]\n        ToProto[\"ToProtobufEvent()\"]\n        PbEvent[\"pb.Event\"]\n        Marshal[\"proto.Marshal()\"]\n        Binary[\"Protobuf 二进制\"]\n    end\n    \n    subgraph Output[\"输出目标\"]\n        WebSocket[\"WebSocket 流\"]\n        HTTP[\"HTTP POST\"]\n        File[\"文件/日志器\"]\n    end\n    \n    Maps --> Reader\n    Reader --> Decoder\n    Decoder --> EventStruct\n    \n    EventStruct --> ToProto\n    ToProto --> PbEvent\n    PbEvent --> Marshal\n    Marshal --> Binary\n    \n    Binary --> WebSocket\n    Binary --> HTTP\n    Binary --> File\n```\n\n来源：[user/event/event_openssl.go:237-266](), [pkg/event_processor/base_event.go:185-194]()\n\n### 实现细节\n\n`ToProtobufEvent()` 方法在所有事件类型中遵循一致的模式：\n\n1. **创建 protobuf 消息**：实例化 `pb.Event` 结构\n2. **填充公共字段**：设置时间戳、UUID、PID、进程名称\n3. **解析连接信息**：在可用时提取 IP 地址和端口（来自 tuple 字符串）\n4. **设置事件特定字段**：根据事件内容填充 `type`、`length` 和 `payload`\n5. **返回指针**：返回 `*pb.Event` 以进行编组\n\n**示例：SSLDataEvent Protobuf 转换**\n\n```\n// SSLDataEvent.ToProtobufEvent() 实现模式：\n1. 使用时间戳和 UUID 创建 pb.Event\n2. 解析 tuple 字符串格式 \"IP:Port-IP:Port\"\n3. 拆分为源和目标部分\n4. 提取 IP 地址和端口号\n5. 从 Data[:DataLen] 设置载荷\n6. 返回 protobuf 事件指针\n```\n\n来源：[user/event/event_openssl.go:237-266]()\n\n### IP 地址和端口提取\n\n具有网络连接信息的事件（主要来自 TLS/SSL 模块）从 tuple 字符串中提取 IP 地址和端口：\n\n**Tuple 格式解析逻辑**：\n- **IPv4 格式**：`192.168.1.1:443-10.0.0.1:54321`\n- **IPv6 格式**：`[2001:db8::1]:443-[fe80::1]:54321`\n- **解析步骤**：\n  1. 按 `-` 分隔符拆分以分离源和目标\n  2. 将每个部分按 `:` 拆分以分离 IP 和端口\n  3. 处理 IPv6 括号表示法\n  4. 将端口字符串转换为 uint32\n\n来源：[user/event/event_openssl.go:245-263](), [user/event/event_openssl.go:361-379]()\n\n---\n\n## WebSocket 流协议\n\n### 服务器架构\n\neCapture 提供 WebSocket 服务器用于实时事件流传输到外部客户端。该服务器默认在 `localhost:28256` 上运行，并实现用于事件传输和配置更新的双向协议。\n\n**图示：WebSocket 通信架构**\n\n```mermaid\nsequenceDiagram\n    participant Client as \"外部客户端<br/>(eCaptureQ/自定义)\"\n    participant WS as \"WebSocket 服务器<br/>localhost:28256\"\n    participant EventProc as \"事件处理器\"\n    participant Module as \"捕获模块\"\n    \n    Client->>WS: 连接\n    WS-->>Client: 连接已接受\n    \n    Client->>WS: 订阅请求\n    WS-->>Client: 订阅已确认\n    \n    loop 事件捕获\n        Module->>EventProc: 捕获的事件\n        EventProc->>EventProc: ToProtobufEvent()\n        EventProc->>EventProc: proto.Marshal()\n        EventProc->>WS: 二进制 protobuf 数据\n        WS->>Client: WebSocket 消息（二进制）\n    end\n    \n    Client->>WS: 配置更新\n    WS->>Module: 应用配置\n    WS-->>Client: 更新已确认\n    \n    Client->>WS: 断开连接\n```\n\n来源：[CHANGELOG.md:82-87](), [README.md:322-327]()\n\n### WebSocket 消息格式\n\nWebSocket 协议使用包含 protobuf 序列化事件的二进制帧：\n\n| 组件 | 描述 |\n|-----------|-------------|\n| **帧类型** | 二进制（0x02） |\n| **载荷** | Protobuf 编码的 `pb.Event` 消息 |\n| **编码** | Protocol Buffers 二进制格式 |\n| **压缩** | 可选（在握手期间协商） |\n\n**消息流模式**：\n1. **心跳**：定期 ping/pong 以维护连接\n2. **事件流**：protobuf 编码事件的连续流\n3. **控制消息**：配置更新和订阅管理\n\n来源：[CHANGELOG.md:82-87]()\n\n### 事件转发配置\n\n可以配置 WebSocket 服务器以选择性地转发事件：\n\n- **模块过滤**：仅从特定模块转发事件（tls、gotls 等）\n- **进程过滤**：按 PID 或 UID 过滤\n- **事件类型过滤**：选择特定事件类型（数据、主密钥、连接）\n- **速率限制**：控制事件传输速率以防止客户端过载\n\n来源：[README.md:322-327](), [docs/event-forward-api.md]()\n\n---\n\n## eCaptureQ 集成\n\n### 远程模式架构\n\neCaptureQ 是一个跨平台的 GUI 客户端，用于可视化 eCapture 事件。它以两种模式运行：\n\n**图示：eCaptureQ 集成模式**\n\n```mermaid\ngraph TB\n    subgraph Integrated[\"集成模式<br/>(Linux/Android)\"]\n        eCaptureQ_Int[\"eCaptureQ<br/>Rust+Tauri+React\"]\n        eCapture_Int[\"eCapture 二进制<br/>内嵌\"]\n        \n        eCaptureQ_Int -->|直接 API 调用| eCapture_Int\n        eCapture_Int -->|通过 IPC 发送事件| eCaptureQ_Int\n    end\n    \n    subgraph Remote[\"远程模式<br/>(Windows/macOS/Linux)\"]\n        eCaptureQ_Remote[\"eCaptureQ 客户端<br/>Rust+Tauri+React\"]\n        \n        subgraph RemoteServer[\"远程 Linux 服务器\"]\n            eCapture_Server[\"eCapture 服务<br/>localhost:28256\"]\n            eBPF[\"eBPF 程序\"]\n            \n            eCapture_Server --> eBPF\n        end\n        \n        eCaptureQ_Remote -->|WebSocket<br/>protobuf 事件| eCapture_Server\n        eCaptureQ_Remote -->|HTTP<br/>配置更新| eCapture_Server\n    end\n    \n    User[\"用户\"] --> eCaptureQ_Int\n    User --> eCaptureQ_Remote\n```\n\n来源：[README.md:267-281](), [README_CN.md:267-281]()\n\n### 远程模式通信协议\n\n在远程模式下，eCaptureQ 通过两个通道与 eCapture 通信：\n\n**1. WebSocket 事件流（二进制）**\n- **端点**：`ws://host:28256/ws`\n- **协议**：带 protobuf 二进制帧的 WebSocket\n- **目的**：从 eCapture 到 GUI 的实时事件流\n- **流向**：服务器 → 客户端（事件单向）\n\n**2. HTTP 配置 API（JSON）**\n- **端点**：`http://host:28256/config`\n- **协议**：带 JSON 载荷的 RESTful HTTP\n- **目的**：运行时配置更新\n- **流向**：客户端 → 服务器（请求/响应）\n\n来源：[README.md:322-327](), [docs/remote-config-update-api.md]()\n\n### 事件可视化流程\n\neCaptureQ 处理 protobuf 事件以进行可视化：\n\n**图示：eCaptureQ 事件处理**\n\n```mermaid\nflowchart LR\n    subgraph eCapture[\"eCapture 服务器\"]\n        Capture[\"事件捕获\"]\n        ToProto[\"ToProtobufEvent()\"]\n        WS_Send[\"WebSocket 发送\"]\n        \n        Capture --> ToProto\n        ToProto --> WS_Send\n    end\n    \n    subgraph eCaptureQ[\"eCaptureQ 客户端\"]\n        WS_Recv[\"WebSocket 接收\"]\n        Unmarshal[\"proto.Unmarshal()\"]\n        Decode[\"事件解码器\"]\n        \n        subgraph UI[\"用户界面\"]\n            List[\"事件列表视图\"]\n            Detail[\"详情面板\"]\n            Filter[\"过滤器控件\"]\n            Export[\"导出操作\"]\n        end\n        \n        WS_Recv --> Unmarshal\n        Unmarshal --> Decode\n        Decode --> List\n        List --> Detail\n        Filter -.过滤.-> List\n        List --> Export\n    end\n    \n    WS_Send -->|二进制 protobuf| WS_Recv\n```\n\n来源：[README.md:287-302]()\n\n### 协议文档\n\n完整的 protobuf 模式定义和协议规范记录在：\n\n- **英文**：[protobuf/PROTOCOLS.md]()\n- **中文**：[protobuf/PROTOCOLS_CN.md]()\n\n这些文档详细说明了：\n- 消息字段定义\n- 事件类型枚举\n- 序列化示例\n- 版本兼容性指南\n\n来源：[README.md:304-308](), [README_CN.md:283-287]()\n\n---\n\n## 外部系统的 HTTP API\n\n### 配置更新 API\n\neCapture 在 `localhost:28256` 上公开 HTTP API 用于运行时配置管理。这使得外部系统能够动态控制捕获行为，而无需重启进程。\n\n**API 端点**：\n\n| 方法 | 端点 | 目的 | 请求格式 |\n|--------|----------|---------|----------------|\n| GET | `/config` | 检索当前配置 | N/A |\n| POST | `/config` | 更新配置参数 | JSON |\n| GET | `/status` | 查询模块状态 | N/A |\n\n**配置更新示例**：\n```json\nPOST /config\n{\n  \"pid\": 1234,\n  \"uid\": 1000,\n  \"btf_mode\": 0,\n  \"log_level\": \"info\"\n}\n```\n\n来源：[README.md:322-324](), [docs/remote-config-update-api.md]()\n\n### 事件转发 API\n\n外部系统可以通过 HTTP POST 回调接收事件：\n\n**转发配置**：\n```json\nPOST /config\n{\n  \"event_forward\": {\n    \"enabled\": true,\n    \"url\": \"http://external-system:8080/events\",\n    \"format\": \"protobuf\",\n    \"modules\": [\"tls\", \"gotls\"],\n    \"batch_size\": 100,\n    \"batch_timeout_ms\": 1000\n  }\n}\n```\n\n**事件 POST 格式**：\n- **Content-Type**：`application/x-protobuf` 或 `application/json`\n- **Body**：Protobuf 二进制或 JSON 序列化事件\n- **Headers**：用于认证/路由的自定义标头\n\n来源：[README.md:325-327](), [docs/event-forward-api.md]()\n\n### 安全考虑\n\n默认情况下，HTTP API 绑定到 `localhost:28256` 以确保安全：\n\n1. **仅本地访问**：默认仅接受 localhost 连接\n2. **无认证**：依赖于 OS 级别的进程隔离\n3. **远程访问**：需要 SSH 隧道或反向代理配置\n4. **速率限制**：可配置请求速率限制以防止滥用\n\n对于远程访问，使用 SSH 端口转发：\n```bash\nssh -L 28256:localhost:28256 user@remote-host\n```\n\n来源：[README.md:82-85](), [README_CN.md:83-88]()\n\n---\n\n## 集成示例\n\n### 自定义客户端实现\n\n实现自定义 protobuf 客户端需要：\n\n1. **Protobuf 定义**：导入或编译 `protobuf/gen/v1/event.proto`\n2. **WebSocket 连接**：建立到 `ws://host:28256/ws` 的连接\n3. **二进制反序列化**：使用特定语言的 protobuf 库进行反编组\n4. **事件处理**：根据 `type` 和 `uuid` 字段处理事件\n\n**Python 示例模式**：\n```python\n# 1. 导入生成的 protobuf 类\nfrom ecapture.protobuf.gen.v1 import event_pb2\n\n# 2. 连接到 WebSocket\nws = websocket.WebSocketApp(\"ws://localhost:28256/ws\")\n\n# 3. 处理二进制消息\ndef on_message(ws, message):\n    event = event_pb2.Event()\n    event.ParseFromString(message)\n    # 处理事件字段\n    print(f\"PID: {event.pid}, Payload: {event.payload}\")\n```\n\n来源：[CHANGELOG.md:16]()\n\n### Burp Suite 集成\n\neCapture 可以将 HTTP/HTTPS 事件转发到 Burp Suite 进行安全分析：\n\n**配置**：\n```json\nPOST /config\n{\n  \"event_forward\": {\n    \"enabled\": true,\n    \"url\": \"http://localhost:8080\",\n    \"format\": \"http_proxy\",\n    \"modules\": [\"tls\", \"gotls\"],\n    \"filter\": {\n      \"protocols\": [\"http\", \"https\"]\n    }\n  }\n}\n```\n\n事件载荷被重构为 HTTP 请求/响应并转发到 Burp 的代理端口。\n\n来源：[README.md:325-327](), [docs/event-forward-api.md]()\n\n### 监控系统集成\n\n将 eCapture 与监控平台（Prometheus、Grafana、ELK）集成：\n\n**指标导出模式**：\n1. **WebSocket 订阅者**：消费 protobuf 事件\n2. **指标聚合**：按类型、PID、协议统计事件\n3. **时序导出**：将指标推送到 Prometheus/InfluxDB\n4. **告警**：在异常模式上触发告警（例如，不寻常的 SQL 查询）\n\n**示例指标**：\n- `ecapture_events_total{module=\"tls\", pid=\"1234\"}` - 事件计数器\n- `ecapture_payload_bytes{module=\"tls\"}` - 捕获的总字节数\n- `ecapture_connections_active` - 活动连接数\n\n来源：[README.md:325-327]()\n\n---\n\n## 实现说明\n\n### 事件批处理\n\n对于高吞吐量场景，可以在 protobuf 序列化之前批处理事件：\n\n- **批大小**：可配置（默认：100 个事件）\n- **超时**：刷新部分批次前的最大等待时间（默认：1 秒）\n- **压缩**：批处理消息的可选 gzip 压缩\n- **排序**：批次内的事件保持基于时间戳的排序\n\n来源：[docs/event-forward-api.md]()\n\n### 版本兼容性\n\nprotobuf 模式使用字段编号来确保向后/向前兼容性：\n\n- **新字段**：可以添加而不会破坏现有客户端\n- **弃用字段**：标记但不删除以保持兼容性\n- **版本头**：WebSocket 握手包含协议版本\n- **优雅降级**：较旧的客户端忽略未知字段\n\n来源：[protobuf/PROTOCOLS.md]()\n\n### 性能优化\n\nProtobuf 序列化针对性能进行了优化：\n\n- **零拷贝**：在可能的情况下，载荷字节被引用而不是复制\n- **池分配**：事件对象被池化以减少 GC 压力\n- **异步编组**：序列化在后台 goroutine 中进行\n- **缓冲区大小**：基于典型事件大小预分配缓冲区\n\n来源：[user/event/event_openssl.go:237-266]()"
          },
          {
            "page_plan": {
              "id": "5",
              "title": "开发指南"
            },
            "content": "# 开发指南\n\n本指南面向希望为 eCapture 做出贡献、添加新捕获模块、修改现有功能或理解代码库架构的开发人员。它涵盖了开发环境设置、关键接口、构建系统和扩展点。\n\n有关特定开发任务的详细信息，请参阅：\n- [构建系统](#5.1) - 全面的构建系统文档\n- [eBPF 程序开发](#5.2) - 编写 eBPF 程序\n- [添加新模块](#5.3) - 创建新捕获模块\n- [事件处理与解析器](#5.4) - 事件处理和协议解析\n\n---\n\n## 开发环境要求\n\neCapture 需要特定的工具和依赖项进行开发。该项目为基于 Ubuntu 的系统提供了自动化设置脚本。\n\n### 必需工具\n\n| 工具 | 最低版本 | 用途 |\n|------|----------------|---------|\n| `clang` | 9+（推荐 14） | eBPF 字节码编译 |\n| `llvm` | 9+（推荐 14） | eBPF 工具链 |\n| `golang` | 1.24+ | 应用程序编译 |\n| `gcc` | 任何最新版本 | 交叉编译支持 |\n| `linux-headers` | 匹配内核版本 | Non-CO-RE 编译 |\n| `libelf-dev` | - | ELF 文件解析 |\n| `bpftool` | - | eBPF 字节码生成 |\n\n### 自动化设置\n\n项目提供了 [builder/init_env.sh:1-106]()，可在 Ubuntu 20.04-24.04 上为 x86_64 和 aarch64 架构自动安装依赖。它会：\n\n1. 检测 Ubuntu 版本并选择适当的 clang 版本\n2. 安装编译工具链和交叉编译工具\n3. 提取并准备 Linux 内核头文件\n4. 安装 Go 1.24.6\n5. 克隆包含子模块的仓库\n\n**来源：** [builder/init_env.sh:1-106](), [.github/workflows/go-c-cpp.yml:16-33]()\n\n---\n\n## 核心开发接口\n\neCapture 的架构围绕三个关键接口构建，开发人员必须理解这些接口才能扩展功能。\n\n### IModule 接口\n\n`IModule` 接口定义了所有捕获模块的契约。每个模块（OpenSSL、GoTLS、Bash 等）都实现此接口。\n\n```mermaid\ngraph TB\n    subgraph \"IModule 接口定义\"\n        IMODULE[\"IModule<br/>(user/module/imodule.go)\"]\n        \n        INIT[\"Init()<br/>Context, Logger, Config, Writer\"]\n        START[\"Start()<br/>附加 eBPF 探针\"]\n        RUN[\"Run()<br/>事件循环\"]\n        EVENTS[\"Events()<br/>返回 eBPF maps\"]\n        DECODE[\"Decode()<br/>[]byte → IEventStruct\"]\n        DECODEFUN[\"DecodeFun()<br/>Map → EventStruct 工厂\"]\n        DISPATCH[\"Dispatcher()<br/>处理事件\"]\n        CLOSE[\"Close()<br/>清理\"]\n        \n        IMODULE --> INIT\n        IMODULE --> START\n        IMODULE --> RUN\n        IMODULE --> EVENTS\n        IMODULE --> DECODE\n        IMODULE --> DECODEFUN\n        IMODULE --> DISPATCH\n        IMODULE --> CLOSE\n    end\n    \n    subgraph \"基础实现\"\n        MODULE[\"Module struct<br/>(可嵌入的基类)\"]\n        \n        READER[\"reader []IClose<br/>perf/ringbuf 读取器\"]\n        PROCESSOR[\"processor *EventProcessor<br/>事件聚合\"]\n        LOGGER[\"logger *zerolog.Logger\"]\n        CTX[\"ctx context.Context\"]\n        \n        MODULE --> READER\n        MODULE --> PROCESSOR\n        MODULE --> LOGGER\n        MODULE --> CTX\n    end\n    \n    subgraph \"具体模块\"\n        OPENSSL[\"MOpenSSLProbe<br/>user/module/probe_openssl.go\"]\n        GOTLS[\"MGoTLSProbe\"]\n        BASH[\"MBashProbe\"]\n        \n        OPENSSL -.->|\"嵌入\"| MODULE\n        GOTLS -.->|\"嵌入\"| MODULE\n        BASH -.->|\"嵌入\"| MODULE\n        \n        OPENSSL -.->|\"实现\"| IMODULE\n        GOTLS -.->|\"实现\"| IMODULE\n        BASH -.->|\"实现\"| IMODULE\n    end\n```\n\n#### IModule 方法契约\n\n| 方法 | 用途 | 典型实现 |\n|--------|---------|----------------------|\n| `Init()` | 初始化模块状态、解析配置、设置映射 | 加载 eBPF 字节码选择逻辑，初始化缓存 |\n| `Start()` | 将 eBPF 程序附加到钩子 | 调用 `bpfManager.Start()`，附加 uprobes/kprobes/TC |\n| `Run()` | 开始事件处理 | 启动事件读取器，运行处理器 |\n| `Events()` | 返回用于事件读取的 eBPF maps | 返回 perf/ringbuf maps |\n| `Decode()` | 将原始字节反序列化为事件结构体 | 解析事件类型，反序列化字段 |\n| `DecodeFun()` | 将 eBPF map 映射到事件解码器 | 返回适当的 `IEventStruct` 工厂 |\n| `Dispatcher()` | 处理已解码的事件 | 路由到输出、更新状态、保存密钥 |\n| `Close()` | 清理资源 | 停止读取器、关闭文件、分离探针 |\n\n**来源：** [user/module/imodule.go:47-75](), [user/module/imodule.go:83-108]()\n\n### IConfig 接口\n\n所有模块都通过 `IConfig` 接口接收配置，该接口提供通用设置和模块特定选项。\n\n```mermaid\ngraph LR\n    subgraph \"IConfig 接口\"\n        ICONFIG[\"IConfig<br/>(user/config/iconfig.go)\"]\n        \n        METHODS[\"GetPid()/SetPid()<br/>GetUid()/SetUid()<br/>GetBTF()/SetBTF()<br/>GetDebug()/SetDebug()<br/>GetHex()/SetHex()<br/>GetPerCpuMapSize()<br/>Check()\"]\n        \n        ICONFIG --> METHODS\n    end\n    \n    subgraph \"基础配置\"\n        BASE[\"BaseConfig struct\"]\n        FIELDS[\"Pid uint64<br/>Uid uint64<br/>BtfMode uint8<br/>Debug bool<br/>IsHex bool<br/>PerCpuMapSize int\"]\n        \n        BASE --> FIELDS\n        BASE -.->|\"实现\"| ICONFIG\n    end\n    \n    subgraph \"模块特定配置\"\n        OPENSSLCONF[\"OpensslConfig<br/>(user/config/config_openssl.go)\"]\n        GOTLSCONF[\"GoTLSConfig\"]\n        BASHCONF[\"BashConfig\"]\n        \n        OPENSSLCONF -.->|\"嵌入\"| BASE\n        GOTLSCONF -.->|\"嵌入\"| BASE\n        BASHCONF -.->|\"嵌入\"| BASE\n        \n        SSLFIELDS[\"SslVersion string<br/>Model string (text/pcap/keylog)<br/>PcapFile string<br/>KeylogFile string<br/>IsAndroid bool<br/>CGroupPath string\"]\n        \n        OPENSSLCONF --> SSLFIELDS\n    end\n```\n\n#### 通用配置字段\n\n| 字段 | 类型 | 用途 | 示例 |\n|-------|------|---------|---------|\n| `Pid` | `uint64` | 目标进程 ID（0 = 全部） | `1234` |\n| `Uid` | `uint64` | 目标用户 ID（0 = 全部） | `1000` |\n| `BtfMode` | `uint8` | BTF 模式（0=自动, 1=core, 2=non-core） | `0` |\n| `Debug` | `bool` | 启用调试日志 | `true` |\n| `IsHex` | `bool` | 十六进制输出模式 | `false` |\n| `PerCpuMapSize` | `int` | 每个 CPU 的 eBPF map 大小（页） | `1024` |\n\n**来源：** [user/config/iconfig.go:24-70](), [user/config/iconfig.go:95-112]()\n\n### IEventStruct 接口\n\n从 eBPF 流向用户空间的事件实现 `IEventStruct`，启用多态事件处理。\n\n| 方法 | 返回类型 | 用途 |\n|--------|-------------|---------|\n| `Decode([]byte)` | `error` | 从原始字节反序列化 |\n| `String()` | `string` | 人类可读的文本格式 |\n| `StringHex()` | `string` | 十六进制文本格式 |\n| `Clone()` | `IEventStruct` | 创建新实例用于解码 |\n| `EventType()` | `EventType` | 事件分类 |\n| `ToProtobufEvent()` | `*pb.Event` | 转换为 protobuf |\n\n**来源：** [user/event/event.go]()（在导入中引用）\n\n---\n\n## 模块开发生命周期\n\n理解模块从初始化到关闭的生命周期对于开发至关重要。\n\n```mermaid\nstateDiagram-v2\n    [*] --> 注册: init() 调用 RegisteFunc()\n    \n    注册 --> 初始化: CLI 调用 GetModuleFunc()\n    \n    初始化 --> 配置: mod.Init(ctx, logger, config)\n    配置 --> 字节码选择: 检测版本/偏移量\n    字节码选择 --> 加载eBPF: 加载适当的 .o 文件\n    \n    加载eBPF --> 附加探针: mod.Start()\n    附加探针 --> 事件读取: mod.Run()\n    \n    事件读取 --> 事件循环: perfEventReader/ringbufEventReader\n    事件循环 --> 解码: mod.Decode(map, bytes)\n    解码 --> 分发: mod.Dispatcher(event)\n    \n    分发 --> 处理: EventProcessor.Write()\n    处理 --> 输出: eventCollector.Write()\n    \n    输出 --> 事件循环: 继续\n    \n    事件循环 --> 清理: ctx.Done() 或 信号\n    清理 --> 分离: mod.Close()\n    分离 --> [*]\n    \n    note right of 注册\n        user/module/probe_openssl.go:777-786\n        工厂函数注册\n    end note\n    \n    note right of 配置\n        user/module/probe_openssl.go:109-176\n        解析配置，设置状态\n    end note\n    \n    note right of 字节码选择\n        user/module/probe_openssl.go:179-278\n        getSslBpfFile(), detectOpenssl()\n    end note\n    \n    note right of 事件循环\n        user/module/imodule.go:285-306\n        readEvents() 分派读取器\n    end note\n    \n    note right of 处理\n        pkg/event_processor/\n        聚合、过滤、格式化\n    end note\n```\n\n### 生命周期阶段详情\n\n**1. 注册阶段**\n- 模块工厂函数通过 `init()` 中的 `RegisteFunc()` 注册\n- 示例：[user/module/probe_openssl.go:777-786]()\n- 工厂创建实现 `IModule` 的模块实例\n\n**2. 初始化阶段** \n- CLI 调用 `Init(ctx, logger, config, eventCollector)`\n- 模块解析配置：[user/module/probe_openssl.go:109-176]()\n- 设置内部状态：连接映射、密钥缓存等\n- 确定 BTF 模式和内核版本\n\n**3. 字节码选择阶段**\n- 模块检测目标库版本（如 OpenSSL 1.0.x-3.5.x）\n- 选择适当的 eBPF 字节码：`_core.o` vs `_noncore.o` vs `_less52.o`\n- 示例：[user/module/probe_openssl.go:179-278]()\n\n**4. 探针附加阶段**\n- `Start()` 方法将 eBPF 程序附加到钩子\n- 使用 `ebpfmanager` 库进行生命周期管理\n- 配置常量编辑器用于 PID/UID 过滤\n\n**5. 事件读取阶段**\n- `Run()` 为每个 eBPF map 启动事件读取器\n- 读取器实现在 [user/module/imodule.go:308-350]()（perf）和 [user/module/imodule.go:353-391]()（ringbuf）\n- 每个事件触发 `Decode()` → `Dispatcher()` 管道\n\n**6. 事件处理阶段**\n- `EventProcessor` 聚合、过滤和格式化事件\n- 处理连接生命周期和协议解析\n- 输出到配置的目标（文件、websocket、stdout）\n\n**7. 清理阶段**\n- `Close()` 停止读取器、分离探针、关闭文件\n- 由 context 取消或 OS 信号触发\n\n**来源：** [user/module/imodule.go:110-171](), [user/module/imodule.go:236-262](), [user/module/probe_openssl.go:109-176](), [user/module/probe_openssl.go:280-350]()\n\n---\n\n## 开发工作流\n\neCapture 开发工作流集成了本地开发、测试和 CI/CD 自动化。\n\n```mermaid\ngraph TB\n    subgraph \"本地开发\"\n        EDIT[\"编辑代码<br/>Go/C/eBPF\"]\n        COMPILE[\"make env && make\"]\n        TEST[\"make test-race<br/>或<br/>make e2e\"]\n        DEBUG[\"使用 -d 标志运行<br/>检查日志\"]\n        \n        EDIT --> COMPILE\n        COMPILE --> TEST\n        TEST --> DEBUG\n        DEBUG -.->|\"迭代\"| EDIT\n    end\n    \n    subgraph \"构建变体\"\n        CORE[\"make<br/>(CO-RE 模式)\"]\n        NONCORE[\"make nocore<br/>(non-CO-RE)\"]\n        CROSS[\"CROSS_ARCH=arm64 make<br/>(交叉编译)\"]\n        ANDROID[\"ANDROID=1 CROSS_ARCH=arm64 make nocore\"]\n        \n        COMPILE --> CORE\n        COMPILE --> NONCORE\n        COMPILE --> CROSS\n        COMPILE --> ANDROID\n    end\n    \n    subgraph \"CI/CD 管道\"\n        PR[\"Pull Request\"]\n        CITEST[\"GitHub Actions<br/>go-c-cpp.yml\"]\n        LINT[\"golangci-lint\"]\n        MULTIARCH[\"构建 x86_64 & arm64<br/>构建 CO-RE & non-CO-RE\"]\n        RELEASE[\"标签推送<br/>release.yml\"]\n        ARTIFACTS[\"构建产物<br/>*.tar.gz, *.deb<br/>Docker 镜像\"]\n        \n        PR --> CITEST\n        CITEST --> LINT\n        CITEST --> MULTIARCH\n        RELEASE --> ARTIFACTS\n    end\n    \n    subgraph \"发布流程\"\n        TAG[\"创建标签<br/>v0.x.y\"]\n        BUILDRPM[\"make rpm<br/>(可选)\"]\n        BUILDDEB[\"make deb\"]\n        PUBLISH[\"make publish<br/>GitHub Release\"]\n        DOCKER[\"Docker Hub<br/>多架构推送\"]\n        \n        TAG --> BUILDDEB\n        TAG --> BUILDRPM\n        TAG --> DOCKER\n        BUILDDEB --> PUBLISH\n    end\n    \n    EDIT -.->|\"就绪\"| PR\n    ARTIFACTS --> DOCKER\n```\n\n### 本地构建命令\n\n| 命令 | 用途 | 输出 |\n|---------|---------|--------|\n| `make env` | 显示构建环境变量 | 配置信息 |\n| `make` 或 `make all` | 构建 CO-RE + non-CO-RE 字节码和二进制文件 | `bin/ecapture` |\n| `make nocore` | 仅构建 non-CO-RE 字节码 | `bin/ecapture`（non-CO-RE） |\n| `make clean` | 删除构建产物 | 清理工作区 |\n| `CROSS_ARCH=arm64 make` | 为 ARM64 交叉编译 | `bin/ecapture`（arm64） |\n| `DEBUG=1 make` | 使用调试符号构建 | 启用调试的二进制文件 |\n| `make test-race` | 使用竞态检测器运行测试 | 测试结果 |\n| `make e2e` | 运行端到端测试 | 集成测试结果 |\n| `make format` | 使用 clang-format 格式化 C 代码 | 格式化的代码 |\n\n### CI/CD 自动化\n\n项目使用 GitHub Actions 进行持续集成：\n\n**Pull Request 检查** [.github/workflows/go-c-cpp.yml:1-128]()\n1. **在 Ubuntu 22.04 x86_64 上构建**\n   - 安装工具链（clang-14, gcc-aarch64-linux-gnu）\n   - 构建 CO-RE 模式\n   - 运行 golangci-lint\n   - 构建 non-CO-RE 模式\n   - 交叉编译到 arm64（CO-RE 和 Android non-CO-RE）\n   - 运行竞态检测器测试\n\n2. **在 Ubuntu 22.04 ARM64 上构建**\n   - x86_64 工作流的镜像\n   - 交叉编译到 x86_64\n\n**发布自动化** [.github/workflows/release.yml:1-129]()\n1. 标签推送时触发（`v*`）\n2. 为 amd64 和 arm64 构建\n3. 从上一个标签生成发布说明\n4. 创建 tar.gz 存档和校验和\n5. 构建多架构 Docker 镜像\n6. 发布到 GitHub Releases 和 Docker Hub\n\n**来源：** [.github/workflows/go-c-cpp.yml:1-128](), [.github/workflows/release.yml:1-129](), [Makefile:1-269]()\n\n---\n\n## 构建系统架构\n\neCapture 构建系统功能强大，处理多种架构、内核版本和编译模式。\n\n```mermaid\ngraph TB\n    subgraph \"Makefile 结构\"\n        MAIN[\"Makefile<br/>(编排)\"]\n        VARS[\"variables.mk<br/>(检测 & 配置)\"]\n        FUNCS[\"functions.mk<br/>(辅助函数)\"]\n        RELEASE[\"builder/Makefile.release<br/>(打包)\"]\n        \n        MAIN --> VARS\n        MAIN --> FUNCS\n        RELEASE --> VARS\n        RELEASE --> FUNCS\n    end\n    \n    subgraph \"variables.mk - 环境检测\"\n        HOST_ARCH[\"HOST_ARCH<br/>uname -m\"]\n        CROSS_ARCH[\"CROSS_ARCH<br/>来自参数\"]\n        TARGET_ARCH[\"TARGET_ARCH<br/>计算得出\"]\n        GOARCH[\"GOARCH<br/>(amd64/arm64)\"]\n        LINUX_ARCH[\"LINUX_ARCH<br/>(x86/arm64)\"]\n        CLANG_VER[\"CLANG_VERSION<br/>提取\"]\n        GO_VER[\"GO_VERSION<br/>提取\"]\n        \n        HOST_ARCH --> TARGET_ARCH\n        CROSS_ARCH --> TARGET_ARCH\n        TARGET_ARCH --> GOARCH\n        TARGET_ARCH --> LINUX_ARCH\n    end\n    \n    subgraph \"编译路径\"\n        KERN_C[\"kern/*.c<br/>eBPF 程序\"]\n        \n        CORE_COMPILE[\"clang -target bpfel<br/>-g -O2 -D__TARGET_ARCH_XXX<br/>→ *_core.o\"]\n        \n        NONCORE_COMPILE[\"clang + llc<br/>-I kernel-headers<br/>→ *_noncore.o\"]\n        \n        LESS52[\"KERNEL_LESS_5_2<br/>变体编译<br/>→ *_less52.o\"]\n        \n        KERN_C --> CORE_COMPILE\n        KERN_C --> NONCORE_COMPILE\n        CORE_COMPILE --> LESS52\n        NONCORE_COMPILE --> LESS52\n    end\n    \n    subgraph \"资源嵌入\"\n        BYTECODE[\"user/bytecode/*.o<br/>27+ 变体\"]\n        GOBINDATA[\"go-bindata<br/>嵌入字节码\"]\n        ASSETS[\"assets/ebpf_probe.go<br/>Asset() 函数\"]\n        \n        BYTECODE --> GOBINDATA\n        GOBINDATA --> ASSETS\n    end\n    \n    subgraph \"Go 编译\"\n        LIBPCAP[\"lib/libpcap<br/>静态构建\"]\n        GOSRC[\"Go 源码<br/>user/*, cli/*, pkg/*\"]\n        GOBUILD[\"CGO_ENABLED=1<br/>静态链接<br/>版本注入\"]\n        BINARY[\"bin/ecapture<br/>自包含\"]\n        \n        ASSETS --> GOBUILD\n        LIBPCAP --> GOBUILD\n        GOSRC --> GOBUILD\n        GOBUILD --> BINARY\n    end\n    \n    subgraph \"发布产物\"\n        TARBALL[\"*.tar.gz<br/>平台存档\"]\n        DEB[\"*.deb<br/>Debian 包\"]\n        CHECKSUM[\"checksum-*.txt<br/>SHA256 校验和\"]\n        \n        BINARY --> TARBALL\n        BINARY --> DEB\n        TARBALL --> CHECKSUM\n        DEB --> CHECKSUM\n    end\n```\n\n### 关键构建概念\n\n**1. 双重编译模式**\n- **CO-RE（Compile Once - Run Everywhere）**：使用 BTF，可在任何启用 BTF 的内核上运行\n  - 使用 `clang -target bpfel` 编译为 `*_core.o`\n  - 跨内核版本可移植\n- **Non-CO-RE**：需要内核头文件，特定于内核版本\n  - 使用内核头文件编译为 `*_noncore.o`\n  - 对于没有 BTF 的内核或 Android 是必需的\n\n**2. 内核版本变体**\n- 内核 < 5.2 具有不同的 eBPF 辅助函数\n- 使用 `-DKERNEL_LESS_5_2` 编译单独的 `*_less52.o` 文件\n- 基于 `kernel.HostVersion()` 的运行时选择\n\n**3. 交叉编译支持**\n- `CROSS_ARCH` 变量触发交叉编译\n- 需要交叉工具链：`gcc-aarch64-linux-gnu` 或 `gcc-x86-64-linux-gnu`\n- 目标架构的内核头文件：`/usr/src/linux-source-*/arch/{x86,arm64}`\n\n**4. 资源嵌入**\n- 所有 eBPF 字节码通过 `go-bindata` 嵌入到 Go 二进制文件中\n- 运行时不依赖 `.o` 文件\n- 运行时从 `assets.Asset()` 选择适当的字节码\n\n**5. 版本注入**\n- 通过 ldflags 注入 Git 版本：[functions.mk:47-54]()\n- 格式：`os_arch:vX.Y.Z-date-commit:kernel_version`\n- 注入字节码模式：`ByteCodeFiles=core|noncore|all`\n\n**来源：** [Makefile:1-269](), [variables.mk:1-200](), [functions.mk:1-76](), [builder/Makefile.release:1-151]()\n\n---\n\n## 开发人员的关键代码模式\n\n### 模式 1：模块注册\n\n所有模块在 `init()` 中使用工厂模式注册自己：\n\n```go\n// user/module/probe_openssl.go:777-786\nfunc init() {\n    RegisteFunc(NewOpenSSLProbe)\n}\n\nfunc NewOpenSSLProbe() IModule {\n    mod := &MOpenSSLProbe{}\n    mod.name = ModuleNameOpenssl\n    mod.mType = ProbeTypeUprobe\n    return mod\n}\n```\n\nCLI 通过 `GetModuleFunc(modName)` 检索模块。\n\n### 模式 2：eBPF 字节码选择\n\n模块实现版本检测和字节码选择：\n\n```go\n// 1. 检测库版本\nverString, err := m.detectOpenssl(soPath)\n\n// 2. 将版本映射到字节码文件\nbpfFile, found := m.sslVersionBpfMap[verString]\n\n// 3. 应用 CO-RE/non-CO-RE 后缀\nfilename := m.geteBPFName(\"user/bytecode/\" + bpfFile)\n// 结果：user/bytecode/openssl_3_0_kern_core.o\n\n// 4. 从嵌入资源加载\nbyteBuf, err := assets.Asset(filename)\n```\n\n参考：[user/module/probe_openssl.go:179-278](), [user/module/imodule.go:191-214]()\n\n### 模式 3：事件分发\n\n事件通过类型切换分发器流动：\n\n```go\n// user/module/probe_openssl.go:733-754\nfunc (m *MOpenSSLProbe) Dispatcher(eventStruct event.IEventStruct) {\n    switch ev := eventStruct.(type) {\n    case *event.ConnDataEvent:\n        if ev.IsDestroy == 0 {\n            m.AddConn(ev.Pid, ev.Fd, ev.Tuple, ev.Sock)\n        } else {\n            m.DelConn(ev.Sock)\n        }\n    case *event.MasterSecretEvent:\n        m.saveMasterSecret(ev)\n    case *event.TcSkbEvent:\n        m.dumpTcSkb(ev)\n    case *event.SSLDataEvent:\n        m.dumpSslData(ev)\n    }\n}\n```\n\n### 模式 4：eBPF 管理器设置\n\n模块使用 `ebpfmanager` 进行探针生命周期管理：\n\n```go\nm.bpfManager = &manager.Manager{\n    Probes: []*manager.Probe{\n        {Section: \"uprobe/SSL_write\", ElfFuncName: \"SSL_write\"},\n        {Section: \"uretprobe/SSL_write\", ElfFuncName: \"SSL_write\"},\n        // ... 更多探针\n    },\n    Maps: []*manager.Map{\n        {Name: \"events\"},\n        {Name: \"mastersecret_events\"},\n    },\n}\n\nm.bpfManagerOptions = manager.Options{\n    ConstantEditors: m.constantEditor(), // PID/UID 过滤\n}\n\n// 加载并启动\nbyteBuf, _ := assets.Asset(bpfFileName)\nm.bpfManager.InitWithOptions(bytes.NewReader(byteBuf), m.bpfManagerOptions)\nm.bpfManager.Start()\n```\n\n**来源：** [user/module/probe_openssl.go:733-754](), [user/module/imodule.go:191-214]()\n\n---\n\n## 测试与调试\n\n### 单元测试\n\n使用竞态检测运行单元测试：\n```bash\nmake test-race\n```\n\n这将执行带有 libpcap 正确 CGO 标志的 `go test -v -race ./...`。\n\n### 端到端测试\n\n运行模块特定的 E2E 测试：\n```bash\nmake e2e-tls      # TLS 模块测试\nmake e2e-gnutls   # GnuTLS 模块测试\nmake e2e-gotls    # GoTLS 模块测试\nmake e2e          # 所有 E2E 测试\n```\n\n参考：[Makefile:240-268]()\n\n### 调试模式\n\n启用调试日志：\n```bash\n./ecapture tls -d          # 调试到标准输出\n./ecapture tls -d -l /tmp/debug.log  # 调试到文件\n```\n\n调试模式启用：\n- 详细的 eBPF 验证器输出\n- 连接跟踪日志\n- 事件解码详情\n- 处理器状态信息\n\n### 常见开发问题\n\n| 问题 | 原因 | 解决方案 |\n|-------|-------|----------|\n| eBPF 验证器错误 | 字节码与内核不兼容 | 检查内核版本，尝试 `-b 2` 使用 non-CO-RE |\n| 模块未找到 | 工厂未注册 | 添加带有 `RegisteFunc()` 调用的 `init()` |\n| 事件未捕获 | 钩子/偏移量错误 | 验证库版本检测逻辑 |\n| 编译错误 | 缺少头文件 | 运行 `make env` 检查 KERN_SRC_PATH |\n| 交叉编译失败 | 缺少工具链 | 安装 `gcc-aarch64-linux-gnu` 或 `gcc-x86-64-linux-gnu` |\n\n**来源：** [Makefile:240-268](), [user/module/imodule.go:110-171]()\n\n---\n\n## 开发人员的后续步骤\n\n有关特定开发任务的详细信息：\n\n- **[构建系统](#5.1)**：深入了解 Makefile 结构、变量、交叉编译和资源嵌入\n- **[eBPF 程序开发](#5.2)**：编写 eBPF C 程序、使用辅助函数、映射操作和调试\n- **[添加新模块](#5.3)**：创建新捕获模块的分步指南，包含完整的生命周期实现\n- **[事件处理与解析器](#5.4)**：实现事件结构体、协议解析器和输出格式化\n\n其他资源：\n- [架构设计](#2)：高级系统架构和组件交互\n- [命令行界面](#1.2)：CLI 结构和命令模式\n- [配置系统](#2.3)：IConfig 实现和运行时更新\n\n**来源：** [cli/cmd/root.go:80-403](), [user/module/imodule.go:47-480](), [user/config/iconfig.go:1-212](), [Makefile:1-269]()"
          },
          {
            "page_plan": {
              "id": "5.1",
              "title": "构建系统"
            },
            "content": "# 构建系统\n\neCapture 构建系统是一个基于 Makefile 的复杂构建编排系统，实现了双 eBPF 编译路径（CO-RE 和 non-CO-RE）、跨架构编译、资源嵌入以及多格式发布产物生成。本页面文档记录了构建配置、编译流程、依赖管理和发布流程。\n\n关于开发新 eBPF 程序的信息，请参见 [eBPF 程序开发](#5.2)。关于模块开发，请参见 [添加新模块](#5.3)。\n\n## 构建配置架构\n\n构建系统由三个相互关联的 Makefile 组成，分别管理配置、编排和发布流程。\n\n```mermaid\ngraph TB\n    subgraph \"构建配置文件\"\n        VARS[\"variables.mk<br/>配置变量\"]\n        MAIN[\"Makefile<br/>构建编排\"]\n        FUNCS[\"functions.mk<br/>辅助函数\"]\n        RELEASE[\"builder/Makefile.release<br/>发布任务\"]\n    end\n    \n    subgraph \"配置变量 - variables.mk\"\n        HOST[\"HOST_ARCH<br/>UNAME_R<br/>KERN_RELEASE\"]\n        CROSS[\"CROSS_ARCH<br/>TARGET_ARCH<br/>GOARCH<br/>LINUX_ARCH\"]\n        PATHS[\"LINUX_SOURCE_PATH<br/>KERN_BUILD_PATH<br/>KERN_SRC_PATH\"]\n        FLAGS[\"EXTRA_CFLAGS<br/>EXTRA_CFLAGS_NOCORE<br/>BPFHEADER\"]\n        TARGETS[\"KERN_OBJECTS<br/>KERN_OBJECTS_NOCORE<br/>TARGET_LIBPCAP\"]\n    end\n    \n    subgraph \"辅助函数 - functions.mk\"\n        CHECK[\".checkver_*<br/>版本验证\"]\n        ALLOW[\"allow-override<br/>变量覆盖\"]\n        GOBUILD[\"gobuild<br/>Go 构建函数\"]\n        RELEASE_TAR[\"release_tar<br/>归档创建\"]\n    end\n    \n    subgraph \"构建目标 - Makefile\"\n        ALL[\"all<br/>完整构建\"]\n        NOCORE[\"nocore<br/>仅 Non-CO-RE\"]\n        EBPF[\"ebpf<br/>CO-RE 字节码\"]\n        EBPF_NC[\"ebpf_noncore<br/>Non-CO-RE 字节码\"]\n        ASSETS[\"assets<br/>嵌入全部\"]\n        ASSETS_NC[\"assets_noncore<br/>嵌入 Non-CO-RE\"]\n        BUILD[\"build<br/>Go 二进制\"]\n    end\n    \n    VARS --> MAIN\n    FUNCS --> MAIN\n    MAIN --> RELEASE\n    \n    HOST --> MAIN\n    CROSS --> MAIN\n    PATHS --> MAIN\n    FLAGS --> MAIN\n    TARGETS --> MAIN\n    \n    CHECK --> MAIN\n    ALLOW --> MAIN\n    GOBUILD --> MAIN\n    RELEASE_TAR --> RELEASE\n    \n    ALL --> EBPF\n    ALL --> EBPF_NC\n    ALL --> ASSETS\n    ALL --> BUILD\n    \n    NOCORE --> EBPF_NC\n    NOCORE --> ASSETS_NC\n    NOCORE --> BUILD\n```\n\n**来源：** [Makefile:1-2](), [functions.mk:1-76](), [builder/Makefile.release:1-3]()\n\n### 配置变量\n\n`variables.mk` 文件（未显示但在 [Makefile:1]() 中引用）定义了关键构建配置：\n\n| 变量类别 | 关键变量 | 用途 |\n|------------------|---------------|---------|\n| **架构检测** | `HOST_ARCH`, `UNAME_R`, `CLANG_VERSION`, `GO_VERSION` | 检测主机环境 |\n| **交叉编译** | `CROSS_ARCH`, `TARGET_ARCH`, `GOARCH`, `LINUX_ARCH`, `LIBPCAP_ARCH` | 目标架构配置 |\n| **内核路径** | `LINUX_SOURCE_PATH`, `KERN_BUILD_PATH`, `KERN_SRC_PATH` | 内核头文件位置 |\n| **构建标志** | `EXTRA_CFLAGS`, `EXTRA_CFLAGS_NOCORE`, `BPFHEADER` | eBPF 编译器标志 |\n| **版本控制** | `VERSION_NUM`, `LAST_GIT_TAG`, `BPF_NOCORE_TAG`, `PACKAGE_VERSION` | 版本信息 |\n| **工具** | `CMD_CLANG`, `CMD_LLC`, `CMD_GO`, `CMD_CC_PREFIX` | 命令路径 |\n\n构建系统通过 `make env` 打印所有配置（[Makefile:19-63]()）。\n\n**来源：** [Makefile:19-63](), [.github/workflows/go-c-cpp.yml:16-33]()\n\n### 辅助函数\n\n[functions.mk:1-76]() 文件提供可重用的构建函数：\n\n#### 版本检查函数\n\n```makefile\n.checkver_$(CMD_CLANG)  # 验证 clang >= 9\n.checkver_$(CMD_GO)      # 验证 go >= 1.24\n.checkver_$(CMD_BPFTOOL) # 验证 bpftool 可用性\n```\n\n这些函数（[functions.mk:13-40]()）创建标记文件以避免重复检查，如果不满足要求则构建失败。\n\n#### 变量覆盖函数\n\n`allow-override` 函数（[functions.mk:41-45]()）启用条件变量默认值：\n\n```makefile\n$(call allow-override,VERSION_FLAG,$(UNAME_R))\n```\n\n这种模式允许命令行或环境变量覆盖默认值。\n\n#### Go 构建函数\n\n`gobuild` 函数（[functions.mk:47-54]()）封装了带静态链接的 Go 构建命令：\n\n- 启用 CGO 并静态链接 libpcap\n- 设置构建模式为 PIE（位置无关可执行文件）\n- 通过 `-ldflags` 注入版本信息\n- 通过 `ByteCodeFiles` 变量注入字节码文件列表\n- 使用 `-extldflags -static` 执行静态链接\n\n#### 发布归档函数\n\n`release_tar` 函数（[functions.mk:62-76]()）创建发布归档：\n\n```makefile\n$(call release_tar,linux,)        # Linux 发布版\n$(call release_tar,android,nocore) # Android 发布版（仅 non-CO-RE）\n```\n\n**来源：** [functions.mk:1-76]()\n\n## eBPF 编译流程\n\n构建系统实现了两条并行的 eBPF 编译路径：CO-RE（一次编译、到处运行）用于具有 BTF 的现代内核，non-CO-RE 用于需要特定头文件的旧内核。\n\n```mermaid\ngraph TB\n    subgraph \"源 eBPF 程序\"\n        KERN_C[\"kern/*.c<br/>27+ 个 eBPF 程序<br/>openssl.c, gotls.c 等\"]\n    end\n    \n    subgraph \"CO-RE 编译路径\"\n        CLANG_CORE[\"clang -target bpfel<br/>-D__TARGET_ARCH_*<br/>启用 BTF\"]\n        \n        CORE_OUT[\"user/bytecode/*_core.o<br/>可移植字节码\"]\n        \n        LESS52_CORE[\"user/bytecode/*_core_less52.o<br/>内核 < 5.2 变体\"]\n    end\n    \n    subgraph \"Non-CO-RE 编译路径\"\n        PREPARE[\"make prepare<br/>生成内核头文件<br/>支持 CROSS_COMPILE\"]\n        \n        CLANG_NC[\"clang + llc<br/>-I KERN_SRC_PATH<br/>-I KERN_BUILD_PATH<br/>内核特定头文件\"]\n        \n        NC_OUT[\"user/bytecode/*_noncore.o<br/>内核特定字节码\"]\n        \n        LESS52_NC[\"user/bytecode/*_noncore_less52.o<br/>内核 < 5.2 变体\"]\n    end\n    \n    subgraph \"资源嵌入\"\n        BINDATA[\"go-bindata<br/>嵌入所有 .o 文件\"]\n        \n        PROBE_GO[\"assets/ebpf_probe.go<br/>嵌入的字节码\"]\n    end\n    \n    subgraph \"编译触发器\"\n        ALL_TARGET[\"make all<br/>包含两条路径\"]\n        NOCORE_TARGET[\"make nocore<br/>仅 Non-CO-RE\"]\n    end\n    \n    KERN_C --> CLANG_CORE\n    KERN_C --> PREPARE\n    \n    CLANG_CORE --> CORE_OUT\n    CLANG_CORE --> LESS52_CORE\n    \n    PREPARE --> CLANG_NC\n    CLANG_NC --> NC_OUT\n    CLANG_NC --> LESS52_NC\n    \n    CORE_OUT --> BINDATA\n    LESS52_CORE --> BINDATA\n    NC_OUT --> BINDATA\n    LESS52_NC --> BINDATA\n    \n    BINDATA --> PROBE_GO\n    \n    ALL_TARGET --> CLANG_CORE\n    ALL_TARGET --> CLANG_NC\n    NOCORE_TARGET --> CLANG_NC\n```\n\n**来源：** [Makefile:117-183](), [Makefile:186-195]()\n\n### CO-RE 编译\n\nCO-RE 编译（[Makefile:117-134]()）使用 BTF（BPF 类型格式）生成可移植的 eBPF 字节码：\n\n**编译命令：**\n```makefile\n$(CMD_CLANG) -D__TARGET_ARCH_$(LINUX_ARCH) \\\n    $(EXTRA_CFLAGS) \\\n    $(BPFHEADER) \\\n    -target bpfel -c $< -o $(OUTPUT) \\\n    -fno-ident -fdebug-compilation-dir . -g \\\n    -D__BPF_TARGET_MISSING=\"...\" \\\n    -MD -MP\n```\n\n**关键特性：**\n\n1. **目标架构：** `-D__TARGET_ARCH_x86` 或 `-D__TARGET_ARCH_arm64`（[Makefile:122]()）\n2. **启用 BTF：** 使用 `-target bpfel` 生成带 CO-RE 重定位的 BPF ELF 格式\n3. **调试信息：** 包含 `-g` 用于 BTF 生成和 `-gdwarf-4`（通过 `EXTRA_CFLAGS`）\n4. **依赖跟踪：** `-MD -MP` 生成 `.d` 文件用于增量构建\n\n**输出：**\n- `user/bytecode/*_core.o` - 标准 CO-RE 字节码\n- `user/bytecode/*_core_less52.o` - 内核 < 5.2 变体，带 `-DKERNEL_LESS_5_2`（[Makefile:131]()）\n\n内核 < 5.2 变体是必要的，因为早期内核缺少某些 eBPF 功能（例如有界循环、特定辅助函数）。\n\n**来源：** [Makefile:117-134](), [.github/workflows/go-c-cpp.yml:38-42]()\n\n### Non-CO-RE 编译\n\nNon-CO-RE 编译（[Makefile:146-183]()）使用显式头文件包含生成内核特定字节码：\n\n**准备步骤：**\n```makefile\nmake prepare  # 如果需要则生成内核头文件\n```\n\n此步骤（[Makefile:98-104]()）在交叉编译场景中调用内核头文件生成：\n```bash\ncd $(LINUX_SOURCE_PATH) && $(KERNEL_HEADER_GEN)\n```\n\n**编译命令：**\n```makefile\n$(CMD_CLANG) \\\n    $(EXTRA_CFLAGS_NOCORE) \\\n    $(BPFHEADER) \\\n    -I $(KERN_SRC_PATH)/arch/$(LINUX_ARCH)/include \\\n    -I $(KERN_BUILD_PATH)/arch/$(LINUX_ARCH)/include/generated \\\n    -I $(KERN_SRC_PATH)/include \\\n    [... 总共 8 个包含路径 ...] \\\n    -c $< -o - | $(CMD_LLC) \\\n    -march=bpf -filetype=obj -o $(OUTPUT)\n```\n\n**关键特性：**\n\n1. **内核头文件：** 使用 8 个包含路径的内核头文件（[Makefile:154-161]()）\n2. **两阶段编译：** \n   - 阶段 1：`clang` 编译为 LLVM 位码（`-o -`）\n   - 阶段 2：`llc` 转换为 BPF 目标文件\n3. **架构特定：** 包含 `arch/$(LINUX_ARCH)/include` 头文件\n4. **交叉编译：** 支持跨架构构建的 `CROSS_COMPILE` 前缀\n\n**输出：**\n- `user/bytecode/*_noncore.o` - 内核特定字节码\n- `user/bytecode/*_noncore_less52.o` - 内核 < 5.2 变体（[Makefile:178]()）\n\n**来源：** [Makefile:98-104](), [Makefile:146-183]()\n\n### 内核 < 5.2 支持\n\n两条编译路径都使用 `-DKERNEL_LESS_5_2` 预处理器标志生成内核 < 5.2 的变体。这在 C 代码中启用条件编译：\n\n```c\n#ifdef KERNEL_LESS_5_2\n    // 使用旧的 eBPF 功能\n#else\n    // 使用现代 eBPF 功能\n#endif\n```\n\n这些变体在文件名中带有 `_less52` 后缀（[Makefile:132](), [Makefile:183]()）。\n\n**来源：** [Makefile:131-134](), [Makefile:178-183]()\n\n## 资源嵌入系统\n\neBPF 编译后，所有字节码文件使用 `go-bindata` 嵌入到 Go 二进制中。\n\n```mermaid\ngraph LR\n    subgraph \"字节码文件\"\n        CORE[\"*_core.o\"]\n        CORE_L52[\"*_core_less52.o\"]\n        NONCORE[\"*_noncore.o\"]\n        NONCORE_L52[\"*_noncore_less52.o\"]\n    end\n    \n    subgraph \"嵌入过程\"\n        BINDATA[\"go-bindata<br/>github.com/shuLhan/go-bindata\"]\n        IGNORE[\"IGNORE_LESS52 标志<br/>可选过滤\"]\n    end\n    \n    subgraph \"生成的资源\"\n        PROBE_GO[\"assets/ebpf_probe.go<br/>Asset() 函数<br/>AssetNames() 函数<br/>嵌入的二进制数据\"]\n    end\n    \n    subgraph \"运行时使用\"\n        MODULE[\"Module.Init()<br/>按名称加载字节码\"]\n        LOADER[\"eBPF 管理器<br/>加载到内核\"]\n    end\n    \n    CORE --> BINDATA\n    CORE_L52 --> BINDATA\n    NONCORE --> BINDATA\n    NONCORE_L52 --> BINDATA\n    \n    IGNORE -.-> BINDATA\n    \n    BINDATA --> PROBE_GO\n    PROBE_GO --> MODULE\n    MODULE --> LOADER\n```\n\n**来源：** [Makefile:186-195]()\n\n### 资源生成\n\n`assets` 目标（[Makefile:186-188]()）嵌入所有字节码：\n\n```makefile\n.PHONY: assets\nassets: .checkver_$(CMD_GO) ebpf ebpf_noncore\n\t$(CMD_GO) run github.com/shuLhan/go-bindata/cmd/go-bindata \\\n\t    $(IGNORE_LESS52) -pkg assets -o \"assets/ebpf_probe.go\" \\\n\t    $(wildcard ./user/bytecode/*.o)\n```\n\n`assets_noncore` 目标（[Makefile:191-195]()）仅嵌入 non-CO-RE 字节码用于特殊构建（如 Android）。\n\n**关键特性：**\n\n1. **包名：** 在 `assets` 包中生成\n2. **输出文件：** `assets/ebpf_probe.go`\n3. **输入文件：** `user/bytecode/` 中的所有 `.o` 文件\n4. **可选过滤：** `IGNORE_LESS52` 可以排除内核 < 5.2 变体\n\n### 生成的资源接口\n\n`go-bindata` 工具生成带有函数的 Go 代码：\n\n```go\n// Asset 加载并返回给定名称的资源\nfunc Asset(name string) ([]byte, error)\n\n// AssetNames 返回所有嵌入资源的名称\nfunc AssetNames() []string\n\n// AssetInfo 返回资源的元数据\nfunc AssetInfo(name string) (os.FileInfo, error)\n```\n\n运行时，模块按文件名加载字节码：\n\n```go\nbytecode, err := assets.Asset(\"user/bytecode/openssl_kern_core.o\")\n```\n\n构建系统通过 `ByteCodeFiles` 构建变量将可用字节码文件列表注入二进制（[functions.mk:52]()）：\n\n```makefile\n-X 'github.com/gojue/ecapture/cli/cmd.ByteCodeFiles=$(BYTECODE_FILES)'\n```\n\n这允许在运行时在 CO-RE 和 non-CO-RE 字节码之间进行选择。\n\n**来源：** [Makefile:186-195](), [go.mod:12](), [functions.mk:52]()\n\n## Go 二进制编译\n\nGo 二进制编译集成了静态链接和嵌入资源。\n\n```mermaid\ngraph TB\n    subgraph \"依赖项\"\n        LIBPCAP[\"lib/libpcap/<br/>静态库构建<br/>Configure + Make\"]\n        ASSETS_GO[\"assets/ebpf_probe.go<br/>嵌入的字节码\"]\n        GO_SRC[\"Go 源代码<br/>cli/cmd/*.go<br/>user/module/*.go<br/>pkg/**/*.go\"]\n    end\n    \n    subgraph \"构建配置\"\n        CGO_FLAGS[\"CGO_ENABLED=1<br/>CGO_CFLAGS=-I libpcap/<br/>CGO_LDFLAGS=-L libpcap/ -lpcap\"]\n        GO_FLAGS[\"GOOS=linux<br/>GOARCH=amd64|arm64<br/>CC=gcc|cross-gcc\"]\n        BUILD_FLAGS[\"-trimpath<br/>-buildmode=pie<br/>-mod=readonly<br/>-tags netgo\"]\n        LD_FLAGS[\"-w -s<br/>-X GitVersion<br/>-X ByteCodeFiles<br/>-linkmode=external<br/>-extldflags -static\"]\n    end\n    \n    subgraph \"输出\"\n        BINARY[\"bin/ecapture<br/>静态二进制<br/>自包含\"]\n    end\n    \n    LIBPCAP --> CGO_FLAGS\n    ASSETS_GO --> GO_SRC\n    GO_SRC --> BUILD_FLAGS\n    CGO_FLAGS --> BINARY\n    GO_FLAGS --> BINARY\n    BUILD_FLAGS --> BINARY\n    LD_FLAGS --> BINARY\n```\n\n**来源：** [Makefile:199-208](), [Makefile:211-225](), [functions.mk:47-54]()\n\n### libpcap 静态构建\n\n在 Go 编译之前，构建系统编译静态 `libpcap` 库（[Makefile:199-208]()）：\n\n```makefile\n$(TARGET_LIBPCAP):\n\ttest -f ./lib/libpcap/configure || git submodule update --init\n\tcd lib/libpcap && \\\n\t    CC=$(CMD_CC_PREFIX)$(CMD_CC) AR=$(CMD_AR_PREFIX)$(CMD_AR) \\\n\t    CFLAGS=\"-O2 -g -gdwarf-4 -static -Wno-unused-result\" \\\n\t    ./configure --disable-rdma --disable-shared --disable-usb \\\n\t        --disable-netmap --disable-bluetooth --disable-dbus \\\n\t        --without-libnl --without-dpdk --without-dag \\\n\t        --without-septel --without-snf --without-gcc \\\n\t        --with-pcap=linux --without-turbocap \\\n\t        --host=$(LIBPCAP_ARCH) && \\\n\t    CC=$(CMD_CC_PREFIX)$(CMD_CC) AR=$(CMD_AR_PREFIX)$(CMD_AR) make\n```\n\n**配置要点：**\n\n- **静态构建：** `--disable-shared` 和 CFLAGS 中的 `-static`\n- **最小功能：** 禁用 RDMA、USB、Bluetooth、DBus\n- **仅 Linux：** `--with-pcap=linux`\n- **交叉编译：** 使用 `$(CMD_CC_PREFIX)` 和 `--host=$(LIBPCAP_ARCH)`\n- **调试信息：** `-g -gdwarf-4` 用于调试\n\n静态 `libpcap.a` 链接到最终二进制。\n\n**来源：** [Makefile:199-208]()\n\n### Go 构建命令\n\n`gobuild` 函数（[functions.mk:47-54]()）执行 Go 编译：\n\n```makefile\nCGO_ENABLED=1 \\\nCGO_CFLAGS='-O2 -g -gdwarf-4 -I$(CURDIR)/lib/libpcap/' \\\nCGO_LDFLAGS='-O2 -g -L$(CURDIR)/lib/libpcap/ -lpcap -static' \\\nGOOS=linux GOARCH=$(GOARCH) CC=$(CMD_CC_PREFIX)$(CMD_CC) \\\n$(CMD_GO) build -trimpath -buildmode=pie -mod=readonly \\\n    -tags '$(TARGET_TAG),netgo' \\\n    -ldflags \"-w -s \\\n        -X 'github.com/gojue/ecapture/cli/cmd.GitVersion=$(TARGET_TAG)_$(GOARCH):$(VERSION_NUM):$(VERSION_FLAG)' \\\n        -X 'github.com/gojue/ecapture/cli/cmd.ByteCodeFiles=$(BYTECODE_FILES)' \\\n        -linkmode=external -extldflags -static\" \\\n    -o $(OUT_BIN)\n```\n\n**构建标志说明：**\n\n| 标志 | 用途 |\n|------|---------|\n| `CGO_ENABLED=1` | 启用 CGO 用于 libpcap 集成 |\n| `CGO_CFLAGS` | 包含 libpcap 头文件 |\n| `CGO_LDFLAGS` | 链接静态 libpcap |\n| `-trimpath` | 移除构建路径以实现可重现性 |\n| `-buildmode=pie` | 位置无关可执行文件 |\n| `-mod=readonly` | 如果 `go.mod` 需要更新则失败 |\n| `-tags netgo` | 使用纯 Go 网络栈（备份） |\n| `-w -s` | 去除调试符号 |\n| `-X` | 注入版本和字节码列表 |\n| `-linkmode=external` | 使用外部 C 链接器 |\n| `-extldflags -static` | 完全静态二进制 |\n\n**版本注入：**\n\n构建注入两个关键变量：\n1. `GitVersion` - 格式：`{TAG}_{ARCH}:{VERSION_NUM}:{VERSION_FLAG}`\n2. `ByteCodeFiles` - 字节码类型列表（如 \"core\", \"noncore\"）\n\n这些在运行时可通过 `cli/cmd` 包变量访问。\n\n**来源：** [functions.mk:47-54]()\n\n### 构建目标\n\n| 目标 | eBPF 字节码 | 资源 | 描述 |\n|--------|---------------|--------|-------------|\n| `make all` | CO-RE + non-CO-RE | 全部 | 包含两种字节码类型的完整构建 |\n| `make nocore` | 仅 non-CO-RE | Non-CO-RE | 内核特定构建 |\n| `make build` | （使用现有） | 全部 | 仅 Go 二进制 |\n| `make build_noncore` | （使用现有） | Non-CO-RE | Non-CO-RE Go 二进制 |\n\n`all` 目标（[Makefile:6]()）是默认目标，生成包含 CO-RE 和 non-CO-RE 字节码的二进制，允许运行时选择。\n\n`nocore` 目标（[Makefile:10]()）生成仅包含内核特定字节码的较小二进制，适用于资源受限环境或 Android。\n\n**来源：** [Makefile:4-14](), [Makefile:211-225]()\n\n## 交叉编译架构\n\neCapture 支持 x86_64 和 aarch64 架构之间的双向交叉编译。\n\n```mermaid\ngraph TB\n    subgraph \"主机检测\"\n        UNAME[\"uname -m<br/>x86_64 或 aarch64\"]\n        HOST_ARCH[\"HOST_ARCH 变量\"]\n    end\n    \n    subgraph \"交叉编译配置\"\n        CROSS_VAR[\"CROSS_ARCH=arm64|amd64<br/>命令行变量\"]\n        \n        MAPPINGS[\"架构映射:<br/>arm64 -> aarch64, arm, aarch64-linux-gnu<br/>amd64 -> x86_64, x86, x86_64-linux-gnu\"]\n        \n        TARGET_ARCH[\"TARGET_ARCH<br/>GOARCH<br/>LINUX_ARCH<br/>LIBPCAP_ARCH\"]\n    end\n    \n    subgraph \"交叉编译工具\"\n        GCC_CROSS[\"交叉 GCC:<br/>x86_64: gcc-aarch64-linux-gnu<br/>aarch64: gcc-x86-64-linux-gnu\"]\n        \n        KERN_HEADERS[\"内核头文件:<br/>KERN_SRC_PATH/arch/$(LINUX_ARCH)<br/>交叉准备的头文件\"]\n        \n        CC_PREFIX[\"CMD_CC_PREFIX<br/>aarch64-linux-gnu-<br/>x86_64-linux-gnu-\"]\n    end\n    \n    subgraph \"构建过程\"\n        EBPF_CROSS[\"eBPF 交叉编译:<br/>-D__TARGET_ARCH_arm64|x86<br/>架构特定头文件\"]\n        \n        LIBPCAP_CROSS[\"libpcap 交叉构建:<br/>CC=$(CMD_CC_PREFIX)gcc<br/>--host=$(LIBPCAP_ARCH)\"]\n        \n        GO_CROSS[\"Go 交叉构建:<br/>GOARCH=arm64|amd64<br/>CC=$(CMD_CC_PREFIX)gcc\"]\n    end\n    \n    subgraph \"输出\"\n        X86_BIN[\"bin/ecapture<br/>x86_64 二进制\"]\n        ARM_BIN[\"bin/ecapture<br/>aarch64 二进制\"]\n    end\n    \n    UNAME --> HOST_ARCH\n    CROSS_VAR --> MAPPINGS\n    HOST_ARCH --> MAPPINGS\n    MAPPINGS --> TARGET_ARCH\n    \n    TARGET_ARCH --> GCC_CROSS\n    TARGET_ARCH --> KERN_HEADERS\n    TARGET_ARCH --> CC_PREFIX\n    \n    GCC_CROSS --> EBPF_CROSS\n    KERN_HEADERS --> EBPF_CROSS\n    CC_PREFIX --> LIBPCAP_CROSS\n    CC_PREFIX --> GO_CROSS\n    \n    EBPF_CROSS --> X86_BIN\n    EBPF_CROSS --> ARM_BIN\n    LIBPCAP_CROSS --> X86_BIN\n    LIBPCAP_CROSS --> ARM_BIN\n    GO_CROSS --> X86_BIN\n    GO_CROSS --> ARM_BIN\n```\n\n**来源：** [.github/workflows/go-c-cpp.yml:56-65](), [.github/workflows/release.yml:93-97](), [builder/init_env.sh:43-61]()\n\n### 交叉编译变量\n\n通过设置 `CROSS_ARCH` 触发交叉编译：\n\n```bash\nCROSS_ARCH=arm64 make    # 在 x86_64 主机上构建 arm64\nCROSS_ARCH=amd64 make    # 在 aarch64 主机上构建 amd64\n```\n\n构建系统将 `CROSS_ARCH` 映射到多个架构特定变量：\n\n| 变量 | arm64 值 | amd64 值 | 用途 |\n|----------|-------------|-------------|---------|\n| `GOARCH` | `arm64` | `amd64` | Go 架构目标 |\n| `LINUX_ARCH` | `arm64` | `x86` | Linux 内核架构名称 |\n| `TARGET_ARCH` | `aarch64` | `x86_64` | GCC 目标架构 |\n| `LIBPCAP_ARCH` | `aarch64-linux-gnu` | `x86_64-linux-gnu` | libpcap configure host |\n| `CMD_CC_PREFIX` | `aarch64-linux-gnu-` | `x86_64-linux-gnu-` | 交叉编译器前缀 |\n\n这些映射在 `variables.mk` 中定义（引用但未显示）。\n\n**来源：** [builder/init_env.sh:43-61]()\n\n### 交叉编译工具链设置\n\nCI 工作流（[.github/workflows/go-c-cpp.yml:16-33]()）和初始化脚本（[builder/init_env.sh:1-106]()）安装交叉编译工具链：\n\n**在 x86_64 主机上（目标 arm64）：**\n```bash\nsudo apt-get install gcc-aarch64-linux-gnu linux-source\ncd /usr/src/linux-source-*\nsudo make ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- prepare\n```\n\n**在 aarch64 主机上（目标 x86_64）：**\n```bash\nsudo apt-get install gcc-x86-64-linux-gnu linux-source\ncd /usr/src/linux-source-*\nsudo make ARCH=x86 CROSS_COMPILE=x86_64-linux-gnu- prepare\n```\n\n`make prepare` 命令生成 non-CO-RE eBPF 编译所需的架构特定内核头文件。\n\n**来源：** [.github/workflows/go-c-cpp.yml:16-33](), [.github/workflows/go-c-cpp.yml:76-93](), [builder/init_env.sh:72-89]()\n\n### 交叉编译实践\n\n#### eBPF 交叉编译\n\nCO-RE eBPF 字节码通过 `-D__TARGET_ARCH_$(LINUX_ARCH)` 标志感知架构（[Makefile:122]()），解析为：\n- x86_64 的 `-D__TARGET_ARCH_x86`\n- aarch64 的 `-D__TARGET_ARCH_arm64`\n\nNon-CO-RE 编译使用目标架构的交叉准备内核头文件（[Makefile:154-161]()）。\n\n#### libpcap 交叉构建\n\nlibpcap configure 步骤（[Makefile:203-207]()）使用：\n```makefile\nCC=$(CMD_CC_PREFIX)$(CMD_CC) --host=$(LIBPCAP_ARCH)\n```\n\n其中：\n- `CMD_CC_PREFIX` 是 `aarch64-linux-gnu-` 或 `x86_64-linux-gnu-`\n- `LIBPCAP_ARCH` 是 `aarch64-linux-gnu` 或 `x86_64-linux-gnu`\n\n#### Go 交叉构建\n\nGo 构建（[functions.mk:51]()）设置：\n```makefile\nGOARCH=$(GOARCH) CC=$(CMD_CC_PREFIX)$(CMD_CC)\n```\n\n这告诉 Go 使用交叉编译器进行 CGO 编译并针对指定架构。\n\n**来源：** [Makefile:122](), [Makefile:154-161](), [Makefile:203-207](), [functions.mk:51]()\n\n### CI/CD 交叉编译工作流\n\nGitHub Actions 工作流演示了交叉编译过程：\n\n```yaml\n- name: Build CO-RE (Cross-Compilation)\n  run: |\n    make clean\n    CROSS_ARCH=arm64 make env\n    CROSS_ARCH=arm64 make -j8\n\n- name: Build non-CO-RE (Cross-Compilation/Android)\n  run: |\n    make clean\n    CROSS_ARCH=arm64 make env\n    ANDROID=1 CROSS_ARCH=arm64 make nocore -j8\n```\n\n此工作流（[.github/workflows/go-c-cpp.yml:56-65]()）验证：\n1. CO-RE 交叉编译工作正常\n2. Non-CO-RE 交叉编译工作正常\n3. Android 特定构建工作正常（仅 non-CO-RE）\n\n该工作流在 x86_64（[.github/workflows/go-c-cpp.yml:9-11]()）和 aarch64（[.github/workflows/go-c-cpp.yml:69-71]()）运行器上运行。\n\n**来源：** [.github/workflows/go-c-cpp.yml:56-65](), [.github/workflows/go-c-cpp.yml:116-125]()\n\n## 发布产物生成\n\n构建系统生成多种发布产物格式：压缩包、Debian 包、Docker 镜像和 Android 特定构建。\n\n```mermaid\ngraph TB\n    subgraph \"发布目标\"\n        RELEASE[\"make release<br/>builder/Makefile.release\"]\n        SNAPSHOT[\"snapshot 目标<br/>Linux 发布版\"]\n        SNAPSHOT_AND[\"snapshot_android 目标<br/>Android 发布版\"]\n        DEB[\"build_deb 目标<br/>Debian 包\"]\n        DOCKER[\"docker build<br/>多架构镜像\"]\n    end\n    \n    subgraph \"产物类型\"\n        LINUX_TAR[\"Linux 压缩包:<br/>ecapture-{VERSION}-linux-{ARCH}.tar.gz<br/>包含: 二进制、LICENSE、README\"]\n        \n        LINUX_NC_TAR[\"Linux Non-CO-RE 压缩包:<br/>ecapture-{VERSION}-linux-{ARCH}-nocore.tar.gz\"]\n        \n        ANDROID_TAR[\"Android 压缩包:<br/>ecapture-{VERSION}-android-{ARCH}-nocore.tar.gz<br/>仅 Non-CO-RE\"]\n        \n        DEB_PKG[\"Debian 包:<br/>ecapture-{VERSION}_{ARCH}.deb<br/>安装到 /usr/local/bin\"]\n        \n        DOCKER_IMG[\"Docker 镜像:<br/>{USERNAME}/ecapture:{VERSION}<br/>{USERNAME}/ecapture:latest<br/>多架构: linux/amd64, linux/arm64\"]\n    end\n    \n    subgraph \"发布过程\"\n        CHECKSUM[\"checksum-{VERSION}.txt<br/>SHA256 校验和\"]\n        \n        GITHUB[\"GitHub Release:<br/>gh release create<br/>上传产物 + 说明\"]\n    end\n    \n    RELEASE --> SNAPSHOT\n    RELEASE --> SNAPSHOT_AND\n    RELEASE --> DEB\n    \n    SNAPSHOT --> LINUX_TAR\n    SNAPSHOT --> LINUX_NC_TAR\n    SNAPSHOT_AND --> ANDROID_TAR\n    DEB --> DEB_PKG\n    DOCKER --> DOCKER_IMG\n    \n    LINUX_TAR --> CHECKSUM\n    LINUX_NC_TAR --> CHECKSUM\n    ANDROID_TAR --> CHECKSUM\n    DEB_PKG --> CHECKSUM\n    \n    CHECKSUM --> GITHUB\n    DOCKER_IMG --> GITHUB\n```\n\n**来源：** [builder/Makefile.release:1-151](), [.github/workflows/release.yml:1-129]()\n\n### 发布压缩包生成\n\n`release_tar` 函数（[functions.mk:62-76]()）创建发布归档：\n\n```makefile\n$(call release_tar,linux,)          # 完整构建（CO-RE + non-CO-RE）\n$(call release_tar,linux,nocore)    # 仅 Non-CO-RE\n$(call release_tar,android,nocore)  # Android（仅 non-CO-RE）\n```\n\n**压缩包内容：**\n1. `ecapture` 二进制\n2. `LICENSE` 文件\n3. `CHANGELOG.md`\n4. `README.md` 和 `README_CN.md`\n\n**命名约定：**\n```\necapture-{VERSION}-{PLATFORM}-{ARCH}{CORE_SUFFIX}.tar.gz\n```\n\n其中：\n- `VERSION` 来自 `SNAPSHOT_VERSION` 或 git 标签\n- `PLATFORM` 是 `linux` 或 `android`\n- `ARCH` 是 `amd64` 或 `arm64`\n- `CORE_SUFFIX` 为空或 `-nocore`\n\n示例：\n- `ecapture-v0.8.0-linux-amd64.tar.gz`（完整构建）\n- `ecapture-v0.8.0-linux-arm64-nocore.tar.gz`（non-CO-RE）\n- `ecapture-v0.8.0-android-arm64-nocore.tar.gz`（Android）\n\n**来源：** [functions.mk:62-76](), [builder/Makefile.release:94-112]()\n\n### Debian 包生成\n\n`build_deb` 目标（[builder/Makefile.release:135-151]()）创建 `.deb` 包：\n\n**包结构：**\n```\nBUILD_DIR/\n├── DEBIAN/\n│   └── control         # 包元数据\n└── usr/local/bin/\n    └── ecapture        # 二进制\n```\n\n**控制文件字段：**\n- `Package`: `ecapture`\n- `Version`: 来自 `PACKAGE_VERSION`\n- `Architecture`: `amd64` 或 `arm64`\n- `Maintainer`: 包维护者\n- `Description`: 简短描述\n- `Homepage`: 项目 URL\n\n**输出文件名：**\n```\necapture-{VERSION}_{ARCH}.deb\n```\n\n示例：`ecapture-0.8.0_amd64.deb`\n\n该包将二进制安装到 `/usr/local/bin/ecapture`，使其在使用 `dpkg -i` 安装后全局可访问。\n\n**来源：** [builder/Makefile.release:135-151]()\n\n### Docker 多架构镜像\n\nDocker 构建（[builder/Dockerfile:1-39]()）使用 BuildKit 创建多架构镜像：\n\n**构建过程：**\n\n1. **基础镜像：** `ubuntu:22.04` 带构建依赖\n2. **编译器安装：** clang-14、llvm-14、gcc\n3. **Go 安装：** 目标架构的特定版本 Go 二进制\n4. **eCapture 构建：** 完整 `make all` 带嵌入字节码\n5. **最终镜像：** 最小 `alpine:latest` 仅包含二进制\n\n**多架构工作流**（[.github/workflows/release.yml:101-129]()）：\n\n```yaml\n- name: Build and push\n  uses: docker/build-push-action@v5\n  with:\n    platforms: linux/amd64,linux/arm64\n    push: true\n    tags: |\n      {USERNAME}/ecapture:{VERSION}\n      {USERNAME}/ecapture:latest\n```\n\n**关键功能：**\n\n- **构建缓存：** 使用注册表缓存加快构建\n- **版本注入：** `--build-args VERSION={VERSION}`\n- **入口点：** `/ecapture` 用于直接执行\n- **多平台：** 同时构建 amd64 和 arm64\n\n使用：\n```bash\ndocker run --rm -it --privileged {USERNAME}/ecapture:latest tls\n```\n\n**来源：** [builder/Dockerfile:1-39](), [.github/workflows/release.yml:101-129]()\n\n### 发布发布工作流\n\n`publish` 目标（[builder/Makefile.release:114-124]()）将产物发布到 GitHub：\n\n```makefile\npublish:\n\tcd $(OUTPUT_DIR)\n\t$(CMD_CHECKSUM) ecapture*v* | $(CMD_SED) 's/.\\/bin\\///g' > checksum-{VERSION}.txt\n\tFILES=$$(ls ecapture-*.tar.gz ecapture*.deb checksum-*.txt)\n\t$(CMD_GITHUB) release create $(DEB_VERSION) $$FILES \\\n\t    --title \"eCapture $(DEB_VERSION)\" \\\n\t    --notes-file $(RELEASE_NOTES)\n```\n\n**过程：**\n\n1. 为所有产物生成 SHA256 校验和\n2. 收集压缩包、`.deb` 文件和校验和文件\n3. 使用标签创建 GitHub release\n4. 上传所有文件\n5. 包含来自 `bin/release_notes.txt` 的发布说明\n\n**发布说明生成**（[.github/workflows/release.yml:68-80]()）使用 GitHub API：\n\n```bash\ngh api /repos/{repo}/releases/generate-notes \\\n    -f tag_name={VERSION} \\\n    -f previous_tag_name={PREVIOUS_TAG}\n```\n\n这会根据提交消息和 PR 自动生成发布说明。\n\n**来源：** [builder/Makefile.release:114-124](), [.github/workflows/release.yml:63-87]()\n\n### Android 特定构建\n\nAndroid 构建专门使用 non-CO-RE 编译（[.github/workflows/go-c-cpp.yml:61-65]()）：\n\n```bash\nANDROID=1 CROSS_ARCH=arm64 make nocore\n```\n\n**理由：**\n\n1. Android 内核通常缺少 BTF 支持\n2. Android 使用自定义内核版本\n3. Non-CO-RE 确保与 Android 内核的兼容性\n4. 更小的二进制（无 CO-RE 字节码开销）\n\n`ANDROID` 标志可能在 `variables.mk` 中触发 Android 特定的预处理器指令或配置。\n\nAndroid 发布版使用 `android` 平台名称标记：\n```\necapture-v0.8.0-android-arm64-nocore.tar.gz\n```\n\n**来源：** [.github/workflows/go-c-cpp.yml:61-65](), [builder/Makefile.release:104-112]()\n\n## CI/CD 集成\n\nGitHub Actions 工作流自动化构建、测试和发布。\n\n```mermaid\ngraph TB\n    subgraph \"CI 工作流 - go-c-cpp.yml\"\n        CI_TRIGGER[\"触发器: push/PR 到 master\"]\n        \n        CI_X86[\"作业: build-on-ubuntu2204<br/>x86_64 运行器\"]\n        CI_ARM[\"作业: build-on-ubuntu2204-arm64<br/>aarch64 运行器\"]\n        \n        CI_STEPS[\"步骤:<br/>1. 安装编译器<br/>2. 构建 CO-RE<br/>3. 运行 golangci-lint<br/>4. 构建 non-CO-RE<br/>5. 交叉编译<br/>6. 运行测试\"]\n    end\n    \n    subgraph \"发布工作流 - release.yml\"\n        REL_TRIGGER[\"触发器: 标签推送 v*\"]\n        \n        REL_BUILD[\"作业: build-on-ubuntu2204<br/>构建发布版\"]\n        \n        REL_STEPS[\"步骤:<br/>1. 生成发布说明<br/>2. 构建 amd64 发布版<br/>3. 构建 arm64 发布版<br/>4. 发布到 GitHub\"]\n        \n        REL_DOCKER[\"作业: build-docker-image<br/>多架构 Docker 构建\"]\n    end\n    \n    subgraph \"CodeQL 工作流 - codeql-analysis.yml\"\n        CQL_TRIGGER[\"触发器: push/PR/计划\"]\n        \n        CQL_STEPS[\"步骤:<br/>1. 安装编译器<br/>2. 使用 autobuild 构建<br/>3. 运行 CodeQL 分析<br/>4. 上传到 Codecov\"]\n    end\n    \n    CI_TRIGGER --> CI_X86\n    CI_TRIGGER --> CI_ARM\n    CI_X86 --> CI_STEPS\n    CI_ARM --> CI_STEPS\n    \n    REL_TRIGGER --> REL_BUILD\n    REL_TRIGGER --> REL_DOCKER\n    REL_BUILD --> REL_STEPS\n    \n    CQL_TRIGGER --> CQL_STEPS\n```\n\n**来源：** [.github/workflows/go-c-cpp.yml:1-128](), [.github/workflows/release.yml:1-129](), [.github/workflows/codeql-analysis.yml:1-92]()\n\n### CI 工作流 (go-c-cpp.yml)\n\n此工作流（[.github/workflows/go-c-cpp.yml:1-128]()）在每次推送和 PR 时运行：\n\n**构建矩阵：**\n- **x86_64 作业：** Ubuntu 22.04 在 x86_64 运行器上（[.github/workflows/go-c-cpp.yml:9-67]()）\n- **aarch64 作业：** Ubuntu 22.04 在 ARM64 运行器上（[.github/workflows/go-c-cpp.yml:69-127]()）\n\n**构建序列：**\n\n1. **安装依赖**（[.github/workflows/go-c-cpp.yml:16-33]()）：\n   - Go 1.24.6\n   - clang-14、llvm-14、gcc\n   - 交叉编译工具链\n   - Linux 内核源码\n\n2. **原生 CO-RE 构建**（[.github/workflows/go-c-cpp.yml:38-44]()）：\n   ```bash\n   make clean\n   make env\n   DEBUG=1 make -j8\n   ```\n\n3. **代码检查**（[.github/workflows/go-c-cpp.yml:45-50]()）：\n   ```bash\n   golangci-lint run\n   ```\n\n4. **原生 non-CO-RE 构建**（[.github/workflows/go-c-cpp.yml:51-55]()）：\n   ```bash\n   make nocore\n   ```\n\n5. **交叉编译 CO-RE**（[.github/workflows/go-c-cpp.yml:56-60]()）：\n   ```bash\n   CROSS_ARCH=arm64 make  # 在 x86_64 上\n   CROSS_ARCH=amd64 make  # 在 ARM64 上\n   ```\n\n6. **交叉编译 Android**（[.github/workflows/go-c-cpp.yml:61-65]()）：\n   ```bash\n   ANDROID=1 CROSS_ARCH=arm64 make nocore\n   ```\n\n7. **运行测试**（[.github/workflows/go-c-cpp.yml:66-67]()）：\n   ```bash\n   go test -v -race ./...\n   ```\n\n这个全面的 CI 确保所有构建配置都能正常工作。\n\n**来源：** [.github/workflows/go-c-cpp.yml:1-128]()\n\n### 发布工作流 (release.yml)\n\n此工作流（[.github/workflows/release.yml:1-129]()）在版本标签（`v*`）时触发：\n\n**作业：**\n\n1. **构建和发布**（[.github/workflows/release.yml:13-100]()）：\n   - 从提交生成发布说明\n   - 构建 amd64 原生发布版\n   - 构建 arm64 交叉编译发布版\n   - 创建 GitHub release\n   - 上传所有产物\n\n2. **Docker 多架构构建**（[.github/workflows/release.yml:101-129]()）：\n   - 为 `linux/amd64` 和 `linux/arm64` 构建\n   - 推送到 Docker Hub\n   - 使用版本和 `latest` 标签\n\n**生成的发布产物：**\n\n对于 **amd64**（在 x86_64 上原生构建）：\n- `ecapture-{VERSION}-linux-amd64.tar.gz`\n- `ecapture-{VERSION}-linux-amd64.deb`\n\n对于 **arm64**（在 x86_64 上交叉编译）：\n- `ecapture-{VERSION}-linux-arm64.tar.gz`\n- `ecapture-{VERSION}-android-arm64-nocore.tar.gz`\n- `ecapture-{VERSION}-linux-arm64.deb`\n\n另外：\n- 包含 SHA256 哈希的 `checksum-{VERSION}.txt`\n- 包含生成的发布说明的 `release_notes.txt`\n\n**来源：** [.github/workflows/release.yml:1-129]()\n\n### CodeQL 分析工作流\n\nCodeQL 工作流（[.github/workflows/codeql-analysis.yml:1-92]()）执行安全扫描：\n\n**触发器：**\n- 推送到 master\n- Pull requests\n- 每周计划（周三 15:42）\n\n**语言矩阵：**\n- C/C++ 分析 eBPF 代码\n- Go 分析应用代码\n\n**过程：**\n1. 安装构建依赖\n2. 运行 autobuild（尝试自动检测构建）\n3. 如果 autobuild 失败，显式运行 `make nocore`\n4. 执行 CodeQL 分析\n5. 将结果上传到 GitHub Security 选项卡\n6. 上传覆盖率到 Codecov\n\n这确保了代码库的持续安全监控。\n\n**来源：** [.github/workflows/codeql-analysis.yml:1-92]()\n\n## 开发环境设置\n\n`builder/init_env.sh` 脚本（[builder/init_env.sh:1-106]()）自动化 Ubuntu 上的开发环境设置：\n\n**功能：**\n\n1. **发行版检测：** 根据 Ubuntu 版本选择适当的 clang 版本\n2. **架构检测：** 配置交叉编译工具链\n3. **依赖安装：** 安装所有必需的构建工具\n4. **内核头文件准备：** 为原生和交叉编译准备头文件\n5. **Go 安装：** 下载并安装 Go 1.24.6\n6. **仓库克隆：** 克隆 eCapture 源码\n\n**使用：**\n```bash\n/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/gojue/ecapture/master/builder/init_env.sh)\"\n```\n\n**支持的 Ubuntu 版本：**\n- 20.04（clang-10）\n- 20.10、21.04、21.10、22.04、22.10（clang-11/12）\n- 23.04、23.10（clang-15）\n- 24.04（clang-18）\n\n运行后，开发人员可以立即使用 `make` 构建 eCapture。\n\n**来源：** [builder/init_env.sh:1-106]()\n\n## 构建系统总结\n\neCapture 构建系统实现了一个生产级的编译和发布流程，具有以下特点：\n\n**架构：**\n- 三文件 Makefile 系统，关注点分离\n- 双 eBPF 编译（CO-RE 和 non-CO-RE）\n- 双向交叉编译（x86_64 ↔ aarch64）\n- 静态链接用于自包含二进制\n- 通过 go-bindata 嵌入资源\n\n**输出：**\n- Linux 原生构建（CO-RE + non-CO-RE）\n- Linux 仅 non-CO-RE 构建\n- Android ARM64 构建\n- Debian 包\n- 多架构 Docker 镜像\n- SHA256 校验和\n\n**自动化：**\n- 在 x86_64 和 aarch64 上持续集成\n- 版本标签时自动发布\n- 使用 CodeQL 进行安全分析\n- 环境设置脚本\n\n这个全面的构建系统确保 eCapture 在各种 Linux 环境中可靠运行，从具有 BTF 启用内核的现代服务器到旧系统和 Android 设备。"
          },
          {
            "page_plan": {
              "id": "5.2",
              "title": "eBPF 程序开发"
            },
            "content": "# eBPF 程序开发\n\n## 目的与范围\n\n本页提供了为 eCapture 开发 eBPF 程序的综合指南。涵盖开发环境设置、常见模式、辅助函数、映射类型、探针附加机制、内存管理策略和调试技术等内容。\n\n关于 eBPF 程序结构模式和组织的详细信息，请参阅 [eBPF 程序结构](#5.2.1)。关于在复杂结构（如 SSL/TLS 库）中计算偏移量的技术，请参阅 [结构体偏移量计算](#5.2.2)。关于编译这些 eBPF 程序的整体构建过程，请参阅 [构建系统](#5.1)。\n\n---\n\n## 开发环境\n\n### CO-RE 与 Non-CO-RE 编译模式\n\neCapture eBPF 程序支持两种编译模式，由 [kern/ecapture.h:18-88]() 中定义的 `NOCORE` 预处理器标志控制：\n\n**CO-RE 模式（一次编译 - 到处运行）：**\n- 使用 BTF（BPF 类型格式）实现内核兼容性\n- 包含具有所有内核类型的 `vmlinux.h`\n- 利用 `bpf_core_read()` 辅助函数实现可移植的结构体访问\n- 需要内核 5.2+ 且支持 BTF\n- 可以使用 `.rodata` 段存储常量值\n\n**Non-CO-RE 模式：**\n- 使用来自特定内核版本的传统内核头文件\n- 直接包含 `<linux/types.h>`、`<linux/bpf.h>` 等\n- 需要为每个目标内核版本单独编译\n- 支持旧版内核（< 5.2）\n- 不能使用 `.rodata` 段（参见 [kern/common.h:63-71]()）\n\n```mermaid\ngraph TB\n    subgraph \"头文件选择 - kern/ecapture.h\"\n        NOCORE{NOCORE<br/>是否定义?}\n        \n        NOCORE -->|否 - CO-RE| CORE_HEADERS[\"vmlinux.h<br/>bpf_core_read.h<br/>bpf_helpers.h<br/>bpf_tracing.h<br/>core_fixes.bpf.h\"]\n        \n        NOCORE -->|是 - Non-CO-RE| NONCORE_HEADERS[\"linux/types.h<br/>linux/bpf.h<br/>linux/socket.h<br/>net/sock.h<br/>uapi/linux/ptrace.h\"]\n    end\n    \n    subgraph \"公共头文件\"\n        CORE_HEADERS --> COMMON[\"common.h<br/>常量<br/>宏<br/>许可证\"]\n        NONCORE_HEADERS --> COMMON\n    end\n    \n    subgraph \"模块特定头文件\"\n        COMMON --> SSL_HEADERS[\"openssl_masterkey.h<br/>boringssl_masterkey.h<br/>openssl_masterkey_3.0.h\"]\n        COMMON --> TC_HEADERS[\"tc.h<br/>网络捕获\"]\n    end\n    \n    subgraph \"编译目标\"\n        SSL_HEADERS --> VARIANTS[\"openssl_kern.o<br/>boringssl_a_13_kern.o<br/>...27+ 个变体\"]\n        TC_HEADERS --> TC_PROGS[\"tc_kern.o\"]\n    end\n```\n\n**来源：** [kern/ecapture.h:18-92](), [kern/common.h:63-71]()\n\n---\n\n## 公共头文件与定义\n\n### 核心头文件：ecapture.h\n\n[kern/ecapture.h:1-92]() 头文件是所有 eBPF 程序的基础，提供：\n\n| 功能 | 用途 | 位置 |\n|---------|---------|----------|\n| 模式选择 | 在 CO-RE 和 Non-CO-RE 之间切换 | 第 18-28、27-88 行 |\n| 辅助宏 | 为 Clang 兼容性重新定义 `asm_inline` | 第 43-46 行 |\n| 内核类型 | 为 Non-CO-RE 提供 `tcphdr`、`ipv6hdr` 结构体 | 第 69-86 行 |\n| 公共包含 | 始终包含 `common.h` | 第 90 行 |\n\n### 公共定义：common.h\n\n[kern/common.h:1-85]() 头文件定义了所有 eBPF 程序中使用的常量和宏：\n\n**调试宏：**\n```c\n#ifdef DEBUG_PRINT\n#define debug_bpf_printk(fmt, ...)                     \\\n    do {                                               \\\n        char s[] = fmt;                                \\\n        bpf_trace_printk(s, sizeof(s), ##__VA_ARGS__); \\\n    } while (0)\n#else\n#define debug_bpf_printk(fmt, ...)\n#endif\n```\n\n**关键常量：**\n\n| 常量 | 值 | 用途 |\n|----------|-------|---------|\n| `TASK_COMM_LEN` | 16 | 进程命令名称长度 |\n| `PATH_MAX_LEN` | 256 | 最大路径长度 |\n| `MAX_DATA_SIZE_OPENSSL` | 16384 | TLS 记录最大大小（RFC 5246） |\n| `MAX_DATA_SIZE_MYSQL` | 256 | MySQL 查询捕获大小 |\n| `MAX_DATA_SIZE_BASH` | 256 | Bash 命令捕获大小 |\n| `SKB_MAX_DATA_SIZE` | 2048 | 网络数据包缓冲区大小 |\n| `AF_INET` | 2 | IPv4 地址族 |\n| `AF_INET6` | 10 | IPv6 地址族 |\n| `TC_ACT_OK` | 0 | TC 程序返回值 |\n\n**目标过滤（仅 CO-RE 模式）：**\n```c\n#ifndef KERNEL_LESS_5_2\nconst volatile u64 target_pid = 0;\nconst volatile u64 target_uid = 0;\nconst volatile u64 target_errno = BASH_ERRNO_DEFAULT;\n#endif\n```\n\n`.rodata` 中的这些 volatile 常量允许用户空间在加载 eBPF 程序之前设置过滤参数。\n\n**来源：** [kern/common.h:18-85](), [kern/ecapture.h:18-92]()\n\n---\n\n## eBPF 映射类型与用法\n\neCapture 使用多种 BPF 映射类型来实现不同的目的。以下是综合概述：\n\n```mermaid\ngraph TB\n    subgraph \"事件输出映射\"\n        PERF[\"BPF_MAP_TYPE_PERF_EVENT_ARRAY<br/>mastersecret_events<br/>skb_events<br/>最大：1024-10240 条目\"]\n    end\n    \n    subgraph \"临时存储映射\"\n        LRU[\"BPF_MAP_TYPE_LRU_HASH<br/>bpf_context<br/>network_map<br/>达到大小限制时自动清除\"]\n        \n        ARRAY[\"BPF_MAP_TYPE_ARRAY<br/>bpf_context_gen<br/>用于栈解决方案的单条目\"]\n        \n        PERCPU[\"BPF_MAP_TYPE_PERCPU_ARRAY<br/>skb_data_buffer_heap<br/>每 CPU 临时缓冲区\"]\n    end\n    \n    subgraph \"使用模式\"\n        PERF -->|\"发送事件到用户空间\"| OUTPUT[\"用户空间<br/>事件读取器\"]\n        \n        LRU -->|\"存储 PID 到上下文<br/>网络元组映射\"| CONTEXT[\"进程<br/>归属\"]\n        \n        ARRAY -->|\"规避 512 字节<br/>栈限制\"| HEAP[\"类堆<br/>分配\"]\n        \n        PERCPU -->|\"每 CPU 缓冲区<br/>避免锁\"| EFFICIENCY[\"无锁<br/>性能\"]\n    end\n```\n\n### 映射类型比较\n\n| 映射类型 | 使用场景 | 关键特性 | 示例 |\n|----------|-----------|--------------|---------|\n| `PERF_EVENT_ARRAY` | 向用户空间发送事件 | 高吞吐量流式传输 | `mastersecret_events` [kern/openssl_masterkey.h:48-53]() |\n| `LRU_HASH` | PID/连接跟踪 | 达到容量时自动清除 | `bpf_context` [kern/boringssl_masterkey.h:115-119]()、`network_map` [kern/tc.h:73-77]() |\n| `ARRAY` | 固定大小查找 | 快速索引访问 | `bpf_context_gen` [kern/openssl_masterkey.h:62-67]() |\n| `PERCPU_ARRAY` | 每 CPU 临时缓冲区 | 无锁操作 | `skb_data_buffer_heap` [kern/tc.h:65-69]() |\n\n### 常见映射定义\n\n**事件输出映射（主密钥提取）：**\n```c\nstruct {\n    __uint(type, BPF_MAP_TYPE_PERF_EVENT_ARRAY);\n    __uint(key_size, sizeof(u32));\n    __uint(value_size, sizeof(u32));\n    __uint(max_entries, 1024);\n} mastersecret_events SEC(\".maps\");\n```\n\n**网络连接跟踪映射：**\n```c\nstruct {\n    __uint(type, BPF_MAP_TYPE_LRU_HASH);\n    __type(key, struct net_id_t);      // 4 元组\n    __type(value, struct net_ctx_t);   // PID/UID/comm\n    __uint(max_entries, 10240);\n} network_map SEC(\".maps\");\n```\n\n**来源：** [kern/tc.h:57-77](), [kern/openssl_masterkey.h:48-67](), [kern/boringssl_masterkey.h:107-126]()\n\n---\n\n## 探针类型与附加点\n\neCapture 使用三种主要的 eBPF 程序类型来实现不同的拦截场景：\n\n```mermaid\ngraph LR\n    subgraph \"应用程序空间\"\n        APP[\"用户应用程序<br/>OpenSSL/Go/MySQL\"]\n    end\n    \n    subgraph \"eBPF 探针类型\"\n        UPROBE[\"uprobe<br/>SEC('uprobe/SSL_write_key')<br/>用户函数钩子\"]\n        \n        KPROBE[\"kprobe<br/>SEC('kprobe/tcp_sendmsg')<br/>内核函数钩子\"]\n        \n        TC[\"TC 分类器<br/>SEC('classifier')<br/>网络数据包钩子\"]\n    end\n    \n    subgraph \"内核空间\"\n        KERNEL_FUNC[\"tcp_sendmsg()<br/>udp_sendmsg()<br/>网络栈\"]\n        \n        NET_LAYER[\"网络设备<br/>入口/出口\"]\n    end\n    \n    APP -->|\"调用 SSL 函数\"| UPROBE\n    UPROBE -->|\"读取内存\"| APP\n    \n    APP -->|\"进行系统调用\"| KERNEL_FUNC\n    KERNEL_FUNC --> KPROBE\n    \n    NET_LAYER -->|\"数据包处理\"| TC\n    TC -->|\"读取数据包数据\"| NET_LAYER\n```\n\n### Uprobe 程序\n\nUprobe 附加到用户空间函数以拦截函数调用并提取数据。主要用例：SSL/TLS 主密钥提取。\n\n**示例：SSL 主密钥捕获**\n[kern/openssl_masterkey.h:81-82]()\n```c\nSEC(\"uprobe/SSL_write_key\")\nint probe_ssl_master_key(struct pt_regs *ctx)\n```\n\n**关键模式：**\n1. **访问函数参数：** 使用 `PT_REGS_PARM1(ctx)` 获取第一个参数（ssl_st 指针）\n2. **读取用户空间内存：** 使用 `bpf_probe_read_user()` 读取结构体字段\n3. **按 PID/UID 过滤：** 在 CO-RE 模式下检查 `target_pid`、`target_uid`\n\n**来源：** [kern/openssl_masterkey.h:81-257](), [kern/boringssl_masterkey.h:169-403]()\n\n### Kprobe 程序\n\nKprobe 附加到内核函数进行连接跟踪和网络归属。\n\n**示例：TCP 连接跟踪**\n[kern/tc.h:290-347]()\n```c\nSEC(\"kprobe/tcp_sendmsg\")\nint tcp_sendmsg(struct pt_regs *ctx)\n```\n\n**用途：** 提取连接 4 元组（src_ip、src_port、dst_ip、dst_port）并与 PID/UID 关联。\n\n**关键操作：**\n1. 提取 PID/UID：`bpf_get_current_pid_tgid()`、`bpf_get_current_uid_gid()`\n2. 读取套接字结构：`PT_REGS_PARM1(ctx)` 获取 `struct sock *`\n3. 提取连接信息：IPv4/IPv6 地址和端口\n4. 存储到映射：`bpf_map_update_elem(&network_map, &conn_id, &net_ctx, BPF_ANY)`\n\n**来源：** [kern/tc.h:290-397]()\n\n### TC 分类器程序\n\nTC（流量控制）分类器在设备层捕获入口和出口流量的网络数据包。\n\n**示例：数据包捕获**\n[kern/tc.h:279-288]()\n```c\nSEC(\"classifier\")\nint egress_cls_func(struct __sk_buff *skb)\nSEC(\"classifier\")\nint ingress_cls_func(struct __sk_buff *skb)\n```\n\n**两者都调用公共函数：** [kern/tc.h:135-276]()\n```c\nstatic __always_inline int capture_packets(struct __sk_buff *skb, bool is_ingress)\n```\n\n**关键操作：**\n1. 解析数据包头：以太网 → IP/IPv6 → TCP/UDP\n2. 从数据包提取 4 元组\n3. 在 `network_map` 中查找 PID 归属\n4. 应用 PID/UID 过滤器\n5. 通过 `bpf_perf_event_output()` 发送到用户空间\n\n**来源：** [kern/tc.h:135-288]()\n\n---\n\n## 内存管理与栈限制\n\n### 512 字节栈问题\n\neBPF 程序有严格的 **512 字节栈限制**。大型结构体（例如 `mastersecret_t` 约 320 字节）无法在栈上分配。\n\n### 解决方案：类堆分配模式\n\neCapture 使用 `BPF_MAP_TYPE_ARRAY` 的巧妙模式来模拟堆分配：\n\n```mermaid\ngraph LR\n    subgraph \"映射作为堆\"\n        ARRAY_MAP[\"BPF_MAP_TYPE_ARRAY<br/>bpf_context_gen<br/>max_entries: 1<br/>value: struct mastersecret_t\"]\n    end\n    \n    subgraph \"临时存储\"\n        HASH_MAP[\"BPF_MAP_TYPE_LRU_HASH<br/>bpf_context<br/>key: u64 (pid_tgid)<br/>value: struct mastersecret_t\"]\n    end\n    \n    subgraph \"eBPF 程序流程\"\n        LOOKUP1[\"1. 在 bpf_context_gen<br/>中查找 key=0\"]\n        UPDATE[\"2. 以当前 PID 作为键<br/>更新 bpf_context\"]\n        LOOKUP2[\"3. 在 bpf_context 中查找<br/>返回指向映射内存的指针\"]\n        USE[\"4. 使用指针<br/>填充结构体\"]\n    end\n    \n    ARRAY_MAP --> LOOKUP1\n    LOOKUP1 --> UPDATE\n    UPDATE --> HASH_MAP\n    HASH_MAP --> LOOKUP2\n    LOOKUP2 --> USE\n```\n\n**实现：**\n[kern/openssl_masterkey.h:71-78]()\n```c\nstatic __always_inline struct mastersecret_t *make_event() {\n    u32 key_gen = 0;\n    struct mastersecret_t *bpf_ctx = bpf_map_lookup_elem(&bpf_context_gen, &key_gen);\n    if (!bpf_ctx) return 0;\n    u64 id = bpf_get_current_pid_tgid();\n    bpf_map_update_elem(&bpf_context, &id, bpf_ctx, BPF_ANY);\n    return bpf_map_lookup_elem(&bpf_context, &id);\n}\n```\n\n**工作原理：**\n1. `bpf_context_gen` 是一个单条目数组，保存结构体模板\n2. 在键 0 处查找返回指向映射分配内存的指针\n3. 复制到 `bpf_context` 哈希映射，以 PID 为键\n4. 从哈希映射返回指针（在程序持续期间保证有效）\n5. 此指针引用映射内存（而非栈），绕过 512 字节限制\n\n**替代方案：每 CPU 数组**\n[kern/tc.h:92-100]()\n```c\nstatic __always_inline struct skb_data_event_t *make_skb_data_event() {\n    u32 kZero = 0;\n    struct skb_data_event_t *event =\n        bpf_map_lookup_elem(&skb_data_buffer_heap, &kZero);\n    if (event == NULL) {\n        return NULL;\n    }\n    return event;\n}\n```\n\n这使用 `BPF_MAP_TYPE_PERCPU_ARRAY` 实现无锁的每 CPU 临时存储。\n\n**来源：** [kern/openssl_masterkey.h:71-78](), [kern/boringssl_masterkey.h:130-137](), [kern/tc.h:92-100]()\n\n---\n\n## 过滤与目标选择\n\n### PID 和 UID 过滤\n\neCapture 实现可选过滤以减少开销并专注于特定进程：\n\n```mermaid\ngraph TB\n    subgraph \"用户空间配置\"\n        CLI[\"CLI 标志<br/>--pid=1234<br/>--uid=1000\"]\n    end\n    \n    subgraph \"eBPF .rodata 段 - 仅 CO-RE\"\n        RODATA[\"const volatile u64 target_pid = 0;<br/>const volatile u64 target_uid = 0;\"]\n    end\n    \n    subgraph \"eBPF 程序过滤\"\n        GET_PID[\"u32 pid = bpf_get_current_pid_tgid() >> 32;<br/>u32 uid = bpf_get_current_uid_gid();\"]\n        \n        CHECK_PID{\"target_pid != 0 &&<br/>target_pid != pid?\"}\n        CHECK_UID{\"target_uid != 0 &&<br/>target_uid != uid?\"}\n        \n        RETURN_EARLY[\"return 0;<br/>跳过处理\"]\n        CONTINUE[\"继续处理<br/>捕获事件\"]\n    end\n    \n    CLI -->|\"加载前设置\"| RODATA\n    RODATA --> GET_PID\n    GET_PID --> CHECK_PID\n    CHECK_PID -->|是| RETURN_EARLY\n    CHECK_PID -->|否| CHECK_UID\n    CHECK_UID -->|是| RETURN_EARLY\n    CHECK_UID -->|否| CONTINUE\n```\n\n**实现模式：**\n[kern/openssl_masterkey.h:88-96]()\n```c\n#ifndef KERNEL_LESS_5_2\n    // if target_ppid is 0 then we target all pids\n    if (target_pid != 0 && target_pid != pid) {\n        return 0;\n    }\n    if (target_uid != 0 && target_uid != uid) {\n        return 0;\n    }\n#endif\n```\n\n**关键点：**\n- 仅在 CO-RE 模式下可用（内核 5.2+）\n- 变量在 `.rodata` 中声明为 `const volatile`\n- 值 0 表示\"捕获所有\"（无过滤）\n- 提前返回最小化被过滤进程的开销\n\n### 网络层过滤\n\nTC 程序还通过桩函数支持 L2/L3/L4 数据包过滤：\n\n[kern/tc.h:122-132]()\n```c\n// filter_pcap_ebpf_l2 是用于注入 pcap 过滤器的桩函数。\nstatic __noinline bool filter_pcap_ebpf_l2(void *_skb, void *__skb,\n                                           void *___skb, void *data,\n                                           void* data_end) {\n    return data != data_end && _skb == __skb && __skb == ___skb;\n}\n\nstatic __always_inline bool filter_pcap_l2(struct __sk_buff *skb, void *data,\n                                           void *data_end) {\n    return filter_pcap_ebpf_l2((void *) skb, (void *) skb, (void *) skb, data,\n                               data_end);\n}\n```\n\n此桩函数可以在编译时替换为 pcap 过滤器字节码，实现 BPF 级别的数据包过滤。\n\n**来源：** [kern/common.h:66-71](), [kern/openssl_masterkey.h:88-96](), [kern/tc.h:122-150]()\n\n---\n\n## 辅助函数与宏\n\n### 内存访问辅助函数\n\n**CO-RE 安全读取：**\n[kern/tc.h:22-28]()\n```c\n#define READ_KERN(ptr)                                                  \\\n    ({                                                                  \\\n        typeof(ptr) _val;                                               \\\n        __builtin_memset((void *)&_val, 0, sizeof(_val));               \\\n        bpf_core_read((void *)&_val, sizeof(_val), &ptr);               \\\n        _val;                                                           \\\n    })\n```\n\n**用户空间内存读取：**\n- `bpf_probe_read_user()` - 从用户空间地址读取\n- `bpf_probe_read_kernel()` - 从内核内存读取（在初始复制之后）\n\n### SKB 数据验证\n\n由于 eBPF 验证器的要求，网络数据包处理需要仔细的边界检查：\n\n[kern/tc.h:102-119]()\n```c\nstatic __always_inline bool skb_revalidate_data(struct __sk_buff *skb,\n                                                uint8_t **head, uint8_t **tail,\n                                                const u32 offset) {\n    if (*head + offset > *tail) {\n        if (bpf_skb_pull_data(skb, offset) < 0) {\n            return false;\n        }\n\n        *head = (uint8_t *)(long)skb->data;\n        *tail = (uint8_t *)(long)skb->data_end;\n\n        if (*head + offset > *tail) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```\n\n**用途：** 确保数据包数据在访问前在线性缓冲区中可用。验证器跟踪 `skb->data` 和 `skb->data_end` 指针，并要求证明访问在边界内。\n\n### 辅助函数摘要表\n\n| 函数 | 用途 | 使用上下文 |\n|----------|---------|---------------|\n| `bpf_get_current_pid_tgid()` | 获取当前 PID/TID | 所有探针类型 |\n| `bpf_get_current_uid_gid()` | 获取当前 UID/GID | 所有探针类型 |\n| `bpf_get_current_comm()` | 获取进程名称 | 所有探针类型 |\n| `bpf_probe_read_user()` | 读取用户空间内存 | Uprobe 程序 |\n| `bpf_probe_read_kernel()` | 读取内核内存 | 复制到栈后 |\n| `bpf_map_lookup_elem()` | 查找映射条目 | 所有上下文 |\n| `bpf_map_update_elem()` | 更新映射条目 | 所有上下文 |\n| `bpf_perf_event_output()` | 向用户空间发送事件 | 事件报告 |\n| `bpf_ntohs()` / `bpf_htons()` | 网络字节序转换 | 网络程序 |\n| `bpf_skb_pull_data()` | 将数据包数据拉到线性缓冲区 | TC 程序 |\n| `bpf_core_read()` | CO-RE 安全字段读取 | 仅 CO-RE 模式 |\n\n**来源：** [kern/tc.h:22-119](), [kern/openssl_masterkey.h:71-78]()\n\n---\n\n## 事件报告机制\n\n### Perf 事件输出\n\n从 eBPF 向用户空间发送数据的主要机制：\n\n```mermaid\ngraph LR\n    subgraph \"eBPF 程序\"\n        EVENT_STRUCT[\"struct mastersecret_t<br/>或<br/>struct skb_data_event_t\"]\n        \n        OUTPUT_CALL[\"bpf_perf_event_output(ctx,<br/>&events_map,<br/>BPF_F_CURRENT_CPU,<br/>event, size)\"]\n    end\n    \n    subgraph \"内核\"\n        PERF_MAP[\"BPF_MAP_TYPE_PERF_EVENT_ARRAY<br/>每 CPU 环形缓冲区\"]\n    end\n    \n    subgraph \"用户空间\"\n        READER[\"perfEventReader<br/>或<br/>ringbufEventReader\"]\n        \n        WORKER[\"事件工作器<br/>解码与处理\"]\n    end\n    \n    EVENT_STRUCT --> OUTPUT_CALL\n    OUTPUT_CALL --> PERF_MAP\n    PERF_MAP --> READER\n    READER --> WORKER\n```\n\n**标准模式：**\n[kern/openssl_masterkey.h:165-168]()\n```c\nbpf_perf_event_output(\n    ctx, &mastersecret_events, BPF_F_CURRENT_CPU, \n    mastersecret, sizeof(struct mastersecret_t));\n```\n\n**标志：**\n- `BPF_F_CURRENT_CPU` - 发送到当前 CPU 的缓冲区（无锁）\n- 对于 TC 程序，编码数据包长度：`flags |= (u64)skb->len << 32;` [kern/tc.h:260-261]()\n\n### 最小与完整事件数据\n\nTC 程序通过在可能的情况下发送最小元数据来优化带宽：\n\n[kern/tc.h:263-271]()\n```c\n// if net_packet event not chosen, send minimal data only:\n//     timestamp (u64)      8 字节\n//     pid (u32)            4 字节\n//     comm (char[])       16 字节\n//     packet len (u32)     4 字节\n//     ifindex (u32)        4 字节\nsize_t pkt_size = TC_PACKET_MIN_SIZE;\nbpf_perf_event_output(skb, &skb_events, flags, &event, pkt_size);\n```\n\n这允许 eBPF 程序在需要时发送元数据加完整数据包数据，或者仅发送元数据以减少流量。\n\n**来源：** [kern/tc.h:260-271](), [kern/openssl_masterkey.h:165-168](), [kern/boringssl_masterkey.h:339-341]()\n\n---\n\n## 调试技术\n\n### 调试打印宏\n\n[kern/common.h:18-26]()\n```c\n#ifdef DEBUG_PRINT\n#define debug_bpf_printk(fmt, ...)                     \\\n    do {                                               \\\n        char s[] = fmt;                                \\\n        bpf_trace_printk(s, sizeof(s), ##__VA_ARGS__); \\\n    } while (0)\n#else\n#define debug_bpf_printk(fmt, ...)\n#endif\n```\n\n**使用模式：**\n```c\ndebug_bpf_printk(\"TLS version :%d\\n\", mastersecret->version);\ndebug_bpf_printk(\"client_random: %x %x %x\\n\", \n    mastersecret->client_random[0], \n    mastersecret->client_random[1],\n    mastersecret->client_random[2]);\n```\n\n**查看输出：**\n```bash\n# 读取 trace_pipe 查看 bpf_printk 输出\nsudo cat /sys/kernel/debug/tracing/trace_pipe\n```\n\n### 调试工作流程\n\n```mermaid\ngraph TB\n    subgraph \"开发周期\"\n        WRITE[\"1. 编写 eBPF 程序<br/>添加 debug_bpf_printk 调用\"]\n        COMPILE[\"2. 使用 DEBUG_PRINT 编译<br/>make DEBUG=1\"]\n        LOAD[\"3. 加载程序\"]\n        RUN[\"4. 运行测试应用程序<br/>触发探针\"]\n        VIEW[\"5. 查看 trace_pipe<br/>检查调试输出\"]\n        VERIFY[\"6. 验证逻辑<br/>检查偏移量/值\"]\n    end\n    \n    subgraph \"常见问题\"\n        VERIFIER[\"验证器拒绝<br/>检查边界、栈使用\"]\n        OFFSET[\"错误的偏移量<br/>结构体已更改\"]\n        NULL[\"空指针<br/>无效的内存访问\"]\n    end\n    \n    WRITE --> COMPILE\n    COMPILE --> LOAD\n    LOAD --> RUN\n    RUN --> VIEW\n    VIEW --> VERIFY\n    \n    VERIFY -->|\"验证器错误\"| VERIFIER\n    VERIFY -->|\"错误的值\"| OFFSET\n    VERIFY -->|\"读取失败\"| NULL\n    \n    VERIFIER --> WRITE\n    OFFSET --> WRITE\n    NULL --> WRITE\n```\n\n### 常见调试场景\n\n**场景 1：验证器拒绝**\n```\n; ret = bpf_probe_read_user(&mastersecret->secret_, sizeof(mastersecret->secret_), ms_ptr);\nR0=inv(id=0) R1_w=map_value(id=0,off=40,ks=4,vs=320,imm=0) \nR2=inv48 R3_w=inv(id=0) R6=ctx(id=0,off=0,imm=0) R10=fp0\n; stack out of bounds\n```\n\n**解决方案：** 使用基于映射的分配模式而不是栈分配\n\n**场景 2：读取失败（ret != 0）**\n```c\nret = bpf_probe_read_user(&version, sizeof(version), (void *)ssl_version_ptr);\nif (ret) {\n    debug_bpf_printk(\"bpf_probe_read tls_version failed, ret :%d\\n\", ret);\n    return 0;\n}\n```\n\n**可能原因：** 无效指针、错误的偏移量、换出的内存\n\n**场景 3：错误的结构体偏移量**\n\n使用用户空间工具验证偏移量：\n- [utils/boringssl-offset.c:1-78]() - 生成 BoringSSL 偏移量\n- 针对目标库头文件编译\n- 与 eBPF 程序的偏移量常量进行比较\n\n**来源：** [kern/common.h:18-26](), [kern/openssl_masterkey.h:97-257]()\n\n---\n\n## 代码组织模式\n\n### 结构声明模式\n\n```mermaid\ngraph TB\n    subgraph \"eBPF 源文件组织\"\n        INCLUDE[\"1. 包含头文件<br/>ecapture.h (CO-RE/non-CO-RE)<br/>common.h (常量)\"]\n        \n        CONSTANTS[\"2. 定义常量<br/>TLS1_3_VERSION<br/>SSL3_RANDOM_SIZE<br/>结构体偏移量\"]\n        \n        STRUCTS[\"3. 定义事件结构体<br/>struct mastersecret_t<br/>struct skb_data_event_t\"]\n        \n        MAPS[\"4. 声明 eBPF 映射<br/>BPF_MAP_TYPE_PERF_EVENT_ARRAY<br/>BPF_MAP_TYPE_LRU_HASH\"]\n        \n        HELPERS[\"5. 静态辅助函数<br/>make_event()<br/>skb_revalidate_data()\"]\n        \n        PROBES[\"6. 探针函数<br/>SEC('uprobe/...')<br/>SEC('kprobe/...')<br/>SEC('classifier')\"]\n    end\n    \n    INCLUDE --> CONSTANTS\n    CONSTANTS --> STRUCTS\n    STRUCTS --> MAPS\n    MAPS --> HELPERS\n    HELPERS --> PROBES\n```\n\n### 文件命名约定\n\n| 模式 | 用途 | 示例 |\n|---------|---------|----------|\n| `*_masterkey.h` | 主密钥提取 | `openssl_masterkey.h`、`boringssl_masterkey.h` |\n| `*_const.h` | 偏移量常量 | `boringssl_const.h` |\n| `tc.h` | 流量控制程序 | 数据包捕获和连接跟踪 |\n| `common.h` | 共享定义 | 常量、宏、许可证 |\n| `ecapture.h` | 主头文件 | 模式切换、包含 |\n\n### 多版本支持模式\n\neCapture 为不同的库版本维护单独的 eBPF 程序：\n\n```\nkern/\n├── openssl_1_0_2a_kern.c        # OpenSSL 1.0.2a\n├── openssl_1_1_0a_kern.c        # OpenSSL 1.1.0a\n├── openssl_1_1_1j_kern.c        # OpenSSL 1.1.1j\n├── openssl_3_0_0_kern.c         # OpenSSL 3.0.0\n├── openssl_3_2_0_kern.c         # OpenSSL 3.2.0\n├── boringssl_a_13_kern.c        # Android 13 BoringSSL\n├── boringssl_a_14_kern.c        # Android 14 BoringSSL\n└── ...\n```\n\n每个都包含特定版本的偏移量常量，但共享头文件中的公共逻辑。\n\n**来源：** [kern/openssl_masterkey.h:1-257](), [kern/boringssl_masterkey.h:1-403](), [kern/tc.h:1-397]()\n\n---\n\n## 最佳实践摘要\n\n| 实践 | 理由 | 实现 |\n|----------|-----------|----------------|\n| **使用基于映射的分配** | 避免 512 字节栈限制 | `make_event()` 模式 |\n| **始终检查 bpf_probe_read 返回值** | 检测无效内存访问 | `if (ret) return 0;` |\n| **对辅助函数使用 `__always_inline`** | 减少栈使用，提高性能 | 所有辅助函数 |\n| **在解引用前验证指针** | 防止验证器拒绝 | `if (!ptr) return 0;` |\n| **自由使用 `debug_bpf_printk`** | 在开发期间辅助调试 | 整个探针函数 |\n| **应用早期过滤** | 最小化开销 | 在函数开始处进行 PID/UID 检查 |\n| **在 pull 后重新验证 SKB 数据** | 满足验证器对数据包访问的要求 | `skb_revalidate_data()` |\n| **尽可能使用 CO-RE** | 提高可移植性 | `bpf_core_read()` 宏 |\n| **保持探针函数专注** | 降低复杂性，辅助验证器 | 每个探针单一职责 |\n| **记录偏移量计算** | 维护版本兼容性 | 注释 + 偏移量工具 |\n\n**来源：** [kern/common.h:1-85](), [kern/tc.h:1-397](), [kern/openssl_masterkey.h:1-257]()"
          },
          {
            "page_plan": {
              "id": "5.2.1",
              "title": "eBPF 程序结构"
            },
            "content": "# eBPF 程序结构\n\n本页面记录了 eCapture 的 eBPF 程序中使用的通用结构模式、约定和机制。内容涵盖 map 类型、探针挂载策略、事件结构、过滤模式以及所有捕获模块共享的数据导出机制。\n\n有关构建和编译 eBPF 程序的信息，请参阅[构建系统](#5.1)。有关计算库特定钩子的结构体偏移量的指导，请参阅[结构体偏移量计算](#5.2.2)。有关创建使用 eBPF 程序的新模块的信息，请参阅[添加新模块](#5.3)。\n\n## eBPF 程序剖析\n\neCapture 中的所有 eBPF 程序都遵循通用结构，包括头文件包含、map 定义、事件结构、辅助函数和探针入口点。下图展示了这种标准剖析结构：\n\n```mermaid\ngraph TB\n    subgraph \"头文件包含\"\n        H1[\"ecapture.h<br/>(CO-RE 或 non-CO-RE 设置)\"]\n        H2[\"common.h<br/>(常量、宏)\"]\n        H3[\"tc.h<br/>(TC 特定辅助函数)\"]\n    end\n    \n    subgraph \"Map 定义\"\n        M1[\"BPF_MAP_TYPE_PERF_EVENT_ARRAY<br/>events map\"]\n        M2[\"BPF_MAP_TYPE_HASH<br/>状态跟踪 maps\"]\n        M3[\"BPF_MAP_TYPE_PERCPU_ARRAY<br/>堆缓冲区\"]\n        M4[\"BPF_MAP_TYPE_LRU_HASH<br/>连接跟踪\"]\n    end\n    \n    subgraph \"数据结构\"\n        D1[\"事件结构<br/>(struct event, ssl_data_event_t, 等)\"]\n        D2[\"键结构<br/>(net_id_t, 等)\"]\n        D3[\"上下文结构<br/>(net_ctx_t, 等)\"]\n    end\n    \n    subgraph \"辅助函数\"\n        F1[\"create_*_event()<br/>事件初始化\"]\n        F2[\"process_*_data()<br/>数据处理\"]\n        F3[\"过滤函数<br/>PID/UID 检查\"]\n    end\n    \n    subgraph \"探针入口点\"\n        P1[\"SEC(uprobe/*)<br/>函数入口钩子\"]\n        P2[\"SEC(uretprobe/*)<br/>函数返回钩子\"]\n        P3[\"SEC(kprobe/*)<br/>内核钩子\"]\n        P4[\"SEC(classifier)<br/>TC 分类器\"]\n    end\n    \n    H1 --> M1\n    H2 --> M1\n    H3 --> M4\n    M1 --> D1\n    M2 --> D1\n    D1 --> F1\n    F1 --> P1\n    F1 --> P2\n    P1 --> P2\n    P3 --> M4\n    P4 --> M4\n```\n\n来源：[kern/ecapture.h](), [kern/common.h](), [kern/bash_kern.c](), [kern/nspr_kern.c](), [kern/mysqld_kern.c](), [kern/postgres_kern.c](), [kern/tc.h]()\n\n## 头文件与编译模式\n\neCapture 支持两种 eBPF 编译模式：CO-RE（一次编译 - 到处运行）和 non-CO-RE。模式由 `NOCORE` 预处理器定义的存在与否决定。\n\n### CO-RE 模式（启用 BTF）\n\n当启用 CO-RE（未定义 `NOCORE`）时，程序使用：\n- `vmlinux.h` - 来自 BTF 的内核类型定义\n- `bpf/bpf_core_read.h` - CO-RE 字段访问宏\n- `core_fixes.bpf.h` - 内核兼容性问题的变通方法\n\n### Non-CO-RE 模式（传统）\n\n当定义 `NOCORE` 时，程序使用：\n- 来自构建系统的内核头文件\n- 传统的 `bpf_probe_read()` 辅助函数\n- 架构特定的结构定义\n\n两种模式都包含：\n- `bpf/bpf_helpers.h` - BPF 辅助函数声明\n- `bpf/bpf_tracing.h` - 跟踪宏如 `PT_REGS_PARM*`\n- `bpf/bpf_endian.h` - 字节序转换辅助函数\n\n**头文件包含模式：**\n\n```\necapture.h 包含：\n├── CO-RE 模式 (#ifndef NOCORE)\n│   ├── vmlinux.h\n│   ├── bpf/bpf_core_read.h\n│   ├── bpf/bpf_helpers.h\n│   ├── bpf/bpf_tracing.h\n│   ├── bpf/bpf_endian.h\n│   └── core_fixes.bpf.h\n├── Non-CO-RE 模式 (#ifdef NOCORE)\n│   ├── linux/types.h\n│   ├── uapi/linux/ptrace.h\n│   ├── linux/bpf.h\n│   ├── linux/socket.h\n│   ├── net/sock.h\n│   ├── bpf/bpf_helpers.h\n│   ├── bpf/bpf_tracing.h\n│   ├── bpf/bpf_endian.h\n│   └── uapi/linux/pkt_cls.h (用于 TC 程序)\n└── common.h (总是包含)\n```\n\n来源：[kern/ecapture.h:15-93](), [kern/common.h:15-85]()\n\n## Map 类型与使用模式\n\neCapture eBPF 程序使用多种 BPF map 类型，每种都在从内核到用户空间的数据流中发挥特定作用。\n\n```mermaid\ngraph LR\n    subgraph \"探针函数\"\n        ENTRY[\"uprobe/kprobe 入口<br/>捕获参数\"]\n        EXIT[\"uretprobe/kretprobe 返回<br/>捕获返回值\"]\n    end\n    \n    subgraph \"Map 类型\"\n        PERF[\"BPF_MAP_TYPE_PERF_EVENT_ARRAY<br/>发送事件到用户空间\"]\n        HASH[\"BPF_MAP_TYPE_HASH<br/>存储入口/返回间的状态<br/>键：pid/tid\"]\n        PERCPU[\"BPF_MAP_TYPE_PERCPU_ARRAY<br/>每 CPU 堆分配<br/>避免 512 字节栈限制\"]\n        LRU[\"BPF_MAP_TYPE_LRU_HASH<br/>连接跟踪<br/>自动驱逐\"]\n    end\n    \n    subgraph \"用户空间\"\n        READER[\"事件读取器<br/>perfEventReader<br/>ringbufEventReader\"]\n    end\n    \n    ENTRY -->|\"存储参数\"| HASH\n    ENTRY -->|\"分配缓冲区\"| PERCPU\n    EXIT -->|\"查找参数\"| HASH\n    EXIT -->|\"删除状态\"| HASH\n    PERCPU -->|\"构建事件\"| PERF\n    HASH -->|\"构建事件\"| PERF\n    PERF -->|\"bpf_perf_event_output()\"| READER\n    \n    TC[\"TC 分类器<br/>capture_packets()\"] -->|\"查找连接\"| LRU\n    KPROBE[\"kprobe tcp_sendmsg<br/>udp_sendmsg\"] -->|\"存储连接\"| LRU\n```\n\n### BPF_MAP_TYPE_PERF_EVENT_ARRAY\n\n用于将捕获的事件从内核发送到用户空间。每个模块定义一个或多个 perf 事件数组：\n\n| 模块 | Map 名称 | 事件类型 |\n|--------|----------|------------|\n| bash | `events` | `struct event` |\n| nspr | `nspr_events` | `struct ssl_data_event_t` |\n| mysqld | `events` | `struct data_t` |\n| postgres | `events` | `struct data_t` |\n| tc | `skb_events` | `struct skb_data_event_t` |\n\n**定义模式：**\n```c\nstruct {\n    __uint(type, BPF_MAP_TYPE_PERF_EVENT_ARRAY);\n    __uint(key_size, sizeof(u32));\n    __uint(value_size, sizeof(u32));\n    __uint(max_entries, 1024);\n} events SEC(\".maps\");\n```\n\n来源：[kern/bash_kern.c:26-31](), [kern/nspr_kern.c:29-34](), [kern/mysqld_kern.c:36-41](), [kern/postgres_kern.c:24-29](), [kern/tc.h:57-62]()\n\n### BPF_MAP_TYPE_HASH\n\n用于在探针入口和返回之间存储状态，通常将线程 ID 映射到捕获的参数：\n\n**通用模式 - 参数存储：**\n```c\n// 在函数入口存储缓冲区指针\nstruct {\n    __uint(type, BPF_MAP_TYPE_HASH);\n    __type(key, u64);              // pid_tgid\n    __type(value, const char*);    // 缓冲区指针\n    __uint(max_entries, 1024);\n} active_ssl_read_args_map SEC(\".maps\");\n\n// 存储完整事件以跟踪返回值\nstruct {\n    __uint(type, BPF_MAP_TYPE_HASH);\n    __type(key, u32);              // pid\n    __type(value, struct event);\n    __uint(max_entries, 1024);\n} events_t SEC(\".maps\");\n```\n\n**生命周期模式：**\n1. 入口探针：`bpf_map_update_elem(&map, &key, &value, BPF_ANY)`\n2. 返回探针：`bpf_map_lookup_elem(&map, &key)`\n3. 返回探针：`bpf_map_delete_elem(&map, &key)`（清理）\n\n来源：[kern/nspr_kern.c:41-53](), [kern/bash_kern.c:33-38](), [kern/mysqld_kern.c:29-34]()\n\n### BPF_MAP_TYPE_PERCPU_ARRAY\n\n用作每 CPU 堆以避免 512 字节的 BPF 栈限制。允许分配大型事件结构：\n\n```c\nstruct {\n    __uint(type, BPF_MAP_TYPE_PERCPU_ARRAY);\n    __type(key, u32);\n    __type(value, struct ssl_data_event_t);  // 可以 > 512 字节\n    __uint(max_entries, 1);\n} data_buffer_heap SEC(\".maps\");\n\n// 在辅助函数中使用：\nstatic __inline struct ssl_data_event_t* create_ssl_data_event(u64 current_pid_tgid) {\n    u32 kZero = 0;\n    struct ssl_data_event_t* event = bpf_map_lookup_elem(&data_buffer_heap, &kZero);\n    if (event == NULL) {\n        return NULL;\n    }\n    // 初始化事件字段...\n    return event;\n}\n```\n\n来源：[kern/nspr_kern.c:57-62,68-80](), [kern/tc.h:64-69,92-100]()\n\n### BPF_MAP_TYPE_LRU_HASH\n\n用于 TC 程序中的连接跟踪。当满时自动驱逐最少使用的条目：\n\n```c\nstruct {\n    __uint(type, BPF_MAP_TYPE_LRU_HASH);\n    __type(key, struct net_id_t);      // 4 元组 + 协议\n    __type(value, struct net_ctx_t);    // pid、uid、comm\n    __uint(max_entries, 10240);\n} network_map SEC(\".maps\");\n```\n\n此 map 由 `tcp_sendmsg`/`udp_sendmsg` 上的 kprobe 填充，并由 TC 分类器查询以将数据包归因于进程。\n\n来源：[kern/tc.h:72-77,290-347,349-397]()\n\n## 事件结构\n\n每个 eBPF 程序定义与捕获的数据相匹配的事件结构。这些结构根据其携带的数据有大小约束。\n\n### 事件结构模式\n\n```mermaid\ngraph TB\n    subgraph \"通用字段\"\n        F1[\"type: u32<br/>事件类型标识符\"]\n        F2[\"pid: u32/u64<br/>进程 ID\"]\n        F3[\"uid: u32<br/>用户 ID\"]\n        F4[\"timestamp: u64<br/>纳秒时间戳\"]\n        F5[\"comm: char[16]<br/>进程名称\"]\n    end\n    \n    subgraph \"负载字段\"\n        P1[\"data/query/line: char[]<br/>捕获的数据<br/>大小由 MAX_DATA_SIZE_* 限制\"]\n        P2[\"len/data_len: u32/s32<br/>实际数据长度\"]\n        P3[\"retval: s8/u8<br/>返回值\"]\n    end\n    \n    subgraph \"大小限制 (common.h)\"\n        L1[\"MAX_DATA_SIZE_OPENSSL: 16384<br/>(16 KB TLS 记录限制)\"]\n        L2[\"MAX_DATA_SIZE_MYSQL: 256\"]\n        L3[\"MAX_DATA_SIZE_POSTGRES: 256\"]\n        L4[\"MAX_DATA_SIZE_BASH: 256\"]\n        L5[\"SKB_MAX_DATA_SIZE: 2048\"]\n    end\n    \n    F1 --> P1\n    F2 --> P1\n    F3 --> P1\n    F4 --> P1\n    F5 --> P1\n    L1 --> P1\n    L2 --> P1\n    L3 --> P1\n    L4 --> P1\n    L5 --> P1\n```\n\n### 事件结构示例\n\n| 模块 | 结构 | 数据字段 | 最大大小 |\n|--------|-----------|------------|----------|\n| bash | `struct event` | `line[256]` | 256 字节 |\n| nspr | `struct ssl_data_event_t` | `data[16384]` | 16 KB |\n| mysqld | `struct data_t` | `query[256]` | 256 字节 |\n| postgres | `struct data_t` | `query[256]` | 256 字节 |\n| tc | `struct skb_data_event_t` | (无数据，使用 perf 标志) | 36 字节（仅头部） |\n\n**大小原理：**\n- TLS/SSL 模块使用 `MAX_DATA_SIZE_OPENSSL`（16384）以适应 RFC 5246 规定的最大 TLS 记录大小\n- 数据库模块使用较小的缓冲区（256），因为仅捕获查询文本\n- Shell 模块对命令行使用 256 字节\n- TC 模块发送最小元数据并使用 `bpf_perf_event_output()` 标志来包含数据包数据\n\n来源：[kern/common.h:28-43](), [kern/bash_kern.c:17-24](), [kern/nspr_kern.c:19-27](), [kern/mysqld_kern.c:19-27](), [kern/postgres_kern.c:17-22](), [kern/tc.h:30-37]()\n\n## 探针挂载与 SEC() 宏\n\n`SEC()` 宏定义探针类型和挂载点。eCapture 使用四种主要探针类型：\n\n```mermaid\ngraph TB\n    subgraph \"用户空间探针\"\n        U1[\"SEC(uprobe/function_name)<br/>入口点钩子<br/>捕获参数\"]\n        U2[\"SEC(uretprobe/function_name)<br/>返回点钩子<br/>捕获返回值\"]\n    end\n    \n    subgraph \"内核探针\"\n        K1[\"SEC(kprobe/kernel_function)<br/>内核函数入口<br/>例如 tcp_sendmsg\"]\n        K2[\"SEC(kretprobe/kernel_function)<br/>内核函数返回<br/>(在 eCapture 中很少使用)\"]\n    end\n    \n    subgraph \"网络探针\"\n        N1[\"SEC(classifier)<br/>TC 入口/出口<br/>数据包拦截\"]\n    end\n    \n    U1 -->|\"在 map 中存储参数\"| U2\n    U2 -->|\"从 map 查找参数\"| EVENT[\"发送事件<br/>bpf_perf_event_output()\"]\n    K1 -->|\"填充 map\"| N1\n    N1 -->|\"查找 map 进行归因\"| EVENT\n```\n\n### Uprobe/Uretprobe 模式\n\n大多数 eCapture 模块遵循入口/返回探针对模式：\n\n```\n入口探针 (uprobe)：\n1. 使用 PT_REGS_PARM* 宏提取函数参数\n2. 将参数存储在哈希 map 中（键：pid/tid）\n3. 可选：按 PID/UID 过滤\n4. 返回\n\n返回探针 (uretprobe)：\n1. 使用 PT_REGS_RC() 提取返回值\n2. 从哈希 map 查找存储的参数\n3. 将参数 + 返回值组合成事件\n4. 通过 bpf_perf_event_output() 发送事件\n5. 删除 map 条目以进行清理\n```\n\n**示例 - NSPR SSL_write：**\n- 入口：`SEC(\"uprobe/PR_Write\")` 存储缓冲区指针\n- 返回：`SEC(\"uretprobe/PR_Write\")` 读取缓冲区内容和长度\n\n来源：[kern/nspr_kern.c:114-162]()\n\n**示例 - Bash readline：**\n- 入口：未钩住（来自 readline 库的函数指针）\n- 返回：`SEC(\"uretprobe/bash_readline\")` 捕获返回的字符串\n- 附加：`SEC(\"uretprobe/bash_retval\")` 捕获命令退出状态\n\n来源：[kern/bash_kern.c:42-112]()\n\n### Kprobe 用法\n\neCapture 主要使用 kprobe 进行连接跟踪，而不是数据捕获：\n\n```c\nSEC(\"kprobe/tcp_sendmsg\")\nint tcp_sendmsg(struct pt_regs *ctx) {\n    // 提取套接字结构\n    struct sock *sk = (struct sock *)PT_REGS_PARM1(ctx);\n    \n    // 从套接字读取连接 4 元组\n    bpf_probe_read(&family, sizeof(family), &sk->__sk_common.skc_family);\n    bpf_probe_read(&lport, sizeof(lport), &sk->__sk_common.skc_num);\n    bpf_probe_read(&dport, sizeof(dport), &sk->__sk_common.skc_dport);\n    bpf_probe_read(&src_ip4, sizeof(src_ip4), &sk->__sk_common.skc_rcv_saddr);\n    bpf_probe_read(&dst_ip4, sizeof(dst_ip4), &sk->__sk_common.skc_daddr);\n    \n    // 存储与连接关联的 pid/uid/comm\n    struct net_ctx_t net_ctx = {.pid = pid, .uid = uid};\n    bpf_get_current_comm(&net_ctx.comm, sizeof(net_ctx.comm));\n    bpf_map_update_elem(&network_map, &conn_id, &net_ctx, BPF_ANY);\n}\n```\n\n对 `udp_sendmsg` 使用相同的模式。TC 分类器稍后使用此 map 将数据包归因于进程。\n\n来源：[kern/tc.h:290-347,349-397]()\n\n### TC 分类器模式\n\nTC 分类器（`SEC(\"classifier\")`）挂载到网络接口以进行数据包捕获：\n\n```c\nSEC(\"classifier\")\nint egress_cls_func(struct __sk_buff *skb) {\n    return capture_packets(skb, false);  // false = 出口\n}\n\nSEC(\"classifier\")\nint ingress_cls_func(struct __sk_buff *skb) {\n    return capture_packets(skb, true);   // true = 入口\n}\n```\n\n`capture_packets()` 函数：\n1. 解析以太网、IP 和 TCP/UDP 头\n2. 提取 4 元组（src_ip、dst_ip、src_port、dst_port）\n3. 在 `network_map` 中查找连接（由 kprobe 填充）\n4. 如果找到连接，应用 PID/UID 过滤器\n5. 通过 `bpf_perf_event_output()` 发送数据包元数据 + 数据\n\n来源：[kern/tc.h:135-289]()\n\n## PID/UID 过滤\n\neCapture 支持按进程 ID 和用户 ID 进行可选过滤。过滤机制取决于内核版本：\n\n```mermaid\ngraph TB\n    START[\"探针入口\"]\n    \n    KERNEL_CHECK{\"内核 >= 5.2?<br/>(#ifndef KERNEL_LESS_5_2)\"}\n    \n    OLD_KERNEL[\"跳过过滤<br/>(不支持 rodata)\"]\n    NEW_KERNEL[\"检查 rodata 变量\"]\n    \n    PID_CHECK{\"target_pid != 0 &&<br/>target_pid != current_pid?\"}\n    UID_CHECK{\"target_uid != 0 &&<br/>target_uid != current_uid?\"}\n    \n    SKIP[\"return 0<br/>(跳过此事件)\"]\n    CONTINUE[\"继续处理\"]\n    \n    START --> KERNEL_CHECK\n    KERNEL_CHECK -->|\"< 5.2\"| OLD_KERNEL\n    KERNEL_CHECK -->|\">= 5.2\"| NEW_KERNEL\n    \n    OLD_KERNEL --> CONTINUE\n    NEW_KERNEL --> PID_CHECK\n    \n    PID_CHECK -->|\"是\"| SKIP\n    PID_CHECK -->|\"否\"| UID_CHECK\n    \n    UID_CHECK -->|\"是\"| SKIP\n    UID_CHECK -->|\"否\"| CONTINUE\n```\n\n### 只读数据变量（内核 >= 5.2）\n\n对于支持 BTF 和 rodata 的内核，过滤目标在 `common.h` 中定义为常量：\n\n```c\n#ifndef KERNEL_LESS_5_2\nconst volatile u64 target_pid = 0;  // 0 = 捕获所有进程\nconst volatile u64 target_uid = 0;  // 0 = 捕获所有用户\nconst volatile u64 target_errno = BASH_ERRNO_DEFAULT;\n#endif\n```\n\n这些变量标记为 `const volatile`，因此 BPF 验证器可以优化它们，但用户空间仍然可以在程序加载之前修改它们。当设置为 0 时，不应用过滤。\n\n来源：[kern/common.h:64-71]()\n\n### 过滤应用模式\n\n标准过滤代码出现在每个探针中：\n\n```c\nu64 current_pid_tgid = bpf_get_current_pid_tgid();\nu32 pid = current_pid_tgid >> 32;\nu64 current_uid_gid = bpf_get_current_uid_gid();\nu32 uid = current_uid_gid;\n\n#ifndef KERNEL_LESS_5_2\n    if (target_pid != 0 && target_pid != pid) {\n        return 0;  // 跳过此事件\n    }\n    if (target_uid != 0 && target_uid != uid) {\n        return 0;  // 跳过此事件\n    }\n#endif\n```\n\n对于内核 < 5.2（编译期间定义 `KERNEL_LESS_5_2` 时），省略过滤检查。\n\n来源：[kern/bash_kern.c:44-57](), [kern/nspr_kern.c:116-130](), [kern/mysqld_kern.c:64-77](), [kern/postgres_kern.c:37-49]()\n\n### 特殊情况 - Bash 返回值过滤\n\nbash 模块包含对命令退出代码的附加过滤：\n\n```c\n#ifndef KERNEL_LESS_5_2\n    if (target_errno != BASH_ERRNO_DEFAULT && target_errno != retval) {\n        // 命令退出代码与目标不匹配\n        if (event_p) {\n            // 发送带有默认 errno 的事件以指示不匹配\n            event_p->retval = BASH_ERRNO_DEFAULT;\n            event_p->type = BASH_EVENT_TYPE_RETVAL;\n            bpf_perf_event_output(ctx, &events, BPF_F_CURRENT_CPU, event_p, \n                                  sizeof(struct event));\n            bpf_map_delete_elem(&events_t, &pid);\n        }\n        return 0;\n    }\n#endif\n```\n\n当 `target_errno` 设置为除 `BASH_ERRNO_DEFAULT`（128）之外的值时，只完全捕获具有该退出代码的命令。\n\n来源：[kern/bash_kern.c:79-102](), [kern/common.h:51,69]()\n\n## 数据提取模式\n\neCapture 根据源位置使用不同的 BPF 辅助函数来读取数据。\n\n### 从用户空间读取\n\n对于用户空间内存中的数据（函数参数、缓冲区）：\n\n```c\n// 读取到局部变量\nchar buf[256];\nbpf_probe_read_user(buf, sizeof(buf), user_ptr);\n\n// 读取到事件结构\nbpf_probe_read_user(&event.data, event.data_len, buf_ptr);\n\n// 读取结构成员\nstruct COM_QUERY_DATA query;\nbpf_probe_read_user(&query, sizeof(query), st);\nbpf_probe_read_user(&data.query, sizeof(data.query), query.query);\n```\n\n来源：[kern/bash_kern.c:64](), [kern/nspr_kern.c:101](), [kern/mysqld_kern.c:214-216]()\n\n### 从内核空间读取\n\n对于内核结构（套接字、任务）：\n\n```c\n// 读取套接字族\nu16 family;\nbpf_probe_read(&family, sizeof(family), &sk->__sk_common.skc_family);\n\n// 读取 IP 地址\nu32 src_ip4, dst_ip4;\nbpf_probe_read(&src_ip4, sizeof(src_ip4), &sk->__sk_common.skc_rcv_saddr);\nbpf_probe_read(&dst_ip4, sizeof(dst_ip4), &sk->__sk_common.skc_daddr);\n\n// CO-RE 替代方案（当 BTF 可用时）：\nfamily = BPF_CORE_READ(sk, __sk_common.skc_family);\n```\n\n来源：[kern/tc.h:311-336]()\n\n### 从 pt_regs 读取\n\n从 `struct pt_regs` 提取函数参数和返回值：\n\n```c\n// 函数参数（x86_64）：\nvoid *arg1 = (void *)PT_REGS_PARM1(ctx);\nvoid *arg2 = (void *)PT_REGS_PARM2(ctx);\nvoid *arg3 = (void *)PT_REGS_PARM3(ctx);\nu64 arg4 = (u64)PT_REGS_PARM4(ctx);\n\n// 返回值：\nint retval = (int)PT_REGS_RC(ctx);\n```\n\n`PT_REGS_PARM*` 和 `PT_REGS_RC` 宏是架构感知的，并在 `bpf/bpf_tracing.h` 中定义。它们为 x86_64、aarch64 等抽象寄存器访问。\n\n来源：[kern/bash_kern.c:64,77](), [kern/nspr_kern.c:87,132](), [kern/mysqld_kern.c:59,79]()\n\n### 获取进程信息\n\n用于检索进程上下文的标准辅助函数：\n\n```c\n// 获取 PID 和 TID\nu64 pid_tgid = bpf_get_current_pid_tgid();\nu32 pid = pid_tgid >> 32;\nu32 tid = pid_tgid & 0xFFFFFFFF;\n\n// 获取 UID 和 GID\nu64 uid_gid = bpf_get_current_uid_gid();\nu32 uid = uid_gid;\nu32 gid = uid_gid >> 32;\n\n// 获取进程名称\nchar comm[TASK_COMM_LEN];  // TASK_COMM_LEN = 16\nbpf_get_current_comm(&comm, sizeof(comm));\n\n// 获取时间戳\nu64 timestamp_ns = bpf_ktime_get_ns();\n```\n\n来源：[kern/bash_kern.c:44-46,65](), [kern/nspr_kern.c:76-78]()\n\n## 辅助函数\n\neBPF 程序定义辅助函数以避免代码重复并保持在 BPF 复杂性限制内。\n\n### 事件创建辅助函数\n\n从每 CPU 堆分配事件并初始化通用字段：\n\n```c\nstatic __inline struct ssl_data_event_t* create_ssl_data_event(u64 current_pid_tgid) {\n    u32 kZero = 0;\n    struct ssl_data_event_t* event = bpf_map_lookup_elem(&data_buffer_heap, &kZero);\n    if (event == NULL) {\n        return NULL;\n    }\n    \n    const u32 kMask32b = 0xffffffff;\n    event->timestamp_ns = bpf_ktime_get_ns();\n    event->pid = current_pid_tgid >> 32;\n    event->tid = current_pid_tgid & kMask32b;\n    return event;\n}\n```\n\n来源：[kern/nspr_kern.c:68-80](), [kern/tc.h:92-100]()\n\n### 数据处理辅助函数\n\n集中通用处理逻辑：\n\n```c\nstatic int process_SSL_data(struct pt_regs* ctx, u64 id, \n                           enum ssl_data_event_type type, const char* buf) {\n    // 获取返回值（读取/写入的字节）\n    int len = (int)PT_REGS_RC(ctx);\n    if (len < 0) {\n        return 0;\n    }\n    \n    // 创建事件\n    struct ssl_data_event_t* event = create_ssl_data_event(id);\n    if (event == NULL) {\n        return 0;\n    }\n    \n    // 填充事件字段\n    event->type = type;\n    event->data_len = (len < MAX_DATA_SIZE_OPENSSL ? \n                       (len & (MAX_DATA_SIZE_OPENSSL - 1)) : \n                       MAX_DATA_SIZE_OPENSSL);\n    bpf_probe_read_user(event->data, event->data_len, buf);\n    bpf_get_current_comm(&event->comm, sizeof(event->comm));\n    \n    // 发送到用户空间\n    bpf_perf_event_output(ctx, &nspr_events, BPF_F_CURRENT_CPU, \n                         event, sizeof(struct ssl_data_event_t));\n    return 0;\n}\n```\n\n来源：[kern/nspr_kern.c:86-105]()\n\n### 数据包验证辅助函数\n\nTC 程序需要处理数据包边界检查：\n\n```c\nstatic __always_inline bool skb_revalidate_data(struct __sk_buff *skb,\n                                                uint8_t **head, uint8_t **tail,\n                                                const u32 offset) {\n    if (*head + offset > *tail) {\n        // 需要将更多数据拉入线性部分\n        if (bpf_skb_pull_data(skb, offset) < 0) {\n            return false;\n        }\n        \n        // 拉取后更新指针\n        *head = (uint8_t *)(long)skb->data;\n        *tail = (uint8_t *)(long)skb->data_end;\n        \n        // 验证偏移量现在是否可访问\n        if (*head + offset > *tail) {\n            return false;\n        }\n    }\n    \n    return true;\n}\n```\n\n此辅助函数确保在解引用之前数据包数据是可访问的，BPF 验证器需要这样做以证明安全性。\n\n来源：[kern/tc.h:102-119]()\n\n### PCAP 过滤器注入点\n\neCapture 支持将 pcap-filter 表达式注入为 eBPF 代码。注入点用存根函数标记：\n\n```c\n// pcap-filter 注入的存根函数\nstatic __noinline bool filter_pcap_ebpf_l2(void *_skb, void *__skb,\n                                           void *___skb, void *data,\n                                           void* data_end) {\n    return data != data_end && _skb == __skb && __skb == ___skb;\n}\n\nstatic __always_inline bool filter_pcap_l2(struct __sk_buff *skb, void *data,\n                                           void *data_end) {\n    return filter_pcap_ebpf_l2((void *) skb, (void *) skb, (void *) skb, data,\n                               data_end);\n}\n```\n\n`__noinline` 属性防止内联，允许用户空间程序用编译的 pcap-filter 逻辑替换此函数的字节码。\n\n来源：[kern/tc.h:121-132]()\n\n## 事件输出机制\n\n事件通过 `bpf_perf_event_output()` 从内核发送到用户空间。\n\n### 标准事件输出\n\n```c\nbpf_perf_event_output(ctx, &events, BPF_F_CURRENT_CPU, &event, sizeof(event));\n```\n\n参数：\n- `ctx` - 探针上下文（`struct pt_regs*` 或 `struct __sk_buff*`）\n- `&events` - perf 事件数组 map\n- `BPF_F_CURRENT_CPU` - 发送到当前 CPU 的 perf 缓冲区\n- `&event` - 指向事件结构的指针\n- `sizeof(event)` - 要复制的大小\n\n来源：[kern/bash_kern.c:67](), [kern/nspr_kern.c:103](), [kern/mysqld_kern.c:139,263](), [kern/postgres_kern.c:58]()\n\n### 可变大小事件输出\n\n对于具有可变长度数据的事件，调整 size 参数：\n\n```c\n// MySQL：仅发送实际查询长度\nsize_t event_size = sizeof(struct data_t);\nbpf_perf_event_output(ctx, &events, BPF_F_CURRENT_CPU, data, event_size);\n\n// TC：发送最小头部 + 使用标志包含数据包数据\nu64 flags = BPF_F_CURRENT_CPU;\nflags |= (u64)skb->len << 32;  // 在高 32 位中编码数据包长度\nsize_t pkt_size = TC_PACKET_MIN_SIZE;  // 36 字节\nbpf_perf_event_output(skb, &skb_events, flags, &event, pkt_size);\n```\n\nTC 方法在 flags 参数中编码数据包长度，允许内核将数据包数据附加到 perf 事件而无需将其复制到事件结构中。\n\n来源：[kern/tc.h:260-271]()\n\n## 调试\n\neCapture 使用 BPF trace printk 提供条件调试输出。\n\n### 调试宏\n\n```c\n#ifdef DEBUG_PRINT\n#define debug_bpf_printk(fmt, ...)                     \\\n    do {                                               \\\n        char s[] = fmt;                                \\\n        bpf_trace_printk(s, sizeof(s), ##__VA_ARGS__); \\\n    } while (0)\n#else\n#define debug_bpf_printk(fmt, ...)\n#endif\n```\n\n当在编译期间定义 `DEBUG_PRINT` 时，调试消息被写入 `/sys/kernel/debug/tracing/trace_pipe`。当未定义时，宏编译为空（零开销）。\n\n来源：[kern/common.h:18-26]()\n\n### 调试使用示例\n\n```c\ndebug_bpf_printk(\"nspr uprobe/PR_Write pid :%d\\n\", pid);\ndebug_bpf_printk(\"capture packet process found, pid: %d, comm :%s\\n\", \n                 event.pid, event.comm);\ndebug_bpf_printk(\"mysql query:%s\\n\", data->query);\ndebug_bpf_printk(\"tcp_sendmsg pid : %d, comm :%s\\n\", net_ctx.pid, net_ctx.comm);\n```\n\n调试语句有助于跟踪程序执行、验证过滤器和诊断问题，而无需修改主逻辑。\n\n来源：[kern/nspr_kern.c:120](), [kern/tc.h:253](), [kern/mysqld_kern.c:136](), [kern/tc.h:344]()\n\n## 许可证和版本元数据\n\n所有 eBPF 程序必须包含许可证和版本信息：\n\n```c\nchar __license[] SEC(\"license\") = \"Dual MIT/GPL\";\n__u32 _version SEC(\"version\") = 0xFFFFFFFE;\n```\n\n- 许可证必须与 GPL 兼容才能使用仅 GPL 的 BPF 辅助函数\n- 版本 `0xFFFFFFFE` 是一个特殊值，表示程序可在多个内核版本上运行\n\n来源：[kern/common.h:82-83]()\n\n## 总结表：通用模式\n\n| 模式 | 位置 | 目的 |\n|---------|----------|---------|\n| `struct { __uint(type, BPF_MAP_TYPE_*); } map SEC(\".maps\")` | 所有模块 | 定义 BPF maps |\n| `SEC(\"uprobe/function\")` / `SEC(\"uretprobe/function\")` | TLS、shell、DB 模块 | 钩住用户空间函数 |\n| `SEC(\"kprobe/function\")` | tc.h | 钩住内核函数 |\n| `SEC(\"classifier\")` | tc.h | TC 数据包捕获 |\n| `#ifndef KERNEL_LESS_5_2` ... `#endif` | 所有模块 | 内核版本特定代码 |\n| `const volatile u64 target_pid` | common.h | 过滤目标（rodata） |\n| `bpf_get_current_pid_tgid()` | 所有模块 | 获取 PID/TID |\n| `bpf_get_current_uid_gid()` | 所有模块 | 获取 UID/GID |\n| `PT_REGS_PARM*()` / `PT_REGS_RC()` | 所有模块 | 提取函数参数/返回值 |\n| `bpf_probe_read_user()` | 所有模块 | 读取用户空间内存 |\n| `bpf_probe_read()` / `BPF_CORE_READ()` | tc.h | 读取内核内存 |\n| `bpf_map_update_elem()` | 所有模块 | 存储状态 |\n| `bpf_map_lookup_elem()` | 所有模块 | 检索状态 |\n| `bpf_map_delete_elem()` | 所有模块 | 清理状态 |\n| `bpf_perf_event_output()` | 所有模块 | 发送事件到用户空间 |\n| `BPF_MAP_TYPE_PERCPU_ARRAY` | nspr、tc | 避免栈限制 |\n| `static __always_inline` / `static __inline` | 所有模块 | 辅助函数 |\n| `debug_bpf_printk()` | 所有模块 | 条件调试输出 |\n\n来源：本文档中引用的所有 kern/*.c 和 kern/*.h 文件。"
          },
          {
            "page_plan": {
              "id": "5.2.2",
              "title": "结构体偏移量计算"
            },
            "content": "# 结构体偏移量计算\n\n## 目的与范围\n\n本文档解释了 eCapture 中用于计算 eBPF 程序访问 SSL/TLS 库结构体内存偏移量的技术。结构体偏移量计算是必要的,因为 eBPF 程序必须读取 OpenSSL 和 BoringSSL 的内部非公开结构体,而这些结构体在不同版本之间会发生变化。\n\n关于通用的 eBPF 程序结构,请参见 [eBPF 程序结构](#5.2.1)。关于添加新的捕获模块,请参见 [添加新模块](#5.3)。关于使用这些偏移量的版本检测系统,请参见 [版本检测与字节码选择](#2.5)。\n\n---\n\n## 偏移量问题\n\n附加到 SSL/TLS 函数的 eBPF 程序需要从内部库结构体中提取加密密钥和会话数据。这些结构体不是公共 API 的一部分,它们的内存布局在不同版本之间会有所不同。这个挑战有三个维度:\n\n**版本多样性**: eCapture 支持 OpenSSL 1.0.2 到 3.5.x 以及 BoringSSL Android 13-16,每个版本可能都有不同的结构体布局 [user/module/probe_openssl_lib.go:30-62]()。\n\n**公有与私有字段**: 某些关键字段在 C++ 中被标记为 `private`,使它们无法被标准偏移量计算工具访问 [kern/boringssl_const.h:11-27]()。\n\n**编译时要求**: eBPF 字节码必须在编译时嵌入偏移量值,因为在内核中无法进行运行时内省。\n\n```mermaid\ngraph TB\n    subgraph \"运行时挑战\"\n        APP[\"应用程序<br/>OpenSSL 3.2.0\"]\n        MEM[\"内存布局<br/>ssl_st 位于 0x7fff000\"]\n        FIELD[\"version 位于 +0x10<br/>s3 位于 +0x30<br/>session 位于 +0x38\"]\n    end\n    \n    subgraph \"eBPF 要求\"\n        BPF[\"eBPF 程序<br/>probe_ssl_master_key\"]\n        OFFSET[\"硬编码偏移量<br/>#define SSL_ST_VERSION 0x10<br/>#define SSL_ST_S3 0x30\"]\n        READ[\"bpf_probe_read_user<br/>ptr + offset\"]\n    end\n    \n    subgraph \"问题空间\"\n        V1[\"OpenSSL 1.1.1<br/>s3 位于 +0x28\"]\n        V2[\"OpenSSL 3.0.0<br/>s3 位于 +0x30\"]\n        V3[\"OpenSSL 3.2.0<br/>s3 位于 +0x38\"]\n        MISMATCH[\"❌ 错误的偏移量 = 崩溃<br/>或垃圾数据\"]\n    end\n    \n    APP --> MEM\n    MEM --> FIELD\n    \n    BPF --> OFFSET\n    OFFSET --> READ\n    READ -.->|必须匹配| FIELD\n    \n    V1 --> MISMATCH\n    V2 --> MISMATCH\n    V3 --> MISMATCH\n    MISMATCH -.->|需要| OFFSET\n    \n    style MISMATCH fill:#fff,stroke:#333,stroke-width:2px\n```\n\n**图示: 偏移量不匹配问题**\n\n来源: [kern/boringssl_masterkey.h:169-257](), [user/module/probe_openssl_lib.go:73-187]()\n\n---\n\n## 偏移量计算技术\n\n### 使用 offsetof() 与库头文件\n\n计算偏移量的主要方法是使用 C 的 `offsetof()` 宏配合实际的库头文件。工具程序 [utils/boringssl-offset.c]() 演示了这种方法:\n\n| 技术 | 描述 | 示例 |\n|-----------|-------------|---------|\n| **宏定义** | 定义要处理的结构体/字段对 | `X(ssl_st, version)` |\n| **offsetof() 应用** | 标准 C 宏计算偏移量 | `offsetof(struct ssl_st, version)` |\n| **代码生成** | 输出 C 预处理器定义 | `#define SSL_ST_VERSION 0x10` |\n\n**关键实现**:\n\n```c\n#define SSL_STRUCT_OFFSETS                   \\\n    X(ssl_st, version)                       \\\n    X(ssl_st, session)                       \\\n    X(ssl_st, s3)                            \\\n    X(ssl_session_st, secret_length)         \\\n    X(ssl_session_st, secret)\n```\n\n`X` 宏模式使得能够遍历所有结构体/字段对 [utils/boringssl-offset.c:23-46]()。每对都被处理以生成偏移量定义:\n\n```c\n#define X(struct_name, field_name) \\\n    format(#struct_name, #field_name, offsetof(struct struct_name, field_name));\nSSL_STRUCT_OFFSETS\n#undef X\n```\n\n这种技术要求:\n1. 在构建期间访问库头文件\n2. 针对特定库版本进行编译\n3. 为每个支持的版本单独编译\n\n来源: [utils/boringssl-offset.c:1-78]()\n\n---\n\n### 私有字段的手动计算\n\nBoringSSL 对 TLS 1.3 密钥使用 C++ 私有字段,使得它们无法被 `offsetof()` 访问。解决方案是基于内存布局分析进行手动偏移量计算:\n\n```mermaid\ngraph LR\n    subgraph \"SSL_HANDSHAKE 结构体布局\"\n        PUBLIC[\"公有字段<br/>max_version (uint16_t)<br/>偏移量: 0x00\"]\n        PADDING[\"对齐填充<br/>6 字节\"]\n        PRIVATE_START[\"私有部分开始<br/>偏移量: 0x08\"]\n        HASH_LEN[\"hash_len_<br/>size_t (8 字节)<br/>偏移量: 0x08\"]\n        SECRET[\"secret_[48]<br/>偏移量: 0x10\"]\n        EARLY[\"early_traffic_secret_[48]<br/>偏移量: 0x40\"]\n        CLIENT_HS[\"client_handshake_secret_[48]<br/>偏移量: 0x70\"]\n    end\n    \n    PUBLIC --> PADDING\n    PADDING --> PRIVATE_START\n    PRIVATE_START --> HASH_LEN\n    HASH_LEN --> SECRET\n    SECRET --> EARLY\n    EARLY --> CLIENT_HS\n```\n\n**图示: BoringSSL SSL_HANDSHAKE 中的私有字段布局**\n\n计算过程 [kern/boringssl_const.h:34-60]():\n\n| 步骤 | 计算 | 结果 | 注释 |\n|------|-------------|--------|---------|\n| 1. 找到最后的公有字段 | `BSSL__SSL_HANDSHAKE_MAX_VERSION` | 变化 | 来自 offsetof() |\n| 2. 加上字段大小 | `+sizeof(uint16_t)` = `+2` | offset+2 | max_version 的大小 |\n| 3. 应用对齐 | `roundup(offset+2, 8)` | 已对齐 | 8 字节边界 |\n| 4. 第一个私有字段 | `+sizeof(size_t)` = `+8` | `hash_len_` 偏移量 | |\n| 5. 后续字段 | `+SSL_MAX_MD_SIZE` | 顺序 | 每个密钥 48 字节 |\n\n**偏移量公式**:\n- `SSL_HANDSHAKE_HASH_LEN_ = roundup(BSSL__SSL_HANDSHAKE_MAX_VERSION+2, 8)`\n- `SSL_HANDSHAKE_SECRET_ = SSL_HANDSHAKE_HASH_LEN_ + 8`\n- `SSL_HANDSHAKE_EARLY_TRAFFIC_SECRET_ = SSL_HANDSHAKE_SECRET_ + 48*1`\n- `SSL_HANDSHAKE_CLIENT_HANDSHAKE_SECRET_ = SSL_HANDSHAKE_SECRET_ + 48*2`\n\n这种方法需要理解:\n1. C++ 内存布局规则\n2. 结构体对齐(在 x86_64 上通常是 8 字节)\n3. 源代码中的成员声明顺序\n\n来源: [kern/boringssl_const.h:1-63]()\n\n---\n\n### 内存对齐考虑\n\n结构体填充会影响偏移量计算。eBPF 程序必须考虑编译器插入的填充:\n\n**对齐规则**:\n- 标量类型对齐到其大小(uint16_t → 2 字节,uint64_t → 8 字节)\n- 结构体对齐匹配最大成员\n- 插入填充以维持对齐\n\n**ssl3_state_st 的示例**:\n\n```c\nstruct ssl3_state_st {\n    u64 read_sequence;          // 偏移量: 0x00, 大小: 8\n    u64 write_sequence;         // 偏移量: 0x08, 大小: 8\n    unsigned char server_random[32];  // 偏移量: 0x10, 大小: 32\n    unsigned char client_random[32];  // 偏移量: 0x30, 大小: 32\n};\n```\n\n`client_random` 字段位于偏移量 `0x30`(48 字节),因为:\n- `read_sequence`: 0 + 8 = 8\n- `write_sequence`: 8 + 8 = 16 (0x10)\n- `server_random`: 16 + 32 = 48 (0x30)\n\n来源: [kern/boringssl_masterkey.h:59-65]()\n\n---\n\n## 版本特定的字节码策略\n\neCapture 通过为每个支持的库版本预编译单独的 eBPF 字节码来解决偏移量变化问题。构建系统生成多个字节码文件,每个文件都包含版本特定的偏移量。\n\n### 字节码变体矩阵\n\n```mermaid\ngraph TB\n    subgraph \"OpenSSL 变体\"\n        O102[\"openssl_1_0_2a_kern.o<br/>版本: 1.0.2a-u\"]\n        O110[\"openssl_1_1_0a_kern.o<br/>版本: 1.1.0a-l\"]\n        O111A[\"openssl_1_1_1a_kern.o<br/>版本: 1.1.1a\"]\n        O111B[\"openssl_1_1_1b_kern.o<br/>版本: 1.1.1b-c\"]\n        O111D[\"openssl_1_1_1d_kern.o<br/>版本: 1.1.1d-i\"]\n        O111J[\"openssl_1_1_1j_kern.o<br/>版本: 1.1.1j-w\"]\n        O300[\"openssl_3_0_0_kern.o<br/>版本: 3.0.0-11,13-17\"]\n        O3012[\"openssl_3_0_12_kern.o<br/>版本: 3.0.12\"]\n        O320[\"openssl_3_2_0_kern.o<br/>版本: 3.2.0-2\"]\n        O350[\"openssl_3_5_0_kern.o<br/>版本: 3.5.0-4\"]\n    end\n    \n    subgraph \"BoringSSL 变体\"\n        BA13[\"boringssl_a_13_kern.o<br/>Android 13\"]\n        BA14[\"boringssl_a_14_kern.o<br/>Android 14\"]\n        BA15[\"boringssl_a_15_kern.o<br/>Android 15\"]\n        BA16[\"boringssl_a_16_kern.o<br/>Android 16\"]\n        BNA[\"boringssl_na_kern.o<br/>非 Android\"]\n    end\n    \n    subgraph \"选择逻辑\"\n        DETECT[\"版本检测<br/>解析 .rodata 部分\"]\n        MAP[\"sslVersionBpfMap<br/>版本 → 字节码\"]\n        LOAD[\"加载适当的<br/>字节码\"]\n    end\n    \n    DETECT --> MAP\n    MAP --> LOAD\n    \n    O102 -.-> LOAD\n    O111J -.-> LOAD\n    O300 -.-> LOAD\n    BA13 -.-> LOAD\n```\n\n**图示: 字节码变体选择系统**\n\n映射在 `initOpensslOffset()` 中定义 [user/module/probe_openssl_lib.go:73-187]():\n\n| 版本模式 | 字节码文件 | 偏移量来源 |\n|-----------------|---------------|---------------|\n| OpenSSL 1.0.2a-u (21 个版本) | `openssl_1_0_2a_kern.o` | 单一偏移量集 |\n| OpenSSL 1.1.1a | `openssl_1_1_1a_kern.o` | 独特偏移量 |\n| OpenSSL 1.1.1b-c | `openssl_1_1_1b_kern.o` | 共享偏移量 |\n| OpenSSL 1.1.1d-i | `openssl_1_1_1d_kern.o` | 共享偏移量 |\n| OpenSSL 1.1.1j-w | `openssl_1_1_1j_kern.o` | 共享偏移量 |\n| OpenSSL 3.0.12 | `openssl_3_0_12_kern.o` | 特殊情况 |\n| OpenSSL 3.0.x (其他) | `openssl_3_0_0_kern.o` | 共享偏移量 |\n\n来源: [user/module/probe_openssl_lib.go:73-187](), [variables.mk:189-228]()\n\n---\n\n## 实际示例\n\n### 示例 1: 读取 TLS 1.2 主密钥 (OpenSSL)\n\neBPF 程序必须导航多个指针间接引用才能读取主密钥:\n\n**导航路径**: `ssl_st` → `ssl_st->session` → `ssl_session_st->master_key`\n\n```mermaid\ngraph LR\n    SSL_ST[\"ssl_st<br/>(SSL* 参数)\"]\n    SESSION_PTR[\"ssl_st->session<br/>(指针位于 +SSL_ST_SESSION)\"]\n    SESSION_STRUCT[\"ssl_session_st<br/>(解引用)\"]\n    MASTER_KEY[\"ssl_session_st->master_key<br/>(位于 +SSL_SESSION_ST_MASTER_KEY)\"]\n    \n    SSL_ST -->|\"偏移量 = SSL_ST_SESSION\"| SESSION_PTR\n    SESSION_PTR -->|\"bpf_probe_read_user\"| SESSION_STRUCT\n    SESSION_STRUCT -->|\"偏移量 = SSL_SESSION_ST_MASTER_KEY\"| MASTER_KEY\n```\n\n**图示: TLS 1.2 主密钥访问路径**\n\n**代码实现** [kern/openssl_masterkey.h:140-165]():\n\n```c\n// 步骤 1: 从 ssl_st 获取 ssl_session_st 指针\nu64 *ssl_session_st_ptr = (u64 *)(ssl_st_ptr + SSL_ST_SESSION);\nu64 ssl_session_st_addr;\nret = bpf_probe_read_user(&ssl_session_st_addr, sizeof(ssl_session_st_addr), \n                          ssl_session_st_ptr);\n\n// 步骤 2: 从 ssl_session_st 读取 master_key\nvoid *ms_ptr = (void *)(ssl_session_st_addr + SSL_SESSION_ST_MASTER_KEY);\nret = bpf_probe_read_user(&mastersecret->master_key, \n                          sizeof(mastersecret->master_key), ms_ptr);\n```\n\n**偏移量依赖**:\n- `SSL_ST_SESSION`: 因 OpenSSL 版本而异(3.0+ 通常为 0x38)\n- `SSL_SESSION_ST_MASTER_KEY`: 因版本而异(通常为 0x50-0x60)\n\n来源: [kern/openssl_masterkey.h:140-168]()\n\n---\n\n### 示例 2: 读取 TLS 1.3 密钥 (BoringSSL)\n\nBoringSSL 中的 TLS 1.3 密钥需要通过握手结构访问私有字段:\n\n**导航路径**: `ssl_st` → `ssl_st->s3` → `SSL3_STATE->hs` → `SSL_HANDSHAKE-><私有字段>`\n\n```mermaid\ngraph TB\n    SSL_ST[\"ssl_st<br/>(SSL* ctx 参数)\"]\n    S3_PTR[\"ssl_st->s3<br/>(位于 +SSL_ST_S3)\"]\n    S3_STRUCT[\"SSL3_STATE\"]\n    HS_PTR[\"SSL3_STATE->hs<br/>(位于 +BSSL__SSL3_STATE_HS)\"]\n    HS_STRUCT[\"SSL_HANDSHAKE\"]\n    \n    subgraph \"私有字段\"\n        HASH_LEN[\"hash_len_<br/>(+SSL_HANDSHAKE_HASH_LEN_)\"]\n        SECRET[\"secret_<br/>(+SSL_HANDSHAKE_SECRET_)\"]\n        EARLY[\"early_traffic_secret_<br/>(+SSL_HANDSHAKE_EARLY_TRAFFIC_SECRET_)\"]\n        CLIENT_HS[\"client_handshake_secret_<br/>(+SSL_HANDSHAKE_CLIENT_HANDSHAKE_SECRET_)\"]\n        CLIENT_APP[\"client_traffic_secret_0_<br/>(+SSL_HANDSHAKE_CLIENT_TRAFFIC_SECRET_0_)\"]\n    end\n    \n    SSL_ST --> S3_PTR\n    S3_PTR --> S3_STRUCT\n    S3_STRUCT --> HS_PTR\n    HS_PTR --> HS_STRUCT\n    HS_STRUCT --> HASH_LEN\n    HS_STRUCT --> SECRET\n    HS_STRUCT --> EARLY\n    HS_STRUCT --> CLIENT_HS\n    HS_STRUCT --> CLIENT_APP\n```\n\n**图示: BoringSSL 中的 TLS 1.3 密钥访问**\n\n**代码实现** [kern/boringssl_masterkey.h:235-382]():\n\n```c\n// 步骤 1: 获取 s3 指针\nu64 *ssl_s3_st_ptr = (u64 *)(ssl_st_ptr + SSL_ST_S3);\nret = bpf_probe_read_user(&s3_address, sizeof(s3_address), ssl_s3_st_ptr);\n\n// 步骤 2: 获取握手结构指针\nu64 *ssl_hs_st_ptr = (u64 *)(s3_address + BSSL__SSL3_STATE_HS);\nret = bpf_probe_read_user(&ssl_hs_st_addr, sizeof(ssl_hs_st_addr), ssl_hs_st_ptr);\n\n// 步骤 3: 读取哈希长度\nu64 *ssl_hs_hashlen_ptr = (u64 *)(ssl_hs_st_addr + SSL_HANDSHAKE_HASH_LEN_);\nret = bpf_probe_read_user(&hash_len, sizeof(hash_len), ssl_hs_hashlen_ptr);\n\n// 步骤 4: 读取 TLS 1.3 密钥(使用为私有字段计算的偏移量)\nvoid *cats_ptr_tls13 = (void *)(ssl_hs_st_addr + SSL_HANDSHAKE_CLIENT_TRAFFIC_SECRET_0_);\nret = bpf_probe_read_user(&mastersecret->client_traffic_secret_0_, \n                          sizeof(mastersecret->client_traffic_secret_0_),\n                          cats_ptr_tls13);\n```\n\n**关键偏移量**:\n- `SSL_HANDSHAKE_CLIENT_TRAFFIC_SECRET_0_ = SSL_HANDSHAKE_SECRET_ + 48*4`\n- 每个 TLS 1.3 密钥为 48 字节(`SSL_MAX_MD_SIZE`)\n- 顺序布局使得能够进行算术偏移量计算\n\n来源: [kern/boringssl_masterkey.h:235-402](), [kern/boringssl_const.h:34-60]()\n\n---\n\n### 示例 3: 版本特定的偏移量差异\n\nOpenSSL 3.0.12 是一个特殊情况,其结构体偏移量与其他 3.0.x 版本不同:\n\n**构建系统逻辑** [user/module/probe_openssl_lib.go:128-130]():\n\n```go\n// OpenSSL 3.0.0-3.0.11 和 3.0.13-3.0.17 使用相同的字节码\nfor ch := 0; ch <= MaxSupportedOpenSSL30Version; ch++ {\n    m.sslVersionBpfMap[fmt.Sprintf(\"openssl 3.0.%d\", ch)] = \"openssl_3_0_0_kern.o\"\n}\n\n// OpenSSL 3.0.12 需要特殊的字节码\nm.sslVersionBpfMap[\"openssl 3.0.12\"] = \"openssl_3_0_12_kern.o\"\n```\n\n**原因**: 3.0.12 中的内部结构重组改变了字段偏移量,需要单独的偏移量计算和字节码编译。\n\n**检测与选择流程**:\n\n| 步骤 | 函数 | 操作 |\n|------|----------|--------|\n| 1 | `detectOpenssl()` | 解析 `.rodata` 部分获取版本字符串 |\n| 2 | 版本规范化 | 转换 \"OpenSSL 3.0.12\" → \"openssl 3.0.12\" |\n| 3 | 映射查找 | 检查 `sslVersionBpfMap[\"openssl 3.0.12\"]` |\n| 4 | 字节码选择 | 返回 `\"openssl_3_0_12_kern.o\"` |\n\n来源: [user/module/probe_openssl_lib.go:128-136](), [variables.mk:202]()\n\n---\n\n## 工具与实用程序\n\n### 偏移量计算器工具\n\n`boringssl-offset.c` 工具为特定 BoringSSL 版本生成偏移量定义:\n\n**编译与使用**:\n```bash\n# 针对 BoringSSL 头文件编译\ng++ -I include/ -I src/ utils/boringssl-offset.c -o offset-calc\n\n# 运行以生成偏移量定义\n./offset-calc > generated_offsets.h\n```\n\n**输出格式** [utils/boringssl-offset.c:60-67]():\n```c\n// ssl_st->version\n#define SSL_ST_VERSION 0x10\n\n// ssl_st->session\n#define SSL_ST_SESSION 0x38\n\n// bssl::SSL3_STATE->hs\n#define BSSL__SSL3_STATE_HS 0x50\n```\n\n**支持的结构体**:\n- `ssl_st`: 主 SSL 上下文结构体\n- `ssl_session_st`: 会话状态,包括主密钥\n- `ssl_cipher_st`: 密码套件信息\n- `bssl::SSL3_STATE`: SSL 3.0/TLS 状态\n- `bssl::SSL_HANDSHAKE`: 握手状态和密钥\n\n来源: [utils/boringssl-offset.c:1-78]()\n\n---\n\n### 构建系统集成\n\nMakefile 为所有版本编排偏移量生成和字节码编译:\n\n```mermaid\ngraph TB\n    subgraph \"每个版本的构建过程\"\n        HEADERS[\"库头文件<br/>openssl-dev 包\"]\n        CALC[\"偏移量计算<br/>offsetof() 或手动\"]\n        DEFINES[\"偏移量定义<br/>头文件\"]\n        COMPILE[\"eBPF 编译<br/>clang -target bpf\"]\n        BYTECODE[\"版本特定<br/>字节码 (.o)\"]\n    end\n    \n    subgraph \"聚合\"\n        ALL_BYTECODE[\"所有字节码文件<br/>27+ 个变体\"]\n        BINDATA[\"go-bindata<br/>嵌入到二进制\"]\n        GO_BUILD[\"Go 编译<br/>ecapture 二进制\"]\n        FINAL[\"最终二进制<br/>包含嵌入的字节码\"]\n    end\n    \n    HEADERS --> CALC\n    CALC --> DEFINES\n    DEFINES --> COMPILE\n    COMPILE --> BYTECODE\n    \n    BYTECODE --> ALL_BYTECODE\n    ALL_BYTECODE --> BINDATA\n    BINDATA --> GO_BUILD\n    GO_BUILD --> FINAL\n```\n\n**图示: 偏移量感知字节码的构建系统流程**\n\n**目标定义** [variables.mk:190-228]():\n- 27+ 个 TARGETS 条目,每个代表一个库版本\n- 每个目标编译为 `<name>_kern.o`\n- CO-RE 和 non-CO-RE 模式分别编译\n- Android 变体排除 shell/数据库模块\n\n**支持偏移量的编译标志**:\n- `-D__TARGET_ARCH_x86` 或 `-D__TARGET_ARCH_arm64`: 特定架构\n- `-I ./kern/bpf/$(LINUX_ARCH)`: 包含架构头文件\n- 通过 `#include` 指令包含版本特定的偏移量头文件\n\n来源: [variables.mk:189-228](), [Makefile (引用)]()\n\n---\n\n## 版本检测与降级策略\n\n当精确版本的字节码不可用时,eCapture 实现了回退策略:\n\n### 降级算法\n\n**逻辑** [user/module/probe_openssl_lib.go:341-369]():\n\n1. **渐进式前缀匹配**: 迭代缩短版本字符串\n   - \"openssl 3.2.7\" → 尝试 \"openssl 3.2\",然后 \"openssl 3\",等等\n\n2. **版本比较**: 选择 ≤ 检测到的版本的最高兼容版本\n   - 如果检测到版本 3.2.7 但只有 3.2.0 可用,则使用 3.2.0\n\n3. **库路径启发式**: 基于库文件名的回退\n   - `libssl.so.3` → 使用 OpenSSL 3.0 默认值\n   - 其他 → 使用 OpenSSL 1.1.1 默认值\n\n**实现**:\n\n```go\nfunc (m *MOpenSSLProbe) downgradeOpensslVersion(ver string, soPath string) (string, bool) {\n    var candidates []string\n    for i := len(ver) - 1; i > 0; i-- {\n        prefix := ver[:i]\n        for libKey := range m.sslVersionBpfMap {\n            if strings.HasPrefix(libKey, prefix) && isVersionLessOrEqual(libKey, ver) {\n                candidates = append(candidates, libKey)\n            }\n        }\n        if len(candidates) > 0 {\n            sort.Strings(candidates)\n            return m.sslVersionBpfMap[candidates[len(candidates)-1]], true\n        }\n    }\n    // 基于 soPath 的回退逻辑\n}\n```\n\n**版本比较**: 自定义比较处理数字和字母后缀(例如,\"1.1.1w\") [user/module/probe_openssl_lib.go:371-448]()。\n\n来源: [user/module/probe_openssl_lib.go:341-448]()\n\n---\n\n## 偏移量维护的最佳实践\n\n### 添加新库版本时\n\n1. **获取源代码**: 下载精确版本的源代码\n2. **生成偏移量**: 使用偏移量计算器工具或手动分析\n3. **创建头文件**: 生成版本特定的偏移量定义\n4. **编译字节码**: 使用新偏移量构建 eBPF 程序\n5. **更新映射**: 向 `sslVersionBpfMap` 添加条目\n6. **更新构建系统**: 向 `variables.mk` 添加目标\n7. **测试**: 使用该版本的实际应用程序进行验证\n\n### 常见陷阱\n\n| 问题 | 原因 | 解决方案 |\n|-------|-------|----------|\n| **不正确的对齐** | 遗漏编译器填充 | 使用 `pahole` 工具检查实际布局 |\n| **私有字段访问** | C++ 访问控制 | 从公有字段手动计算 |\n| **指针追踪错误** | 错误的解引用顺序 | 绘制结构体导航图 |\n| **版本检测失败** | 缺少版本字符串 | 向检测正则表达式添加版本 |\n\n### 调试偏移量问题\n\n**eBPF 调试打印** [kern/boringssl_masterkey.h:273-275]():\n```c\ndebug_bpf_printk(\"client_version:%d, state:%d, tls13_state:%d\\n\", \n                 client_version, ssl3_hs_state.state, ssl3_hs_state.tls13_state);\n```\n\n**验证步骤**:\n1. 启用调试打印(`DEBUG=1` 构建标志)\n2. 检查 `bpf_probe_read_user()` 返回值\n3. 验证指针地址非零\n4. 将提取的值与已知的良好数据进行比较\n5. 使用 GDB 检查目标进程中的实际结构体布局\n\n来源: [kern/boringssl_masterkey.h:169-402](), [kern/openssl_masterkey.h:80-257]()"
          },
          {
            "page_plan": {
              "id": "5.3",
              "title": "添加新模块"
            },
            "content": "# 添加新模块\n\n本文档提供了在 eCapture 系统中实现新捕获模块的分步指南。创建新模块涉及：(1) 实现 `IModule` 接口，(2) 创建 CLI 命令，(3) 定义配置结构，(4) 集成 eBPF 程序，以及 (5) 处理事件。\n\n有关整体系统架构的信息，请参阅[架构设计](#2)。有关现有捕获模块的详细信息，请参阅[捕获模块](#3)。有关 eBPF 程序开发细节，请参阅[eBPF 程序开发](#5.2)。\n\n## 模块架构概述\n\neCapture 模块系统使用插件架构，其中每个模块实现 `IModule` 接口 [user/module/imodule.go:47-75]()。模块使用 eBPF 程序捕获特定类型的网络流量或系统事件。所有模块遵循一致的模式：通过 `manager.Manager` 管理 eBPF 程序，通过 `EventProcessor` 处理事件，并将数据输出到配置的目标位置。\n\n**模块架构图**\n\n```mermaid\ngraph TB\n    subgraph \"CLI 层\"\n        rootCmd[\"rootCmd<br/>cobra.Command\"]\n        tlsCmd[\"opensslCmd<br/>cobra.Command\"]\n        bashCmd[\"bashCmd<br/>cobra.Command\"]\n        customCmd[\"yourModuleCmd<br/>cobra.Command\"]\n    end\n    \n    subgraph \"配置层\"\n        IConfig[\"IConfig interface\"]\n        OpensslConfig[\"OpensslConfig\"]\n        BashConfig[\"BashConfig\"]\n        CustomConfig[\"YourModuleConfig\"]\n    end\n    \n    subgraph \"模块层\"\n        IModule[\"IModule interface\"]\n        Module[\"Module 基础结构\"]\n        MOpenSSLProbe[\"MOpenSSLProbe\"]\n        MBashProbe[\"MBashProbe\"]\n        MCustomProbe[\"MYourModuleProbe\"]\n    end\n    \n    subgraph \"eBPF 管理\"\n        bpfManager[\"manager.Manager\"]\n        bpfManagerOptions[\"manager.Options\"]\n        eventMaps[\"eventMaps []*ebpf.Map\"]\n        eventFuncMaps[\"eventFuncMaps\"]\n    end\n    \n    subgraph \"事件处理\"\n        EventProcessor[\"EventProcessor\"]\n        IEventStruct[\"IEventStruct\"]\n        Dispatcher[\"Dispatcher()\"]\n    end\n    \n    rootCmd --> tlsCmd\n    rootCmd --> bashCmd\n    rootCmd --> customCmd\n    \n    tlsCmd --> OpensslConfig\n    bashCmd --> BashConfig\n    customCmd --> CustomConfig\n    \n    OpensslConfig --> IConfig\n    BashConfig --> IConfig\n    CustomConfig --> IConfig\n    \n    IModule --> Module\n    Module --> MOpenSSLProbe\n    Module --> MBashProbe\n    Module --> MCustomProbe\n    \n    MOpenSSLProbe --> bpfManager\n    MBashProbe --> bpfManager\n    MCustomProbe --> bpfManager\n    \n    bpfManager --> bpfManagerOptions\n    bpfManager --> eventMaps\n    bpfManager --> eventFuncMaps\n    \n    eventMaps --> EventProcessor\n    eventFuncMaps --> IEventStruct\n    IEventStruct --> Dispatcher\n```\n\n来源：[user/module/imodule.go:47-75](), [user/module/probe_openssl.go:83-106](), [cli/cmd/tls.go:29-48](), [cli/cmd/root.go:249-403]()\n\n## 核心接口要求\n\n每个模块必须实现在 [user/module/imodule.go:47-75]() 定义的 `IModule` 接口，并嵌入 `Module` 基础结构 [user/module/imodule.go:83-108]()。该接口定义了基本的生命周期和事件处理方法：\n\n**IModule 接口方法**\n\n| 方法 | 签名 | 目的 |\n|--------|-----------|---------|\n| `Init()` | `Init(context.Context, *zerolog.Logger, config.IConfig, io.Writer) error` | 使用上下文、日志记录器、配置和事件写入器初始化模块 |\n| `Name()` | `Name() string` | 返回用于注册的模块标识符 |\n| `Start()` | `Start() error` | 加载 eBPF 程序并附加探针 |\n| `Run()` | `Run() error` | 启动事件读取循环 |\n| `Stop()` | `Stop() error` | 暂停捕获（可选） |\n| `Close()` | `Close() error` | 清理资源并分离探针 |\n| `SetChild()` | `SetChild(IModule)` | 为基础结构设置具体模块实现 |\n| `Events()` | `Events() []*ebpf.Map` | 返回包含事件的 eBPF 映射 |\n| `DecodeFun()` | `DecodeFun(*ebpf.Map) (event.IEventStruct, bool)` | 获取特定映射的事件解码器 |\n| `Decode()` | `Decode(*ebpf.Map, []byte) (event.IEventStruct, error)` | 解析原始事件字节 |\n| `Dispatcher()` | `Dispatcher(event.IEventStruct)` | 处理已解码的事件 |\n\n基础 `Module` 结构提供了通用功能：\n- 从 perf 数组和环形缓冲区读取事件 [user/module/imodule.go:308-391]()\n- BTF 模式自动检测 [user/module/imodule.go:173-190]()\n- eBPF 字节码文件选择（CO-RE vs non-CO-RE）[user/module/imodule.go:191-214]()\n- 与 `EventProcessor` 集成以进行数据聚合 [user/module/imodule.go:127]()\n- 输出格式化（文本 vs protobuf）[user/module/imodule.go:461-479]()\n\n来源：[user/module/imodule.go:47-75](), [user/module/imodule.go:83-108](), [user/module/imodule.go:110-171]()\n\n## 模块实现模式\n\n所有具体模块遵循一致的实现模式，具有特定的结构字段和初始化步骤：\n\n| 组件 | 目的 | 实现 |\n|-----------|---------|----------------|\n| `bpfManager` | eBPF 程序生命周期管理 | `*manager.Manager` |\n| `bpfManagerOptions` | eBPF 程序配置 | `manager.Options` |\n| `eventFuncMaps` | 事件类型到解码器的映射 | `map[*ebpf.Map]event.IEventStruct` |\n| `eventMaps` | 用于事件数据的 eBPF 映射 | `[]*ebpf.Map` |\n| 模块特定字段 | 自定义状态和配置 | 因模块而异 |\n\n```mermaid\ngraph TD\n    subgraph \"模块结构布局\"\n        Base[\"Module（嵌入）<br/>基础功能\"]\n        Manager[\"bpfManager<br/>*manager.Manager\"]\n        Options[\"bpfManagerOptions<br/>manager.Options\"]\n        EventMaps[\"eventMaps<br/>[]*ebpf.Map\"]\n        EventFuncs[\"eventFuncMaps<br/>map[*ebpf.Map]event.IEventStruct\"]\n        Custom[\"模块特定字段<br/>配置、状态等\"]\n    end\n    \n    subgraph \"初始化流程\"\n        InitCall[\"调用 Init()\"]\n        BaseInit[\"Module.Init()\"]\n        SetChild[\"SetChild(m)\"]\n        InitMaps[\"初始化映射\"]\n        InitState[\"初始化模块状态\"]\n    end\n    \n    InitCall --> BaseInit\n    BaseInit --> SetChild\n    SetChild --> InitMaps\n    InitMaps --> InitState\n    \n    Base --> Manager\n    Manager --> Options\n    Options --> EventMaps\n    EventMaps --> EventFuncs\n    EventFuncs --> Custom\n```\n\n来源：[user/module/probe_openssl.go:83-106](), [user/module/probe_bash.go:42-49](), [user/module/probe_nspr.go:38-44]()\n\n## eBPF 程序集成\n\n模块通过 `manager.Manager` 系统与 eBPF 程序集成，该系统处理程序加载、附加和映射管理。每个模块必须定义其探针配置和映射要求：\n\n```mermaid\ngraph TB\n    subgraph \"eBPF 程序设置\"\n        setupManagers[\"setupManagers()<br/>配置探针和映射\"]\n        Probes[\"manager.Probe[]<br/>附加点\"]\n        Maps[\"manager.Map[]<br/>数据结构\"]\n    end\n    \n    subgraph \"程序生命周期\"\n        LoadAsset[\"assets.Asset()<br/>加载字节码\"]\n        InitManager[\"InitWithOptions()<br/>初始化\"]\n        StartManager[\"Start()<br/>附加探针\"]\n        InitDecode[\"initDecodeFun()<br/>设置解码器\"]\n    end\n    \n    subgraph \"探针配置\"\n        Section[\"Section<br/>eBPF 程序段\"]\n        EbpfFunc[\"EbpfFuncName<br/>函数名称\"]\n        AttachFunc[\"AttachToFuncName<br/>目标函数\"]\n        BinaryPath[\"BinaryPath<br/>目标二进制文件\"]\n    end\n    \n    setupManagers --> Probes\n    setupManagers --> Maps\n    LoadAsset --> InitManager\n    InitManager --> StartManager\n    StartManager --> InitDecode\n    \n    Probes --> Section\n    Probes --> EbpfFunc\n    Probes --> AttachFunc\n    Probes --> BinaryPath\n```\n\n来源：[user/module/probe_bash.go:147-236](), [user/module/probe_openssl.go:285-355](), [user/module/probe_nspr.go:135-247]()\n\n## 事件处理流程\n\n模块通过提供事件映射和解码函数与事件处理系统集成。流程处理事件路由、解析和输出格式化：\n\n```mermaid\ngraph LR\n    subgraph \"内核空间\"\n        eBPFProg[\"eBPF 程序\"]\n        eBPFMaps[\"eBPF 映射\"]\n    end\n    \n    subgraph \"模块事件处理\"\n        Events[\"Events()<br/>返回事件映射\"]\n        DecodeFun[\"DecodeFun()<br/>获取事件解码器\"]\n        Decode[\"Decode()<br/>解析原始字节\"]\n        Dispatcher[\"Dispatcher()<br/>处理已解析事件\"]\n    end\n    \n    subgraph \"事件处理系统\"\n        Processor[\"EventProcessor<br/>主事件循环\"]\n        Workers[\"EventWorkers<br/>每连接处理\"]\n        Parsers[\"IParser<br/>协议解析\"]\n    end\n    \n    eBPFProg --> eBPFMaps\n    eBPFMaps --> Events\n    Events --> DecodeFun\n    DecodeFun --> Decode\n    Decode --> Dispatcher\n    Dispatcher --> Processor\n    Processor --> Workers\n    Workers --> Parsers\n```\n\n来源：[user/module/imodule.go:267-333](), [pkg/event_processor/processor.go:66-89](), [pkg/event_processor/iworker.go:87-94]()\n\n## 模块注册系统\n\n模块使用工厂模式和 `RegisteFunc()` 系统自注册。这使得能够通过 `GetModuleFunc()` 进行动态模块发现和实例化：\n\n```mermaid\ngraph TD\n    subgraph \"注册模式\"\n        Factory[\"NewXxxProbe()<br/>工厂函数\"]\n        ModStruct[\"创建模块结构\"]\n        SetName[\"设置模块名称\"]\n        SetType[\"设置探针类型\"]\n        Return[\"返回 IModule\"]\n    end\n    \n    subgraph \"注册过程\"\n        InitFunc[\"init() 函数\"]\n        CallRegister[\"RegisteFunc(NewXxxProbe)\"]\n        ModuleMap[\"全局模块注册表\"]\n    end\n    \n    subgraph \"模块发现\"\n        GetModules[\"模块枚举\"]\n        CreateInstance[\"工厂调用\"]\n        ModuleInit[\"模块初始化\"]\n    end\n    \n    Factory --> ModStruct\n    ModStruct --> SetName\n    SetName --> SetType\n    SetType --> Return\n    \n    InitFunc --> CallRegister\n    CallRegister --> ModuleMap\n    \n    GetModules --> CreateInstance\n    CreateInstance --> ModuleInit\n```\n\n来源：[user/module/probe_bash.go:311-320](), [user/module/probe_openssl.go:782-791](), [user/module/probe_nspr.go:273-282]()\n\n## 分步实现指南\n\n### 步骤 1：定义配置结构\n\n在 `user/config/config_yourmodule.go` 中创建实现 `IConfig` 接口 [user/config/iconfig.go:24-70]() 的配置结构：\n\n```go\ntype YourModuleConfig struct {\n    BaseConfig                    // 嵌入基础配置\n    YourModulePath string         // 模块特定路径\n    Model          string         // 捕获模式：text、pcap、keylog\n    PcapFile       string         // 输出 pcap 文件\n    PcapFilter     string         // BPF 过滤表达式\n    // 添加模块特定字段\n}\n\nfunc NewYourModuleConfig() *YourModuleConfig {\n    return &YourModuleConfig{\n        BaseConfig: BaseConfig{},\n    }\n}\n\nfunc (y *YourModuleConfig) Check() error {\n    // 验证配置\n    return nil\n}\n```\n\n参见示例：[user/config/config_openssl.go](), [user/config/config_bash.go]()。\n\n来源：[user/config/iconfig.go:24-70](), [cli/cmd/tls.go:26](), [cli/cmd/bash.go:24]()\n\n### 步骤 2：创建 CLI 命令\n\n遵循 Cobra 模式在 `cli/cmd/yourmodule.go` 中创建 CLI 命令文件：\n\n```go\nvar ymc = config.NewYourModuleConfig()\n\nvar yourmoduleCmd = &cobra.Command{\n    Use:     \"yourmodule\",\n    Aliases: []string{\"ym\"},\n    Short:   \"从目标捕获数据\",\n    Long:    `关于模块功能的详细描述`,\n    RunE:    yourmoduleCommandFunc,\n}\n\nfunc init() {\n    yourmoduleCmd.PersistentFlags().StringVar(&ymc.YourModulePath, \"path\", \"\", \"目标二进制路径\")\n    yourmoduleCmd.PersistentFlags().StringVarP(&ymc.Model, \"model\", \"m\", \"text\", \"捕获模式：text、pcap、keylog\")\n    yourmoduleCmd.PersistentFlags().StringVarP(&ymc.PcapFile, \"pcapfile\", \"w\", \"save.pcapng\", \"pcapng 输出文件\")\n    rootCmd.AddCommand(yourmoduleCmd)\n}\n\nfunc yourmoduleCommandFunc(command *cobra.Command, args []string) error {\n    return runModule(module.ModuleNameYourModule, ymc)\n}\n```\n\n[cli/cmd/root.go:250-403]() 中的 `runModule()` 函数处理：\n- 从全局标志设置模块配置\n- 初始化日志记录器和事件收集器\n- 通过工厂函数创建模块实例\n- 运行模块生命周期：Init → Run → Close\n\n来源：[cli/cmd/tls.go:26-67](), [cli/cmd/bash.go:24-55](), [cli/cmd/root.go:250-403]()\n\n### 步骤 3：创建模块结构\n\n在 `user/module/probe_yourmodule.go` 中创建新文件并定义模块结构：\n\n```go\ntype MYourModuleProbe struct {\n    Module                                     // 嵌入基础模块\n    bpfManager        *manager.Manager         // eBPF 程序管理器\n    bpfManagerOptions manager.Options          // 管理器配置\n    eventFuncMaps     map[*ebpf.Map]event.IEventStruct  // 映射 -> 解码器\n    eventMaps         []*ebpf.Map              // 事件数据映射\n    // 在此添加模块特定字段\n    targetPath        string                   // 目标二进制路径\n    targetFuncName    string                   // 要钩取的函数\n}\n```\n\n来源：[user/module/probe_openssl.go:83-106](), [user/module/probe_bash.go:42-50]()\n\n### 步骤 4：实现 Init() 方法\n\n实现 `Init()` 方法以初始化模块 [user/module/probe_openssl.go:109-176]()：\n\n```go\nfunc (m *MYourModuleProbe) Init(ctx context.Context, logger *zerolog.Logger, conf config.IConfig, ecw io.Writer) error {\n    // 调用基础 Init()\n    err := m.Module.Init(ctx, logger, conf, ecw)\n    if err != nil {\n        return err\n    }\n    \n    // 设置配置\n    m.conf = conf\n    m.Module.SetChild(m)\n    \n    // 初始化事件映射和解码器\n    m.eventMaps = make([]*ebpf.Map, 0, 2)\n    m.eventFuncMaps = make(map[*ebpf.Map]event.IEventStruct)\n    \n    // 模块特定初始化\n    ymc := conf.(*config.YourModuleConfig)\n    m.targetPath = ymc.YourModulePath\n    \n    // 验证目标二进制文件存在\n    if _, err := os.Stat(m.targetPath); err != nil {\n        return fmt.Errorf(\"目标二进制文件未找到: %w\", err)\n    }\n    \n    return nil\n}\n```\n\n来源：[user/module/probe_openssl.go:109-176](), [user/module/probe_bash.go:52-76]()\n\n### 步骤 5：配置 eBPF 程序\n\n实现调用 `setupManagers()` 的 `Start()` 方法以配置 eBPF 程序。`setupManagers()` 方法定义探针附加点和映射 [user/module/probe_bash.go:147-236]()：\n\n```go\nfunc (m *MYourModuleProbe) setupManagers() error {\n    // 定义 uprobe 附加点\n    m.bpfManager = &manager.Manager{\n        Probes: []*manager.Probe{\n            {\n                Section:          \"uprobe/your_target_function\",\n                EbpfFuncName:     \"probe_your_function\",\n                AttachToFuncName: \"your_target_function\",\n                BinaryPath:       m.targetPath,\n            },\n            {\n                Section:          \"uretprobe/your_target_function\",\n                EbpfFuncName:     \"probe_your_function_ret\",\n                AttachToFuncName: \"your_target_function\",\n                BinaryPath:       m.targetPath,\n            },\n        },\n        Maps: []*manager.Map{\n            {\n                Name: \"events\",\n            },\n        },\n    }\n    \n    // 设置管理器选项\n    m.bpfManagerOptions = manager.Options{\n        DefaultKProbeMaxActive: 512,\n        VerifierOptions: ebpf.CollectionOptions{\n            Programs: ebpf.ProgramOptions{\n                LogSize: 2097152,\n            },\n        },\n        RLimit: &unix.Rlimit{\n            Cur: math.MaxUint64,\n            Max: math.MaxUint64,\n        },\n    }\n    \n    return nil\n}\n```\n\n**manager.Probe 配置参数**\n\n| 参数 | 目的 | 示例 |\n|-----------|---------|---------|\n| `Section` | 字节码中的 eBPF 程序段名称 | `\"uprobe/readline\"` |\n| `EbpfFuncName` | eBPF C 代码中的函数名称 | `\"probe_readline\"` |\n| `AttachToFuncName` | 要钩取的目标函数 | `\"readline\"` |\n| `BinaryPath` | 目标二进制文件的路径 | `\"/bin/bash\"` |\n| `UID` | 按用户 ID 过滤（可选） | `\"uprobe/SSL_write\"` |\n\n来源：[user/module/probe_bash.go:147-236](), [user/module/probe_openssl.go:285-350]()\n\n### 步骤 6：加载并启动 eBPF 程序\n\n完成 `Start()` 方法以加载 eBPF 字节码并启动管理器 [user/module/probe_openssl.go:280-350]()：\n\n```go\nfunc (m *MYourModuleProbe) Start() error {\n    // 设置管理器\n    err := m.setupManagers()\n    if err != nil {\n        return err\n    }\n    \n    // 获取 eBPF 字节码文件\n    bpfFileName := m.geteBPFName(\"user/bytecode/yourmodule_kern.o\")\n    byteBuf, err := assets.Asset(bpfFileName)\n    if err != nil {\n        return fmt.Errorf(\"找不到资源: %w\", err)\n    }\n    \n    // 使用字节码初始化 eBPF 管理器\n    if err = m.bpfManager.InitWithOptions(bytes.NewReader(byteBuf), m.bpfManagerOptions); err != nil {\n        return fmt.Errorf(\"无法初始化管理器: %w\", err)\n    }\n    \n    // 启动 eBPF 管理器（附加探针）\n    if err = m.bpfManager.Start(); err != nil {\n        return fmt.Errorf(\"无法启动管理器: %w\", err)\n    }\n    \n    // 初始化事件解码器\n    err = m.initDecodeFun()\n    if err != nil {\n        return err\n    }\n    \n    return nil\n}\n```\n\n`geteBPFName()` 方法根据系统检测自动选择正确的字节码变体（CO-RE vs non-CO-RE，kernel < 5.2）[user/module/imodule.go:191-214]()。\n\n来源：[user/module/probe_openssl.go:280-350](), [user/module/imodule.go:191-214]()\n\n### 步骤 7：实现事件处理\n\n在 `initDecodeFun()` 中创建事件结构和解码器映射 [user/module/probe_bash.go:243-258]()：\n\n```go\nfunc (m *MYourModuleProbe) initDecodeFun() error {\n    // 获取 eBPF 映射\n    eventsMap, found, err := m.bpfManager.GetMap(\"events\")\n    if err != nil {\n        return err\n    }\n    if !found {\n        return errors.New(\"未找到 events 映射\")\n    }\n    \n    // 创建事件解码器实例\n    yourEvent := &event.YourModuleEvent{}\n    \n    // 将解码器映射到映射\n    m.eventFuncMaps[eventsMap] = yourEvent\n    \n    // 将映射添加到事件映射列表\n    m.eventMaps = append(m.eventMaps, eventsMap)\n    \n    return nil\n}\n```\n\n来源：[user/module/probe_bash.go:243-258](), [user/module/probe_openssl.go:336-348]()\n\n### 步骤 8：实现必需的接口方法\n\n实现其余的 `IModule` 接口方法：\n\n```go\n// Events 返回要从中读取事件的 eBPF 映射\nfunc (m *MYourModuleProbe) Events() []*ebpf.Map {\n    return m.eventMaps\n}\n\n// DecodeFun 返回给定 eBPF 映射的解码器\nfunc (m *MYourModuleProbe) DecodeFun(em *ebpf.Map) (event.IEventStruct, bool) {\n    fun, found := m.eventFuncMaps[em]\n    return fun, found\n}\n\n// Dispatcher 处理已解码的事件\nfunc (m *MYourModuleProbe) Dispatcher(e event.IEventStruct) {\n    switch ev := e.(type) {\n    case *event.YourModuleEvent:\n        // 处理您的事件\n        m.logger.Info().Str(\"data\", ev.String()).Msg(\"捕获的事件\")\n        // 写入事件收集器\n        m.processor.Write(ev)\n    }\n}\n\n// Close 清理资源\nfunc (m *MYourModuleProbe) Close() error {\n    if err := m.bpfManager.Stop(manager.CleanAll); err != nil {\n        return err\n    }\n    return m.Module.Close()\n}\n```\n\n来源：[user/module/probe_openssl.go:389-396](), [user/module/probe_openssl.go:733-754](), [user/module/probe_openssl.go:352-358]()\n\n### 步骤 9：注册模块\n\n在模块文件末尾使用工厂模式添加注册代码：\n\n```go\nfunc init() {\n    RegisteFunc(NewYourModuleProbe)\n}\n\nfunc NewYourModuleProbe() IModule {\n    mod := &MYourModuleProbe{}\n    mod.name = ModuleNameYourModule  // 定义此常量\n    mod.mType = ProbeTypeUprobe\n    return mod\n}\n```\n\n将模块名称常量添加到 `user/module/const.go`：\n```go\nconst (\n    ModuleNameYourModule = \"yourmodule\"\n)\n```\n\n`RegisteFunc()` 将工厂函数添加到全局模块注册表，通过 `GetModuleFunc()` 实现动态模块实例化 [cli/cmd/root.go:344]()。\n\n来源：[user/module/probe_bash.go:311-320](), [user/module/probe_openssl.go:777-786](), [user/module/imodule.go]()\n\n### 步骤 10：将模块添加到构建系统\n\n通过编辑 `Makefile` 将 eBPF 程序添加到构建系统：\n\n1. 在 `variables.mk` 中将字节码目标添加到 `TARGETS` 变量\n2. 在 `kern/yourmodule_kern.c` 创建 eBPF C 源文件\n3. 构建将生成 `yourmodule_kern_core.o` 和 `yourmodule_kern_noncore.o`\n4. 字节码通过 `go-bindata` 嵌入到 `assets/ebpf_probe.go`\n\n详见[开发指南 - 构建系统](#5.1)。\n\n来源：[Makefile](), [variables.mk](), [user/module/probe_bash.go:52-63]()\n\n## 创建事件结构\n\n创建实现 `event.IEventStruct` 接口的事件结构，以表示 eBPF 程序捕获的数据。事件结构在内核空间 eBPF 程序和用户空间 Go 代码之间架起桥梁。\n\n**事件结构模式**\n\n创建事件文件 `user/event/event_yourmodule.go`：\n\n```go\ntype YourModuleEvent struct {\n    eventType EventType\n    Pid       uint32\n    Uid       uint32\n    Timestamp uint64\n    Comm      [16]byte\n    // 与 eBPF 结构匹配的模块特定字段\n    DataLen   uint32\n    Data      [MAX_DATA_SIZE]byte\n}\n\n// Clone 创建新实例\nfunc (e *YourModuleEvent) Clone() IEventStruct {\n    return new(YourModuleEvent)\n}\n\n// EventType 返回用于路由的事件类型\nfunc (e *YourModuleEvent) EventType() EventType {\n    return e.eventType\n}\n\n// Decode 从 eBPF 解析原始字节\nfunc (e *YourModuleEvent) Decode(payload []byte) error {\n    buf := bytes.NewBuffer(payload)\n    if err := binary.Read(buf, binary.LittleEndian, &e.Pid); err != nil {\n        return err\n    }\n    if err := binary.Read(buf, binary.LittleEndian, &e.Uid); err != nil {\n        return err\n    }\n    // 解码剩余字段...\n    return nil\n}\n\n// String 返回人类可读格式\nfunc (e *YourModuleEvent) String() string {\n    s := fmt.Sprintf(\"PID:%d UID:%d Data:%s\",\n        e.Pid, e.Uid, string(e.Data[:e.DataLen]))\n    return s\n}\n\n// StringHex 返回十六进制格式\nfunc (e *YourModuleEvent) StringHex() string {\n    return fmt.Sprintf(\"%s\\n%s\", e.String(), \n        hex.Dump(e.Data[:e.DataLen]))\n}\n```\n\n**事件类型常量**\n\n根据数据处理要求在 `Decode()` 方法中设置 `eventType`：\n\n| 事件类型 | 目的 | 处理 |\n|------------|---------|------------|\n| `TypeEventProcessor` | 需要聚合/解析 | 发送到 `EventProcessor`，由 `IWorker` 处理 |\n| `TypeOutput` | 直接输出 | 立即格式化并写入 |\n| `TypeModuleData` | 模块内部 | 由模块的 `Dispatcher()` 处理 |\n\n来源：[user/event/event_bash.go](), [pkg/event_processor/iworker.go:32-46](), [user/module/imodule.go:430-448]()\n\n## 模块注册与发现\n\n模块系统使用工厂模式进行注册。模块在其 `init()` 函数中自注册，使其可用于动态实例化。\n\n**模块注册流程**\n\n```mermaid\ngraph LR\n    subgraph \"模块注册\"\n        InitFunc[\"init() 函数<br/>在 probe_yourmodule.go 中\"]\n        RegisteFunc[\"RegisteFunc()<br/>注册工厂\"]\n        ModuleRegistry[\"moduleRegistry<br/>map[string]GetModuleFunc\"]\n    end\n    \n    subgraph \"模块实例化\"\n        CLI[\"CLI 命令执行<br/>yourmoduleCommandFunc()\"]\n        RunModule[\"runModule()<br/>在 root.go 中\"]\n        GetModuleFunc[\"GetModuleFunc()<br/>查找工厂\"]\n        Factory[\"NewYourModuleProbe()<br/>创建实例\"]\n        ModuleInit[\"mod.Init()<br/>初始化模块\"]\n    end\n    \n    InitFunc --> RegisteFunc\n    RegisteFunc --> ModuleRegistry\n    \n    CLI --> RunModule\n    RunModule --> GetModuleFunc\n    GetModuleFunc --> ModuleRegistry\n    ModuleRegistry --> Factory\n    Factory --> ModuleInit\n```\n\n[cli/cmd/root.go:250-403]() 中的 `runModule()` 函数协调整个模块生命周期：\n\n1. 通过 `GetModuleFunc(modName)` 检索模块工厂\n2. 通过调用工厂函数创建模块实例\n3. 使用配置调用 `mod.Init()`\n4. 调用 `mod.Run()` 启动捕获\n5. 等待信号或配置重新加载\n6. 调用 `mod.Close()` 进行清理\n\n来源：[cli/cmd/root.go:250-403](), [user/module/probe_bash.go:311-320]()\n\n## 配置模式\n\n模块通过 `IConfig` 接口接收配置。创建一个嵌入 `BaseConfig` 并添加模块特定字段的配置结构：\n\n```go\ntype YourModuleConfig struct {\n    BaseConfig               // 继承：Pid、Uid、Debug、IsHex、BtfMode、PerCpuMapSize\n    YourModulePath string    // 目标二进制路径\n    Model          string    // 输出模式：text、pcap、keylog\n    // 根据需要添加更多字段\n}\n\nfunc (c *YourModuleConfig) Check() error {\n    // 验证 YourModulePath 存在\n    if c.YourModulePath == \"\" {\n        return errors.New(\"需要目标路径\")\n    }\n    return nil\n}\n```\n\n配置通过 CLI → `runModule()` → `mod.Init()` → 模块代码路径传递。使用类型断言访问模块特定字段：\n\n```go\nfunc (m *MYourModuleProbe) Init(ctx context.Context, logger *zerolog.Logger, conf config.IConfig, ecw io.Writer) error {\n    // ...\n    ymc := conf.(*config.YourModuleConfig)\n    m.targetPath = ymc.YourModulePath\n    // ...\n}\n```\n\n来源：[user/config/iconfig.go:95-112](), [cli/cmd/root.go:157-175]()\n\n## 测试与调试\n\n**测试方法**\n\n| 测试阶段 | 技术 | 命令/工具 |\n|---------------|-----------|--------------|\n| eBPF 附加 | 验证探针已附加 | `bpftool prog list`、`bpftool map list` |\n| 事件生成 | 触发目标应用程序 | 运行应用程序与模块 |\n| 事件解码 | 添加调试日志 | 在 `Dispatcher()` 中使用 `logger.Debug().Msg()` |\n| 集成 | 端到端测试 | `ecapture yourmodule --debug` |\n\n**常见问题**\n\n| 问题 | 症状 | 解决方案 |\n|-------|----------|----------|\n| 探针附加失败 | `couldn't start manager` | 验证 `BinaryPath` 和 `AttachToFuncName` 是否正确 |\n| 未接收到事件 | 静默操作 | 检查 eBPF 程序是否触发，验证映射名称 |\n| 解码错误 | `m.child.decode error` | 确保 Go 结构与 eBPF 结构布局完全匹配 |\n| 未找到模块 | `cant found module function` | 验证 `init()` 调用 `RegisteFunc()`，检查模块名称 |\n\n**调试工作流程**\n\n1. 启用调试模式：`ecapture yourmodule --debug`\n2. 检查 eBPF 程序加载：查找\"BPF bytecode file is matched\"日志\n3. 验证探针附加：查找\"module started successfully\"日志\n4. 监控事件：在 `Dispatcher()` 方法中添加日志\n5. 检查事件处理器：查找处理器工作者日志\n\n来源：[user/module/probe_openssl.go:280-350](), [user/module/imodule.go:285-306]()\n\n## 总结\n\n创建新的 eCapture 模块涉及：\n\n1. **配置**：创建实现 `IConfig` 的 `YourModuleConfig` 结构\n2. **CLI 命令**：在 `cli/cmd/` 目录中添加 `yourmoduleCmd`\n3. **模块结构**：创建嵌入 `Module` 基础的 `MYourModuleProbe`\n4. **初始化**：实现 `Init()` 以设置模块状态\n5. **eBPF 设置**：实现 `setupManagers()` 以配置探针和映射\n6. **启动**：实现 `Start()` 以加载字节码并附加探针\n7. **事件处理**：实现 `Events()`、`DecodeFun()`、`Dispatcher()`\n8. **事件结构**：创建实现 `IEventStruct` 的事件类型\n9. **注册**：添加调用 `RegisteFunc()` 的 `init()` 函数\n10. **构建集成**：将 eBPF 程序添加到构建系统\n\n参考现有模块如 `MOpenSSLProbe` [user/module/probe_openssl.go]() 或 `MBashProbe` [user/module/probe_bash.go]() 作为参考实现。模块化架构确保新模块与现有的事件处理、配置和输出系统无缝集成。\n\n来源：[user/module/probe_openssl.go](), [user/module/probe_bash.go](), [cli/cmd/tls.go](), [cli/cmd/bash.go]()"
          },
          {
            "page_plan": {
              "id": "5.4",
              "title": "事件处理与解析器"
            },
            "content": "# 事件处理与解析器\n\n本文档说明 eCapture 中的事件处理系统和协议解析器。该系统在原始 eBPF 事件和格式化输出之间架起桥梁，处理事件反序列化、聚合、协议解析和输出格式化。\n\n有关输出格式（文本、PCAP、密钥日志）的信息，请参阅[输出格式](#4)。有关模块如何生成事件的信息，请参阅[捕获模块](#3)。\n\n## 概述\n\n事件处理流程由三个主要组件组成：\n\n1. **事件结构体** - 实现 `IEventStruct` 接口的强类型事件，用于反序列化 eBPF 数据\n2. **事件处理器** - 管理 worker 生命周期并基于 UUID 路由事件\n3. **协议解析器** - 从聚合的载荷中检测和解析应用协议（HTTP/1.x、HTTP/2）\n\n## 事件结构体系统\n\n### IEventStruct 接口\n\neCapture 中的所有事件都实现 `IEventStruct` 接口，该接口定义了事件处理的标准契约：\n\n```mermaid\ngraph TB\n    IEventStruct[\"IEventStruct 接口\"]\n    \n    IEventStruct --> Decode[\"Decode(payload []byte) error\"]\n    IEventStruct --> Payload[\"Payload() []byte\"]\n    IEventStruct --> PayloadLen[\"PayloadLen() int\"]\n    IEventStruct --> String[\"String() string\"]\n    IEventStruct --> StringHex[\"StringHex() string\"]\n    IEventStruct --> Clone[\"Clone() IEventStruct\"]\n    IEventStruct --> EventType[\"EventType() Type\"]\n    IEventStruct --> GetUUID[\"GetUUID() string\"]\n    IEventStruct --> Base[\"Base() Base\"]\n    IEventStruct --> ToProtobufEvent[\"ToProtobufEvent() *pb.Event\"]\n    \n    style IEventStruct fill:#e3f2fd\n```\n\n**来源：** [user/event/ievent.go:41-52]()\n\n接口方法各有特定用途：\n\n| 方法 | 用途 |\n|------|------|\n| `Decode()` | 将 eBPF map 中的二进制载荷反序列化为结构化字段 |\n| `Payload()` / `PayloadLen()` | 访问原始数据字节（例如 SSL 明文、SQL 查询） |\n| `String()` / `StringHex()` | 格式化事件以供文本输出，有或无十六进制转储 |\n| `Clone()` | 创建空实例用于多态事件读取 |\n| `EventType()` | 确定路由：`TypeOutput`、`TypeModuleData` 或 `TypeEventProcessor` |\n| `GetUUID()` | 生成唯一标识符用于分组相关事件 |\n| `Base()` | 提取公共元数据（时间戳、PID、IP 地址）用于文本输出 |\n| `ToProtobufEvent()` | 序列化为 protobuf 格式以集成 eCaptureQ GUI |\n\n### 事件类型分类\n\n事件通过 `Type` 枚举分类以控制其处理路径：\n\n```mermaid\ngraph LR\n    Type[\"event.Type 枚举\"]\n    \n    Type --> TypeOutput[\"TypeOutput<br/>直接写入日志\"]\n    Type --> TypeModuleData[\"TypeModuleData<br/>模块缓存\"]\n    Type --> TypeEventProcessor[\"TypeEventProcessor<br/>解析器聚合\"]\n    \n    TypeOutput --> Logger[\"io.Writer\"]\n    TypeModuleData --> ModuleState[\"模块状态<br/>pidConns, masterKeys\"]\n    TypeEventProcessor --> EventProcessor[\"EventProcessor<br/>IWorker 路由\"]\n```\n\n**来源：** [user/event/ievent.go:26-37]()\n\n- **`TypeOutput`** - 直接写入输出而不聚合的事件（例如 Bash 命令、数据库查询）\n- **`TypeModuleData`** - 存储在模块状态中用于关联的事件（例如连接元数据、主密钥）\n- **`TypeEventProcessor`** - 通过 EventProcessor 路由以进行载荷聚合和解析的事件（例如 SSL 数据事件）\n\n### 具体事件实现\n\n以下图表将事件结构体映射到它们的源模块：\n\n```mermaid\ngraph TB\n    subgraph \"TLS 事件\"\n        SSLDataEvent[\"SSLDataEvent<br/>OpenSSL/BoringSSL 明文\"]\n        ConnDataEvent[\"ConnDataEvent<br/>TCP 连接元数据\"]\n        MasterSecretEvent[\"MasterSecretEvent<br/>TLS 1.2 主密钥\"]\n        MasterSecretBSSLEvent[\"MasterSecretBSSLEvent<br/>TLS 1.3 BoringSSL 密钥\"]\n    end\n    \n    subgraph \"TLS 库事件\"\n        GnutlsDataEvent[\"GnutlsDataEvent<br/>GnuTLS 明文\"]\n        NsprDataEvent[\"NsprDataEvent<br/>NSPR/NSS 明文\"]\n    end\n    \n    subgraph \"数据库事件\"\n        MysqldEvent[\"MysqldEvent<br/>MySQL 查询\"]\n        PostgresEvent[\"PostgresEvent<br/>PostgreSQL 查询\"]\n    end\n    \n    subgraph \"Shell 事件\"\n        BashEvent[\"BashEvent<br/>Bash 命令\"]\n    end\n    \n    subgraph \"网络事件\"\n        TcSkbEvent[\"TcSkbEvent<br/>TC 数据包捕获\"]\n    end\n    \n    IEventStruct[\"IEventStruct 接口\"]\n    \n    SSLDataEvent -.->|实现| IEventStruct\n    ConnDataEvent -.->|实现| IEventStruct\n    MasterSecretEvent -.->|实现| IEventStruct\n    MasterSecretBSSLEvent -.->|实现| IEventStruct\n    GnutlsDataEvent -.->|实现| IEventStruct\n    NsprDataEvent -.->|实现| IEventStruct\n    MysqldEvent -.->|实现| IEventStruct\n    PostgresEvent -.->|实现| IEventStruct\n    BashEvent -.->|实现| IEventStruct\n    TcSkbEvent -.->|实现| IEventStruct\n```\n\n**来源：** [user/event/event_openssl.go:77-92](), [user/event/event_openssl.go:289-294](), [user/event/event_masterkey.go:37-55](), [user/event/event_masterkey.go:156-174](), [user/event/event_gnutls.go:25-35](), [user/event/event_nspr.go:26-36](), [user/event/event_mysqld.go:68-78](), [user/event/event_postgres.go:38-44](), [user/event/event_bash.go:37-47](), [user/event/event_openssl_tc.go:30-40]()\n\n#### SSLDataEvent 结构体\n\n`SSLDataEvent` 是最常用的事件，从 OpenSSL/BoringSSL 捕获 SSL/TLS 明文：\n\n```mermaid\ngraph TB\n    SSLDataEvent[\"SSLDataEvent\"]\n    \n    SSLDataEvent --> Fields[\"关键字段\"]\n    Fields --> DataType[\"DataType: int64<br/>ProbeEntry(0) 或 ProbeRet(1)\"]\n    Fields --> Timestamp[\"Timestamp: uint64\"]\n    Fields --> Pid[\"Pid: uint32\"]\n    Fields --> Tid[\"Tid: uint32\"]\n    Fields --> Data[\"Data: [16384]byte<br/>明文载荷\"]\n    Fields --> DataLen[\"DataLen: int32<br/>实际载荷长度\"]\n    Fields --> Comm[\"Comm: [16]byte<br/>进程名\"]\n    Fields --> Fd[\"Fd: uint32<br/>文件描述符\"]\n    Fields --> Version[\"Version: int32<br/>TLS 版本\"]\n    Fields --> Tuple[\"Tuple: string<br/>IP:端口-IP:端口\"]\n    Fields --> Sock[\"Sock: uint64<br/>Socket 指针\"]\n    \n    UUID[\"GetUUID() 格式\"]\n    UUID --> UUIDFormat[\"sock:Pid_Tid_Comm_Fd_DataType_Tuple_Sock<br/>示例: sock:1234_5678_curl_3_0_192.168.1.1:443-1.2.3.4:12345_0x7f8a9b0c1d2e\"]\n```\n\n**来源：** [user/event/event_openssl.go:77-92](), [user/event/event_openssl.go:138-141]()\n\nUUID 格式包含 `sock:` 前缀用于 socket 生命周期管理的 worker（参见 Worker 生命周期管理章节）。\n\n#### ConnDataEvent 结构体\n\n`ConnDataEvent` 提供来自 TC eBPF 钩子的连接元数据：\n\n```mermaid\ngraph LR\n    ConnDataEvent[\"ConnDataEvent\"]\n    \n    ConnDataEvent --> Decode[\"Decode()\"]\n    Decode --> ParseAddrs[\"解析 Saddr/Daddr\"]\n    ParseAddrs --> IPv4[\"AF_INET<br/>netip.AddrFrom4\"]\n    ParseAddrs --> IPv6[\"AF_INET6<br/>netip.AddrFrom16\"]\n    IPv4 --> Tuple[\"Tuple: 'IP:端口-IP:端口'\"]\n    IPv6 --> Tuple\n    \n    ConnDataEvent --> Fields[\"Saddr/Daddr: [16]byte<br/>Sport/Dport: uint16<br/>Family: uint16<br/>Sock: uint64\"]\n```\n\n**来源：** [user/event/event_openssl.go:272-308]()\n\n### 事件解码过程\n\n事件解码遵循使用 `binary.Read()` 的标准模式：\n\n```mermaid\nsequenceDiagram\n    participant eBPF as eBPF Map\n    participant Module as 模块读取器\n    participant Event as IEventStruct\n    participant Buffer as bytes.Buffer\n    \n    eBPF->>Module: 原始字节\n    Module->>Event: 调用 Decode(payload)\n    Event->>Buffer: 从载荷创建缓冲区\n    \n    loop 对于每个字段\n        Event->>Buffer: binary.Read(buf, binary.LittleEndian, &field)\n    end\n    \n    Event->>Event: 后处理<br/>(解码 ktime, 解析 tuple)\n    Event->>Module: 返回已解码的事件\n```\n\n**来源：** [user/event/event_openssl.go:94-132](), [user/event/event_bash.go:49-69](), [user/event/event_mysqld.go:80-109]()\n\n所有事件都使用 `binary.LittleEndian` 以匹配 eBPF 数据布局。包含时间戳的事件调用 `DecodeKtime()` 将内核时间转换为 Unix 纳秒。\n\n## EventProcessor 架构\n\n### 核心组件\n\n`EventProcessor` 管理事件处理流程：\n\n```mermaid\ngraph TB\n    subgraph \"EventProcessor 结构体\"\n        EP[\"EventProcessor\"]\n        \n        EP --> incoming[\"incoming chan<br/>IEventStruct<br/>缓冲区: 1024\"]\n        EP --> outComing[\"outComing chan<br/>[]byte<br/>缓冲区: 1024\"]\n        EP --> destroyConn[\"destroyConn chan<br/>uint64<br/>Socket 清理\"]\n        EP --> workerQueue[\"workerQueue<br/>map[string]IWorker<br/>UUID -> Worker\"]\n        EP --> logger[\"logger io.Writer<br/>输出目标\"]\n        EP --> closeChan[\"closeChan bool<br/>关闭信号\"]\n    end\n    \n    Module[\"模块\"] --> incoming\n    workerQueue --> Workers[\"eventWorker 实例\"]\n    Workers --> outComing\n    outComing --> logger\n```\n\n**来源：** [pkg/event_processor/processor.go:30-50]()\n\n处理器维护：\n- **`incoming` 通道** - 从模块接收事件（缓冲区大小 1024）\n- **`outComing` 通道** - 格式化输出到日志器（缓冲区大小 1024）\n- **`destroyConn` 通道** - Socket 销毁通知\n- **`workerQueue` 映射** - UUID 到 worker 的映射用于事件路由\n- **`logger` io.Writer** - 输出目标（控制台、文件或 CollectorWriter）\n\n### 事件调度流程\n\n```mermaid\nsequenceDiagram\n    participant Module as 模块\n    participant EP as EventProcessor\n    participant WQ as workerQueue\n    participant EW as eventWorker\n    \n    Module->>EP: Write(event)\n    EP->>EP: incoming <- event\n    \n    EP->>EP: Serve() select incoming\n    EP->>EP: dispatch(event)\n    \n    EP->>EP: uuid = event.GetUUID()\n    EP->>WQ: getWorkerByUUID(uuid)\n    \n    alt Worker 存在\n        WQ->>EW: 返回现有 worker\n        EW->>EW: worker.Get()<br/>(原子引用)\n    else Worker 未找到\n        EP->>EW: NewEventWorker(uuid, ep)\n        EP->>WQ: addWorkerByUUID(worker)\n    end\n    \n    EP->>EW: worker.Write(event)\n    EW->>EW: incoming <- event\n    EP->>EW: worker.Put()<br/>(释放引用)\n```\n\n**来源：** [pkg/event_processor/processor.go:66-109](), [pkg/event_processor/processor.go:130-148]()\n\n关键方面：\n1. **基于 UUID 的路由** - `GetUUID()` 将相关事件分组到同一个 worker\n2. **延迟 worker 创建** - Worker 在 UUID 的第一个事件时创建\n3. **引用计数** - `Get()`/`Put()` 防止删除期间的竞态条件\n4. **非阻塞写入** - 如果 incoming 通道已满则丢弃事件\n\n## Worker 系统\n\n### IWorker 接口\n\nWorker 聚合事件并调用解析器：\n\n```mermaid\ngraph TB\n    IWorker[\"IWorker 接口\"]\n    \n    IWorker --> Write[\"Write(event.IEventStruct) error<br/>向 worker 添加事件\"]\n    IWorker --> GetUUID[\"GetUUID() string<br/>返回 worker UUID\"]\n    IWorker --> GetDestroyUUID[\"GetDestroyUUID() uint64<br/>用于清理的 Socket 指针\"]\n    IWorker --> IfUsed[\"IfUsed() bool<br/>引用计数\"]\n    IWorker --> Get[\"Get()<br/>获取引用\"]\n    IWorker --> Put[\"Put()<br/>释放引用\"]\n    IWorker --> CloseEventWorker[\"CloseEventWorker()<br/>外部关闭信号\"]\n```\n\n**来源：** [pkg/event_processor/iworker.go:35-49]()\n\n### eventWorker 实现\n\n```mermaid\ngraph TB\n    subgraph \"eventWorker 结构体\"\n        EW[\"eventWorker\"]\n        \n        EW --> incoming[\"incoming chan<br/>IEventStruct<br/>缓冲区: 1024\"]\n        EW --> outComing[\"outComing chan<br/>[]byte<br/>与处理器共享\"]\n        EW --> ticker[\"ticker *time.Ticker<br/>100ms 间隔\"]\n        EW --> tickerCount[\"tickerCount uint8<br/>空闲检测\"]\n        EW --> UUID[\"UUID string<br/>完整 UUID\"]\n        EW --> uuidOutput[\"uuidOutput string<br/>显示 UUID\"]\n        EW --> DestroyUUID[\"DestroyUUID uint64<br/>Socket 指针\"]\n        EW --> parser[\"parser IParser<br/>协议解析器\"]\n        EW --> payload[\"payload *bytes.Buffer<br/>聚合数据\"]\n        EW --> used[\"used atomic.Bool<br/>引用计数\"]\n        EW --> closeChan[\"closeChan chan struct{}<br/>关闭信号\"]\n        EW --> ewLifeCycleState[\"ewLifeCycleState<br/>LifeCycleState\"]\n    end\n```\n\n**来源：** [pkg/event_processor/iworker.go:70-89]()\n\n### Worker 生命周期管理\n\nWorker 基于 UUID 前缀支持两种生命周期模式：\n\n```mermaid\ngraph TB\n    UUID[\"event.GetUUID()\"]\n    \n    UUID --> CheckPrefix[\"检查 'sock:' 前缀\"]\n    \n    CheckPrefix -->|有前缀| Socket[\"LifeCycleStateSock\"]\n    CheckPrefix -->|无前缀| Default[\"LifeCycleStateDefault\"]\n    \n    Socket --> ParseSock[\"从 UUID 后缀<br/>解析 socket 指针\"]\n    Socket --> CreateClose[\"closeChan = make(chan struct{})\"]\n    Socket --> SetDestroy[\"DestroyUUID = sock 指针\"]\n    Socket --> Lifecycle1[\"生命周期:<br/>1. Ticker 超时: Display() 并继续<br/>2. closeChan 信号: 销毁 worker\"]\n    \n    Default --> NilClose[\"closeChan = nil\"]\n    Default --> NoDestroy[\"DestroyUUID = 0\"]\n    Default --> Lifecycle2[\"生命周期:<br/>1. Ticker 超时: 销毁 worker\"]\n    \n    style Socket fill:#e3f2fd\n    style Default fill:#fff3e0\n```\n\n**来源：** [pkg/event_processor/iworker.go:57-63](), [pkg/event_processor/iworker.go:100-123]()\n\n**LifeCycleStateDefault:**\n- 当 UUID 不以 `sock:` 开头时使用\n- Worker 在空闲超时后销毁（1 秒 = 10 次 tick × 100ms）\n- 示例：Bash 事件、MySQL 查询，UUID 为 `PID_TID_Comm`\n\n**LifeCycleStateSock:**\n- 当 UUID 以 `sock:` 前缀开头时使用\n- Worker 在空闲期间持续存在\n- 仅在 socket 关闭时销毁（外部 `CloseEventWorker()` 调用）\n- 示例：SSL 数据事件，UUID 为 `sock:PID_TID_Comm_Fd_DataType_Tuple_Sock`\n- `DestroyUUID` 包含用于清理匹配的 socket 指针\n\n### Worker 事件循环\n\n```mermaid\nsequenceDiagram\n    participant Ticker as ticker.C\n    participant Worker as eventWorker\n    participant Channel as incoming\n    participant Close as closeChan\n    \n    loop Run() 永久循环\n        alt Ticker 触发 (100ms)\n            Ticker->>Worker: Tick\n            Worker->>Worker: tickerCount++\n            \n            alt tickerCount > 10 (1 秒空闲)\n                alt LifeCycleStateSock\n                    Worker->>Worker: drainAndClose()\n                    Worker->>Worker: tickerCount = 0\n                    Worker->>Worker: ticker 重启标志\n                else LifeCycleStateDefault\n                    Worker->>Worker: processor.delWorkerByUUID()\n                    Worker->>Worker: drainAndClose()\n                    Worker->>Worker: Return (退出)\n                end\n            end\n            \n        else 事件到达\n            Channel->>Worker: event\n            Worker->>Worker: tickerCount = 0\n            Worker->>Worker: writeEvent(event)\n            Worker->>Worker: payload.Write(event.Payload())\n            \n        else Socket 关闭 (仅 Sock 生命周期)\n            Close->>Worker: 信号\n            Worker->>Worker: processor.delWorkerByUUID()\n            Worker->>Worker: drainAndClose()\n            Worker->>Worker: Return (退出)\n        end\n    end\n```\n\n**来源：** [pkg/event_processor/iworker.go:262-306]()\n\n关键行为：\n- **Ticker 重置** - 每个事件到达时重置（`tickerCount = 0`）\n- **载荷聚合** - 事件在 `payload` 缓冲区中累积\n- **空闲超时** - 10 次 tick（1 秒）无事件触发生命周期操作\n- **Socket 生命周期** - 来自外部 socket 销毁的 `closeChan` 信号\n\n### 事件显示与解析\n\n当 worker 准备输出时（超时或 socket 关闭），它调用显示流程：\n\n```mermaid\nsequenceDiagram\n    participant Worker as eventWorker\n    participant Parser as IParser\n    participant Processor as EventProcessor\n    participant Logger as io.Writer\n    \n    Worker->>Worker: Display()\n    Worker->>Worker: parserEvents()\n    \n    alt parser == nil (首次调用)\n        Worker->>Parser: NewParser(payload.Bytes())\n        Parser->>Parser: detect() 所有解析器\n        Parser-->>Worker: 返回匹配的解析器\n    end\n    \n    Worker->>Parser: parser.Write(payload.Bytes())\n    Parser->>Parser: 解析协议数据\n    Worker->>Parser: parser.Display()\n    Parser-->>Worker: 格式化字节\n    \n    alt isHex == true\n        Worker->>Worker: hex.Dump(bytes)\n    end\n    \n    alt logger 是 CollectorWriter\n        Worker->>Worker: 使用 Base 信息格式化\n        Worker->>Processor: writeToChan(formatted)\n    else logger 是 protobuf\n        Worker->>Worker: ToProtobufEvent()\n        Worker->>Worker: proto.Marshal()\n        Worker->>Processor: writeToChan(marshalled)\n    end\n    \n    Processor->>Logger: Write(bytes)\n    \n    Worker->>Parser: parser.Reset()\n    Worker->>Worker: payload.Reset()\n```\n\n**来源：** [pkg/event_processor/iworker.go:175-228](), [pkg/event_processor/iworker.go:248-260]()\n\n显示过程：\n1. 聚合的载荷传递给解析器\n2. 解析器检测协议并格式化输出\n3. 基于日志器类型（文本 vs protobuf）格式化输出\n4. Worker 状态重置以备下一批\n\n## 解析器系统\n\n### IParser 接口\n\n解析器检测和格式化应用协议：\n\n```mermaid\ngraph TB\n    IParser[\"IParser 接口\"]\n    \n    IParser --> detect[\"detect(b []byte) error<br/>测试载荷是否匹配协议\"]\n    IParser --> Write[\"Write(b []byte) (int, error)<br/>累积载荷数据\"]\n    IParser --> ParserType[\"ParserType() ParserType<br/>返回解析器类型枚举\"]\n    IParser --> PacketType[\"PacketType() PacketType<br/>编码: Null/Gzip/WebSocket\"]\n    IParser --> Name[\"Name() string<br/>解析器标识符\"]\n    IParser --> IsDone[\"IsDone() bool<br/>完整消息已接收\"]\n    IParser --> Init[\"Init()<br/>初始化缓冲区\"]\n    IParser --> Display[\"Display() []byte<br/>格式化解析后的输出\"]\n    IParser --> Reset[\"Reset()<br/>准备下一条消息\"]\n```\n\n**来源：** [pkg/event_processor/iparser.go:49-60]()\n\n### 解析器类型\n\n```mermaid\ngraph TB\n    ParserType[\"ParserType 枚举\"]\n    \n    ParserType --> Null[\"ParserTypeNull (0)<br/>DefaultParser\"]\n    ParserType --> HttpReq[\"ParserTypeHttpRequest (1)<br/>HTTPRequest\"]\n    ParserType --> Http2Req[\"ParserTypeHttp2Request (2)<br/>HTTP2Request\"]\n    ParserType --> HttpResp[\"ParserTypeHttpResponse (3)<br/>HTTPResponse\"]\n    ParserType --> Http2Resp[\"ParserTypeHttp2Response (4)<br/>HTTP2Response\"]\n    ParserType --> WebSocket[\"ParserTypeWebSocket (5)<br/>WebSocket\"]\n    \n    Null --> DefaultBehavior[\"原始文本或十六进制转储<br/>无协议解析\"]\n    HttpReq --> HTTP1Req[\"Go net/http.ReadRequest\"]\n    Http2Req --> H2Frame[\"HTTP/2 帧解析\"]\n    HttpResp --> HTTP1Resp[\"Go net/http.ReadResponse\"]\n    Http2Resp --> H2FrameResp[\"HTTP/2 帧解析\"]\n```\n\n**来源：** [pkg/event_processor/iparser.go:40-47]()\n\n### 解析器选择\n\n`NewParser()` 函数自动检测协议：\n\n```mermaid\nsequenceDiagram\n    participant Worker as eventWorker\n    participant Factory as NewParser()\n    participant Registry as parsers map\n    participant Parser as IParser\n    \n    Worker->>Factory: NewParser(payload)\n    \n    alt payload 非空\n        Factory->>Registry: 迭代所有解析器\n        \n        loop 对于每个注册的解析器\n            Factory->>Parser: detect(payload)\n            \n            alt 无错误\n                Factory->>Factory: 根据 ParserType() 切换\n                Factory->>Parser: 创建新实例\n                Factory->>Parser: Init()\n                Factory-->>Worker: 返回解析器\n            end\n        end\n        \n        alt 无解析器匹配\n            Factory->>Parser: new(DefaultParser)\n            Factory->>Parser: Init()\n            Factory-->>Worker: 返回 DefaultParser\n        end\n        \n    else payload 为空\n        Factory->>Parser: new(DefaultParser)\n        Factory->>Parser: Init()\n        Factory-->>Worker: 返回 DefaultParser\n    end\n```\n\n**来源：** [pkg/event_processor/iparser.go:85-115]()\n\n检测顺序：\n1. 尝试每个注册解析器的 `detect()` 方法\n2. 第一个成功匹配创建类型化解析器实例\n3. 如果无匹配则回退到 `DefaultParser`\n\n### 解析器注册\n\n解析器在包初始化期间自注册：\n\n```mermaid\ngraph LR\n    init1[\"http_request.go init()\"]\n    init2[\"http_response.go init()\"]\n    init3[\"http2_request.go init()\"]\n    init4[\"http2_response.go init()\"]\n    \n    init1 --> Register[\"Register(*HTTPRequest)\"]\n    init2 --> Register\n    init3 --> Register\n    init4 --> Register\n    \n    Register --> parsers[\"parsers map[string]IParser\"]\n```\n\n**来源：** [pkg/event_processor/http_request.go:159-163](), [pkg/event_processor/http_response.go:177-181](), [pkg/event_processor/iparser.go:64-73]()\n\n### HTTP 请求解析器\n\n`HTTPRequest` 解析器处理 HTTP/1.x 请求：\n\n```mermaid\ngraph TB\n    subgraph \"HTTPRequest 结构体\"\n        HR[\"HTTPRequest\"]\n        \n        HR --> request[\"request *http.Request<br/>已解析的请求\"]\n        HR --> reader[\"reader *bytes.Buffer<br/>累加器\"]\n        HR --> bufReader[\"bufReader *bufio.Reader<br/>缓冲读取器\"]\n        HR --> isInit[\"isInit bool<br/>头部已解析\"]\n        HR --> isDone[\"isDone bool<br/>正文完成\"]\n        HR --> packerType[\"packerType PacketType<br/>Null/Gzip\"]\n    end\n    \n    subgraph \"处理步骤\"\n        Write[\"Write(b []byte)\"]\n        \n        Write --> Check[\"检查 isInit\"]\n        Check -->|false| Parse[\"reader.Write(b)<br/>http.ReadRequest(bufReader)\"]\n        Parse --> SetInit[\"isInit = true\"]\n        Check -->|true| Append[\"reader.Write(b)\"]\n        \n        Display[\"Display()\"]\n        Display --> ReadBody[\"io.ReadAll(request.Body)\"]\n        Display --> CheckGzip[\"检查 Content-Encoding\"]\n        CheckGzip -->|gzip| Decompress[\"gzip.NewReader<br/>io.ReadAll\"]\n        CheckGzip -->|其他| Raw[\"使用原始正文\"]\n        Display --> Dump[\"httputil.DumpRequest\"]\n        Display --> Combine[\"组合头部 + 正文\"]\n    end\n```\n\n**来源：** [pkg/event_processor/http_request.go:28-35](), [pkg/event_processor/http_request.go:54-81](), [pkg/event_processor/http_request.go:105-157]()\n\n关键特性：\n- **增量解析** - 头部完成时调用一次 `http.ReadRequest()`\n- **正文累积** - 额外写入追加到正文缓冲区\n- **Gzip 解压** - 自动处理 `Content-Encoding: gzip`\n- **HTTP/2 检测** - 如果 `Proto == \"HTTP/2.0\"` 则返回原始字节\n\n### HTTP 响应解析器\n\n类似于请求解析器，但使用 `http.ReadResponse()`：\n\n```mermaid\ngraph TB\n    subgraph \"HTTPResponse 结构体\"\n        HResp[\"HTTPResponse\"]\n        \n        HResp --> response[\"response *http.Response\"]\n        HResp --> reader[\"reader *bytes.Buffer\"]\n        HResp --> bufReader[\"bufReader *bufio.Reader\"]\n        HResp --> receivedLen[\"receivedLen int64<br/>已累积字节\"]\n        HResp --> headerLength[\"headerLength int64\"]\n        HResp --> isInit[\"isInit bool\"]\n        HResp --> isDone[\"isDone bool\"]\n        HResp --> packerType[\"packerType PacketType\"]\n    end\n    \n    Display[\"Display()\"]\n    Display --> ReadBody[\"io.ReadAll(response.Body)\"]\n    Display --> HandleEOF[\"处理 io.ErrUnexpectedEOF<br/>Content-Length 不匹配\"]\n    Display --> CheckEnc[\"检查 Content-Encoding\"]\n    CheckEnc -->|gzip| Gunzip[\"gzip.NewReader\"]\n    CheckEnc -->|分块| ChunkLog[\"记录分块传输\"]\n    Display --> DumpResp[\"httputil.DumpResponse\"]\n```\n\n**来源：** [pkg/event_processor/http_response.go:28-37](), [pkg/event_processor/http_response.go:58-92](), [pkg/event_processor/http_response.go:115-175]()\n\n响应解析器处理：\n- **分块编码** - 通过 `ContentLength < 0` 检测\n- **截断的响应** - 优雅处理 `ErrUnexpectedEOF`\n- **Content-Length 不匹配** - 记录警告用于调试\n\n### DefaultParser\n\n非 HTTP 协议的回退解析器：\n\n```mermaid\ngraph TB\n    DefaultParser[\"DefaultParser\"]\n    \n    DefaultParser --> Structure[\"reader *bytes.Buffer<br/>isdone bool\"]\n    \n    Write[\"Write(b []byte)\"]\n    Write --> WriteBuffer[\"reader.Write(b)\"]\n    Write --> SetDone[\"isdone = true\"]\n    \n    Display[\"Display()\"]\n    Display --> GetBytes[\"reader.Bytes()\"]\n    Display --> CheckFirst[\"检查第一个字节\"]\n    CheckFirst -->|\"< 32 或 > 126\"| HexDump[\"hex.Dump(bytes)\"]\n    CheckFirst -->|可打印| String[\"CToGoString(bytes)\"]\n```\n\n**来源：** [pkg/event_processor/iparser.go:117-166]()\n\nDefaultParser：\n- 立即累积所有数据（`isdone = true`）\n- 自动检测二进制 vs 文本（检查第一个字节）\n- 对不可打印数据使用十六进制转储\n- 从 C 字符串中去除空终止符\n\n## 完整事件流程示例\n\n### TLS 捕获流程\n\n```mermaid\nsequenceDiagram\n    participant eBPF as SSL_read uprobe\n    participant PerfMap as perfEventMap\n    participant Module as MOpenSSLProbe\n    participant EP as EventProcessor\n    participant EW as eventWorker\n    participant Parser as HTTPRequest\n    participant Logger as io.Writer\n    \n    eBPF->>PerfMap: SSL 数据事件\n    Module->>PerfMap: perfReader.Read()\n    Module->>Module: SSLDataEvent.Decode()\n    Module->>Module: GetUUID()<br/>sock:1234_5678_curl_3_0_IP:Port_Sock\n    \n    Module->>EP: eventProcessor.Write(event)\n    EP->>EP: incoming <- event\n    EP->>EP: Serve() dispatch(event)\n    \n    EP->>EW: getWorkerByUUID() 或 NewEventWorker()\n    EP->>EW: worker.Write(event)\n    EW->>EW: incoming <- event\n    \n    EW->>EW: Run() select incoming\n    EW->>EW: tickerCount = 0\n    EW->>EW: writeEvent(event)\n    EW->>EW: payload.Write(event.Payload())\n    \n    Note over EW: 等待超时或 socket 关闭\n    \n    EW->>EW: Ticker 触发 (检测到空闲)\n    EW->>EW: Display()\n    EW->>EW: parserEvents()\n    \n    EW->>Parser: NewParser(payload.Bytes())\n    Parser->>Parser: detect() -> HTTPRequest\n    EW->>Parser: parser.Write(payload.Bytes())\n    Parser->>Parser: http.ReadRequest()\n    EW->>Parser: parser.Display()\n    Parser->>Parser: httputil.DumpRequest()\n    Parser-->>EW: 格式化字节\n    \n    EW->>EP: outComing <- formatted\n    EP->>Logger: logger.Write(formatted)\n    \n    EW->>Parser: parser.Reset()\n    EW->>EW: payload.Reset()\n```\n\n**来源：** [pkg/event_processor/processor.go:66-109](), [pkg/event_processor/iworker.go:262-306](), [pkg/event_processor/iworker.go:175-228](), [pkg/event_processor/iparser.go:85-115]()\n\n## 输出格式化\n\n### 文本模式\n\n对于 `CollectorWriter` 日志器：\n\n```mermaid\ngraph TB\n    Display[\"eventWorker.Display()\"]\n    \n    Display --> GetBase[\"originEvent.Base()\"]\n    GetBase --> Metadata[\"PID, Comm<br/>SrcIP:SrcPort<br/>DstIP:DstPort\"]\n    \n    Display --> GetType[\"parser.ParserType()\"]\n    Display --> GetPayload[\"parser.Display()\"]\n    \n    Display --> CheckHex[\"检查 isHex 标志\"]\n    CheckHex -->|true| HexDump[\"hex.Dump(payload)\"]\n    CheckHex -->|false| Raw[\"使用原始载荷\"]\n    \n    Display --> Format[\"fmt.Fprintf()\"]\n    Format --> Output[\"PID:123, Comm:curl, Src:IP:Port, Dest:IP:Port,<br/>Payload:<br/>GET / HTTP/1.1...\"]\n```\n\n**来源：** [pkg/event_processor/iworker.go:175-228]()\n\n### Protobuf 模式\n\n对于 protobuf 日志器（eCaptureQ GUI）：\n\n```mermaid\ngraph TB\n    Display[\"eventWorker.Display()\"]\n    \n    Display --> CreateLogEntry[\"new(pb.LogEntry)\"]\n    Display --> SetType[\"LogType = LOG_TYPE_EVENT\"]\n    \n    Display --> ToProto[\"originEvent.ToProtobufEvent()\"]\n    ToProto --> ProtoEvent[\"pb.Event{<br/>  Timestamp, UUID, PID, Pname,<br/>  SrcIP, SrcPort, DstIP, DstPort<br/>}\"]\n    \n    Display --> SetPayload[\"ep.Payload = parser.Display()\"]\n    Display --> SetMeta[\"ep.Type = parser.ParserType()<br/>ep.Length = len(payload)\"]\n    \n    Display --> Marshal[\"proto.Marshal(logEntry)\"]\n    Display --> WriteChan[\"outComing <- marshalled\"]\n```\n\n**来源：** [pkg/event_processor/iworker.go:214-227]()\n\n## 事件截断\n\nEventProcessor 支持载荷截断：\n\n```mermaid\ngraph TB\n    writeEvent[\"eventWorker.writeEvent()\"]\n    \n    writeEvent --> CheckSize[\"truncateSize > 0?\"]\n    CheckSize -->|false| Append[\"payload.Write(event.Payload())\"]\n    \n    CheckSize -->|true| CheckLen[\"payload.Len() >= truncateSize?\"]\n    CheckLen -->|false| Append\n    CheckLen -->|true| Truncate[\"payload.Truncate(truncateSize)\"]\n    Truncate --> Log[\"记录 '事件已截断，大小: N 字节'\"]\n    Truncate --> Return[\"Return (不写入)\"]\n```\n\n**来源：** [pkg/event_processor/iworker.go:230-245]()\n\n截断防止大型载荷造成过度内存使用（可通过 `--truncate` 标志配置）。\n\n## 错误处理\n\n### Event Worker 错误\n\nWorker 使用错误通道处理非致命错误：\n\n```mermaid\ngraph TB\n    Error[\"发生错误\"]\n    \n    Error --> Type1[\"ErrEventWorkerIncomingFull\"]\n    Error --> Type2[\"ErrEventWorkerOutcomingFull\"]\n    Error --> Type3[\"解析器写入错误\"]\n    \n    Type1 --> Log1[\"事件已丢弃<br/>incoming 通道已满\"]\n    Type2 --> Log2[\"输出已丢弃<br/>outComing 通道已满\"]\n    Type3 --> Log3[\"解析器错误已记录<br/>继续处理\"]\n    \n    All[\"所有错误\"] --> EP[\"EventProcessor.errChan\"]\n    EP --> Caller[\"模块决定<br/>是否继续\"]\n```\n\n**来源：** [pkg/event_processor/iworker.go:66-68](), [pkg/event_processor/processor.go:72-79]()\n\n关键错误行为：\n- **非阻塞通道** - 如果缓冲区已满则丢弃事件而不是阻塞\n- **解析器错误** - 已记录但不停止处理\n- **Worker panic** - `Get()`/`Put()` panic 表示使用不正确\n\n### Socket 生命周期清理\n\n基于 socket 的 worker 通过 `destroyConn` 通道清理：\n\n```mermaid\nsequenceDiagram\n    participant TC as TC eBPF\n    participant Module as 模块\n    participant EP as EventProcessor\n    participant EW as eventWorker\n    \n    TC->>Module: ConnDataEvent<br/>IsDestroy=1\n    Module->>Module: GetSockPointer()\n    Module->>EP: WriteDestroyConn(sockPtr)\n    \n    EP->>EP: destroyConn <- sockPtr\n    EP->>EP: Serve() select destroyConn\n    EP->>EP: destroyWorkers(sockPtr)\n    \n    loop 对于每个 worker\n        EP->>EW: GetDestroyUUID()\n        \n        alt 找到匹配\n            EP->>EW: CloseEventWorker()\n            EW->>EW: close(closeChan)\n            EW->>EW: Run() 接收关闭信号\n            EW->>EW: drainAndClose()\n            EW->>EP: delWorkerByUUID()\n        end\n    end\n```\n\n**来源：** [pkg/event_processor/processor.go:177-185](), [pkg/event_processor/processor.go:115-128](), [pkg/event_processor/iworker.go:142-148]()\n\n此机制确保关闭 socket 的 worker 被正确清理，防止内存泄漏。\n\n## 总结\n\n事件处理系统提供：\n\n1. **强类型** 通过 `IEventStruct` 接口实现类型安全的事件处理\n2. **基于 UUID 的路由** 将相关事件聚合到 worker 中\n3. **双生命周期模式** 实现高效的资源管理\n4. **自动协议检测** 和解析 HTTP/1.x 与 HTTP/2\n5. **多种输出格式** 支持文本、十六进制和 protobuf\n6. **优雅的错误处理** 采用非阻塞通道和事件丢弃机制\n\n此架构使 eCapture 能够处理来自多个 eBPF 程序的大量事件流，同时维护适合人类和机器消费的结构化输出。"
          },
          {
            "page_plan": {
              "id": "6",
              "title": "常见问题"
            },
            "content": "# 常见问题\n\n本页面提供使用 eCapture 时遇到的常见问题的解决方案，以及调试技术和常见问题解答。有关系统要求和安装的信息，请参阅[依赖与系统要求](#1.3)。有关构建问题，请参考[构建系统](#5.1)。\n\n---\n\n## 常见问题决策树\n\n以下图表显示了诊断常见 eCapture 问题的决策树：\n\n```mermaid\ngraph TB\n    START[\"eCapture 问题\"]\n    \n    STARTS[\"eCapture 能启动吗?\"]\n    PERM[\"权限错误?\"]\n    KERNEL[\"内核版本检查\"]\n    BTF[\"BTF 支持检查\"]\n    \n    CAPTURE[\"捕获能工作吗?\"]\n    VERSION[\"版本检测错误?\"]\n    NODATA[\"没有捕获到数据?\"]\n    CORRUPT[\"输出损坏?\"]\n    \n    PERM_FIX[\"使用 sudo 运行<br/>检查 CAP_BPF 权限\"]\n    KERNEL_FIX[\"升级内核至 4.18+ (x86_64)<br/>或 5.5+ (aarch64)\"]\n    BTF_FIX[\"检查 CONFIG_DEBUG_INFO_BTF=y<br/>或使用 non-CO-RE 版本\"]\n    \n    VERSION_FIX[\"手动指定 --ssl_version<br/>使用 --libssl 检查库路径\"]\n    NODATA_FIX[\"检查 PID/UID 过滤器<br/>验证目标进程使用目标库\"]\n    CORRUPT_FIX[\"检查输出模式设置<br/>验证磁盘空间<br/>检查文件权限\"]\n    \n    START --> STARTS\n    STARTS -->|否| PERM\n    PERM -->|是| PERM_FIX\n    PERM -->|否| KERNEL\n    KERNEL -->|< 4.18 x86_64<br/>< 5.5 aarch64| KERNEL_FIX\n    KERNEL -->|正常| BTF\n    BTF -->|缺失| BTF_FIX\n    \n    STARTS -->|是| CAPTURE\n    CAPTURE -->|否| VERSION\n    VERSION -->|是| VERSION_FIX\n    VERSION -->|否| NODATA\n    NODATA -->|是| NODATA_FIX\n    NODATA -->|否| CORRUPT\n    CORRUPT -->|是| CORRUPT_FIX\n```\n\n来源：[README.md:13-17](), [CHANGELOG.md:41-50](), [user/module/probe_openssl_lib.go:64-70]()\n\n---\n\n## 内核和系统要求问题\n\n### 问题：\"内核版本过低\"或 eCapture 无法启动\n\n**症状：**\n- 关于内核版本的错误消息\n- 程序立即退出\n- eBPF 程序加载失败\n\n**所需内核版本：**\n\n| 架构 | 最低内核版本 | CO-RE 支持 |\n|------|------------|-----------|\n| x86_64 | 4.18 | 是 |\n| aarch64 | 5.5 | 是 |\n\n**解决方案：**\n\n1. 检查内核版本：\n```bash\nuname -r\n```\n\n2. 验证 BTF 支持（CO-RE 模式所需）：\n```bash\ncat /boot/config-$(uname -r) | grep CONFIG_DEBUG_INFO_BTF\n# 应返回：CONFIG_DEBUG_INFO_BTF=y\n```\n\n3. 如果 BTF 不可用：\n   - 检查 BTF 数据是否存在：`ls -l /sys/kernel/btf/vmlinux`\n   - 如果 BTF 不可用，eCapture 会自动回退到 non-CO-RE 模式\n\n**故障排除图：**\n\n```mermaid\ngraph LR\n    CHECK[\"检查内核版本\"]\n    BTF_CHECK[\"BTF 可用?\"]\n    CORE_MODE[\"CO-RE 模式\"]\n    NONCORE_MODE[\"Non-CO-RE 模式\"]\n    UPGRADE[\"升级内核\"]\n    \n    CHECK -->|\">= 4.18 (x86_64)<br/>>= 5.5 (aarch64)\"| BTF_CHECK\n    CHECK -->|\"< 4.18 (x86_64)<br/>< 5.5 (aarch64)\"| UPGRADE\n    \n    BTF_CHECK -->|是| CORE_MODE\n    BTF_CHECK -->|否| NONCORE_MODE\n    \n    CORE_MODE -->|\"使用 BTF 实现可移植性<br/>单个二进制可跨内核工作\"|DONE[\"准备运行\"]\n    NONCORE_MODE -->|\"使用内核头文件<br/>内核特定字节码\"|DONE\n```\n\n来源：[README.md:13-17](), [variables.mk:153-167](), [CHANGELOG.md:41]()\n\n---\n\n## 权限问题\n\n### 问题：\"操作不被允许\"或\"权限被拒绝\"\n\n**症状：**\n- 加载 eBPF 程序时出错\n- \"failed to load BPF program\" 消息\n- CAP_BPF 相关错误\n\n**所需权限：**\n\neCapture 需要 **ROOT 权限**或特定权限：\n\n1. **CAP_BPF** - 加载 eBPF 程序（Linux 5.8+）\n2. **CAP_PERFMON** - 访问性能监控\n3. **CAP_NET_ADMIN** - 附加 TC 程序\n4. **CAP_SYS_ADMIN** - 旧版内核的传统权限\n\n**解决方案：**\n\n1. 使用 sudo 运行：\n```bash\nsudo ecapture tls\n```\n\n2. 检查权限（Linux 5.8+）：\n```bash\n# eCapture 会自动检测 CAP_BPF\n# 如果检测失败，您会看到警告\n```\n\n3. 对于 Docker 容器：\n```bash\ndocker run --rm --privileged=true --net=host gojue/ecapture tls\n```\n\n**权限检查流程：**\n\n```mermaid\ngraph TB\n    START[\"权限检查\"]\n    ROOT[\"以 root 身份运行?\"]\n    KERNEL58[\"内核 >= 5.8?\"]\n    CAPBPF[\"CAP_BPF 可用?\"]\n    LEGACY[\"使用 CAP_SYS_ADMIN\"]\n    SUCCESS[\"权限正常\"]\n    FAIL[\"权限被拒绝\"]\n    \n    START --> ROOT\n    ROOT -->|是| SUCCESS\n    ROOT -->|否| KERNEL58\n    KERNEL58 -->|是| CAPBPF\n    KERNEL58 -->|否| LEGACY\n    CAPBPF -->|是| SUCCESS\n    CAPBPF -->|否| FAIL\n    LEGACY -->|可用| SUCCESS\n    LEGACY -->|不可用| FAIL\n```\n\n来源：[CHANGELOG.md:322-323](), [CHANGELOG.md:343](), [CHANGELOG.md:370]()\n\n---\n\n## 版本检测问题\n\n### 问题：\"未找到 OpenSSL/BoringSSL 版本\"或\"使用默认版本\"\n\n**症状：**\n- 警告：\"OpenSSL/BoringSSL version not found from shared library file\"\n- 警告：\"used default version\"\n- 未捕获到数据或数据不正确\n\n**版本检测过程：**\n\n```mermaid\ngraph TB\n    START[\"开始版本检测\"]\n    SCAN[\".rodata 段扫描<br/>detectOpenssl 函数\"]\n    REGEX[\"正则匹配:<br/>OpenSSL \\d\\.\\d\\.[0-9a-z]+\"]\n    FOUND{\"找到版本<br/>字符串?\"}\n    MAP[\"检查 sslVersionBpfMap\"]\n    BYTECODE{\"字节码<br/>存在?\"}\n    DOWNGRADE[\"downgradeOpensslVersion<br/>寻找最接近的匹配\"]\n    DEFAULT[\"使用默认版本<br/>基于库名称\"]\n    LOAD[\"加载字节码\"]\n    \n    START --> SCAN\n    SCAN --> REGEX\n    REGEX --> FOUND\n    FOUND -->|是| MAP\n    FOUND -->|否| DEFAULT\n    MAP --> BYTECODE\n    BYTECODE -->|是| LOAD\n    BYTECODE -->|否| DOWNGRADE\n    DOWNGRADE --> LOAD\n    DEFAULT --> LOAD\n    \n    LOAD --> END[\"版本: linux_default_3_0<br/>或 linux_default_1_1_1\"]\n```\n\n**解决方案：**\n\n1. **手动指定 OpenSSL 版本：**\n```bash\n# 对于 OpenSSL 3.0.x\nsudo ecapture tls --ssl_version=\"openssl 3.0.0\"\n\n# 对于 OpenSSL 1.1.1\nsudo ecapture tls --ssl_version=\"openssl 1.1.1\"\n\n# 对于 Android BoringSSL\nsudo ecapture tls --ssl_version=\"boringssl_a_14\"\n```\n\n2. **显式指定库路径：**\n```bash\n# 如果库在非标准位置\nsudo ecapture tls --libssl=/usr/local/lib/libssl.so.3\n\n# 对于静态链接的二进制文件\nsudo ecapture tls --libssl=/path/to/static/binary\n```\n\n3. **支持的 OpenSSL/BoringSSL 版本：**\n\n| 库类型 | 支持的版本 |\n|--------|-----------|\n| OpenSSL 1.0.2 | 1.0.2a - 1.0.2u |\n| OpenSSL 1.1.0 | 1.1.0a - 1.1.0l |\n| OpenSSL 1.1.1 | 1.1.1a - 1.1.1w |\n| OpenSSL 3.0.x | 3.0.0 - 3.0.17 |\n| OpenSSL 3.1.x | 3.1.0 - 3.1.8 |\n| OpenSSL 3.2.x | 3.2.0 - 3.2.5 |\n| OpenSSL 3.3.x | 3.3.0 - 3.3.4 |\n| OpenSSL 3.4.x | 3.4.0 - 3.4.2 |\n| OpenSSL 3.5.x | 3.5.0 - 3.5.4 |\n| BoringSSL (Android) | Android 12-16 (A12-A16) |\n| BoringSSL (Non-Android) | 最新 master 分支 |\n\n4. **版本降级逻辑：**\n\n当找不到完全匹配时，eCapture 实现了自动版本降级以找到最接近的支持版本。\n\n**错误消息映射：**\n\n| 错误/警告 | 含义 | 解决方案 |\n|----------|------|---------|\n| `OpenSSL/BoringSSL version not found from shared library file` | 在 .rodata 段中找不到版本字符串 | 手动指定 `--ssl_version` |\n| `used default version` | 使用回退字节码 | 验证捕获是否工作；如果不行，指定版本 |\n| `Can not find Default BoringSSL version` | sslVersionBpfMap 缺少 Android 默认值 | 使用 `--android_ver` 检查 Android 版本 |\n| `OpenSSL/BoringSSL version bytecode not found` | 检测到的版本没有编译的字节码 | 使用支持的版本或默认版本 |\n\n来源：[user/module/probe_openssl_lib.go:189-282](), [user/module/probe_openssl_lib.go:284-317](), [user/module/probe_openssl_lib.go:341-369](), [user/module/probe_openssl_lib.go:44-62](), [variables.mk:190-212]()\n\n---\n\n## 库检测问题\n\n### 问题：\"couldn't find bpf bytecode file error\"或找不到库\n\n**症状：**\n- 错误：\"couldn't find bpf bytecode file error\"\n- 库路径检测失败\n- 没有附加钩子\n\n**库搜索顺序：**\n\n```mermaid\ngraph TB\n    START[\"库检测开始\"]\n    LIBSSL[\"--libssl 标志<br/>是否指定?\"]\n    MANUAL[\"使用指定路径\"]\n    LDCONF[\"解析 /etc/ld.so.conf\"]\n    SEARCH[\"搜索位置:<br/>/lib64<br/>/usr/lib64<br/>/lib<br/>/usr/lib\"]\n    PATTERN[\"匹配模式:<br/>libssl.so*<br/>libcrypto.so*\"]\n    FOUND{\"找到<br/>库?\"}\n    ERROR[\"错误: 未找到库\"]\n    ELF[\"解析 ELF 文件<br/>检查架构\"]\n    SUCCESS[\"库已加载\"]\n    \n    START --> LIBSSL\n    LIBSSL -->|是| MANUAL\n    LIBSSL -->|否| LDCONF\n    MANUAL --> ELF\n    LDCONF --> SEARCH\n    SEARCH --> PATTERN\n    PATTERN --> FOUND\n    FOUND -->|是| ELF\n    FOUND -->|否| ERROR\n    ELF --> SUCCESS\n```\n\n**解决方案：**\n\n1. **检查库是否存在：**\n```bash\n# 查找 OpenSSL 库\nldconfig -p | grep libssl\n\n# 检查库版本\nstrings /usr/lib/x86_64-linux-gnu/libssl.so.3 | grep \"OpenSSL\"\n```\n\n2. **修复 /etc/ld.so.conf 路径问题：**\n```bash\n# 验证 ld.so.conf\ncat /etc/ld.so.conf\n\n# 更新库缓存\nsudo ldconfig\n```\n\n3. **显式指定库路径：**\n```bash\n# 对于自定义安装\nsudo ecapture tls --libssl=/opt/openssl/lib/libssl.so\n\n# 对于非标准路径的容器环境\nsudo ecapture tls --libssl=/custom/path/libssl.so.1.1\n```\n\n4. **常见库位置：**\n\n| 发行版 | 典型路径 |\n|--------|---------|\n| Ubuntu/Debian | `/usr/lib/x86_64-linux-gnu/libssl.so.3` |\n| CentOS/RHEL | `/usr/lib64/libssl.so.1.1` |\n| Alpine Linux | `/usr/lib/libssl.so.3` |\n| Android | `/apex/com.android.conscrypt/lib64/libssl.so` |\n\n来源：[CHANGELOG.md:84](), [CHANGELOG.md:436](), [user/module/probe_openssl_lib.go:189-217]()\n\n---\n\n## 运行时错误\n\n### 问题：空指针异常\n\n**症状：**\n- 程序崩溃并出现空指针解引用\n- 探针初始化时发生 panic\n\n**常见原因和解决方案：**\n\n1. **GnuTLS 探针设置失败：**\n```\npanic: runtime error: invalid memory address or nil pointer dereference\nin gnutls probe\n```\n\n**解决方案：**已在 v1.5.0 中修复 - 确保您使用的是最新版本。\n\n2. **未初始化的通道：**\n```\npanic: send on nil channel\n```\n\n**解决方案：**模块初始化顺序问题。使用重现步骤提交错误报告。\n\n来源：[CHANGELOG.md:20](), [CHANGELOG.md:603]()\n\n### 问题：并发 Map 访问\n\n**症状：**\n- 错误：\"concurrent map read and map write\"\n- 高负载期间程序崩溃\n- 数据损坏\n\n**解决方案：**\n\n这是 v0.7.3 中修复的已知问题。更新到最新版本：\n```bash\n# 检查您的版本\necapture -v\n\n# 更新到最新版本\nwget https://github.com/gojue/ecapture/releases/latest/download/ecapture-linux-amd64.tar.gz\n```\n\n来源：[CHANGELOG.md:650]()\n\n### 问题：\"incoming chan is full\"错误\n\n**症状：**\n- 警告：\"incoming chan is full\"\n- 进程意外退出\n- 捕获期间数据丢失\n\n**解决方案：**\n\n这表示事件处理管道过载。已在 v0.9.0 中修复。\n\n1. **减少捕获范围：**\n```bash\n# 按 PID 过滤\nsudo ecapture tls --pid=1234\n\n# 按 UID 过滤\nsudo ecapture tls --uid=1000\n```\n\n2. **增加 map 大小：**\n```bash\n# 默认为 5120 KB，如需要可增加\nsudo ecapture tls --mapsize=10240\n```\n\n3. **使用 pcap 模式而不是 text 模式：**\n```bash\n# PCAP 模式对于大流量捕获性能更好\nsudo ecapture tls -m pcap -w output.pcapng -i eth0\n```\n\n来源：[CHANGELOG.md:373](), [CHANGELOG.md:709]()\n\n---\n\n## 模块特定故障排除\n\n### OpenSSL/TLS 模块\n\n#### 问题：成功启动但未捕获到数据\n\n**诊断步骤：**\n\n```mermaid\ngraph TB\n    START[\"未捕获到数据\"]\n    PROCESS[\"目标进程<br/>正在运行?\"]\n    LIBRARY[\"使用 OpenSSL<br/>库?\"]\n    VERSION[\"检测到的<br/>版本正确?\"]\n    FILTER[\"PID/UID 过滤器<br/>太严格?\"]\n    PORT[\"目标端口<br/>正确?\"]\n    TRAFFIC[\"实际 TLS<br/>流量发生?\"]\n    \n    RESTART[\"在 eCapture 之后<br/>启动目标进程\"]\n    CHECK_LIB[\"使用 lsof -p PID 检查\"]\n    FIX_VER[\"指定 --ssl_version\"]\n    REMOVE_FILTER[\"移除 --pid/--uid\"]\n    FIX_PORT[\"使用 --target_port<br/>或 --target_port=0 捕获所有端口\"]\n    GENERATE[\"生成测试流量\"]\n    \n    START --> PROCESS\n    PROCESS -->|否| RESTART\n    PROCESS -->|是| LIBRARY\n    LIBRARY -->|否| CHECK_LIB\n    LIBRARY -->|是| VERSION\n    VERSION -->|否| FIX_VER\n    VERSION -->|是| FILTER\n    FILTER -->|是| REMOVE_FILTER\n    FILTER -->|否| PORT\n    PORT -->|错误| FIX_PORT\n    PORT -->|正常| TRAFFIC\n    TRAFFIC -->|否| GENERATE\n```\n\n**示例命令：**\n\n```bash\n# 捕获所有端口\nsudo ecapture tls --target_port=0\n\n# 捕获特定进程\nsudo ecapture tls --pid=$(pgrep curl)\n\n# 调试详细输出\nsudo ecapture tls --log-level=debug\n```\n\n来源：[README.md:72-149](), [CHANGELOG.md:778]()\n\n#### 问题：Keylog 文件为空或不完整\n\n**症状：**\n- `--keylogfile` 已创建但为空\n- 缺少 CLIENT_RANDOM 条目\n- Wireshark 无法解密流量\n\n**解决方案：**\n\n1. **验证 keylog 模式：**\n```bash\n# keylog 模式的正确语法\nsudo ecapture tls -m keylog --keylogfile=keys.log\n```\n\n2. **检查 TLS 版本：**\n- TLS 1.2：捕获带主密钥的 `CLIENT_RANDOM`\n- TLS 1.3：捕获流量密钥（需要 OpenSSL 3.0+）\n\n3. **常见问题：**\n- OpenSSL 3.0.12 有特定错误（已在 v1.4.1 中修复）\n- GoTLS keylog 中缺少尾随字节（已在 v1.4.0 中修复）\n- 某些 OpenSSL 版本中 keylog 丢失（已在 v1.3.0 中修复）\n\n来源：[CHANGELOG.md:69](), [CHANGELOG.md:85](), [CHANGELOG.md:127]()\n\n#### 问题：PCAP 文件损坏或 Wireshark 无法打开\n\n**症状：**\n- PCAP 文件无法在 Wireshark 中打开\n- \"格式无效\"错误\n- 数据包缺失\n\n**解决方案：**\n\n1. **确保正确终止：**\n```bash\n# 使用 Ctrl+C 正确关闭 PCAP 文件\n# 不要使用 kill -9\n```\n\n2. **检查磁盘空间：**\n```bash\ndf -h /path/to/pcap/directory\n```\n\n3. **验证 PCAP-NG 格式：**\n```bash\n# eCapture 使用 PCAP-NG 格式\nfile output.pcapng\n# 应显示：pcapng capture file\n```\n\n4. **DSB（解密密钥块）：**\neCapture 在 PCAP-NG 文件中将 TLS 密钥写入 DSB。确保您使用的是较新版本的 Wireshark（3.0+）。\n\n来源：[CHANGELOG.md:161](), [CHANGELOG.md:542](), [CHANGELOG.md:664]()\n\n### GoTLS 模块\n\n#### 问题：\"cant found RET offset\"或剥离的 Go 二进制文件\n\n**症状：**\n- 错误：\"cant found RET offset in gotls mode\"\n- 剥离的 Go 二进制文件无法工作\n- PIE 可执行文件偏移错误\n\n**解决方案：**\n\n1. **剥离二进制文件支持：**\n已在 v0.7.0 中添加 - 更新到最新版本。\n\n2. **PIE 可执行文件问题：**\n```bash\n# 检查二进制文件是否为 PIE\nfile /path/to/go/binary\n# 应显示：\"dynamically linked\"或\"pie executable\"\n```\n\n已在 v0.7.7 中修复 aarch64 PIE 可执行文件。\n\n3. **指定 Go 二进制文件路径：**\n```bash\nsudo ecapture gotls --elfpath=/path/to/go/binary\n```\n\n来源：[CHANGELOG.md:593](), [CHANGELOG.md:752](), [CHANGELOG.md:573]()\n\n#### 问题：未捕获到 GoTLS 数据\n\n**检查清单：**\n\n```mermaid\ngraph LR\n    CHECK1[\"Go 二进制文件使用<br/>crypto/tls?\"]\n    CHECK2[\"--elfpath 指定<br/>正确?\"]\n    CHECK3[\"Go 版本<br/>支持?\"]\n    CHECK4[\"TLS 连接<br/>活动?\"]\n    \n    FIX1[\"验证:<br/>strings binary | grep crypto/tls\"]\n    FIX2[\"使用完整路径:<br/>--elfpath=/full/path\"]\n    FIX3[\"支持 Go 1.18+<br/>如需要更新 Go\"]\n    FIX4[\"生成测试流量\"]\n    \n    CHECK1 -->|否| FIX1\n    CHECK2 -->|否| FIX2\n    CHECK3 -->|否| FIX3\n    CHECK4 -->|否| FIX4\n```\n\n来源：[README.md:259-276]()\n\n### Bash/Zsh 模块\n\n#### 问题：未捕获 Bash 命令\n\n**症状：**\n- 没有 bash 输出\n- 探针附加失败\n- \"不正确的探针附加\"警告\n\n**解决方案：**\n\n1. **检查 bash 路径：**\n```bash\nwhich bash\n# 常见路径：/bin/bash, /usr/bin/bash\n```\n\n2. **改进的 bash 路径检测：**\n已在 v1.3.1 中修复，具有更好的路径检测和探针附加。\n\n3. **Readline 钩子验证：**\n```bash\n# 检查 bash 是否使用 readline\nldd $(which bash) | grep readline\n```\n\n来源：[CHANGELOG.md:114-115](), [CHANGELOG.md:592]()\n\n### MySQL/PostgreSQL 模块\n\n#### 问题：未捕获 SQL 查询\n\n**支持的版本：**\n\n| 数据库 | 支持的版本 |\n|--------|----------|\n| MySQL | 5.6, 5.7, 8.0 |\n| MariaDB | 所有版本 |\n| PostgreSQL | 10+ |\n\n**解决方案：**\n\n1. **验证 mysqld 进程：**\n```bash\nps aux | grep mysqld\n```\n\n2. **检查 dispatch_command 符号：**\n```bash\n# 对于 MySQL\nnm /usr/sbin/mysqld | grep dispatch_command\n```\n\n3. **模块特定标志：**\n```bash\n# MySQL\nsudo ecapture mysqld\n\n# PostgreSQL\nsudo ecapture postgres\n```\n\n来源：[README.md:42](), [README.md:157-159]()\n\n---\n\n## 性能问题\n\n### 问题：高 CPU 或内存使用率\n\n**症状：**\n- eCapture 消耗过多 CPU\n- 内存持续增长\n- 系统减速\n\n**解决方案：**\n\n1. **内存优化（v0.9.5+）：**\n```bash\n# 设置截断大小以减少内存成本\nsudo ecapture tls --truncate_size=1024\n```\n\n2. **减少 map 大小：**\n```bash\n# 默认为 5120 KB\nsudo ecapture tls --mapsize=2048\n```\n\n3. **使用过滤器：**\n```bash\n# 按 PID 过滤\nsudo ecapture tls --pid=1234\n\n# 按 UID 过滤\nsudo ecapture tls --uid=1000\n\n# 按端口过滤（pcap 模式）\nsudo ecapture tls -m pcap -i eth0 \"tcp port 443\"\n```\n\n4. **双重生命周期管理（v1.2.0+）：**\neCapture 现在实现了优化的事件工作器生命周期管理，以实现更好的资源使用。\n\n来源：[CHANGELOG.md:291](), [CHANGELOG.md:137](), [CHANGELOG.md:709]()\n\n### 问题：不完整的 SSL 数据或截断\n\n**症状：**\n- 截断的 HTTP 响应\n- \"过长长度的不完整 SSL 数据\"\n- 缺失数据块\n\n**解决方案：**\n\n1. **调整截断大小：**\n```bash\n# 默认截断大小\nsudo ecapture tls --truncate_size=4096\n```\n\n2. **已在 v0.9.5 中修复：**\n长长度不完整 SSL 数据的错误已解决。\n\n来源：[CHANGELOG.md:289](), [CHANGELOG.md:154]()\n\n---\n\n## 构建和编译问题\n\n### 问题：构建失败，提示\"header not found\"\n\n**症状：**\n- 内核头文件生成期间出错\n- 缺少 vmlinux.h\n- 交叉编译失败\n\n**解决方案：**\n\n1. **安装所需工具：**\n```bash\n# Ubuntu/Debian\nsudo apt-get install clang llvm libelf-dev linux-headers-$(uname -r)\n\n# CentOS/RHEL\nsudo yum install clang llvm elfutils-libelf-devel kernel-devel\n```\n\n2. **交叉编译设置：**\n```bash\n# 对于 x86_64 上的 ARM64\nsudo apt-get install gcc-aarch64-linux-gnu\n\n# 设置 CROSS_ARCH\nmake CROSS_ARCH=arm64\n```\n\n3. **内核头文件路径：**\n```bash\n# 如果非标准，指定内核头文件\nmake KERN_HEADERS=/path/to/kernel/headers\n```\n\n来源：[CHANGELOG.md:447](), [variables.mk:172-179]()\n\n### 问题：Docker 构建错误\n\n**症状：**\n- Docker 镜像构建失败\n- 基础镜像中的 CVE 漏洞\n\n**解决方案：**\n\n1. **使用官方 Docker 镜像：**\n```bash\ndocker pull gojue/ecapture:latest\n```\n\n2. **从源代码构建：**\n```bash\n# 克隆仓库\ngit clone https://github.com/gojue/ecapture.git\ncd ecapture\n\n# 构建\nmake\n```\n\n来源：[CHANGELOG.md:372](), [README.md:59-68]()\n\n---\n\n## 常见问题解答\n\n### 问：eCapture 支持 Windows 或 macOS 吗？\n\n**答：**不，eCapture 仅支持 Linux 和 Android 系统。它依赖于 eBPF 技术，这是 Linux 特有的。对于跨平台可视化，请在远程模式下使用 [eCaptureQ](#README.md:287-302) GUI。\n\n来源：[README.md:13-17]()\n\n### 问：我可以在没有 root 权限的情况下捕获流量吗？\n\n**答：**eCapture 需要 root 权限或特定权限（CAP_BPF、CAP_PERFMON、CAP_NET_ADMIN）来加载 eBPF 程序。没有办法绕过这个要求。\n\n来源：[README.md:15]()\n\n### 问：为什么 eCapture 显示\"未找到 OpenSSL 版本\"？\n\n**答：**eCapture 尝试通过解析库的 `.rodata` 段自动检测 OpenSSL 版本。如果检测失败：\n1. 它使用自动降级逻辑找到最接近的版本\n2. 回退到默认版本（通常是 3.0 或 1.1.1）\n3. 您可以使用 `--ssl_version` 手动指定版本\n\n来源：[user/module/probe_openssl_lib.go:189-282](), [user/module/probe_openssl_lib.go:284-317]()\n\n### 问：CO-RE 和 non-CO-RE 模式有什么区别？\n\n**答：**\n- **CO-RE（一次编译 - 到处运行）：**使用 BTF 信息使 eBPF 程序跨不同内核版本可移植。需要支持 BTF 的内核（CONFIG_DEBUG_INFO_BTF=y）。\n- **Non-CO-RE：**使用特定内核头文件编译 eBPF 程序。可在没有 BTF 的旧内核上工作，但需要特定于内核的字节码。\n\neCapture 自动检测 BTF 可用性并选择适当的模式。\n\n来源：[variables.mk:270-272]()\n\n### 问：我可以捕获静态链接二进制文件的流量吗？\n\n**答：**可以，对于静态链接的二进制文件，使用 `--libssl` 直接指定二进制文件路径：\n```bash\nsudo ecapture tls --libssl=/path/to/static/binary\n```\n\n来源：[README.md:169]()\n\n### 问：如何在 Wireshark 中使用捕获的 keylog？\n\n**答：**\n1. 捕获 TLS 密钥：\n```bash\nsudo ecapture tls -m keylog --keylogfile=keys.log\n```\n\n2. 在 Wireshark 中：\n   - 转到 编辑 → 首选项 → 协议 → TLS\n   - 将\"(Pre)-Master-Secret 日志文件名\"设置为 keys.log 的路径\n   - 重新加载捕获\n\n3. 或直接使用 tshark：\n```bash\ntshark -o tls.keylog_file:keys.log -Y http -f \"port 443\" -i eth0\n```\n\n来源：[README.md:235-247]()\n\n### 问：eCapture 会影响被监控应用程序的性能吗？\n\n**答：**eCapture 对性能的影响很小，因为：\n1. eBPF 在内核空间运行，开销低\n2. 使用高效的 perf 环形缓冲区进行数据传输\n3. 在 eBPF 级别实现过滤\n4. 内存优化截断（v0.9.5+）\n\n但是，捕获非常高流量的应用程序可能需要调整 `--mapsize` 和 `--truncate_size`。\n\n来源：[CHANGELOG.md:291](), [CHANGELOG.md:709]()\n\n### 问：我可以按进程或用户过滤捕获吗？\n\n**答：**可以，eCapture 支持多种过滤选项：\n\n```bash\n# 按 PID 过滤\nsudo ecapture tls --pid=1234\n\n# 按 UID 过滤\nsudo ecapture tls --uid=1000\n\n# 按端口过滤（所有模块）\nsudo ecapture tls --target_port=443\n\n# PCAP 过滤器（仅 pcap 模式）\nsudo ecapture tls -m pcap -i eth0 \"host 192.168.1.1 and port 443\"\n```\n\n来源：[README.md:183-184](), [CHANGELOG.md:472]()\n\n### 问：如何捕获 HTTP/2 或 HTTP/3 流量？\n\n**答：**\n- **HTTP/2：**在 text 模式下自动支持（v0.8.5+）。eCapture 解析 HTTP/2 帧并显示标头/数据。\n- **HTTP/3（QUIC）：**在 PCAP 模式下支持。使用：\n```bash\nsudo ecapture tls -m pcap -i eth0 \"udp port 443\"\n```\n\n来源：[README.md:179](), [CHANGELOG.md:487]()\n\n### 问：支持哪些 Android 版本？\n\n**答：**eCapture 支持带有 BoringSSL 的 Android 12 到 Android 16。指定 Android 版本：\n```bash\nsudo ecapture tls --android_ver=14\n```\n\n可用版本：a_13（Android 12/13）、a_14（Android 14）、a_15（Android 15）、a_16（Android 16）。\n\n来源：[variables.mk:94-97](), [CHANGELOG.md:23](), [CHANGELOG.md:305]()\n\n### 问：我可以使用 eCapture 进行安全审计吗？\n\n**答：**可以，eCapture 专为安全审计场景设计：\n- **主机安全：**捕获 bash/zsh 命令\n- **数据库审计：**捕获 MySQL/PostgreSQL 查询\n- **网络安全：**捕获和分析加密流量\n- **合规性：**使用 `--eventcollector` 标志生成审计日志\n\n来源：[README.md:40-42]()\n\n### 问：eCapture 在容器中工作吗？\n\n**答：**可以，但有注意事项：\n1. 容器必须在特权模式下运行或具有 BPF 权限\n2. 可以监控容器内部和外部的进程\n3. 使用主机网络模式进行网络捕获\n\n```bash\ndocker run --rm --privileged=true --net=host \\\n  -v /path/to/output:/output \\\n  gojue/ecapture tls --eventcollector=/output/events.log\n```\n\n来源：[README.md:63-68]()\n\n---\n\n## 调试技术\n\n### 启用调试日志\n\n```bash\n# 启用调试输出\nsudo ecapture tls --log-level=debug\n\n# 将日志保存到文件\nsudo ecapture tls --logaddr=/var/log/ecapture.log\n```\n\n### 验证 eBPF 程序加载\n\n```bash\n# 检查已加载的 eBPF 程序\nsudo bpftool prog list | grep ecapture\n\n# 检查 eBPF maps\nsudo bpftool map list\n\n# 转储 map 内容（高级）\nsudo bpftool map dump id <map_id>\n```\n\n### 跟踪系统调用\n\n```bash\n# 跟踪 eCapture 系统调用\nsudo strace -f ecapture tls\n\n# 跟踪特定系统调用\nsudo strace -e trace=bpf,perf_event_open ecapture tls\n```\n\n### 检查库加载\n\n```bash\n# 验证目标进程是否加载了库\nsudo lsof -p <PID> | grep libssl\n\n# 检查库依赖关系\nldd /path/to/target/binary | grep ssl\n```\n\n### 网络验证\n\n```bash\n# 验证网络接口\nip link show\n\n# 检查 TC 过滤器（用于数据包捕获）\nsudo tc filter show dev eth0 ingress\nsudo tc filter show dev eth0 egress\n\n# 监控网络流量\nsudo tcpdump -i eth0 -n \"port 443\"\n```\n\n### 核心转储分析\n\n如果 eCapture 崩溃：\n```bash\n# 启用核心转储\nulimit -c unlimited\n\n# 运行 eCapture\nsudo ecapture tls\n\n# 分析核心转储（如果发生崩溃）\ngdb ecapture core\n```\n\n### 有用的诊断命令\n\n| 命令 | 目的 |\n|------|-----|\n| `ecapture -v` | 显示版本信息 |\n| `uname -r` | 检查内核版本 |\n| `cat /boot/config-$(uname -r) \\| grep BTF` | 验证 BTF 支持 |\n| `ls -l /sys/kernel/btf/vmlinux` | 检查 BTF 可用性 |\n| `sudo bpftool prog list` | 列出 eBPF 程序 |\n| `ldd $(which ecapture)` | 检查依赖关系 |\n| `file /path/to/libssl.so` | 验证库架构 |\n\n来源：[CHANGELOG.md:521](), [README_CN.md:84-126]()\n\n---\n\n## 获取帮助\n\n如果您遇到此处未涵盖的问题：\n\n1. **检查 GitHub Issues：**在 https://github.com/gojue/ecapture/issues 搜索现有问题\n2. **创建新 Issue：**包括：\n   - eCapture 版本（`ecapture -v`）\n   - 内核版本（`uname -r`）\n   - 发行版和架构\n   - 完整的错误消息\n   - 重现步骤\n   - 调试日志输出\n3. **加入社区：**QQ群 或 GitHub Discussions\n4. **查看更新日志：**最近的修复可能解决了您的问题：[CHANGELOG.md:1-782]()\n\n---\n\n## 快速参考：错误消息\n\n| 错误消息 | 页面章节 | 快速修复 |\n|---------|---------|---------|\n| \"kernel version is too low\" | [内核要求](#内核和系统要求问题) | 升级内核 |\n| \"Operation not permitted\" | [权限问题](#权限问题) | 使用 `sudo` |\n| \"OpenSSL version not found\" | [版本检测](#版本检测问题) | 使用 `--ssl_version` 标志 |\n| \"couldn't find bpf bytecode\" | [库检测](#库检测问题) | 使用 `--libssl` 标志 |\n| \"incoming chan is full\" | [运行时错误](#问题incoming-chan-is-full错误) | 减少范围或增加 mapsize |\n| \"concurrent map access\" | [运行时错误](#问题并发-map-访问) | 更新到 v0.7.3+ |\n| \"cant found RET offset\" | [GoTLS 模块](#问题cant-found-ret-offset或剥离的-go-二进制文件) | 更新到 v0.7.0+ |\n\n来源：[CHANGELOG.md:1-782](), [user/module/probe_openssl_lib.go:64-70](), [README.md:1-335]()"
          }
        ]
      }
    },
    "default_language": "en"
  },
  "git_connection_type": "github_app",
  "git_host": "github.com"
}