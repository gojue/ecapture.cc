# Network Packet Capture with TC

<details>
<summary>Relevant source files</summary>

The following files were used as context for generating this wiki page:

- [cli/cmd/root.go](https://github.com/gojue/ecapture/blob/0766a93b/cli/cmd/root.go)
- [kern/common.h](https://github.com/gojue/ecapture/blob/0766a93b/kern/common.h)
- [kern/ecapture.h](https://github.com/gojue/ecapture/blob/0766a93b/kern/ecapture.h)
- [kern/tc.h](https://github.com/gojue/ecapture/blob/0766a93b/kern/tc.h)
- [user/config/iconfig.go](https://github.com/gojue/ecapture/blob/0766a93b/user/config/iconfig.go)
- [user/module/imodule.go](https://github.com/gojue/ecapture/blob/0766a93b/user/module/imodule.go)
- [user/module/probe_openssl.go](https://github.com/gojue/ecapture/blob/0766a93b/user/module/probe_openssl.go)

</details>



## Purpose and Scope

This document explains eCapture's Traffic Control (TC) based network packet capture subsystem. TC eBPF programs attach to network interfaces to intercept packets at the kernel level, enabling the capture of encrypted network traffic alongside plaintext data extracted from TLS libraries. The TC subsystem provides process attribution by mapping network connections to processes using kprobe-based connection tracking.

For information about TLS/SSL plaintext capture, see [TLS/SSL Modules](3.1-tlsssl-modules.md). For PCAP file generation and output formats, see [PCAP Integration](../4-output-formats/4.2-pcap-integration.md).

## Architecture Overview

The TC packet capture system consists of three main components:

1. **TC Classifier Programs**: eBPF programs attached to network interfaces that intercept packets at ingress and egress points
2. **Connection Tracking Kprobes**: eBPF kprobes on `tcp_sendmsg` and `udp_sendmsg` that map network connections to processes
3. **Network Mapping System**: An LRU hash map that maintains the association between network 4-tuples and process metadata

```mermaid
graph TB
    subgraph "Network Interface Layer"
        NIC["Network Interface<br/>(eth0, wlan0, etc.)"]
    end
    
    subgraph "TC eBPF Programs - kern/tc.h"
        INGRESS["ingress_cls_func()<br/>SEC classifier<br/>Lines 285-288"]
        EGRESS["egress_cls_func()<br/>SEC classifier<br/>Lines 279-282"]
        CAPTURE["capture_packets()<br/>Main capture logic<br/>Lines 135-276"]
    end
    
    subgraph "Connection Tracking Kprobes - kern/tc.h"
        TCP_PROBE["tcp_sendmsg<br/>SEC kprobe<br/>Lines 290-347"]
        UDP_PROBE["udp_sendmsg<br/>SEC kprobe<br/>Lines 349-397"]
    end
    
    subgraph "eBPF Maps - kern/tc.h"
        NET_MAP["network_map<br/>BPF_MAP_TYPE_LRU_HASH<br/>Lines 73-77"]
        SKB_EVENTS["skb_events<br/>BPF_MAP_TYPE_PERF_EVENT_ARRAY<br/>Lines 57-62"]
        SKB_BUFFER["skb_data_buffer_heap<br/>BPF_MAP_TYPE_PERCPU_ARRAY<br/>Lines 64-69"]
    end
    
    subgraph "User Space - user/module/"
        MODULE["MOpenSSLProbe<br/>MTCProbe embedded<br/>probe_openssl.go:83-106"]
        PROCESSOR["Event Processor<br/>Packet handling"]
    end
    
    NIC -->|"ingress packets"| INGRESS
    NIC <--"|egress packets"| EGRESS
    
    INGRESS --> CAPTURE
    EGRESS --> CAPTURE
    
    TCP_PROBE -->|"store tuple->ctx"| NET_MAP
    UDP_PROBE -->|"store tuple->ctx"| NET_MAP
    
    CAPTURE -->|"lookup ctx"| NET_MAP
    CAPTURE -->|"send event"| SKB_EVENTS
    CAPTURE -->|"use buffer"| SKB_BUFFER
    
    SKB_EVENTS -->|"perf events"| MODULE
    MODULE --> PROCESSOR
    
    style CAPTURE fill:#f9f9f9
    style NET_MAP fill:#f9f9f9
    style TCP_PROBE fill:#f9f9f9
    style UDP_PROBE fill:#f9f9f9
```

**Sources**: [kern/tc.h:1-398](https://github.com/gojue/ecapture/blob/0766a93b/kern/tc.h#L1-L398), [user/module/probe_openssl.go:83-106](https://github.com/gojue/ecapture/blob/0766a93b/user/module/probe_openssl.go#L83-L106)

## TC Classifier Programs

TC classifiers are eBPF programs that attach to network devices and process every packet passing through them. eCapture deploys two classifier programs: one for ingress traffic and one for egress traffic.

### Attachment Points

```mermaid
graph LR
    subgraph "Kernel Network Stack"
        RX["Packet Reception<br/>from NIC"]
        TX["Packet Transmission<br/>to NIC"]
    end
    
    subgraph "TC Hooks"
        ING["ingress_cls_func()<br/>tc.h:285-288"]
        EGR["egress_cls_func()<br/>tc.h:279-282"]
    end
    
    subgraph "Capture Logic"
        CAP["capture_packets(skb, is_ingress)<br/>tc.h:135-276"]
    end
    
    RX --> ING
    ING --> CAP
    
    CAP --> EGR
    EGR --> TX
    
    CAP -->|"TC_ACT_OK<br/>pass through"| TX
```

Both classifier functions delegate to the same `capture_packets()` function with a direction flag:

- **ingress_cls_func**: Processes incoming packets [kern/tc.h:285-288](https://github.com/gojue/ecapture/blob/0766a93b/kern/tc.h#L285-L288)
- **egress_cls_func**: Processes outgoing packets [kern/tc.h:279-282](https://github.com/gojue/ecapture/blob/0766a93b/kern/tc.h#L279-L282)

The classifiers return `TC_ACT_OK` to allow packets to continue through the network stack without modification [kern/common.h:58](https://github.com/gojue/ecapture/blob/0766a93b/kern/common.h#L58).

**Sources**: [kern/tc.h:135-288](https://github.com/gojue/ecapture/blob/0766a93b/kern/tc.h#L135-L288), [kern/common.h:58](https://github.com/gojue/ecapture/blob/0766a93b/kern/common.h#L58)

## Packet Capture Logic

The `capture_packets()` function implements the core packet capture logic. It operates on socket buffer structures (`struct __sk_buff`) provided by the kernel.

### Processing Pipeline

```mermaid
flowchart TD
    START["capture_packets(skb, is_ingress)"]
    
    VALIDATE["Validate packet length<br/>eth + ip headers<br/>tc.h:141-144"]
    
    FILTER["PCAP filter check<br/>filter_pcap_l2()<br/>tc.h:148-150"]
    
    PROTO_CHECK{"Protocol?"}
    
    IPV4["Parse IPv4 packet<br/>Extract 4-tuple<br/>tc.h:199-236"]
    
    IPV6["Parse IPv6 packet<br/>Extract 4-tuple<br/>tc.h:156-198"]
    
    LOOKUP["Lookup network_map<br/>by conn_id<br/>tc.h:225 or 188"]
    
    FOUND{"Context<br/>found?"}
    
    REVERSE["Try reverse lookup<br/>swap src/dst<br/>tc.h:227-234 or 189-197"]
    
    FILTER_PID["Filter by PID/UID<br/>target_pid, target_uid<br/>tc.h:244-249"]
    
    BUILD["Build skb_data_event_t<br/>timestamp, len, ifindex<br/>tc.h:239-258"]
    
    SEND["Send to skb_events<br/>bpf_perf_event_output<br/>tc.h:271"]
    
    RETURN["Return TC_ACT_OK<br/>tc.h:275"]
    
    START --> VALIDATE
    VALIDATE -->|"fail"| RETURN
    VALIDATE -->|"pass"| FILTER
    
    FILTER -->|"reject"| RETURN
    FILTER -->|"accept"| PROTO_CHECK
    
    PROTO_CHECK -->|"IPv4"| IPV4
    PROTO_CHECK -->|"IPv6"| IPV6
    PROTO_CHECK -->|"other"| RETURN
    
    IPV4 --> LOOKUP
    IPV6 --> LOOKUP
    
    LOOKUP --> FOUND
    FOUND -->|"not found"| REVERSE
    FOUND -->|"found"| FILTER_PID
    
    REVERSE --> FOUND
    
    FILTER_PID -->|"pass"| BUILD
    FILTER_PID -->|"reject"| RETURN
    
    BUILD --> SEND
    SEND --> RETURN
```

**Sources**: [kern/tc.h:135-276](https://github.com/gojue/ecapture/blob/0766a93b/kern/tc.h#L135-L276)

### Protocol Support

The TC capture supports multiple protocols with both IPv4 and IPv6:

| Protocol | Constant | Filter Location |
|----------|----------|-----------------|
| TCP | `IPPROTO_TCP` | [kern/tc.h:208,320,332]() |
| UDP | `IPPROTO_UDP` | [kern/tc.h:208,370,382]() |
| ICMP | `IPPROTO_ICMP` | [kern/tc.h:208](https://github.com/gojue/ecapture/blob/0766a93b/kern/tc.h#L208) |
| ICMPv6 | `IPPROTO_ICMPV6` | [kern/tc.h:164](https://github.com/gojue/ecapture/blob/0766a93b/kern/tc.h#L164) |

The capture extracts the following network tuple information:

```c
struct net_id_t {
    u32 protocol;      // IPPROTO_TCP or IPPROTO_UDP
    u32 src_port;      // Source port
    u32 src_ip4;       // Source IPv4 address
    u32 dst_port;      // Destination port
    u32 dst_ip4;       // Destination IPv4 address
    u32 src_ip6[4];    // Source IPv6 address
    u32 dst_ip6[4];    // Destination IPv6 address
};
```

**Sources**: [kern/tc.h:39-47,156-236]()

## Connection Tracking with Kprobes

To attribute captured packets to specific processes, eCapture uses kprobes on kernel functions that establish network connections. These kprobes capture the process context before packets are transmitted.

### Kprobe Attachment Points

```mermaid
graph TB
    subgraph "Application Space"
        APP["Application Process<br/>send()/sendto()"]
    end
    
    subgraph "System Call Layer"
        SYSCALL["sys_sendto/sys_write"]
    end
    
    subgraph "Kernel Functions"
        TCP["tcp_sendmsg(sock *sk, ...)<br/>tc.h:291-347"]
        UDP["udp_sendmsg(sock *sk, ...)<br/>tc.h:350-397"]
    end
    
    subgraph "eBPF Kprobes"
        TCP_PROBE["SEC kprobe/tcp_sendmsg<br/>Extract sock info<br/>Store to network_map"]
        UDP_PROBE["SEC kprobe/udp_sendmsg<br/>Extract sock info<br/>Store to network_map"]
    end
    
    subgraph "Data Extraction"
        SOCK["struct sock<br/>__sk_common"]
        EXTRACT["Extract:<br/>- family (AF_INET/AF_INET6)<br/>- src/dst IP<br/>- src/dst port"]
    end
    
    subgraph "Context Collection"
        CTX["Collect:<br/>- PID (bpf_get_current_pid_tgid)<br/>- UID (bpf_get_current_uid_gid)<br/>- comm (bpf_get_current_comm)"]
    end
    
    subgraph "Storage"
        MAP["network_map<br/>key: net_id_t<br/>value: net_ctx_t"]
    end
    
    APP --> SYSCALL
    SYSCALL --> TCP
    SYSCALL --> UDP
    
    TCP --> TCP_PROBE
    UDP --> UDP_PROBE
    
    TCP_PROBE --> SOCK
    UDP_PROBE --> SOCK
    
    SOCK --> EXTRACT
    EXTRACT --> CTX
    
    CTX --> MAP
    
    style TCP_PROBE fill:#f9f9f9
    style UDP_PROBE fill:#f9f9f9
    style MAP fill:#f9f9f9
```

**Sources**: [kern/tc.h:290-397](https://github.com/gojue/ecapture/blob/0766a93b/kern/tc.h#L290-L397)

### Process Context Extraction

Both kprobes extract the same information and store it in the `network_map`:

```c
struct net_ctx_t {
    u32 pid;              // Process ID
    u32 uid;              // User ID
    char comm[16];        // Command name (TASK_COMM_LEN)
};
```

The kprobes perform the following steps:

1. **Get Process Context** [kern/tc.h:292-294,351-353]()
   - `bpf_get_current_pid_tgid() >> 32` - Extract PID
   - `bpf_get_current_uid_gid()` - Extract UID
   - `bpf_get_current_comm()` - Get process name

2. **Extract Socket Information** [kern/tc.h:304-337,354-387]()
   - Read `sock->__sk_common.skc_family` - Address family
   - Read `sock->__sk_common.skc_num` - Local port
   - Read `sock->__sk_common.skc_dport` - Remote port
   - Read source/destination IP addresses

3. **Store Mapping** [kern/tc.h:345,395]()
   - Create `net_id_t` key from network tuple
   - Create `net_ctx_t` value from process context
   - `bpf_map_update_elem(&network_map, &conn_id, &net_ctx, BPF_ANY)`

**Sources**: [kern/tc.h:290-397](https://github.com/gojue/ecapture/blob/0766a93b/kern/tc.h#L290-L397)

## Network Mapping System

The `network_map` is the central data structure that associates network connections with process information. It uses an LRU (Least Recently Used) eviction policy to maintain a bounded cache of active connections.

### Map Configuration

```mermaid
graph LR
    subgraph "Map Definition - tc.h:73-77"
        TYPE["Type: BPF_MAP_TYPE_LRU_HASH"]
        KEY["Key: struct net_id_t<br/>4-tuple + protocol"]
        VALUE["Value: struct net_ctx_t<br/>pid + uid + comm"]
        SIZE["Max Entries: 10240"]
    end
    
    subgraph "Key Structure - net_id_t"
        K_PROTO["protocol: u32"]
        K_SPORT["src_port: u32"]
        K_SIP4["src_ip4: u32"]
        K_DPORT["dst_port: u32"]
        K_DIP4["dst_ip4: u32"]
        K_SIP6["src_ip6: u32[4]"]
        K_DIP6["dst_ip6: u32[4]"]
    end
    
    subgraph "Value Structure - net_ctx_t"
        V_PID["pid: u32"]
        V_UID["uid: u32"]
        V_COMM["comm: char[16]"]
    end
    
    TYPE --> KEY
    KEY --> VALUE
    VALUE --> SIZE
    
    KEY --> K_PROTO
    KEY --> K_SPORT
    KEY --> K_DIP4
    
    VALUE --> V_PID
    VALUE --> V_UID
    VALUE --> V_COMM
```

**Sources**: [kern/tc.h:39-77](https://github.com/gojue/ecapture/blob/0766a93b/kern/tc.h#L39-L77)

### Bidirectional Lookup

Since packets can arrive in either direction (client→server or server→client), the `capture_packets()` function implements bidirectional lookup:

1. **Initial Lookup**: Try to find the connection using the packet's source as the connection source [kern/tc.h:225,188]()
2. **Reverse Lookup**: If not found, swap source and destination and try again [kern/tc.h:227-234,189-197]()

This ensures that both incoming and outgoing packets are correctly attributed to the originating process.

**Sources**: [kern/tc.h:188-234](https://github.com/gojue/ecapture/blob/0766a93b/kern/tc.h#L188-L234)

## Packet Filtering

eCapture supports multiple levels of filtering to reduce overhead and capture only relevant traffic.

### Filter Hierarchy

```mermaid
flowchart TD
    PKT["Incoming Packet"]
    
    L1["Length Filter<br/>Minimum header size<br/>tc.h:141-144"]
    
    L2["PCAP Filter (Optional)<br/>filter_pcap_l2()<br/>tc.h:121-132,148-150"]
    
    L3["Protocol Filter<br/>TCP/UDP/ICMP only<br/>tc.h:164,208"]
    
    L4["Process Filter<br/>target_pid, target_uid<br/>tc.h:244-249"]
    
    CAPTURE["Capture Packet"]
    DROP["Drop Packet"]
    
    PKT --> L1
    L1 -->|"< min size"| DROP
    L1 -->|"≥ min size"| L2
    
    L2 -->|"rejected"| DROP
    L2 -->|"accepted"| L3
    
    L3 -->|"unsupported"| DROP
    L3 -->|"supported"| L4
    
    L4 -->|"no match"| DROP
    L4 -->|"match"| CAPTURE
```

### PCAP Filter Integration

The `filter_pcap_l2()` function [kern/tc.h:121-132](https://github.com/gojue/ecapture/blob/0766a93b/kern/tc.h#L121-L132) serves as an injection point for BPF bytecode generated from PCAP filter expressions. The function is marked `__noinline` to prevent compiler optimization, allowing userspace to patch its instructions.

The filter patching is initiated in userspace [user/module/probe_openssl.go:303-307](https://github.com/gojue/ecapture/blob/0766a93b/user/module/probe_openssl.go#L303-L307):

```go
if m.eBPFProgramType == TlsCaptureModelTypePcap && pcapFilter != "" {
    ebpfFuncs := []string{tcFuncNameIngress, tcFuncNameEgress}
    m.bpfManager.InstructionPatchers = prepareInsnPatchers(m.bpfManager,
        ebpfFuncs, pcapFilter)
}
```

**Sources**: [kern/tc.h:121-150](https://github.com/gojue/ecapture/blob/0766a93b/kern/tc.h#L121-L150), [user/module/probe_openssl.go:303-307](https://github.com/gojue/ecapture/blob/0766a93b/user/module/probe_openssl.go#L303-L307)

### Process Filtering

When `target_pid` or `target_uid` are set (kernel ≥ 5.2), packets are filtered to match specific processes [kern/tc.h:244-249](https://github.com/gojue/ecapture/blob/0766a93b/kern/tc.h#L244-L249):

```c
if (target_pid != 0 && target_pid != net_ctx->pid) {
    return TC_ACT_OK;
}
if (target_uid != 0 && target_uid != net_ctx->uid) {
    return TC_ACT_OK;
}
```

This filtering happens after successful connection lookup, ensuring that only packets belonging to the target process are captured.

**Note**: The kprobes themselves do NOT filter by PID/UID [kern/tc.h:296-302](https://github.com/gojue/ecapture/blob/0766a93b/kern/tc.h#L296-L302) because the `network_map` must contain all connections for the TC classifiers to perform attribution. Process filtering only occurs during packet capture.

**Sources**: [kern/tc.h:244-249,296-302](), [kern/common.h:64-71](https://github.com/gojue/ecapture/blob/0766a93b/kern/common.h#L64-L71)

## Data Structures

### Event Structure

Captured packet metadata is transmitted to userspace using the `skb_data_event_t` structure:

```c
struct skb_data_event_t {
    uint64_t ts;                // Timestamp (bpf_ktime_get_ns)
    u32 pid;                    // Process ID
    char comm[TASK_COMM_LEN];   // Process name
    u32 len;                    // Packet length (skb->len)
    u32 ifindex;                // Network interface index
};
```

The event contains minimal metadata (36 bytes) [kern/tc.h:20](https://github.com/gojue/ecapture/blob/0766a93b/kern/tc.h#L20) with the packet payload appended via the `bpf_perf_event_output()` flags parameter [kern/tc.h:260-271](https://github.com/gojue/ecapture/blob/0766a93b/kern/tc.h#L260-L271):

```c
u64 flags = BPF_F_CURRENT_CPU;
flags |= (u64)skb->len << 32;  // Encode packet length in upper 32 bits
bpf_perf_event_output(skb, &skb_events, flags, &event, TC_PACKET_MIN_SIZE);
```

**Sources**: [kern/tc.h:30-37,239-271]()

### Buffer Management

To avoid stack overflow with large structures, eCapture uses a per-CPU array map for temporary event storage:

```c
struct {
    __uint(type, BPF_MAP_TYPE_PERCPU_ARRAY);
    __type(key, u32);
    __type(value, struct skb_data_event_t);
    __uint(max_entries, 1);
} skb_data_buffer_heap SEC(".maps");
```

The `make_skb_data_event()` function [kern/tc.h:92-100](https://github.com/gojue/ecapture/blob/0766a93b/kern/tc.h#L92-L100) retrieves a buffer from this map, which is automatically managed per-CPU by the kernel.

**Sources**: [kern/tc.h:64-100](https://github.com/gojue/ecapture/blob/0766a93b/kern/tc.h#L64-L100)

## Integration with Capture Modules

The TC packet capture integrates primarily with TLS capture modules to provide complete network traffic visibility.

### MTCProbe Base Structure

The TC functionality is encapsulated in the `MTCProbe` struct, which is embedded by capture modules that need network packet capture [user/module/probe_openssl.go:84](https://github.com/gojue/ecapture/blob/0766a93b/user/module/probe_openssl.go#L84):

```mermaid
graph TB
    subgraph "Module Hierarchy"
        MOD["Module<br/>base module struct"]
        MTCP["MTCProbe<br/>TC probe base<br/>probe_tc.go"]
        MOSSL["MOpenSSLProbe<br/>OpenSSL/BoringSSL capture<br/>probe_openssl.go:83-106"]
    end
    
    subgraph "TC Components in MTCProbe"
        PKT_CHAN["tcPacketsChan<br/>chan *TcPacket<br/>Buffered: 2048"]
        PKT_BUF["tcPackets<br/>[]*TcPacket<br/>Batch buffer: 256"]
        PCAP_FILE["pcapngFilename<br/>Output file path"]
        TIME["startTime, bootTime<br/>Timestamp conversion"]
    end
    
    subgraph "PCAP Generation - probe_tc.go"
        WRITER["PCAP-NG Writer<br/>savePcapngSslKeyLog()"]
        DSB["DSB Block<br/>TLS key log"]
    end
    
    MOD -.->|"embedded"| MTCP
    MTCP -.->|"embedded"| MOSSL
    
    MTCP --> PKT_CHAN
    MTCP --> PKT_BUF
    MTCP --> PCAP_FILE
    MTCP --> TIME
    
    MOSSL -->|"TcSkbEvent"| PKT_CHAN
    PKT_CHAN --> WRITER
    WRITER --> PCAP_FILE
    WRITER --> DSB
```

**Sources**: [user/module/probe_openssl.go:83-106](https://github.com/gojue/ecapture/blob/0766a93b/user/module/probe_openssl.go#L83-L106), [user/module/probe_tc.go](https://github.com/gojue/ecapture/blob/0766a93b/user/module/probe_tc.go)

### Event Flow

When the OpenSSL module operates in PCAP mode, it receives both TC packet events and TLS master secret events:

1. **Initialization** [user/module/probe_openssl.go:137-148](https://github.com/gojue/ecapture/blob/0766a93b/user/module/probe_openssl.go#L137-L148):
   - Set `eBPFProgramType = TlsCaptureModelTypePcap`
   - Create `tcPacketsChan` buffered channel (2048 entries)
   - Initialize `tcPackets` batch buffer (256 entries)
   - Store PCAP output filename

2. **Event Dispatch** [user/module/probe_openssl.go:733-753](https://github.com/gojue/ecapture/blob/0766a93b/user/module/probe_openssl.go#L733-L753):
   ```go
   switch ev := eventStruct.(type) {
   case *event.TcSkbEvent:
       err := m.dumpTcSkb(ev)  // Process TC packet
   case *event.MasterSecretEvent:
       m.saveMasterSecret(ev)   // Process TLS key
   }
   ```

3. **PCAP Output** [user/module/probe_openssl.go:558-565](https://github.com/gojue/ecapture/blob/0766a93b/user/module/probe_openssl.go#L558-L565):
   - TC packets written to PCAP-NG file
   - TLS master secrets written as DSB (Decryption Secrets Block)
   - Enables Wireshark to decrypt captured TLS traffic

**Sources**: [user/module/probe_openssl.go:137-148,558-565,733-753]()

## Userspace Event Reading

The userspace module reads TC events from the `skb_events` perf event array using the standard event reading infrastructure.

### Event Reader Setup

```mermaid
flowchart LR
    subgraph "eBPF Maps"
        SKB_MAP["skb_events<br/>PERF_EVENT_ARRAY"]
    end
    
    subgraph "Module Event System - imodule.go"
        EVENTS["Events() []*ebpf.Map<br/>Returns list of maps"]
        DECODE["DecodeFun(*ebpf.Map)<br/>Returns decoder"]
        READER["perfEventReader()<br/>imodule.go:308-350"]
    end
    
    subgraph "Event Processing"
        PERF["perf.NewReader()<br/>cilium/ebpf/perf"]
        LOOP["Read Loop<br/>record, err := rd.Read()"]
        DEC["Decode event<br/>child.Decode(em, record.RawSample)"]
        DISP["Dispatcher()<br/>child.Dispatcher(evt)"]
    end
    
    SKB_MAP --> EVENTS
    EVENTS --> READER
    READER --> PERF
    PERF --> LOOP
    LOOP --> DEC
    DEC --> DISP
```

The reading process [user/module/imodule.go:285-350](https://github.com/gojue/ecapture/blob/0766a93b/user/module/imodule.go#L285-L350):

1. **Map Discovery**: `Events()` returns all event maps including `skb_events`
2. **Reader Creation**: `perfEventReader()` creates a perf event reader with configurable buffer size
3. **Event Loop**: Continuously reads from the perf ring buffer
4. **Decoding**: `Decode()` parses the raw event bytes into `TcSkbEvent` struct
5. **Dispatch**: Passes the event to the module's `Dispatcher()` for handling

**Sources**: [user/module/imodule.go:285-350](https://github.com/gojue/ecapture/blob/0766a93b/user/module/imodule.go#L285-L350)

## Kernel Version Compatibility

TC capture has specific kernel version requirements:

| Feature | Minimum Kernel | Note |
|---------|----------------|------|
| TC Classifier | 4.1+ | Basic TC BPF support |
| PCAP Filter Injection | 5.2+ | Required for `filter_pcap_l2()` patching |
| PID/UID Filtering | 5.2+ | Uses global const variables [kern/common.h:64-71](https://github.com/gojue/ecapture/blob/0766a93b/kern/common.h#L64-L71) |

For kernels < 5.2, the following limitations apply:
- No runtime PCAP filter injection
- No PID/UID filtering in TC programs
- Connection tracking still works via kprobes

The `KERNEL_LESS_5_2` preprocessor directive [kern/common.h:64-71](https://github.com/gojue/ecapture/blob/0766a93b/kern/common.h#L64-L71) controls conditional compilation of features requiring newer kernels.

**Sources**: [kern/common.h:64-71](https://github.com/gojue/ecapture/blob/0766a93b/kern/common.h#L64-L71), [kern/tc.h:147-150,243-250]()

## Summary

The TC-based packet capture system provides comprehensive network visibility by:

1. **Intercepting All Traffic**: TC classifiers capture packets at the network interface level before encryption/after decryption
2. **Process Attribution**: Kprobes on `tcp_sendmsg`/`udp_sendmsg` map connections to processes via the `network_map` LRU hash
3. **Bidirectional Capture**: Handles both ingress and egress traffic with automatic source/destination reversal
4. **Flexible Filtering**: Supports PCAP filter expressions, protocol filtering, and PID/UID filtering
5. **TLS Integration**: Combines network packets with TLS master secrets for complete traffic decryption in PCAP-NG format

This approach enables eCapture to capture complete network traffic with process context, even for encrypted connections, without requiring application instrumentation or certificate installation.

**Sources**: [kern/tc.h:1-398](https://github.com/gojue/ecapture/blob/0766a93b/kern/tc.h#L1-L398), [user/module/probe_openssl.go:83-106,303-307,558-565,733-753](), [user/module/imodule.go:285-350](https://github.com/gojue/ecapture/blob/0766a93b/user/module/imodule.go#L285-L350)