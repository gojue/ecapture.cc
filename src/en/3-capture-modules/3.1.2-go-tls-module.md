# Go TLS Module

<details>
<summary>Relevant source files</summary>

The following files were used as context for generating this wiki page:

- [cli/cmd/bash.go](https://github.com/gojue/ecapture/blob/0766a93b/cli/cmd/bash.go)
- [cli/cmd/gnutls.go](https://github.com/gojue/ecapture/blob/0766a93b/cli/cmd/gnutls.go)
- [cli/cmd/gotls.go](https://github.com/gojue/ecapture/blob/0766a93b/cli/cmd/gotls.go)
- [cli/cmd/mysqld.go](https://github.com/gojue/ecapture/blob/0766a93b/cli/cmd/mysqld.go)
- [cli/cmd/nspr.go](https://github.com/gojue/ecapture/blob/0766a93b/cli/cmd/nspr.go)
- [cli/cmd/postgres.go](https://github.com/gojue/ecapture/blob/0766a93b/cli/cmd/postgres.go)
- [cli/cmd/tls.go](https://github.com/gojue/ecapture/blob/0766a93b/cli/cmd/tls.go)
- [cli/cmd/zsh.go](https://github.com/gojue/ecapture/blob/0766a93b/cli/cmd/zsh.go)
- [kern/go_argument.h](https://github.com/gojue/ecapture/blob/0766a93b/kern/go_argument.h)
- [kern/gotls_kern.c](https://github.com/gojue/ecapture/blob/0766a93b/kern/gotls_kern.c)
- [pkg/util/ws/client.go](https://github.com/gojue/ecapture/blob/0766a93b/pkg/util/ws/client.go)
- [pkg/util/ws/client_test.go](https://github.com/gojue/ecapture/blob/0766a93b/pkg/util/ws/client_test.go)
- [user/config/config_gotls.go](https://github.com/gojue/ecapture/blob/0766a93b/user/config/config_gotls.go)
- [user/module/probe_gotls.go](https://github.com/gojue/ecapture/blob/0766a93b/user/module/probe_gotls.go)
- [user/module/probe_gotls_keylog.go](https://github.com/gojue/ecapture/blob/0766a93b/user/module/probe_gotls_keylog.go)
- [user/module/probe_gotls_text.go](https://github.com/gojue/ecapture/blob/0766a93b/user/module/probe_gotls_text.go)

</details>



## Purpose and Scope

The Go TLS Module captures plaintext TLS/SSL traffic and cryptographic secrets from applications compiled with the Go programming language. Unlike the OpenSSL Module (see [3.1.1](3.1.1-openssl-module.md)), which hooks dynamic library functions, this module directly instruments the Go binary's crypto/tls package functions by parsing the Go application's ELF structure and symbol tables.

This module addresses unique challenges of Go binaries: statically-linked TLS implementation, evolving Application Binary Interface (ABI) conventions (register-based vs stack-based), Position Independent Executable (PIE) build modes, and version-specific symbol table formats. For general TLS capture concepts and master secret extraction techniques, see [3.1.4](3.1.4-master-secret-extraction.md).

**Key Capabilities:**
- Capture plaintext TLS data from Go applications without library injection
- Extract TLS master secrets for traffic decryption
- Support both register-based ABI (Go 1.17+) and stack-based ABI (Go <1.17)
- Handle PIE and non-PIE Go binaries
- Three output modes: text, keylog, and pcap (see [4](../4-output-formats/index.md))

---

## Architecture Overview

The Go TLS Module follows a three-phase initialization and execution pattern distinct from library-based modules:

```mermaid
graph TB
    subgraph "Phase 1: Binary Analysis"
        ELF["ELF File Reader<br/>(config_gotls.go)"]
        BUILDINFO["buildinfo.ReadFile()<br/>Extract Go version<br/>Build settings"]
        SYMTAB["Symbol Table Parser<br/>ReadTable()<br/>.gopclntab section"]
        PIE_DETECT["PIE Detection<br/>-buildmode=pie"]
    end
    
    subgraph "Phase 2: Function Location"
        ABI_SELECT["ABI Selection<br/>Go >= 1.17: Register<br/>Go < 1.17: Stack"]
        OFFSET_CALC["Offset Calculator<br/>findRetOffsets()<br/>findPieSymbolAddr()"]
        HOOK_ADDRS["Hook Addresses<br/>writeRecordLocked<br/>Read (multiple RET)<br/>writeKeyLog"]
    end
    
    subgraph "Phase 3: eBPF Attachment"
        UPROBE_MGR["Uprobe Manager<br/>ebpfmanager"]
        REG_PROG["Register ABI Programs<br/>gotls_write_register<br/>gotls_read_register<br/>gotls_mastersecret_register"]
        STACK_PROG["Stack ABI Programs<br/>gotls_write_stack<br/>gotls_read_stack<br/>gotls_mastersecret_stack"]
        ARG_EXTRACT["Argument Extraction<br/>go_argument.h<br/>go_get_argument()"]
    end
    
    subgraph "Runtime Capture"
        DATA_EVENT["go_tls_event<br/>Plaintext data<br/>Read/Write type"]
        SECRET_EVENT["mastersecret_gotls_t<br/>Label + ClientRandom<br/>+ Secret"]
        TC_EVENT["TcSkbEvent<br/>(pcap mode only)"]
    end
    
    ELF --> BUILDINFO
    ELF --> SYMTAB
    BUILDINFO --> PIE_DETECT
    BUILDINFO --> ABI_SELECT
    SYMTAB --> OFFSET_CALC
    PIE_DETECT --> OFFSET_CALC
    ABI_SELECT --> OFFSET_CALC
    OFFSET_CALC --> HOOK_ADDRS
    HOOK_ADDRS --> UPROBE_MGR
    ABI_SELECT --> REG_PROG
    ABI_SELECT --> STACK_PROG
    REG_PROG --> ARG_EXTRACT
    STACK_PROG --> ARG_EXTRACT
    UPROBE_MGR --> DATA_EVENT
    UPROBE_MGR --> SECRET_EVENT
    UPROBE_MGR --> TC_EVENT
    
    style BUILDINFO fill:#f9f9f9
    style ABI_SELECT fill:#f9f9f9
    style ARG_EXTRACT fill:#f9f9f9
```

**Sources:** [user/module/probe_gotls.go:58-122](https://github.com/gojue/ecapture/blob/0766a93b/user/module/probe_gotls.go#L58-L122), [user/config/config_gotls.go:95-190](https://github.com/gojue/ecapture/blob/0766a93b/user/config/config_gotls.go#L95-L190)

---

## Go Binary Analysis and ABI Detection

### ELF Structure Parsing

The module begins by extracting metadata from the target Go binary using Go's `debug/buildinfo` and `debug/elf` packages:

```mermaid
flowchart TD
    START["GoTLSConfig.Check()"]
    READ_BUILD["buildinfo.ReadFile()<br/>Extract BuildInfo"]
    OPEN_ELF["elf.Open()<br/>Parse ELF headers"]
    ARCH_CHECK["Architecture Check<br/>EM_X86_64 → amd64<br/>EM_AARCH64 → arm64"]
    PIE_CHECK{"Check BuildSettings<br/>-buildmode=pie?"}
    READ_SYMTAB["ReadTable()<br/>Parse .gopclntab"]
    FIND_FUNCS["Find Function Addresses<br/>findPieSymbolAddr()"]
    FIND_OFFSETS_PIE["findRetOffsetsPie()<br/>Decode instructions"]
    FIND_OFFSETS_NOPIE["findRetOffsets()<br/>Search symbol table"]
    VALIDATE["Validate hook points<br/>Set addresses"]
    
    START --> READ_BUILD
    READ_BUILD --> OPEN_ELF
    OPEN_ELF --> ARCH_CHECK
    ARCH_CHECK --> PIE_CHECK
    PIE_CHECK -->|Yes| READ_SYMTAB
    PIE_CHECK -->|No| FIND_OFFSETS_NOPIE
    READ_SYMTAB --> FIND_FUNCS
    FIND_FUNCS --> FIND_OFFSETS_PIE
    FIND_OFFSETS_NOPIE --> VALIDATE
    FIND_OFFSETS_PIE --> VALIDATE
```

**Key Data Structures:**

| Field | Type | Purpose |
|-------|------|---------|
| `Buildinfo` | `*buildinfo.BuildInfo` | Go version, build settings, module info |
| `goElf` | `*elf.File` | ELF file handle for section/symbol access |
| `goSymTab` | `*gosym.Table` | Symbol table for PIE binaries |
| `IsPieBuildMode` | `bool` | Indicates PIE compilation |
| `ReadTlsAddrs` | `[]int` | Multiple RET instruction offsets for Read uretprobes |
| `GoTlsWriteAddr` | `uint64` | Address of writeRecordLocked function |
| `GoTlsMasterSecretAddr` | `uint64` | Address of Config.writeKeyLog function |

**Sources:** [user/config/config_gotls.go:102-190](https://github.com/gojue/ecapture/blob/0766a93b/user/config/config_gotls.go#L102-L190)

### Symbol Table Parsing for PIE Binaries

PIE binaries require special handling because symbols are unlabeled and relocated. The module locates the `.gopclntab` section (or `.data.rel.ro.gopclntab` for PIE) using magic number matching:

```mermaid
graph LR
    SECTIONS["ELF Sections"]
    PCLNTAB[".gopclntab<br/>.data.rel.ro.gopclntab<br/>.data.rel.ro"]
    MAGIC["Magic Number<br/>0xFFFFFFFA (Go 1.16)<br/>0xFFFFFFF0 (Go 1.18)<br/>0xFFFFFFF1 (Go 1.20)"]
    INDEX["bytes.Index()<br/>Find magic in data"]
    LINETAB["gosym.NewLineTable()<br/>PC-to-line mapping"]
    SYMTAB["gosym.NewTable()<br/>Function symbols"]
    LOOKUP["LookupFunc()<br/>Resolve addresses"]
    
    SECTIONS --> PCLNTAB
    PCLNTAB --> MAGIC
    MAGIC --> INDEX
    INDEX --> LINETAB
    LINETAB --> SYMTAB
    SYMTAB --> LOOKUP
```

The magic number varies by Go version to accommodate changes in the program counter line table format:

| Go Version | Magic Number | Hex Value |
|------------|--------------|-----------|
| < 1.16 | `go12magic` | `0xFFFFFFFB` |
| 1.16-1.17 | `go116magic` | `0xFFFFFFFA` |
| 1.18-1.19 | `go118magic` | `0xFFFFFFF0` |
| ≥ 1.20 | `go120magic` | `0xFFFFFFF1` |

**Sources:** [user/config/config_gotls.go:46-69](https://github.com/gojue/ecapture/blob/0766a93b/user/config/config_gotls.go#L46-L69), [user/config/config_gotls.go:281-325](https://github.com/gojue/ecapture/blob/0766a93b/user/config/config_gotls.go#L281-L325)

### ABI Version Detection

Go 1.17 introduced a register-based calling convention, fundamentally changing how function arguments are passed. The module detects this by comparing the Go version:

```mermaid
graph TD
    VERSION["Extract Go Version<br/>proc.ExtraceGoVersion()"]
    COMPARE{"Version >= 1.17?"}
    REG_ABI["isRegisterABI = true<br/>Use register-based argument extraction"]
    STACK_ABI["isRegisterABI = false<br/>Use stack-based argument extraction"]
    SELECT_PROG{"Select eBPF Programs"}
    REG_PROGS["gotls_write_register<br/>gotls_read_register<br/>gotls_mastersecret_register"]
    STACK_PROGS["gotls_write_stack<br/>gotls_read_stack<br/>gotls_mastersecret_stack"]
    
    VERSION --> COMPARE
    COMPARE -->|Yes| REG_ABI
    COMPARE -->|No| STACK_ABI
    REG_ABI --> SELECT_PROG
    STACK_ABI --> SELECT_PROG
    SELECT_PROG --> REG_PROGS
    SELECT_PROG --> STACK_PROGS
```

**Sources:** [user/module/probe_gotls.go:71-79](https://github.com/gojue/ecapture/blob/0766a93b/user/module/probe_gotls.go#L71-L79), [user/module/probe_gotls_text.go:37-47](https://github.com/gojue/ecapture/blob/0766a93b/user/module/probe_gotls_text.go#L37-L47)

---

## Hook Points and Function Offsets

### Target Functions

The module hooks three critical functions in the `crypto/tls` package:

| Function | Constant | Purpose | Hook Type |
|----------|----------|---------|-----------|
| `(*Conn).writeRecordLocked` | `GoTlsWriteFunc` | Writes TLS records (plaintext data) | Uprobe (entry) |
| `(*Conn).Read` | `GoTlsReadFunc` | Reads TLS records (plaintext data) | Uretprobe (return) |
| `(*Config).writeKeyLog` | `GoTlsMasterSecretFunc` | Logs TLS secrets for keylog files | Uprobe (entry) |

**Sources:** [user/config/config_gotls.go:31-35](https://github.com/gojue/ecapture/blob/0766a93b/user/config/config_gotls.go#L31-L35)

### RET Instruction Offset Calculation

For `Read` function uretprobes, the module must find all RET instruction offsets because uretprobes in userspace are implemented as uprobes on RET instructions. The process differs for PIE vs non-PIE binaries:

```mermaid
graph TB
    subgraph "Non-PIE: findRetOffsets()"
        SYMBOL1["Search .symtab<br/>Find symbol by name"]
        SECTION1["Get symbol.Section<br/>Extract code bytes"]
        DECODE1["decodeInstruction()<br/>Find RET offsets"]
        ADJUST1["Adjust for PT_LOAD<br/>segment offset"]
    end
    
    subgraph "PIE: findRetOffsetsPie()"
        SYMTAB["goSymTab.LookupFunc()<br/>Get function entry/end"]
        ADDR["Get function address<br/>from symbol table"]
        PROG["Find PT_LOAD segment<br/>Read function bytes"]
        DECODE2["decodeInstruction()<br/>Find RET offsets"]
        ADJUST2["Calculate absolute<br/>addresses"]
    end
    
    START{"IsPieBuildMode?"}
    RESULT["ReadTlsAddrs []int<br/>List of RET addresses"]
    
    START -->|No| SYMBOL1
    START -->|Yes| SYMTAB
    SYMBOL1 --> SECTION1
    SECTION1 --> DECODE1
    DECODE1 --> ADJUST1
    ADJUST1 --> RESULT
    SYMTAB --> ADDR
    ADDR --> PROG
    PROG --> DECODE2
    DECODE2 --> ADJUST2
    ADJUST2 --> RESULT
```

The `decodeInstruction()` function is architecture-specific and searches for RET opcodes (0xC3 on x86-64, specific patterns on ARM64).

**Sources:** [user/config/config_gotls.go:196-262](https://github.com/gojue/ecapture/blob/0766a93b/user/config/config_gotls.go#L196-L262), [user/config/config_gotls.go:327-357](https://github.com/gojue/ecapture/blob/0766a93b/user/config/config_gotls.go#L327-L357)

---

## eBPF Programs and Argument Extraction

### Register vs Stack ABI Argument Access

The core challenge is extracting function arguments, which differ fundamentally between ABIs:

```mermaid
graph TB
    subgraph "Register-Based ABI (Go >= 1.17)"
        REG_PARAMS["x86-64 Registers:<br/>AX, BX, CX, DI, SI, R8, R9, R10<br/><br/>ARM64 Registers:<br/>X0-X7"]
        REG_MACRO["GO_PARAMx() Macros<br/>go_argument.h"]
        REG_READ["Direct register read<br/>BPF_CORE_READ(ctx, reg)"]
    end
    
    subgraph "Stack-Based ABI (Go < 1.17)"
        STACK_PTR["Stack Pointer (SP)<br/>PT_REGS_SP(ctx)"]
        STACK_OFFSET["Calculate offset<br/>SP + (index * 8)"]
        STACK_READ["bpf_probe_read()<br/>Read from stack"]
    end
    
    FUNC_CALL["go_get_argument(ctx, is_register_abi, index)"]
    SWITCH{"is_register_abi?"}
    
    FUNC_CALL --> SWITCH
    SWITCH -->|true| REG_PARAMS
    SWITCH -->|false| STACK_PTR
    REG_PARAMS --> REG_MACRO
    REG_MACRO --> REG_READ
    STACK_PTR --> STACK_OFFSET
    STACK_OFFSET --> STACK_READ
```

**x86-64 Register Mapping:**

| Argument Index | Register (Register ABI) | Stack Offset (Stack ABI) |
|----------------|------------------------|-------------------------|
| 1 | RAX | SP + 8 |
| 2 | RBX | SP + 16 |
| 3 | RCX | SP + 24 |
| 4 | RDI | SP + 32 |
| 5 | RSI | SP + 40 |
| 6 | R8 | SP + 48 |
| 7 | R9 | SP + 56 |
| 8 | R10 | SP + 64 |

**Sources:** [kern/go_argument.h:74-108](https://github.com/gojue/ecapture/blob/0766a93b/kern/go_argument.h#L74-L108)

### Write Capture (gotls_write)

The `writeRecordLocked` function signature is:
```go
func (c *Conn) writeRecordLocked(typ recordType, data []byte) (int, error)
```

The eBPF program extracts:
- Argument 2: `recordType` (uint8) - must be `recordTypeApplicationData` (23)
- Argument 3: `data` pointer (byte slice array pointer)
- Argument 4: `len` (int) - length of data

```mermaid
sequenceDiagram
    participant App as "Go Application"
    participant Uprobe as "gotls_write_*"
    participant Helper as "go_get_argument()"
    participant Map as "events map"
    
    App->>Uprobe: writeRecordLocked(conn, 23, []byte, len)
    Uprobe->>Helper: get_argument(ctx, is_register_abi, 2)
    Helper-->>Uprobe: record_type = 23
    Uprobe->>Uprobe: Check if ApplicationData
    Uprobe->>Helper: get_argument(ctx, is_register_abi, 3)
    Helper-->>Uprobe: data pointer
    Uprobe->>Helper: get_argument(ctx, is_register_abi, 4)
    Helper-->>Uprobe: length
    Uprobe->>Uprobe: bpf_probe_read_user(&event.data, len, ptr)
    Uprobe->>Map: bpf_perf_event_output(event)
```

**Event Structure:**

```c
struct go_tls_event {
    u64 ts_ns;              // Timestamp
    u32 pid;                // Process ID
    u32 tid;                // Thread ID
    s32 data_len;           // Data length
    u8 event_type;          // 0=Write, 1=Read
    char comm[TASK_COMM_LEN]; // Process name
    char data[MAX_DATA_SIZE_OPENSSL]; // Plaintext data
};
```

**Sources:** [kern/gotls_kern.c:89-123](https://github.com/gojue/ecapture/blob/0766a93b/kern/gotls_kern.c#L89-L123), [kern/gotls_kern.c:31-39](https://github.com/gojue/ecapture/blob/0766a93b/kern/gotls_kern.c#L31-L39)

### Read Capture (gotls_read)

The `Read` function signature is:
```go
func (c *Conn) Read(b []byte) (int, error)
```

This uses **uretprobe** to capture data after the read completes. The challenge is that at return time, arguments are on the stack even for register ABI:

```mermaid
graph TB
    URETPROBE["Uretprobe on RET instruction"]
    STACK_READ["Always use stack reads<br/>Arguments pushed during call"]
    ARG1["Arg 2: byte slice pointer<br/>go_get_argument(ctx, false, 2)"]
    RET_VAL{"Return value location"}
    REG_RET["Register ABI:<br/>Return in register<br/>go_get_argument(ctx, true, 1)"]
    STACK_RET["Stack ABI:<br/>Return at SP+40<br/>go_get_argument(ctx, false, 5)"]
    READ_DATA["bpf_probe_read_user()<br/>Copy data to event"]
    OUTPUT["Send event"]
    
    URETPROBE --> STACK_READ
    STACK_READ --> ARG1
    ARG1 --> RET_VAL
    RET_VAL -->|is_register_abi=true| REG_RET
    RET_VAL -->|is_register_abi=false| STACK_RET
    REG_RET --> READ_DATA
    STACK_RET --> READ_DATA
    READ_DATA --> OUTPUT
```

**Sources:** [kern/gotls_kern.c:137-179](https://github.com/gojue/ecapture/blob/0766a93b/kern/gotls_kern.c#L137-L179)

### Master Secret Capture (gotls_mastersecret)

The `writeKeyLog` function signature is:
```go
func (c *Config) writeKeyLog(label string, clientRandom, secret []byte) error
```

Go slices are represented as three-word structures: `{pointer, len, cap}`. The eBPF program extracts:

| Argument | Index | Content |
|----------|-------|---------|
| label (string) | 2 | Label pointer |
| label.len | 3 | Label length |
| clientRandom ([]byte) | 4 | Client random pointer |
| clientRandom.len | 5 | Client random length |
| clientRandom.cap | 6 | (skipped) |
| secret ([]byte) | 7 | Secret pointer |
| secret.len | 8 | Secret length |

```c
struct mastersecret_gotls_t {
    u8 label[MASTER_SECRET_KEY_LEN];           // "CLIENT_RANDOM" etc
    u8 labellen;
    u8 client_random[EVP_MAX_MD_SIZE];         // 32 bytes
    u8 client_random_len;
    u8 secret_[EVP_MAX_MD_SIZE];               // TLS secret
    u8 secret_len;
};
```

**Sources:** [kern/gotls_kern.c:194-267](https://github.com/gojue/ecapture/blob/0766a93b/kern/gotls_kern.c#L194-L267), [kern/gotls_kern.c:41-48](https://github.com/gojue/ecapture/blob/0766a93b/kern/gotls_kern.c#L41-L48)

---

## Capture Modes

The module supports three capture modes, each with different eBPF program configurations:

### Text Mode

Captures plaintext data for immediate console output or logging.

**Setup:**
- Hooks: `writeRecordLocked` (uprobe), `Read` (multiple uretprobes)
- Maps: `events` (perf array for `go_tls_event`)
- No TC programs

```mermaid
graph LR
    WRITE["writeRecordLocked<br/>uprobe"]
    READ["Read<br/>uretprobes (multiple RET)"]
    EVENTS["events map<br/>PERF_EVENT_ARRAY"]
    USERSPACE["Event Processor<br/>GoTLSEvent"]
    OUTPUT["Text output<br/>HTTP/HTTP2 parsing"]
    
    WRITE --> EVENTS
    READ --> EVENTS
    EVENTS --> USERSPACE
    USERSPACE --> OUTPUT
```

**Sources:** [user/module/probe_gotls_text.go:31-118](https://github.com/gojue/ecapture/blob/0766a93b/user/module/probe_gotls_text.go#L31-L118), [user/module/probe_gotls_text.go:120-135](https://github.com/gojue/ecapture/blob/0766a93b/user/module/probe_gotls_text.go#L120-L135)

### Keylog Mode

Captures TLS master secrets for decryption with external tools (Wireshark, etc).

**Setup:**
- Hooks: `writeKeyLog` (uprobe) only
- Maps: `mastersecret_go_events` (perf array for `mastersecret_gotls_t`)
- Output: SSLKEYLOGFILE format

```mermaid
graph LR
    KEYLOG["writeKeyLog<br/>uprobe"]
    SECRETS["mastersecret_go_events<br/>PERF_EVENT_ARRAY"]
    USERSPACE["Event Processor<br/>MasterSecretGotlsEvent"]
    DEDUP["Deduplication<br/>masterSecrets map"]
    FILE["Write to keylog file<br/>Label ClientRandom Secret"]
    
    KEYLOG --> SECRETS
    SECRETS --> USERSPACE
    USERSPACE --> DEDUP
    DEDUP --> FILE
```

Master secrets are deduplicated using a key: `{label}-{clientRandom}` to prevent duplicate entries for the same TLS session.

**Sources:** [user/module/probe_gotls_keylog.go:31-122](https://github.com/gojue/ecapture/blob/0766a93b/user/module/probe_gotls_keylog.go#L31-L122), [user/module/probe_gotls.go:236-275](https://github.com/gojue/ecapture/blob/0766a93b/user/module/probe_gotls.go#L236-L275)

### PCAP Mode

Captures both plaintext data and network packets for complete traffic reconstruction.

**Setup:**
- Hooks: `writeKeyLog` (uprobe), TC ingress/egress classifiers
- Maps: `mastersecret_go_events`, `packet_events`, connection tracking maps
- Output: PCAP-NG with DSB (Decryption Secrets Block)

```mermaid
graph TB
    KEYLOG["writeKeyLog<br/>uprobe"]
    TC_IN["TC Ingress<br/>capture_packets"]
    TC_OUT["TC Egress<br/>capture_packets"]
    SECRET_MAP["mastersecret_go_events"]
    PACKET_MAP["packet_events"]
    
    PROCESSOR["Event Processor"]
    DSB["DSB Block<br/>Embed secrets"]
    PACKETS["Packet Blocks<br/>Network data"]
    PCAPNG["PCAP-NG Writer<br/>save.pcapng"]
    
    KEYLOG --> SECRET_MAP
    TC_IN --> PACKET_MAP
    TC_OUT --> PACKET_MAP
    SECRET_MAP --> PROCESSOR
    PACKET_MAP --> PROCESSOR
    PROCESSOR --> DSB
    PROCESSOR --> PACKETS
    DSB --> PCAPNG
    PACKETS --> PCAPNG
```

The TC classifiers use connection tracking (see [2.6](../2-architecture/2.6-network-connection-tracking.md)) to associate packets with processes.

**Sources:** [user/module/probe_gotls_pcap.go](https://github.com/gojue/ecapture/blob/0766a93b/user/module/probe_gotls_pcap.go)

---

## Configuration and CLI

### Configuration Structure

The `GoTLSConfig` struct centralizes all module settings:

```mermaid
classDiagram
    class GoTLSConfig {
        +BaseConfig
        +string Path
        +string PcapFile
        +string KeylogFile
        +string Model
        +string Ifname
        +string PcapFilter
        +bool IsPieBuildMode
        +bool isRegisterABI
        +buildinfo.BuildInfo Buildinfo
        +[]int ReadTlsAddrs
        +uint64 GoTlsWriteAddr
        +uint64 GoTlsMasterSecretAddr
        +Check() error
        +ReadTable() gosym.Table
        +findRetOffsets() []int
        +findPieSymbolAddr() uint64
    }
    
    class BaseConfig {
        +uint64 Pid
        +uint64 Uid
        +uint64 PerCpuMapSize
        +string LogFile
        +bool IsHex
        +int BTFMode
    }
    
    GoTLSConfig --|> BaseConfig
```

**Sources:** [user/config/config_gotls.go:76-93](https://github.com/gojue/ecapture/blob/0766a93b/user/config/config_gotls.go#L76-L93)

### CLI Commands

The `gotls` subcommand provides the user interface:

```bash
# Basic text capture
ecapture gotls --elfpath=/path/to/go_binary

# Keylog mode with filtering
ecapture gotls -m keylog -k /tmp/keys.log --elfpath=/path/to/go_binary --pid=1234

# PCAP mode with network interface
ecapture gotls -m pcap -w capture.pcapng -i eth0 --elfpath=/path/to/go_binary tcp port 443
```

**Flag Mapping:**

| Flag | Config Field | Default | Purpose |
|------|--------------|---------|---------|
| `-e, --elfpath` | `Path` | (required) | Path to Go binary |
| `-m, --model` | `Model` | `text` | Capture mode: text/pcap/keylog |
| `-w, --pcapfile` | `PcapFile` | `ecapture_gotls.pcapng` | PCAP output file |
| `-k, --keylogfile` | `KeylogFile` | `ecapture_gotls_key.log` | Keylog output file |
| `-i, --ifname` | `Ifname` | (required for pcap) | Network interface |
| `--pid` | `Pid` | 0 (all) | Target process ID |

**Sources:** [cli/cmd/gotls.go:26-58](https://github.com/gojue/ecapture/blob/0766a93b/cli/cmd/gotls.go#L26-L58)

---

## Event Processing and Output

### Event Dispatcher

The `Dispatcher` method routes events based on type:

```mermaid
flowchart TD
    EVENT["eventStruct received"]
    TYPE_CHECK{"Event Type?"}
    MASTER["MasterSecretGotlsEvent"]
    TCSKB["TcSkbEvent"]
    GOTLS["GoTLSEvent"]
    
    SAVE_MASTER["saveMasterSecret()<br/>Write to keylog/DSB"]
    DUMP_TC["dumpTcSkb()<br/>Write to PCAP"]
    PARSE_HTTP["HTTP/HTTP2 Parser<br/>Format output"]
    
    EVENT --> TYPE_CHECK
    TYPE_CHECK --> MASTER
    TYPE_CHECK --> TCSKB
    TYPE_CHECK --> GOTLS
    MASTER --> SAVE_MASTER
    TCSKB --> DUMP_TC
    GOTLS --> PARSE_HTTP
```

**Sources:** [user/module/probe_gotls.go:277-288](https://github.com/gojue/ecapture/blob/0766a93b/user/module/probe_gotls.go#L277-L288)

### Deduplication of Master Secrets

Master secrets are deduplicated to prevent multiple writes of the same key:

```go
// Key format: "LABEL-CLIENTRANDOM"
// e.g., "CLIENT_RANDOM-6a7b8c9d..."
k := fmt.Sprintf("%s-%02x", label, clientRandom)

_, exists := g.masterSecrets[k]
if exists {
    return // Skip duplicate
}
g.masterSecrets[k] = true
```

This ensures that repeated TLS handshakes (e.g., HTTP/2 with session resumption) don't produce redundant keylog entries.

**Sources:** [user/module/probe_gotls.go:242-248](https://github.com/gojue/ecapture/blob/0766a93b/user/module/probe_gotls.go#L242-L248)

---

## Build System Integration

The module integrates with eCapture's dual-path eBPF compilation:

```mermaid
graph TB
    SOURCE["kern/gotls_kern.c"]
    HEADER["kern/go_argument.h<br/>kern/ecapture.h"]
    
    CORE["CO-RE Path<br/>clang -target bpf<br/>-D__TARGET_ARCH_xxx"]
    NONCORE["Non-CO-RE Path<br/>clang + kernel headers"]
    
    CORE_OBJ["gotls_kern_core.o"]
    NONCORE_OBJ["gotls_kern_noncore.o"]
    
    BINDATA["go-bindata<br/>Embed bytecode"]
    ASSETS["assets/ebpf_probe.go"]
    
    SOURCE --> CORE
    SOURCE --> NONCORE
    HEADER --> CORE
    HEADER --> NONCORE
    CORE --> CORE_OBJ
    NONCORE --> NONCORE_OBJ
    CORE_OBJ --> BINDATA
    NONCORE_OBJ --> BINDATA
    BINDATA --> ASSETS
```

The module selects bytecode at runtime via `geteBPFName()` based on kernel BTF support.

**Sources:** See [5.1](../5-development-guide/5.1-build-system.md) for comprehensive build system documentation.

---

## Error Handling and Edge Cases

### Common Failure Scenarios

| Issue | Detection | Mitigation |
|-------|-----------|-----------|
| Not a Go binary | `buildinfo.ReadFile()` fails | Return `ErrNotGoCompiledBin` |
| Architecture mismatch | `runtime.GOARCH != goElfArch` | Return architecture error |
| Stripped PIE binary | Symbol table not found | Return `ErrorSymbolNotFoundFromTable` |
| No RET instructions found | `decodeInstruction()` returns empty | Return `ErrorNoRetFound` |
| Function not found | `LookupFunc()` returns nil | Return `ErrorNoFuncFoundFromSymTabFun` |

**Sources:** [user/config/config_gotls.go:37-44](https://github.com/gojue/ecapture/blob/0766a93b/user/config/config_gotls.go#L37-L44), [user/module/probe_gotls.go:40](https://github.com/gojue/ecapture/blob/0766a93b/user/module/probe_gotls.go#L40)

### PIE Binary Challenges

PIE binaries present unique challenges:
1. **Relocated Symbols**: Addresses are relative, requiring runtime calculation
2. **Hidden Sections**: `.gopclntab` may be unlabeled in `.data.rel.ro`
3. **Magic Number Search**: Must scan section data for pclntab signature
4. **Address Translation**: Must account for `PT_LOAD` segment virtual addresses

The module handles these by parsing the symbol table directly and using `gosym.Table.LookupFunc()` for address resolution.

**Sources:** [user/config/config_gotls.go:281-325](https://github.com/gojue/ecapture/blob/0766a93b/user/config/config_gotls.go#L281-L325), [user/config/config_gotls.go:327-357](https://github.com/gojue/ecapture/blob/0766a93b/user/config/config_gotls.go#L327-L357)

---

## Summary

The Go TLS Module demonstrates sophisticated binary instrumentation techniques tailored to Go's unique runtime characteristics. By parsing ELF structures, detecting ABI conventions, and hooking crypto/tls functions, it captures TLS traffic without requiring source modifications or dynamic library injection. The module's support for both legacy stack-based and modern register-based ABIs ensures compatibility across Go versions 1.0 through current releases.

For related TLS capture techniques using dynamic libraries, see the OpenSSL Module ([3.1.1](3.1.1-openssl-module.md)). For master secret extraction details applicable to both modules, see [3.1.4](3.1.4-master-secret-extraction.md).