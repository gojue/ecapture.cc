# Master Secret Extraction

<details>
<summary>Relevant source files</summary>

The following files were used as context for generating this wiki page:

- [cli/cmd/root.go](https://github.com/gojue/ecapture/blob/0766a93b/cli/cmd/root.go)
- [kern/boringssl_const.h](https://github.com/gojue/ecapture/blob/0766a93b/kern/boringssl_const.h)
- [kern/boringssl_masterkey.h](https://github.com/gojue/ecapture/blob/0766a93b/kern/boringssl_masterkey.h)
- [kern/openssl_masterkey.h](https://github.com/gojue/ecapture/blob/0766a93b/kern/openssl_masterkey.h)
- [kern/openssl_masterkey_3.0.h](https://github.com/gojue/ecapture/blob/0766a93b/kern/openssl_masterkey_3.0.h)
- [user/config/iconfig.go](https://github.com/gojue/ecapture/blob/0766a93b/user/config/iconfig.go)
- [user/module/imodule.go](https://github.com/gojue/ecapture/blob/0766a93b/user/module/imodule.go)
- [user/module/probe_openssl.go](https://github.com/gojue/ecapture/blob/0766a93b/user/module/probe_openssl.go)
- [utils/boringssl-offset.c](https://github.com/gojue/ecapture/blob/0766a93b/utils/boringssl-offset.c)

</details>



This document describes the mechanisms eCapture uses to extract TLS master secrets and traffic keys from OpenSSL and BoringSSL libraries. These secrets enable decryption of captured TLS traffic without requiring certificate private keys.

For information about general TLS capture architecture, see [OpenSSL Module](3.1.1-openssl-module.md). For keylog file generation and PCAP integration, see [TLS Key Logging](../4-output-formats/4.3-tls-key-logging.md) and [PCAP Integration](../4-output-formats/4.2-pcap-integration.md).

## Overview

Master secret extraction operates through eBPF uprobes attached to SSL/TLS library functions. eCapture intercepts cryptographic handshakes to capture:

- **TLS 1.2**: Single master secret derived during handshake
- **TLS 1.3**: Multiple traffic secrets (handshake, client/server traffic, exporter secrets)

The extracted secrets are exported in SSLKEYLOGFILE format for use with Wireshark and other decryption tools.

Sources: [user/module/probe_openssl.go:482-575](https://github.com/gojue/ecapture/blob/0766a93b/user/module/probe_openssl.go#L482-L575), [kern/openssl_masterkey.h:25-39](https://github.com/gojue/ecapture/blob/0766a93b/kern/openssl_masterkey.h#L25-L39), [kern/boringssl_masterkey.h:37-56](https://github.com/gojue/ecapture/blob/0766a93b/kern/boringssl_masterkey.h#L37-L56)

## TLS Version Differences

### TLS 1.2 Secret Extraction

TLS 1.2 uses a single 48-byte `master_key` derived from the pre-master secret and client/server random values. This master key remains constant for the session.

```mermaid
graph LR
    subgraph "TLS 1.2 Structure Navigation"
        SSL_ST["ssl_st"]
        SESSION["ssl_session_st"]
        MASTER["master_key[48]"]
        CLIENT_RND["client_random[32]"]
        
        SSL_ST -->|"SSL_ST_SESSION"| SESSION
        SSL_ST -->|"SSL_ST_S3"| S3["ssl3_state_st"]
        S3 -->|"SSL3_STATE_ST_CLIENT_RANDOM"| CLIENT_RND
        SESSION -->|"SSL_SESSION_ST_MASTER_KEY"| MASTER
    end
```

**TLS 1.2 Extraction Process:**
1. Read `ssl_st->version` to verify TLS version
2. Navigate to `ssl_st->s3->client_random` for the 32-byte random value
3. Navigate to `ssl_st->session->master_key` for the 48-byte master secret
4. Format as: `CLIENT_RANDOM <client_random> <master_key>`

Sources: [kern/openssl_masterkey.h:151-168](https://github.com/gojue/ecapture/blob/0766a93b/kern/openssl_masterkey.h#L151-L168), [kern/boringssl_masterkey.h:288-342](https://github.com/gojue/ecapture/blob/0766a93b/kern/boringssl_masterkey.h#L288-L342)

### TLS 1.3 Secret Extraction

TLS 1.3 replaced the single master secret with multiple derived secrets for different phases:

| Secret Type | Purpose | Size |
|------------|---------|------|
| `early_secret` | Early data (0-RTT) | 32 or 48 bytes |
| `handshake_secret` | Handshake encryption | 32 or 48 bytes |
| `client_handshake_secret` | Derived from handshake_secret | 32 or 48 bytes |
| `server_handshake_secret` | Derived from handshake_secret | 32 or 48 bytes |
| `client_app_traffic_secret` | Client application data | 32 or 48 bytes |
| `server_app_traffic_secret` | Server application data | 32 or 48 bytes |
| `exporter_master_secret` | Key exporters | 32 or 48 bytes |

The secret length depends on cipher suite (32 bytes for SHA256-based, 48 bytes for SHA384-based).

Sources: [kern/openssl_masterkey.h:171-256](https://github.com/gojue/ecapture/blob/0766a93b/kern/openssl_masterkey.h#L171-L256), [kern/boringssl_masterkey.h:344-402](https://github.com/gojue/ecapture/blob/0766a93b/kern/boringssl_masterkey.h#L344-L402), [user/module/probe_openssl.go:502-551](https://github.com/gojue/ecapture/blob/0766a93b/user/module/probe_openssl.go#L502-L551)

## OpenSSL vs BoringSSL Extraction

### OpenSSL Structure Layout

OpenSSL stores TLS 1.3 secrets directly in the `ssl_st` structure at fixed offsets:

```mermaid
graph TB
    subgraph "OpenSSL ssl_st Structure"
        SSL_ST["ssl_st"]
        VERSION["version"]
        SESSION["session*"]
        S3["s3*"]
        EARLY["early_secret[64]"]
        HS["handshake_secret[64]"]
        HTH["handshake_traffic_hash[64]"]
        CATS["client_app_traffic_secret[64]"]
        SATS["server_app_traffic_secret[64]"]
        EMS["exporter_master_secret[64]"]
        
        SSL_ST --> VERSION
        SSL_ST --> SESSION
        SSL_ST --> S3
        SSL_ST --> EARLY
        SSL_ST --> HS
        SSL_ST --> HTH
        SSL_ST --> CATS
        SSL_ST --> SATS
        SSL_ST --> EMS
    end
```

**OpenSSL Offset Macros** (version-specific):
- `SSL_ST_VERSION`: Version field offset
- `SSL_ST_SESSION`: Session pointer offset
- `SSL_ST_EARLY_SECRET`: Early secret offset (TLS 1.3)
- `SSL_ST_HANDSHAKE_SECRET`: Handshake secret offset
- `SSL_ST_CLIENT_APP_TRAFFIC_SECRET`: Client traffic secret offset
- `SSL_ST_SERVER_APP_TRAFFIC_SECRET`: Server traffic secret offset
- `SSL_ST_EXPORTER_MASTER_SECRET`: Exporter secret offset

Sources: [kern/openssl_masterkey.h:80-257](https://github.com/gojue/ecapture/blob/0766a93b/kern/openssl_masterkey.h#L80-L257), [kern/openssl_masterkey_3.0.h:80-253](https://github.com/gojue/ecapture/blob/0766a93b/kern/openssl_masterkey_3.0.h#L80-L253)

### BoringSSL Structure Layout

BoringSSL stores TLS 1.3 secrets in the `SSL_HANDSHAKE` structure (accessible via `ssl_st->s3->hs`), and some secrets are marked `private`, requiring manual offset calculation:

```mermaid
graph TB
    subgraph "BoringSSL Structure Hierarchy"
        SSL_ST["ssl_st"]
        S3["ssl3_state_st (s3)"]
        HS["SSL_HANDSHAKE (hs)"]
        NEW_SESSION["new_session*"]
        
        SSL_ST -->|"SSL_ST_S3"| S3
        S3 -->|"BSSL__SSL3_STATE_HS"| HS
        S3 -->|"BSSL__SSL3_STATE_EXPORTER_SECRET"| EXPORT_SEC["exporter_secret[64]"]
        HS -->|"BSSL__SSL_HANDSHAKE_NEW_SESSION"| NEW_SESSION
        HS -->|"SSL_HANDSHAKE_HASH_LEN_"| HASH_LEN["hash_len_"]
        HS -->|"private fields"| SECRETS["secret_, early_traffic_secret_,<br/>client_handshake_secret_,<br/>server_handshake_secret_,<br/>client_traffic_secret_0_,<br/>server_traffic_secret_0_"]
    end
```

**Private Field Offset Calculation:**

BoringSSL's `SSL_HANDSHAKE` structure contains private fields that cannot be accessed via standard `offsetof()`. The offsets are computed manually:

```c
// max_version is the last public field (uint16_t, offset 30)
// After memory alignment to 8 bytes: offset 32
// hash_len_ (size_t): offset 32
// secret_ starts at: 32 + sizeof(size_t) = 40
#define SSL_HANDSHAKE_HASH_LEN_ roundup(BSSL__SSL_HANDSHAKE_MAX_VERSION+2,8)
#define SSL_HANDSHAKE_SECRET_ SSL_HANDSHAKE_HASH_LEN_+8
#define SSL_HANDSHAKE_EARLY_TRAFFIC_SECRET_ SSL_HANDSHAKE_SECRET_+SSL_MAX_MD_SIZE*1
#define SSL_HANDSHAKE_CLIENT_HANDSHAKE_SECRET_ SSL_HANDSHAKE_SECRET_+SSL_MAX_MD_SIZE*2
// ... and so on
```

Sources: [kern/boringssl_const.h:28-60](https://github.com/gojue/ecapture/blob/0766a93b/kern/boringssl_const.h#L28-L60), [kern/boringssl_masterkey.h:90-98](https://github.com/gojue/ecapture/blob/0766a93b/kern/boringssl_masterkey.h#L90-L98), [utils/boringssl-offset.c:23-78](https://github.com/gojue/ecapture/blob/0766a93b/utils/boringssl-offset.c#L23-L78)

## eBPF Hook Point

Both OpenSSL and BoringSSL extraction use the same hook point strategy:

**Uprobe Function:** `SSL_write_key` (symbolic name, actual function varies)

The eBPF program `probe_ssl_master_key` is attached as a uprobe to SSL/TLS library functions. The actual hook functions are determined by version detection (see [Version Detection and Bytecode Selection](../2-architecture/2.5-version-detection-and-bytecode-selection.md)):

| Hook Function | Library | Purpose |
|--------------|---------|---------|
| `SSL_write` | OpenSSL/BoringSSL | Main hook point for capturing secrets during writes |
| `SSL_do_handshake` | OpenSSL/BoringSSL | Handshake completion hook |
| `SSL_get_wbio` | BoringSSL | BIO retrieval for connection tracking |
| `SSL_in_before` | OpenSSL 1.1.0+ | Handshake state check |
| `SSL_state` | OpenSSL 1.0.x | Alternative handshake state (older versions) |

The master hook functions are configured in [user/module/probe_openssl_masterkey.go:13-21](https://github.com/gojue/ecapture/blob/0766a93b/user/module/probe_openssl_masterkey.go#L13-L21):

```go
var masterKeyHookFuncs = []string{
    "SSL_write",
    "SSL_read",
    "SSL_do_handshake",
}
```

Sources: [kern/openssl_masterkey.h:81-82](https://github.com/gojue/ecapture/blob/0766a93b/kern/openssl_masterkey.h#L81-L82), [kern/boringssl_masterkey.h:169-170](https://github.com/gojue/ecapture/blob/0766a93b/kern/boringssl_masterkey.h#L169-L170), [user/module/probe_openssl.go:104](https://github.com/gojue/ecapture/blob/0766a93b/user/module/probe_openssl.go#L104), [user/module/probe_openssl.go:179-195](https://github.com/gojue/ecapture/blob/0766a93b/user/module/probe_openssl.go#L179-L195)

## Extraction Flow

### Complete Extraction Pipeline

```mermaid
flowchart TD
    subgraph "Kernel Space - eBPF"
        UPROBE["uprobe: probe_ssl_master_key"]
        SSL_PTR["Read ssl_st* from PT_REGS_PARM1"]
        VER_CHECK["Check TLS Version<br/>(ssl_st->version)"]
        
        TLS12["TLS 1.2 Extraction"]
        TLS13["TLS 1.3 Extraction"]
        
        CLIENT_RND["Read client_random[32]<br/>(ssl_st->s3->client_random)"]
        
        MASTER12["Read master_key[48]<br/>(ssl_session_st->master_key)"]
        
        SECRETS13["Read multiple secrets:<br/>handshake_secret,<br/>client/server traffic secrets,<br/>exporter_secret"]
        
        EVENT_OUT["bpf_perf_event_output<br/>(mastersecret_events)"]
    end
    
    subgraph "User Space - Go"
        READ_EVENT["perfEventReader reads<br/>MasterSecretEvent"]
        DISPATCH["Dispatcher routes event"]
        SAVE["saveMasterSecret/<br/>saveMasterSecretBSSL"]
        
        NULL_CHECK["Null Secret Validation"]
        DEDUP["Deduplication Check<br/>(masterKeys map)"]
        
        FORMAT12["Format TLS 1.2:<br/>CLIENT_RANDOM <cr> <mk>"]
        FORMAT13["Format TLS 1.3:<br/>Multiple lines with<br/>HKDF expansion"]
        
        OUTPUT["Write to keylogger file<br/>or PCAP DSB block"]
    end
    
    UPROBE --> SSL_PTR
    SSL_PTR --> VER_CHECK
    VER_CHECK -->|"!= TLS1_3_VERSION"| TLS12
    VER_CHECK -->|"== TLS1_3_VERSION"| TLS13
    
    TLS12 --> CLIENT_RND
    TLS13 --> CLIENT_RND
    
    CLIENT_RND --> MASTER12
    TLS12 --> MASTER12
    
    CLIENT_RND --> SECRETS13
    TLS13 --> SECRETS13
    
    MASTER12 --> EVENT_OUT
    SECRETS13 --> EVENT_OUT
    
    EVENT_OUT --> READ_EVENT
    READ_EVENT --> DISPATCH
    DISPATCH --> SAVE
    
    SAVE --> NULL_CHECK
    NULL_CHECK -->|"Not null"| DEDUP
    NULL_CHECK -->|"All null"| DISCARD["Discard Event"]
    
    DEDUP -->|"New"| FORMAT12
    DEDUP -->|"New"| FORMAT13
    DEDUP -->|"Duplicate"| DISCARD
    
    FORMAT12 --> OUTPUT
    FORMAT13 --> OUTPUT
```

Sources: [kern/openssl_masterkey.h:82-257](https://github.com/gojue/ecapture/blob/0766a93b/kern/openssl_masterkey.h#L82-L257), [kern/boringssl_masterkey.h:170-403](https://github.com/gojue/ecapture/blob/0766a93b/kern/boringssl_masterkey.h#L170-L403), [user/module/probe_openssl.go:482-642](https://github.com/gojue/ecapture/blob/0766a93b/user/module/probe_openssl.go#L482-L642)

### State Validation

The eBPF programs check handshake state to ensure secrets are only captured after negotiation completes:

**OpenSSL:** No explicit state check (relies on secret availability)

**BoringSSL TLS 1.2:**
```c
if (ssl3_hs_state.state < CLIENT_STATE12_SEND_CLIENT_FINISHED) {
    return 0; // not finished yet
}
```

**BoringSSL TLS 1.3:**
```c
if (ssl3_hs_state.tls13_state < CLIENT_STATE13_READ_SERVER_FINISHED) {
    return 0; // not finished yet
}
```

Sources: [kern/boringssl_masterkey.h:263-292](https://github.com/gojue/ecapture/blob/0766a93b/kern/boringssl_masterkey.h#L263-L292), [kern/boringssl_masterkey.h:345-348](https://github.com/gojue/ecapture/blob/0766a93b/kern/boringssl_masterkey.h#L345-L348)

## Data Structures

### Kernel-Side Event Structures

**OpenSSL Event Structure:**

```c
struct mastersecret_t {
    s32 version;                                   // TLS version
    u8 client_random[SSL3_RANDOM_SIZE];            // 32 bytes
    u8 master_key[MASTER_SECRET_MAX_LEN];          // 48 bytes (TLS 1.2)
    
    // TLS 1.3 fields
    u32 cipher_id;                                 // Cipher suite ID
    u8 early_secret[EVP_MAX_MD_SIZE];              // 64 bytes
    u8 handshake_secret[EVP_MAX_MD_SIZE];          // 64 bytes
    u8 handshake_traffic_hash[EVP_MAX_MD_SIZE];    // 64 bytes
    u8 client_app_traffic_secret[EVP_MAX_MD_SIZE]; // 64 bytes
    u8 server_app_traffic_secret[EVP_MAX_MD_SIZE]; // 64 bytes
    u8 exporter_master_secret[EVP_MAX_MD_SIZE];    // 64 bytes
};
```

**BoringSSL Event Structure:**

```c
struct mastersecret_bssl_t {
    s32 version;                                   // TLS version
    u8 client_random[SSL3_RANDOM_SIZE];            // 32 bytes
    u8 secret_[MASTER_SECRET_MAX_LEN];             // 48 bytes (TLS 1.2)
    
    // TLS 1.3 fields
    u32 hash_len;                                  // Hash length (32 or 48)
    u8 early_traffic_secret_[EVP_MAX_MD_SIZE];    // 64 bytes
    u8 client_handshake_secret_[EVP_MAX_MD_SIZE]; // 64 bytes
    u8 server_handshake_secret_[EVP_MAX_MD_SIZE]; // 64 bytes
    u8 client_traffic_secret_0_[EVP_MAX_MD_SIZE]; // 64 bytes
    u8 server_traffic_secret_0_[EVP_MAX_MD_SIZE]; // 64 bytes
    u8 exporter_secret[EVP_MAX_MD_SIZE];          // 64 bytes
};
```

Sources: [kern/openssl_masterkey.h:25-39](https://github.com/gojue/ecapture/blob/0766a93b/kern/openssl_masterkey.h#L25-L39), [kern/boringssl_masterkey.h:37-56](https://github.com/gojue/ecapture/blob/0766a93b/kern/boringssl_masterkey.h#L37-L56)

### User-Space Event Structures

The Go-side mirrors these structures in [user/event/event_openssl.go](https://github.com/gojue/ecapture/blob/0766a93b/user/event/event_openssl.go):

- `MasterSecretEvent`: OpenSSL master secret event
- `MasterSecretBSSLEvent`: BoringSSL master secret event

Both implement the `IEventStruct` interface for unified event processing.

Sources: [user/module/probe_openssl.go:50-56](https://github.com/gojue/ecapture/blob/0766a93b/user/module/probe_openssl.go#L50-L56)

## Master Secret Processing

### User-Space Handler: saveMasterSecret

The `saveMasterSecret` function processes OpenSSL master secret events:

```mermaid
flowchart TD
    START["saveMasterSecret(secretEvent)"]
    
    KEY["Generate key:<br/>fmt.Sprintf('%02x', client_random)"]
    
    DEDUP{"Key exists in<br/>masterKeys map?"}
    
    VER_CHECK{"TLS Version"}
    
    TLS12_PROC["TLS 1.2 Processing"]
    NULL12["Check master_key != all zeros"]
    FMT12["Format: CLIENT_RANDOM <cr> <mk>"]
    
    TLS13_PROC["TLS 1.3 Processing"]
    CIPHER["Determine hash length<br/>based on cipher_id"]
    EXPAND["HKDF Expand:<br/>client_handshake_secret,<br/>server_handshake_secret"]
    NULL13["Validate secrets != all zeros"]
    FMT13["Format multiple lines:<br/>CLIENT_HANDSHAKE_TRAFFIC_SECRET,<br/>SERVER_HANDSHAKE_TRAFFIC_SECRET,<br/>CLIENT_TRAFFIC_SECRET_0,<br/>SERVER_TRAFFIC_SECRET_0,<br/>EXPORTER_SECRET"]
    
    WRITE["Write to output"]
    KEYLOG["Write to keylogger file"]
    PCAP["Save to PCAP DSB block"]
    MARK["Mark key as saved:<br/>masterKeys[k] = true"]
    
    START --> KEY
    KEY --> DEDUP
    DEDUP -->|"Yes"| RETURN["Return (skip duplicate)"]
    DEDUP -->|"No"| VER_CHECK
    
    VER_CHECK -->|"TLS 1.2"| TLS12_PROC
    VER_CHECK -->|"TLS 1.3"| TLS13_PROC
    
    TLS12_PROC --> NULL12
    NULL12 -->|"Valid"| FMT12
    NULL12 -->|"All zeros"| RETURN
    FMT12 --> MARK
    
    TLS13_PROC --> CIPHER
    CIPHER --> EXPAND
    EXPAND --> NULL13
    NULL13 -->|"Valid"| FMT13
    NULL13 -->|"Has nulls"| RETURN
    FMT13 --> MARK
    
    MARK --> WRITE
    WRITE -->|"TlsCaptureModelTypeKeylog"| KEYLOG
    WRITE -->|"TlsCaptureModelTypePcap"| PCAP
    KEYLOG --> DONE["Done"]
    PCAP --> DONE
```

Sources: [user/module/probe_openssl.go:482-575](https://github.com/gojue/ecapture/blob/0766a93b/user/module/probe_openssl.go#L482-L575)

### TLS 1.3 HKDF Expansion

For TLS 1.3, the handshake secrets must be expanded using HKDF-Expand-Label:

**Cipher Suite Hash Determination:**

| Cipher Suite | Hash | Length |
|-------------|------|--------|
| `TLS_AES_128_GCM_SHA256` | SHA256 | 32 bytes |
| `TLS_CHACHA20_POLY1305_SHA256` | SHA256 | 32 bytes |
| `TLS_AES_256_GCM_SHA384` | SHA384 | 48 bytes |

**HKDF-Expand-Label Invocations:**

```go
// Expand handshake secret into client/server handshake secrets
clientHandshakeSecret := hkdf.ExpandLabel(
    secretEvent.HandshakeSecret[:length],
    hkdf.ClientHandshakeTrafficLabel,
    secretEvent.HandshakeTrafficHash[:length],
    length,
    transcript
)

serverHandshakeSecret := hkdf.ExpandLabel(
    secretEvent.HandshakeSecret[:length],
    hkdf.ServerHandshakeTrafficLabel,
    secretEvent.HandshakeTrafficHash[:length],
    length,
    transcript
)
```

Labels used:
- `ClientHandshakeTrafficLabel`: "c hs traffic"
- `ServerHandshakeTrafficLabel`: "s hs traffic"

Sources: [user/module/probe_openssl.go:502-551](https://github.com/gojue/ecapture/blob/0766a93b/user/module/probe_openssl.go#L502-L551), [pkg/util/hkdf/hkdf.go](https://github.com/gojue/ecapture/blob/0766a93b/pkg/util/hkdf/hkdf.go)

### Null Secret Validation

Both TLS 1.2 and TLS 1.3 secrets are validated to ensure they are not all zeros (which would indicate an error or incomplete handshake):

**TLS 1.2 Validation:**
```go
func (m *MOpenSSLProbe) mk12NullSecrets(hashLen int, secret []byte) bool {
    isNull := true
    for i := 0; i < hashLen; i++ {
        if secret[i] != 0 {
            isNull = false
            break
        }
    }
    return isNull
}
```

**TLS 1.3 Validation:**
The function checks all five secrets (client handshake, client traffic, server handshake, server traffic, exporter) and returns `true` if any remain all-zero:

```go
func (m *MOpenSSLProbe) mk13NullSecrets(hashLen int,
    ClientHandshakeSecret [64]byte,
    ClientTrafficSecret0 [64]byte,
    ServerHandshakeSecret [64]byte,
    ServerTrafficSecret0 [64]byte,
    ExporterSecret [64]byte) bool {
    // Returns true if any secret is still null
    // ...
}
```

Sources: [user/module/probe_openssl.go:652-731](https://github.com/gojue/ecapture/blob/0766a93b/user/module/probe_openssl.go#L652-L731)

## Output Formats

### SSLKEYLOGFILE Format

The standard format for TLS key logging:

**TLS 1.2:**
```
CLIENT_RANDOM <64 hex digits client_random> <96 hex digits master_key>
```

**TLS 1.3:**
```
CLIENT_HANDSHAKE_TRAFFIC_SECRET <64 hex digits client_random> <64-96 hex digits>
SERVER_HANDSHAKE_TRAFFIC_SECRET <64 hex digits client_random> <64-96 hex digits>
CLIENT_TRAFFIC_SECRET_0 <64 hex digits client_random> <64-96 hex digits>
SERVER_TRAFFIC_SECRET_0 <64 hex digits client_random> <64-96 hex digits>
EXPORTER_SECRET <64 hex digits client_random> <64-96 hex digits>
```

### Output Modes

Based on `TlsCaptureModelType` configuration:

| Mode | Implementation | Output Location |
|------|---------------|-----------------|
| `TlsCaptureModelTypeKeylog` | Write to file via `m.keylogger.WriteString()` | Keylog file specified by `--keylog` flag |
| `TlsCaptureModelTypePcap` | Embed in PCAP-NG DSB block via `m.savePcapngSslKeyLog()` | Inside PCAP-NG file |
| `TlsCaptureModelTypeText` | No output (secrets not needed) | N/A |

Sources: [user/module/probe_openssl.go:58-76](https://github.com/gojue/ecapture/blob/0766a93b/user/module/probe_openssl.go#L58-L76), [user/module/probe_openssl.go:558-574](https://github.com/gojue/ecapture/blob/0766a93b/user/module/probe_openssl.go#L558-L574)

## Offset Calculation Utilities

### BoringSSL Offset Generator

The `boringssl-offset.c` utility generates offset macros for BoringSSL structures by compiling against BoringSSL headers:

```bash
g++ -I include/ -I src/ ./utils/boringssl-offset.c -o off
./off > generated_offsets.h
```

It uses the `offsetof()` macro for public fields:

```c
#define X(struct_name, field_name) \
    format(#struct_name, #field_name, offsetof(struct struct_name, field_name));
SSL_STRUCT_OFFSETS
#undef X
```

Output example:
```c
// ssl_st->version
#define SSL_ST_VERSION 0x10

// ssl_st->session
#define SSL_ST_SESSION 0x18
```

For private fields in BoringSSL, manual calculation is required (see [BoringSSL Structure Layout](#boringssl-structure-layout)).

Sources: [utils/boringssl-offset.c:1-78](https://github.com/gojue/ecapture/blob/0766a93b/utils/boringssl-offset.c#L1-L78), [kern/boringssl_const.h:28-60](https://github.com/gojue/ecapture/blob/0766a93b/kern/boringssl_const.h#L28-L60)

## Deduplication Strategy

The `masterKeys` map prevents duplicate master secret output:

```go
type MOpenSSLProbe struct {
    // ...
    masterKeys map[string]bool
}
```

**Key:** Hexadecimal representation of `client_random` (32 bytes â†’ 64 hex characters)

**Value:** Boolean flag indicating whether the secret has been saved

When a new master secret event arrives:
1. Generate key: `k := fmt.Sprintf("%02x", secretEvent.ClientRandom)`
2. Check existence: `_, f := m.masterKeys[k]`
3. If exists, return early (duplicate)
4. If new, process and mark: `m.masterKeys[k] = true`

This prevents duplicate entries when multiple SSL/TLS functions are hooked on the same connection.

Sources: [user/module/probe_openssl.go:98](https://github.com/gojue/ecapture/blob/0766a93b/user/module/probe_openssl.go#L98), [user/module/probe_openssl.go:482-489](https://github.com/gojue/ecapture/blob/0766a93b/user/module/probe_openssl.go#L482-L489), [user/module/probe_openssl.go:500](https://github.com/gojue/ecapture/blob/0766a93b/user/module/probe_openssl.go#L500), [user/module/probe_openssl.go:533](https://github.com/gojue/ecapture/blob/0766a93b/user/module/probe_openssl.go#L533)