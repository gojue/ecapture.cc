# TC 网络数据包捕获

## 目的与范围

本文档解释了 eCapture 基于流量控制（TC）的网络数据包捕获子系统。TC eBPF 程序附加到网络接口，在内核层面拦截数据包，使得能够捕获加密网络流量以及从 TLS 库中提取的明文数据。TC 子系统通过使用基于 kprobe 的连接跟踪，将网络连接映射到进程，从而提供进程归属功能。

有关 TLS/SSL 明文捕获的信息，请参阅 [TLS/SSL 模块](3.1-tlsssl-modules.md)。有关 PCAP 文件生成和输出格式的信息，请参阅 [PCAP 集成](../4-output-formats/4.2-pcap-integration.md)。

## 架构概述

TC 数据包捕获系统由三个主要组件组成：

1. **TC 分类器程序**：附加到网络接口的 eBPF 程序，在入口和出口点拦截数据包
2. **连接跟踪 Kprobes**：在 `tcp_sendmsg` 和 `udp_sendmsg` 上的 eBPF kprobes，将网络连接映射到进程
3. **网络映射系统**：一个 LRU 哈希映射，维护网络四元组与进程元数据之间的关联

```mermaid
graph TB
    subgraph "网络接口层"
        NIC["网络接口<br/>(eth0, wlan0, 等)"]
    end
    
    subgraph "TC eBPF 程序 - kern/tc.h"
        INGRESS["ingress_cls_func()<br/>SEC classifier<br/>第 285-288 行"]
        EGRESS["egress_cls_func()<br/>SEC classifier<br/>第 279-282 行"]
        CAPTURE["capture_packets()<br/>主捕获逻辑<br/>第 135-276 行"]
    end
    
    subgraph "连接跟踪 Kprobes - kern/tc.h"
        TCP_PROBE["tcp_sendmsg<br/>SEC kprobe<br/>第 290-347 行"]
        UDP_PROBE["udp_sendmsg<br/>SEC kprobe<br/>第 349-397 行"]
    end
    
    subgraph "eBPF Maps - kern/tc.h"
        NET_MAP["network_map<br/>BPF_MAP_TYPE_LRU_HASH<br/>第 73-77 行"]
        SKB_EVENTS["skb_events<br/>BPF_MAP_TYPE_PERF_EVENT_ARRAY<br/>第 57-62 行"]
        SKB_BUFFER["skb_data_buffer_heap<br/>BPF_MAP_TYPE_PERCPU_ARRAY<br/>第 64-69 行"]
    end
    
    subgraph "用户空间 - user/module/"
        MODULE["MOpenSSLProbe<br/>嵌入 MTCProbe<br/>probe_openssl.go:83-106"]
        PROCESSOR["事件处理器<br/>数据包处理"]
    end
    
    NIC -->|"入口数据包"| INGRESS
    NIC <--"|出口数据包"| EGRESS
    
    INGRESS --> CAPTURE
    EGRESS --> CAPTURE
    
    TCP_PROBE -->|"存储 tuple->ctx"| NET_MAP
    UDP_PROBE -->|"存储 tuple->ctx"| NET_MAP
    
    CAPTURE -->|"查找 ctx"| NET_MAP
    CAPTURE -->|"发送事件"| SKB_EVENTS
    CAPTURE -->|"使用缓冲区"| SKB_BUFFER
    
    SKB_EVENTS -->|"perf 事件"| MODULE
    MODULE --> PROCESSOR
    
    style CAPTURE fill:#f9f9f9
    style NET_MAP fill:#f9f9f9
    style TCP_PROBE fill:#f9f9f9
    style UDP_PROBE fill:#f9f9f9
```

**来源**：[kern/tc.h:1-398](https://github.com/gojue/ecapture/blob/0766a93b/kern/tc.h#L1-L398)，[user/module/probe_openssl.go:83-106](https://github.com/gojue/ecapture/blob/0766a93b/user/module/probe_openssl.go#L83-L106)

## TC 分类器程序

TC 分类器是附加到网络设备并处理通过它们的每个数据包的 eBPF 程序。eCapture 部署两个分类器程序：一个用于入口流量，一个用于出口流量。

### 附加点

```mermaid
graph LR
    subgraph "内核网络栈"
        RX["从 NIC 接收数据包"]
        TX["向 NIC 发送数据包"]
    end
    
    subgraph "TC 钩子"
        ING["ingress_cls_func()<br/>tc.h:285-288"]
        EGR["egress_cls_func()<br/>tc.h:279-282"]
    end
    
    subgraph "捕获逻辑"
        CAP["capture_packets(skb, is_ingress)<br/>tc.h:135-276"]
    end
    
    RX --> ING
    ING --> CAP
    
    CAP --> EGR
    EGR --> TX
    
    CAP -->|"TC_ACT_OK<br/>通过"| TX
```

两个分类器函数都委托给相同的 `capture_packets()` 函数，并带有方向标志：

- **ingress_cls_func**：处理传入的数据包 [kern/tc.h:285-288](https://github.com/gojue/ecapture/blob/0766a93b/kern/tc.h#L285-L288)
- **egress_cls_func**：处理传出的数据包 [kern/tc.h:279-282](https://github.com/gojue/ecapture/blob/0766a93b/kern/tc.h#L279-L282)

分类器返回 `TC_ACT_OK` 以允许数据包继续通过网络栈而不进行修改 [kern/common.h:58](https://github.com/gojue/ecapture/blob/0766a93b/kern/common.h#L58)。

**来源**：[kern/tc.h:135-288](https://github.com/gojue/ecapture/blob/0766a93b/kern/tc.h#L135-L288)，[kern/common.h:58](https://github.com/gojue/ecapture/blob/0766a93b/kern/common.h#L58)

## 数据包捕获逻辑

`capture_packets()` 函数实现核心的数据包捕获逻辑。它操作内核提供的套接字缓冲区结构（`struct __sk_buff`）。

### 处理流程

```mermaid
flowchart TD
    START["capture_packets(skb, is_ingress)"]
    
    VALIDATE["验证数据包长度<br/>eth + ip 头部<br/>tc.h:141-144"]
    
    FILTER["PCAP 过滤器检查<br/>filter_pcap_l2()<br/>tc.h:148-150"]
    
    PROTO_CHECK{"协议?"}
    
    IPV4["解析 IPv4 数据包<br/>提取四元组<br/>tc.h:199-236"]
    
    IPV6["解析 IPv6 数据包<br/>提取四元组<br/>tc.h:156-198"]
    
    LOOKUP["查找 network_map<br/>通过 conn_id<br/>tc.h:225 或 188"]
    
    FOUND{"找到<br/>上下文?"}
    
    REVERSE["尝试反向查找<br/>交换 src/dst<br/>tc.h:227-234 或 189-197"]
    
    FILTER_PID["按 PID/UID 过滤<br/>target_pid, target_uid<br/>tc.h:244-249"]
    
    BUILD["构建 skb_data_event_t<br/>timestamp, len, ifindex<br/>tc.h:239-258"]
    
    SEND["发送到 skb_events<br/>bpf_perf_event_output<br/>tc.h:271"]
    
    RETURN["返回 TC_ACT_OK<br/>tc.h:275"]
    
    START --> VALIDATE
    VALIDATE -->|"失败"| RETURN
    VALIDATE -->|"通过"| FILTER
    
    FILTER -->|"拒绝"| RETURN
    FILTER -->|"接受"| PROTO_CHECK
    
    PROTO_CHECK -->|"IPv4"| IPV4
    PROTO_CHECK -->|"IPv6"| IPV6
    PROTO_CHECK -->|"其他"| RETURN
    
    IPV4 --> LOOKUP
    IPV6 --> LOOKUP
    
    LOOKUP --> FOUND
    FOUND -->|"未找到"| REVERSE
    FOUND -->|"已找到"| FILTER_PID
    
    REVERSE --> FOUND
    
    FILTER_PID -->|"通过"| BUILD
    FILTER_PID -->|"拒绝"| RETURN
    
    BUILD --> SEND
    SEND --> RETURN
```

**来源**：[kern/tc.h:135-276](https://github.com/gojue/ecapture/blob/0766a93b/kern/tc.h#L135-L276)

### 协议支持

TC 捕获支持多种协议，包括 IPv4 和 IPv6：

| 协议 | 常量 | 过滤位置 |
|----------|----------|-----------------|
| TCP | `IPPROTO_TCP` | [kern/tc.h:208,320,332]() |
| UDP | `IPPROTO_UDP` | [kern/tc.h:208,370,382]() |
| ICMP | `IPPROTO_ICMP` | [kern/tc.h:208](https://github.com/gojue/ecapture/blob/0766a93b/kern/tc.h#L208) |
| ICMPv6 | `IPPROTO_ICMPV6` | [kern/tc.h:164](https://github.com/gojue/ecapture/blob/0766a93b/kern/tc.h#L164) |

捕获提取以下网络元组信息：

```c
struct net_id_t {
    u32 protocol;      // IPPROTO_TCP 或 IPPROTO_UDP
    u32 src_port;      // 源端口
    u32 src_ip4;       // 源 IPv4 地址
    u32 dst_port;      // 目标端口
    u32 dst_ip4;       // 目标 IPv4 地址
    u32 src_ip6[4];    // 源 IPv6 地址
    u32 dst_ip6[4];    // 目标 IPv6 地址
};
```

**来源**：[kern/tc.h:39-47,156-236]()

## 使用 Kprobes 进行连接跟踪

为了将捕获的数据包归属到特定进程，eCapture 在建立网络连接的内核函数上使用 kprobes。这些 kprobes 在数据包传输之前捕获进程上下文。

### Kprobe 附加点

```mermaid
graph TB
    subgraph "应用程序空间"
        APP["应用程序进程<br/>send()/sendto()"]
    end
    
    subgraph "系统调用层"
        SYSCALL["sys_sendto/sys_write"]
    end
    
    subgraph "内核函数"
        TCP["tcp_sendmsg(sock *sk, ...)<br/>tc.h:291-347"]
        UDP["udp_sendmsg(sock *sk, ...)<br/>tc.h:350-397"]
    end
    
    subgraph "eBPF Kprobes"
        TCP_PROBE["SEC kprobe/tcp_sendmsg<br/>提取 sock 信息<br/>存储到 network_map"]
        UDP_PROBE["SEC kprobe/udp_sendmsg<br/>提取 sock 信息<br/>存储到 network_map"]
    end
    
    subgraph "数据提取"
        SOCK["struct sock<br/>__sk_common"]
        EXTRACT["提取:<br/>- family (AF_INET/AF_INET6)<br/>- src/dst IP<br/>- src/dst port"]
    end
    
    subgraph "上下文收集"
        CTX["收集:<br/>- PID (bpf_get_current_pid_tgid)<br/>- UID (bpf_get_current_uid_gid)<br/>- comm (bpf_get_current_comm)"]
    end
    
    subgraph "存储"
        MAP["network_map<br/>键: net_id_t<br/>值: net_ctx_t"]
    end
    
    APP --> SYSCALL
    SYSCALL --> TCP
    SYSCALL --> UDP
    
    TCP --> TCP_PROBE
    UDP --> UDP_PROBE
    
    TCP_PROBE --> SOCK
    UDP_PROBE --> SOCK
    
    SOCK --> EXTRACT
    EXTRACT --> CTX
    
    CTX --> MAP
    
    style TCP_PROBE fill:#f9f9f9
    style UDP_PROBE fill:#f9f9f9
    style MAP fill:#f9f9f9
```

**来源**：[kern/tc.h:290-397](https://github.com/gojue/ecapture/blob/0766a93b/kern/tc.h#L290-L397)

### 进程上下文提取

两个 kprobes 都提取相同的信息并将其存储在 `network_map` 中：

```c
struct net_ctx_t {
    u32 pid;              // 进程 ID
    u32 uid;              // 用户 ID
    char comm[16];        // 命令名称 (TASK_COMM_LEN)
};
```

kprobes 执行以下步骤：

1. **获取进程上下文** [kern/tc.h:292-294,351-353]()
   - `bpf_get_current_pid_tgid() >> 32` - 提取 PID
   - `bpf_get_current_uid_gid()` - 提取 UID
   - `bpf_get_current_comm()` - 获取进程名称

2. **提取套接字信息** [kern/tc.h:304-337,354-387]()
   - 读取 `sock->__sk_common.skc_family` - 地址族
   - 读取 `sock->__sk_common.skc_num` - 本地端口
   - 读取 `sock->__sk_common.skc_dport` - 远程端口
   - 读取源/目标 IP 地址

3. **存储映射** [kern/tc.h:345,395]()
   - 从网络元组创建 `net_id_t` 键
   - 从进程上下文创建 `net_ctx_t` 值
   - `bpf_map_update_elem(&network_map, &conn_id, &net_ctx, BPF_ANY)`

**来源**：[kern/tc.h:290-397](https://github.com/gojue/ecapture/blob/0766a93b/kern/tc.h#L290-L397)

## 网络映射系统

`network_map` 是将网络连接与进程信息关联的核心数据结构。它使用 LRU（最近最少使用）驱逐策略来维护活动连接的有界缓存。

### 映射配置

```mermaid
graph LR
    subgraph "映射定义 - tc.h:73-77"
        TYPE["类型: BPF_MAP_TYPE_LRU_HASH"]
        KEY["键: struct net_id_t<br/>四元组 + 协议"]
        VALUE["值: struct net_ctx_t<br/>pid + uid + comm"]
        SIZE["最大条目数: 10240"]
    end
    
    subgraph "键结构 - net_id_t"
        K_PROTO["protocol: u32"]
        K_SPORT["src_port: u32"]
        K_SIP4["src_ip4: u32"]
        K_DPORT["dst_port: u32"]
        K_DIP4["dst_ip4: u32"]
        K_SIP6["src_ip6: u32[4]"]
        K_DIP6["dst_ip6: u32[4]"]
    end
    
    subgraph "值结构 - net_ctx_t"
        V_PID["pid: u32"]
        V_UID["uid: u32"]
        V_COMM["comm: char[16]"]
    end
    
    TYPE --> KEY
    KEY --> VALUE
    VALUE --> SIZE
    
    KEY --> K_PROTO
    KEY --> K_SPORT
    KEY --> K_DIP4
    
    VALUE --> V_PID
    VALUE --> V_UID
    VALUE --> V_COMM
```

**来源**：[kern/tc.h:39-77](https://github.com/gojue/ecapture/blob/0766a93b/kern/tc.h#L39-L77)

### 双向查找

由于数据包可以从任一方向到达（客户端→服务器或服务器→客户端），`capture_packets()` 函数实现了双向查找：

1. **初始查找**：尝试使用数据包的源作为连接源来查找连接 [kern/tc.h:225,188]()
2. **反向查找**：如果未找到，交换源和目标后再次尝试 [kern/tc.h:227-234,189-197]()

这确保传入和传出的数据包都能正确归属到发起进程。

**来源**：[kern/tc.h:188-234](https://github.com/gojue/ecapture/blob/0766a93b/kern/tc.h#L188-L234)

## 数据包过滤

eCapture 支持多级过滤，以减少开销并仅捕获相关流量。

### 过滤层次结构

```mermaid
flowchart TD
    PKT["传入数据包"]
    
    L1["长度过滤器<br/>最小头部大小<br/>tc.h:141-144"]
    
    L2["PCAP 过滤器（可选）<br/>filter_pcap_l2()<br/>tc.h:121-132,148-150"]
    
    L3["协议过滤器<br/>仅 TCP/UDP/ICMP<br/>tc.h:164,208"]
    
    L4["进程过滤器<br/>target_pid, target_uid<br/>tc.h:244-249"]
    
    CAPTURE["捕获数据包"]
    DROP["丢弃数据包"]
    
    PKT --> L1
    L1 -->|"< 最小大小"| DROP
    L1 -->|"≥ 最小大小"| L2
    
    L2 -->|"拒绝"| DROP
    L2 -->|"接受"| L3
    
    L3 -->|"不支持"| DROP
    L3 -->|"支持"| L4
    
    L4 -->|"不匹配"| DROP
    L4 -->|"匹配"| CAPTURE
```

### PCAP 过滤器集成

`filter_pcap_l2()` 函数 [kern/tc.h:121-132](https://github.com/gojue/ecapture/blob/0766a93b/kern/tc.h#L121-L132) 作为从 PCAP 过滤器表达式生成的 BPF 字节码的注入点。该函数标记为 `__noinline` 以防止编译器优化，允许用户空间修补其指令。

过滤器修补在用户空间启动 [user/module/probe_openssl.go:303-307](https://github.com/gojue/ecapture/blob/0766a93b/user/module/probe_openssl.go#L303-L307)：

```go
if m.eBPFProgramType == TlsCaptureModelTypePcap && pcapFilter != "" {
    ebpfFuncs := []string{tcFuncNameIngress, tcFuncNameEgress}
    m.bpfManager.InstructionPatchers = prepareInsnPatchers(m.bpfManager,
        ebpfFuncs, pcapFilter)
}
```

**来源**：[kern/tc.h:121-150](https://github.com/gojue/ecapture/blob/0766a93b/kern/tc.h#L121-L150)，[user/module/probe_openssl.go:303-307](https://github.com/gojue/ecapture/blob/0766a93b/user/module/probe_openssl.go#L303-L307)

### 进程过滤

当设置了 `target_pid` 或 `target_uid`（内核 ≥ 5.2）时，数据包被过滤以匹配特定进程 [kern/tc.h:244-249](https://github.com/gojue/ecapture/blob/0766a93b/kern/tc.h#L244-L249)：

```c
if (target_pid != 0 && target_pid != net_ctx->pid) {
    return TC_ACT_OK;
}
if (target_uid != 0 && target_uid != net_ctx->uid) {
    return TC_ACT_OK;
}
```

此过滤发生在成功连接查找之后，确保只捕获属于目标进程的数据包。

**注意**：kprobes 本身不按 PID/UID 过滤 [kern/tc.h:296-302](https://github.com/gojue/ecapture/blob/0766a93b/kern/tc.h#L296-L302)，因为 `network_map` 必须包含所有连接，以便 TC 分类器执行归属。进程过滤仅在数据包捕获期间发生。

**来源**：[kern/tc.h:244-249,296-302]()，[kern/common.h:64-71](https://github.com/gojue/ecapture/blob/0766a93b/kern/common.h#L64-L71)

## 数据结构

### 事件结构

捕获的数据包元数据使用 `skb_data_event_t` 结构传输到用户空间：

```c
struct skb_data_event_t {
    uint64_t ts;                // 时间戳 (bpf_ktime_get_ns)
    u32 pid;                    // 进程 ID
    char comm[TASK_COMM_LEN];   // 进程名称
    u32 len;                    // 数据包长度 (skb->len)
    u32 ifindex;                // 网络接口索引
};
```

事件包含最小元数据（36 字节）[kern/tc.h:20](https://github.com/gojue/ecapture/blob/0766a93b/kern/tc.h#L20)，数据包有效载荷通过 `bpf_perf_event_output()` 的 flags 参数附加 [kern/tc.h:260-271](https://github.com/gojue/ecapture/blob/0766a93b/kern/tc.h#L260-L271)：

```c
u64 flags = BPF_F_CURRENT_CPU;
flags |= (u64)skb->len << 32;  // 在高 32 位编码数据包长度
bpf_perf_event_output(skb, &skb_events, flags, &event, TC_PACKET_MIN_SIZE);
```

**来源**：[kern/tc.h:30-37,239-271]()

### 缓冲区管理

为了避免大型结构导致的栈溢出，eCapture 使用每 CPU 数组映射进行临时事件存储：

```c
struct {
    __uint(type, BPF_MAP_TYPE_PERCPU_ARRAY);
    __type(key, u32);
    __type(value, struct skb_data_event_t);
    __uint(max_entries, 1);
} skb_data_buffer_heap SEC(".maps");
```

`make_skb_data_event()` 函数 [kern/tc.h:92-100](https://github.com/gojue/ecapture/blob/0766a93b/kern/tc.h#L92-L100) 从此映射检索缓冲区，该映射由内核自动按 CPU 管理。

**来源**：[kern/tc.h:64-100](https://github.com/gojue/ecapture/blob/0766a93b/kern/tc.h#L64-L100)

## 与捕获模块的集成

TC 数据包捕获主要与 TLS 捕获模块集成，以提供完整的网络流量可见性。

### MTCProbe 基础结构

TC 功能封装在 `MTCProbe` 结构体中，该结构体被需要网络数据包捕获的捕获模块嵌入 [user/module/probe_openssl.go:84](https://github.com/gojue/ecapture/blob/0766a93b/user/module/probe_openssl.go#L84)：

```mermaid
graph TB
    subgraph "模块层次结构"
        MOD["Module<br/>基础模块结构"]
        MTCP["MTCProbe<br/>TC 探针基础<br/>probe_tc.go"]
        MOSSL["MOpenSSLProbe<br/>OpenSSL/BoringSSL 捕获<br/>probe_openssl.go:83-106"]
    end
    
    subgraph "MTCProbe 中的 TC 组件"
        PKT_CHAN["tcPacketsChan<br/>chan *TcPacket<br/>缓冲区: 2048"]
        PKT_BUF["tcPackets<br/>[]*TcPacket<br/>批处理缓冲区: 256"]
        PCAP_FILE["pcapngFilename<br/>输出文件路径"]
        TIME["startTime, bootTime<br/>时间戳转换"]
    end
    
    subgraph "PCAP 生成 - probe_tc.go"
        WRITER["PCAP-NG 写入器<br/>savePcapngSslKeyLog()"]
        DSB["DSB 块<br/>TLS 密钥日志"]
    end
    
    MOD -.->|"嵌入"| MTCP
    MTCP -.->|"嵌入"| MOSSL
    
    MTCP --> PKT_CHAN
    MTCP --> PKT_BUF
    MTCP --> PCAP_FILE
    MTCP --> TIME
    
    MOSSL -->|"TcSkbEvent"| PKT_CHAN
    PKT_CHAN --> WRITER
    WRITER --> PCAP_FILE
    WRITER --> DSB
```

**来源**：[user/module/probe_openssl.go:83-106](https://github.com/gojue/ecapture/blob/0766a93b/user/module/probe_openssl.go#L83-L106)，[user/module/probe_tc.go](https://github.com/gojue/ecapture/blob/0766a93b/user/module/probe_tc.go)

### 事件流

当 OpenSSL 模块在 PCAP 模式下运行时，它接收 TC 数据包事件和 TLS 主密钥事件：

1. **初始化** [user/module/probe_openssl.go:137-148](https://github.com/gojue/ecapture/blob/0766a93b/user/module/probe_openssl.go#L137-L148)：
   - 设置 `eBPFProgramType = TlsCaptureModelTypePcap`
   - 创建 `tcPacketsChan` 缓冲通道（2048 个条目）
   - 初始化 `tcPackets` 批处理缓冲区（256 个条目）
   - 存储 PCAP 输出文件名

2. **事件分发** [user/module/probe_openssl.go:733-753](https://github.com/gojue/ecapture/blob/0766a93b/user/module/probe_openssl.go#L733-L753)：
   ```go
   switch ev := eventStruct.(type) {
   case *event.TcSkbEvent:
       err := m.dumpTcSkb(ev)  // 处理 TC 数据包
   case *event.MasterSecretEvent:
       m.saveMasterSecret(ev)   // 处理 TLS 密钥
   }
   ```

3. **PCAP 输出** [user/module/probe_openssl.go:558-565](https://github.com/gojue/ecapture/blob/0766a93b/user/module/probe_openssl.go#L558-L565)：
   - TC 数据包写入 PCAP-NG 文件
   - TLS 主密钥写入为 DSB（解密密钥块）
   - 使 Wireshark 能够解密捕获的 TLS 流量

**来源**：[user/module/probe_openssl.go:137-148,558-565,733-753]()

## 用户空间事件读取

用户空间模块使用标准事件读取基础设施从 `skb_events` perf 事件数组读取 TC 事件。

### 事件读取器设置

```mermaid
flowchart LR
    subgraph "eBPF Maps"
        SKB_MAP["skb_events<br/>PERF_EVENT_ARRAY"]
    end
    
    subgraph "模块事件系统 - imodule.go"
        EVENTS["Events() []*ebpf.Map<br/>返回映射列表"]
        DECODE["DecodeFun(*ebpf.Map)<br/>返回解码器"]
        READER["perfEventReader()<br/>imodule.go:308-350"]
    end
    
    subgraph "事件处理"
        PERF["perf.NewReader()<br/>cilium/ebpf/perf"]
        LOOP["读取循环<br/>record, err := rd.Read()"]
        DEC["解码事件<br/>child.Decode(em, record.RawSample)"]
        DISP["Dispatcher()<br/>child.Dispatcher(evt)"]
    end
    
    SKB_MAP --> EVENTS
    EVENTS --> READER
    READER --> PERF
    PERF --> LOOP
    LOOP --> DEC
    DEC --> DISP
```

读取过程 [user/module/imodule.go:285-350](https://github.com/gojue/ecapture/blob/0766a93b/user/module/imodule.go#L285-L350)：

1. **映射发现**：`Events()` 返回所有事件映射，包括 `skb_events`
2. **读取器创建**：`perfEventReader()` 创建具有可配置缓冲区大小的 perf 事件读取器
3. **事件循环**：持续从 perf 环形缓冲区读取
4. **解码**：`Decode()` 将原始事件字节解析为 `TcSkbEvent` 结构
5. **分发**：将事件传递给模块的 `Dispatcher()` 进行处理

**来源**：[user/module/imodule.go:285-350](https://github.com/gojue/ecapture/blob/0766a93b/user/module/imodule.go#L285-L350)

## 内核版本兼容性

TC 捕获有特定的内核版本要求：

| 功能 | 最低内核版本 | 说明 |
|---------|----------------|------|
| TC 分类器 | 4.1+ | 基本 TC BPF 支持 |
| PCAP 过滤器注入 | 5.2+ | `filter_pcap_l2()` 修补所需 |
| PID/UID 过滤 | 5.2+ | 使用全局常量变量 [kern/common.h:64-71](https://github.com/gojue/ecapture/blob/0766a93b/kern/common.h#L64-L71) |

对于内核 < 5.2，存在以下限制：
- 无运行时 PCAP 过滤器注入
- TC 程序中无 PID/UID 过滤
- 通过 kprobes 的连接跟踪仍然有效

`KERNEL_LESS_5_2` 预处理指令 [kern/common.h:64-71](https://github.com/gojue/ecapture/blob/0766a93b/kern/common.h#L64-L71) 控制需要较新内核的功能的条件编译。

**来源**：[kern/common.h:64-71](https://github.com/gojue/ecapture/blob/0766a93b/kern/common.h#L64-L71)，[kern/tc.h:147-150,243-250]()

## 总结

基于 TC 的数据包捕获系统通过以下方式提供全面的网络可见性：

1. **拦截所有流量**：TC 分类器在网络接口层捕获数据包，在加密之前/解密之后
2. **进程归属**：在 `tcp_sendmsg`/`udp_sendmsg` 上的 Kprobes 通过 `network_map` LRU 哈希将连接映射到进程
3. **双向捕获**：处理入口和出口流量，具有自动源/目标反转功能
4. **灵活过滤**：支持 PCAP 过滤器表达式、协议过滤和 PID/UID 过滤
5. **TLS 集成**：将网络数据包与 TLS 主密钥结合，以 PCAP-NG 格式实现完整的流量解密

这种方法使 eCapture 能够捕获完整的网络流量及进程上下文，即使对于加密连接，也无需应用程序插桩或证书安装。

**来源**：[kern/tc.h:1-398](https://github.com/gojue/ecapture/blob/0766a93b/kern/tc.h#L1-L398)，[user/module/probe_openssl.go:83-106,303-307,558-565,733-753]()，[user/module/imodule.go:285-350](https://github.com/gojue/ecapture/blob/0766a93b/user/module/imodule.go#L285-L350)